// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for user (user@user-multicom) on Wed Sep 16 13:14:39 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

#ifndef jabber__server_HH
#define jabber__server_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "urn_ietf_params_xml_ns_xmpp_stanzas.hh"

#if TTCN3_VERSION != 50300
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef jabber__server_HH
#endif

namespace jabber__server {

/* Forward declarations of classes */

class Message_choice__list;
class Message_choice__list_template;
class Message_choice__list_0;
class Message_choice__list_0_template;
class Subject;
class Subject_template;
class Body;
class Body_template;
class Thread;
class Thread_template;
class Message_elem__list;
class Message_elem__list_template;
class Message;
class Message_template;
class Message_type__;
class Message_type___template;
class Error_type__;
class Error_type___template;
class Error;
class Error_template;
class Presence_choice__list;
class Presence_choice__list_template;
class Presence_choice__list_0;
class Presence_choice__list_0_template;
class Show;
class Show_template;
class Status;
class Status_template;
class Presence_elem__list;
class Presence_elem__list_template;
class Presence;
class Presence_template;
class Presence_type__;
class Presence_type___template;
class Iq_type__;
class Iq_type___template;
class Iq;
class Iq_template;

} /* end of namespace */

#ifndef jabber__server_HH
#define jabber__server_HH

namespace jabber__server {

/* Type definitions */

typedef UNIVERSAL_CHARSTRING String1024;
typedef UNIVERSAL_CHARSTRING_template String1024_template;
typedef INTEGER Priority;
typedef INTEGER_template Priority_template;

/* Class definitions */

class Message_choice__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Message_choice__list_0 **value_elements;
} *val_ptr;

static const Message_choice__list_0 UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const Message_choice__list& other_value);

public:
  typedef Message_choice__list_0 of_type;
Message_choice__list();
Message_choice__list(null_type other_value);
Message_choice__list(const Message_choice__list& other_value);
~Message_choice__list();

void clean_up();
Message_choice__list& operator=(null_type other_value);
Message_choice__list& operator=(const Message_choice__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const Message_choice__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Message_choice__list& other_value) const { return !(*this == other_value); }

Message_choice__list_0& operator[](int index_value);
Message_choice__list_0& operator[](const INTEGER& index_value);
const Message_choice__list_0& operator[](int index_value) const;
const Message_choice__list_0& operator[](const INTEGER& index_value) const;

Message_choice__list operator<<=(int rotate_count) const;
Message_choice__list operator<<=(const INTEGER& rotate_count) const;
Message_choice__list operator>>=(int rotate_count) const;
Message_choice__list operator>>=(const INTEGER& rotate_count) const;

Message_choice__list operator+(const Message_choice__list& other_value) const;

Message_choice__list substr(int index, int returncount) const;

Message_choice__list replace(int index, int len, const Message_choice__list& repl) const;

Message_choice__list replace(int index, int len, const Message_choice__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Message_choice__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
Message_choice__list_0_template **value_elements;
} single_value;
struct {
unsigned int n_values;
Message_choice__list_template *list_value;
} value_list;
};
void copy_value(const Message_choice__list& other_value);
void copy_template(const Message_choice__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
Message_choice__list_template();
Message_choice__list_template(template_sel other_value);
Message_choice__list_template(null_type other_value);
Message_choice__list_template(const Message_choice__list& other_value);
Message_choice__list_template(const OPTIONAL<Message_choice__list>& other_value);
Message_choice__list_template(const Message_choice__list_template& other_value);
~Message_choice__list_template();

void clean_up();
Message_choice__list_template& operator=(template_sel other_value);
Message_choice__list_template& operator=(null_type other_value);
Message_choice__list_template& operator=(const Message_choice__list& other_value);
Message_choice__list_template& operator=(const OPTIONAL<Message_choice__list>& other_value);
Message_choice__list_template& operator=(const Message_choice__list_template& other_value);

Message_choice__list_0_template& operator[](int index_value);
Message_choice__list_0_template& operator[](const INTEGER& index_value);
const Message_choice__list_0_template& operator[](int index_value) const;
const Message_choice__list_0_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const Message_choice__list& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
Message_choice__list valueof() const;
Message_choice__list substr(int index, int returncount) const;

Message_choice__list replace(int index, int len, const Message_choice__list_template& repl) const;

Message_choice__list replace(int index, int len, const Message_choice__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
Message_choice__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Message_choice__list& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Message_choice__list_0 : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_subject = 1, ALT_body = 2, ALT_thread = 3 };
private:
union_selection_type union_selection;
union {
Subject *field_subject;
Body *field_body;
Thread *field_thread;
};
void copy_value(const Message_choice__list_0& other_value);

public:
Message_choice__list_0();
Message_choice__list_0(const Message_choice__list_0& other_value);
~Message_choice__list_0();
Message_choice__list_0& operator=(const Message_choice__list_0& other_value);
boolean operator==(const Message_choice__list_0& other_value) const;
inline boolean operator!=(const Message_choice__list_0& other_value) const { return !(*this == other_value); }
Subject& subject();
const Subject& subject() const;
Body& body();
const Body& body() const;
Thread& thread();
const Thread& thread() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Message_choice__list_0_template : public Base_Template {
union {
struct {
Message_choice__list_0::union_selection_type union_selection;
union {
Subject_template *field_subject;
Body_template *field_body;
Thread_template *field_thread;
};
} single_value;
struct {
unsigned int n_values;
Message_choice__list_0_template *list_value;
} value_list;
};
void copy_value(const Message_choice__list_0& other_value);

void copy_template(const Message_choice__list_0_template& other_value);

public:
Message_choice__list_0_template();
Message_choice__list_0_template(template_sel other_value);
Message_choice__list_0_template(const Message_choice__list_0& other_value);
Message_choice__list_0_template(const OPTIONAL<Message_choice__list_0>& other_value);
Message_choice__list_0_template(const Message_choice__list_0_template& other_value);
~Message_choice__list_0_template();
void clean_up();
Message_choice__list_0_template& operator=(template_sel other_value);
Message_choice__list_0_template& operator=(const Message_choice__list_0& other_value);
Message_choice__list_0_template& operator=(const OPTIONAL<Message_choice__list_0>& other_value);
Message_choice__list_0_template& operator=(const Message_choice__list_0_template& other_value);
boolean match(const Message_choice__list_0& other_value) const;
boolean is_value() const;Message_choice__list_0 valueof() const;
Message_choice__list_0_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
Subject_template& subject();
const Subject_template& subject() const;
Body_template& body();
const Body_template& body() const;
Thread_template& thread();
const Thread_template& thread() const;
boolean ischosen(Message_choice__list_0::union_selection_type checked_selection) const;
void log() const;
void log_match(const Message_choice__list_0& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Subject : public Base_Type {
  OPTIONAL<CHARSTRING> field_lang;
  UNIVERSAL_CHARSTRING field_base;
  boolean bound_flag;
public:
  Subject();
  Subject(const OPTIONAL<CHARSTRING>& par_lang,
    const UNIVERSAL_CHARSTRING& par_base);
  Subject(const Subject& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Subject& operator=(const Subject& other_value);
  boolean operator==(const Subject& other_value) const;
  inline boolean operator!=(const Subject& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<CHARSTRING>& lang()
    {return field_lang;}
  inline const OPTIONAL<CHARSTRING>& lang() const
    {return field_lang;}
  inline UNIVERSAL_CHARSTRING& base()
    {return field_base;}
  inline const UNIVERSAL_CHARSTRING& base() const
    {return field_base;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Subject_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Subject_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Subject& other_value);
void copy_template(const Subject_template& other_value);

public:
Subject_template();
Subject_template(template_sel other_value);
Subject_template(const Subject& other_value);
Subject_template(const OPTIONAL<Subject>& other_value);
Subject_template(const Subject_template& other_value);
~Subject_template();
Subject_template& operator=(template_sel other_value);
Subject_template& operator=(const Subject& other_value);
Subject_template& operator=(const OPTIONAL<Subject>& other_value);
Subject_template& operator=(const Subject_template& other_value);
boolean match(const Subject& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Subject valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Subject_template& list_item(unsigned int list_index) const;
CHARSTRING_template& lang();
const CHARSTRING_template& lang() const;
UNIVERSAL_CHARSTRING_template& base();
const UNIVERSAL_CHARSTRING_template& base() const;
int size_of() const;
void log() const;
void log_match(const Subject& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class Body : public Base_Type {
  OPTIONAL<CHARSTRING> field_lang;
  UNIVERSAL_CHARSTRING field_base;
  boolean bound_flag;
public:
  Body();
  Body(const OPTIONAL<CHARSTRING>& par_lang,
    const UNIVERSAL_CHARSTRING& par_base);
  Body(const Body& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Body& operator=(const Body& other_value);
  boolean operator==(const Body& other_value) const;
  inline boolean operator!=(const Body& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<CHARSTRING>& lang()
    {return field_lang;}
  inline const OPTIONAL<CHARSTRING>& lang() const
    {return field_lang;}
  inline UNIVERSAL_CHARSTRING& base()
    {return field_base;}
  inline const UNIVERSAL_CHARSTRING& base() const
    {return field_base;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Body_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Body_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Body& other_value);
void copy_template(const Body_template& other_value);

public:
Body_template();
Body_template(template_sel other_value);
Body_template(const Body& other_value);
Body_template(const OPTIONAL<Body>& other_value);
Body_template(const Body_template& other_value);
~Body_template();
Body_template& operator=(template_sel other_value);
Body_template& operator=(const Body& other_value);
Body_template& operator=(const OPTIONAL<Body>& other_value);
Body_template& operator=(const Body_template& other_value);
boolean match(const Body& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Body valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Body_template& list_item(unsigned int list_index) const;
CHARSTRING_template& lang();
const CHARSTRING_template& lang() const;
UNIVERSAL_CHARSTRING_template& base();
const UNIVERSAL_CHARSTRING_template& base() const;
int size_of() const;
void log() const;
void log_match(const Body& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class Thread : public Base_Type {
  OPTIONAL<UNIVERSAL_CHARSTRING> field_parent;
  UNIVERSAL_CHARSTRING field_base;
  boolean bound_flag;
public:
  Thread();
  Thread(const OPTIONAL<UNIVERSAL_CHARSTRING>& par_parent,
    const UNIVERSAL_CHARSTRING& par_base);
  Thread(const Thread& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Thread& operator=(const Thread& other_value);
  boolean operator==(const Thread& other_value) const;
  inline boolean operator!=(const Thread& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<UNIVERSAL_CHARSTRING>& parent()
    {return field_parent;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& parent() const
    {return field_parent;}
  inline UNIVERSAL_CHARSTRING& base()
    {return field_base;}
  inline const UNIVERSAL_CHARSTRING& base() const
    {return field_base;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Thread_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Thread_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Thread& other_value);
void copy_template(const Thread_template& other_value);

public:
Thread_template();
Thread_template(template_sel other_value);
Thread_template(const Thread& other_value);
Thread_template(const OPTIONAL<Thread>& other_value);
Thread_template(const Thread_template& other_value);
~Thread_template();
Thread_template& operator=(template_sel other_value);
Thread_template& operator=(const Thread& other_value);
Thread_template& operator=(const OPTIONAL<Thread>& other_value);
Thread_template& operator=(const Thread_template& other_value);
boolean match(const Thread& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Thread valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Thread_template& list_item(unsigned int list_index) const;
UNIVERSAL_CHARSTRING_template& parent();
const UNIVERSAL_CHARSTRING_template& parent() const;
UNIVERSAL_CHARSTRING_template& base();
const UNIVERSAL_CHARSTRING_template& base() const;
int size_of() const;
void log() const;
void log_match(const Thread& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class Message_elem__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
UNIVERSAL_CHARSTRING **value_elements;
} *val_ptr;

static const UNIVERSAL_CHARSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const Message_elem__list& other_value);

public:
  typedef UNIVERSAL_CHARSTRING of_type;
Message_elem__list();
Message_elem__list(null_type other_value);
Message_elem__list(const Message_elem__list& other_value);
~Message_elem__list();

void clean_up();
Message_elem__list& operator=(null_type other_value);
Message_elem__list& operator=(const Message_elem__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const Message_elem__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Message_elem__list& other_value) const { return !(*this == other_value); }

UNIVERSAL_CHARSTRING& operator[](int index_value);
UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value) const;

Message_elem__list operator<<=(int rotate_count) const;
Message_elem__list operator<<=(const INTEGER& rotate_count) const;
Message_elem__list operator>>=(int rotate_count) const;
Message_elem__list operator>>=(const INTEGER& rotate_count) const;

Message_elem__list operator+(const Message_elem__list& other_value) const;

Message_elem__list substr(int index, int returncount) const;

Message_elem__list replace(int index, int len, const Message_elem__list& repl) const;

Message_elem__list replace(int index, int len, const Message_elem__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Message_elem__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
UNIVERSAL_CHARSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
Message_elem__list_template *list_value;
} value_list;
};
void copy_value(const Message_elem__list& other_value);
void copy_template(const Message_elem__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
Message_elem__list_template();
Message_elem__list_template(template_sel other_value);
Message_elem__list_template(null_type other_value);
Message_elem__list_template(const Message_elem__list& other_value);
Message_elem__list_template(const OPTIONAL<Message_elem__list>& other_value);
Message_elem__list_template(const Message_elem__list_template& other_value);
~Message_elem__list_template();

void clean_up();
Message_elem__list_template& operator=(template_sel other_value);
Message_elem__list_template& operator=(null_type other_value);
Message_elem__list_template& operator=(const Message_elem__list& other_value);
Message_elem__list_template& operator=(const OPTIONAL<Message_elem__list>& other_value);
Message_elem__list_template& operator=(const Message_elem__list_template& other_value);

UNIVERSAL_CHARSTRING_template& operator[](int index_value);
UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING_template& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const Message_elem__list& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
Message_elem__list valueof() const;
Message_elem__list substr(int index, int returncount) const;

Message_elem__list replace(int index, int len, const Message_elem__list_template& repl) const;

Message_elem__list replace(int index, int len, const Message_elem__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
Message_elem__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Message_elem__list& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Message : public Base_Type {
  UNIVERSAL_CHARSTRING field_from__;
  OPTIONAL<UNIVERSAL_CHARSTRING> field_id;
  OPTIONAL<CHARSTRING> field_lang;
  UNIVERSAL_CHARSTRING field_to__;
  OPTIONAL<Message_type__> field_type__;
  Message_choice__list field_choice__list;
  Message_elem__list field_elem__list;
  OPTIONAL<Error> field_error__;
  boolean bound_flag;
public:
  Message();
  Message(const UNIVERSAL_CHARSTRING& par_from__,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_id,
    const OPTIONAL<CHARSTRING>& par_lang,
    const UNIVERSAL_CHARSTRING& par_to__,
    const OPTIONAL<Message_type__>& par_type__,
    const Message_choice__list& par_choice__list,
    const Message_elem__list& par_elem__list,
    const OPTIONAL<Error>& par_error__);
  Message(const Message& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Message& operator=(const Message& other_value);
  boolean operator==(const Message& other_value) const;
  inline boolean operator!=(const Message& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline UNIVERSAL_CHARSTRING& from__()
    {return field_from__;}
  inline const UNIVERSAL_CHARSTRING& from__() const
    {return field_from__;}
  inline OPTIONAL<UNIVERSAL_CHARSTRING>& id()
    {return field_id;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& id() const
    {return field_id;}
  inline OPTIONAL<CHARSTRING>& lang()
    {return field_lang;}
  inline const OPTIONAL<CHARSTRING>& lang() const
    {return field_lang;}
  inline UNIVERSAL_CHARSTRING& to__()
    {return field_to__;}
  inline const UNIVERSAL_CHARSTRING& to__() const
    {return field_to__;}
  inline OPTIONAL<Message_type__>& type__()
    {return field_type__;}
  inline const OPTIONAL<Message_type__>& type__() const
    {return field_type__;}
  inline Message_choice__list& choice__list()
    {return field_choice__list;}
  inline const Message_choice__list& choice__list() const
    {return field_choice__list;}
  inline Message_elem__list& elem__list()
    {return field_elem__list;}
  inline const Message_elem__list& elem__list() const
    {return field_elem__list;}
  inline OPTIONAL<Error>& error__()
    {return field_error__;}
  inline const OPTIONAL<Error>& error__() const
    {return field_error__;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Message_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Message_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Message& other_value);
void copy_template(const Message_template& other_value);

public:
Message_template();
Message_template(template_sel other_value);
Message_template(const Message& other_value);
Message_template(const OPTIONAL<Message>& other_value);
Message_template(const Message_template& other_value);
~Message_template();
Message_template& operator=(template_sel other_value);
Message_template& operator=(const Message& other_value);
Message_template& operator=(const OPTIONAL<Message>& other_value);
Message_template& operator=(const Message_template& other_value);
boolean match(const Message& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Message valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Message_template& list_item(unsigned int list_index) const;
UNIVERSAL_CHARSTRING_template& from__();
const UNIVERSAL_CHARSTRING_template& from__() const;
UNIVERSAL_CHARSTRING_template& id();
const UNIVERSAL_CHARSTRING_template& id() const;
CHARSTRING_template& lang();
const CHARSTRING_template& lang() const;
UNIVERSAL_CHARSTRING_template& to__();
const UNIVERSAL_CHARSTRING_template& to__() const;
Message_type___template& type__();
const Message_type___template& type__() const;
Message_choice__list_template& choice__list();
const Message_choice__list_template& choice__list() const;
Message_elem__list_template& elem__list();
const Message_elem__list_template& elem__list() const;
Error_template& error__();
const Error_template& error__() const;
int size_of() const;
void log() const;
void log_match(const Message& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class Message_type__ : public Base_Type { // enum
friend class Message_type___template;
public:
enum enum_type { chat = 0, error__ = 1, groupchat = 2, headline = 3, normal = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
Message_type__();
Message_type__(int other_value);
Message_type__(enum_type other_value);
Message_type__(const Message_type__& other_value);

Message_type__& operator=(int other_value);
Message_type__& operator=(enum_type other_value);
Message_type__& operator=(const Message_type__& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Message_type__& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Message_type__& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Message_type__& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Message_type__& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Message_type__& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Message_type__& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Message_type__& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Message_type___template : public Base_Template {
union {
Message_type__::enum_type single_value;
struct {
unsigned int n_values;
Message_type___template *list_value;
} value_list;
};

void copy_template(const Message_type___template& other_value);

public:
Message_type___template();
Message_type___template(template_sel other_value);
Message_type___template(int other_value);
Message_type___template(Message_type__::enum_type other_value);
Message_type___template(const Message_type__& other_value);
Message_type___template(const OPTIONAL<Message_type__>& other_value);
Message_type___template(const Message_type___template& other_value);
~Message_type___template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Message_type___template& operator=(template_sel other_value);
Message_type___template& operator=(int other_value);
Message_type___template& operator=(Message_type__::enum_type other_value);
Message_type___template& operator=(const Message_type__& other_value);
Message_type___template& operator=(const OPTIONAL<Message_type__>& other_value);
Message_type___template& operator=(const Message_type___template& other_value);

boolean match(Message_type__::enum_type other_value) const;
boolean match(const Message_type__& other_value) const;
Message_type__::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Message_type___template& list_item(unsigned int list_index);
void log() const;
void log_match(const Message_type__& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Error_type__ : public Base_Type { // enum
friend class Error_type___template;
public:
enum enum_type { auth = 0, cancel = 1, continue__ = 2, modify = 3, wait = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
Error_type__();
Error_type__(int other_value);
Error_type__(enum_type other_value);
Error_type__(const Error_type__& other_value);

Error_type__& operator=(int other_value);
Error_type__& operator=(enum_type other_value);
Error_type__& operator=(const Error_type__& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Error_type__& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Error_type__& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Error_type__& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Error_type__& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Error_type__& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Error_type__& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Error_type__& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Error_type___template : public Base_Template {
union {
Error_type__::enum_type single_value;
struct {
unsigned int n_values;
Error_type___template *list_value;
} value_list;
};

void copy_template(const Error_type___template& other_value);

public:
Error_type___template();
Error_type___template(template_sel other_value);
Error_type___template(int other_value);
Error_type___template(Error_type__::enum_type other_value);
Error_type___template(const Error_type__& other_value);
Error_type___template(const OPTIONAL<Error_type__>& other_value);
Error_type___template(const Error_type___template& other_value);
~Error_type___template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Error_type___template& operator=(template_sel other_value);
Error_type___template& operator=(int other_value);
Error_type___template& operator=(Error_type__::enum_type other_value);
Error_type___template& operator=(const Error_type__& other_value);
Error_type___template& operator=(const OPTIONAL<Error_type__>& other_value);
Error_type___template& operator=(const Error_type___template& other_value);

boolean match(Error_type__::enum_type other_value) const;
boolean match(const Error_type__& other_value) const;
Error_type__::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Error_type___template& list_item(unsigned int list_index);
void log() const;
void log_match(const Error_type__& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Error : public Base_Type {
  OPTIONAL<UNIVERSAL_CHARSTRING> field_by;
  Error_type__ field_type__;
  urn__ietf__params__xml__ns__xmpp__stanzas::StanzaErrorGroup field_stanzaErrorGroup;
  OPTIONAL<urn__ietf__params__xml__ns__xmpp__stanzas::Text> field_text;
  boolean bound_flag;
public:
  Error();
  Error(const OPTIONAL<UNIVERSAL_CHARSTRING>& par_by,
    const Error_type__& par_type__,
    const urn__ietf__params__xml__ns__xmpp__stanzas::StanzaErrorGroup& par_stanzaErrorGroup,
    const OPTIONAL<urn__ietf__params__xml__ns__xmpp__stanzas::Text>& par_text);
  Error(const Error& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Error& operator=(const Error& other_value);
  boolean operator==(const Error& other_value) const;
  inline boolean operator!=(const Error& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<UNIVERSAL_CHARSTRING>& by()
    {return field_by;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& by() const
    {return field_by;}
  inline Error_type__& type__()
    {return field_type__;}
  inline const Error_type__& type__() const
    {return field_type__;}
  inline urn__ietf__params__xml__ns__xmpp__stanzas::StanzaErrorGroup& stanzaErrorGroup()
    {return field_stanzaErrorGroup;}
  inline const urn__ietf__params__xml__ns__xmpp__stanzas::StanzaErrorGroup& stanzaErrorGroup() const
    {return field_stanzaErrorGroup;}
  inline OPTIONAL<urn__ietf__params__xml__ns__xmpp__stanzas::Text>& text()
    {return field_text;}
  inline const OPTIONAL<urn__ietf__params__xml__ns__xmpp__stanzas::Text>& text() const
    {return field_text;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Error_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Error_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Error& other_value);
void copy_template(const Error_template& other_value);

public:
Error_template();
Error_template(template_sel other_value);
Error_template(const Error& other_value);
Error_template(const OPTIONAL<Error>& other_value);
Error_template(const Error_template& other_value);
~Error_template();
Error_template& operator=(template_sel other_value);
Error_template& operator=(const Error& other_value);
Error_template& operator=(const OPTIONAL<Error>& other_value);
Error_template& operator=(const Error_template& other_value);
boolean match(const Error& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Error valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Error_template& list_item(unsigned int list_index) const;
UNIVERSAL_CHARSTRING_template& by();
const UNIVERSAL_CHARSTRING_template& by() const;
Error_type___template& type__();
const Error_type___template& type__() const;
urn__ietf__params__xml__ns__xmpp__stanzas::StanzaErrorGroup_template& stanzaErrorGroup();
const urn__ietf__params__xml__ns__xmpp__stanzas::StanzaErrorGroup_template& stanzaErrorGroup() const;
urn__ietf__params__xml__ns__xmpp__stanzas::Text_template& text();
const urn__ietf__params__xml__ns__xmpp__stanzas::Text_template& text() const;
int size_of() const;
void log() const;
void log_match(const Error& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class Presence_choice__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Presence_choice__list_0 **value_elements;
} *val_ptr;

static const Presence_choice__list_0 UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const Presence_choice__list& other_value);

public:
  typedef Presence_choice__list_0 of_type;
Presence_choice__list();
Presence_choice__list(null_type other_value);
Presence_choice__list(const Presence_choice__list& other_value);
~Presence_choice__list();

void clean_up();
Presence_choice__list& operator=(null_type other_value);
Presence_choice__list& operator=(const Presence_choice__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const Presence_choice__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Presence_choice__list& other_value) const { return !(*this == other_value); }

Presence_choice__list_0& operator[](int index_value);
Presence_choice__list_0& operator[](const INTEGER& index_value);
const Presence_choice__list_0& operator[](int index_value) const;
const Presence_choice__list_0& operator[](const INTEGER& index_value) const;

Presence_choice__list operator<<=(int rotate_count) const;
Presence_choice__list operator<<=(const INTEGER& rotate_count) const;
Presence_choice__list operator>>=(int rotate_count) const;
Presence_choice__list operator>>=(const INTEGER& rotate_count) const;

Presence_choice__list operator+(const Presence_choice__list& other_value) const;

Presence_choice__list substr(int index, int returncount) const;

Presence_choice__list replace(int index, int len, const Presence_choice__list& repl) const;

Presence_choice__list replace(int index, int len, const Presence_choice__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Presence_choice__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
Presence_choice__list_0_template **value_elements;
} single_value;
struct {
unsigned int n_values;
Presence_choice__list_template *list_value;
} value_list;
};
void copy_value(const Presence_choice__list& other_value);
void copy_template(const Presence_choice__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
Presence_choice__list_template();
Presence_choice__list_template(template_sel other_value);
Presence_choice__list_template(null_type other_value);
Presence_choice__list_template(const Presence_choice__list& other_value);
Presence_choice__list_template(const OPTIONAL<Presence_choice__list>& other_value);
Presence_choice__list_template(const Presence_choice__list_template& other_value);
~Presence_choice__list_template();

void clean_up();
Presence_choice__list_template& operator=(template_sel other_value);
Presence_choice__list_template& operator=(null_type other_value);
Presence_choice__list_template& operator=(const Presence_choice__list& other_value);
Presence_choice__list_template& operator=(const OPTIONAL<Presence_choice__list>& other_value);
Presence_choice__list_template& operator=(const Presence_choice__list_template& other_value);

Presence_choice__list_0_template& operator[](int index_value);
Presence_choice__list_0_template& operator[](const INTEGER& index_value);
const Presence_choice__list_0_template& operator[](int index_value) const;
const Presence_choice__list_0_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const Presence_choice__list& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
Presence_choice__list valueof() const;
Presence_choice__list substr(int index, int returncount) const;

Presence_choice__list replace(int index, int len, const Presence_choice__list_template& repl) const;

Presence_choice__list replace(int index, int len, const Presence_choice__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
Presence_choice__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Presence_choice__list& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Presence_choice__list_0 : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_show = 1, ALT_status = 2, ALT_priority = 3 };
private:
union_selection_type union_selection;
union {
Show *field_show;
Status *field_status;
INTEGER *field_priority;
};
void copy_value(const Presence_choice__list_0& other_value);

public:
Presence_choice__list_0();
Presence_choice__list_0(const Presence_choice__list_0& other_value);
~Presence_choice__list_0();
Presence_choice__list_0& operator=(const Presence_choice__list_0& other_value);
boolean operator==(const Presence_choice__list_0& other_value) const;
inline boolean operator!=(const Presence_choice__list_0& other_value) const { return !(*this == other_value); }
Show& show();
const Show& show() const;
Status& status();
const Status& status() const;
INTEGER& priority();
const INTEGER& priority() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Presence_choice__list_0_template : public Base_Template {
union {
struct {
Presence_choice__list_0::union_selection_type union_selection;
union {
Show_template *field_show;
Status_template *field_status;
INTEGER_template *field_priority;
};
} single_value;
struct {
unsigned int n_values;
Presence_choice__list_0_template *list_value;
} value_list;
};
void copy_value(const Presence_choice__list_0& other_value);

void copy_template(const Presence_choice__list_0_template& other_value);

public:
Presence_choice__list_0_template();
Presence_choice__list_0_template(template_sel other_value);
Presence_choice__list_0_template(const Presence_choice__list_0& other_value);
Presence_choice__list_0_template(const OPTIONAL<Presence_choice__list_0>& other_value);
Presence_choice__list_0_template(const Presence_choice__list_0_template& other_value);
~Presence_choice__list_0_template();
void clean_up();
Presence_choice__list_0_template& operator=(template_sel other_value);
Presence_choice__list_0_template& operator=(const Presence_choice__list_0& other_value);
Presence_choice__list_0_template& operator=(const OPTIONAL<Presence_choice__list_0>& other_value);
Presence_choice__list_0_template& operator=(const Presence_choice__list_0_template& other_value);
boolean match(const Presence_choice__list_0& other_value) const;
boolean is_value() const;Presence_choice__list_0 valueof() const;
Presence_choice__list_0_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
Show_template& show();
const Show_template& show() const;
Status_template& status();
const Status_template& status() const;
INTEGER_template& priority();
const INTEGER_template& priority() const;
boolean ischosen(Presence_choice__list_0::union_selection_type checked_selection) const;
void log() const;
void log_match(const Presence_choice__list_0& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Show : public Base_Type { // enum
friend class Show_template;
public:
enum enum_type { away = 0, chat = 1, dnd = 2, xa = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
Show();
Show(int other_value);
Show(enum_type other_value);
Show(const Show& other_value);

Show& operator=(int other_value);
Show& operator=(enum_type other_value);
Show& operator=(const Show& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Show& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Show& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Show& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Show& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Show& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Show& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Show& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Show_template : public Base_Template {
union {
Show::enum_type single_value;
struct {
unsigned int n_values;
Show_template *list_value;
} value_list;
};

void copy_template(const Show_template& other_value);

public:
Show_template();
Show_template(template_sel other_value);
Show_template(int other_value);
Show_template(Show::enum_type other_value);
Show_template(const Show& other_value);
Show_template(const OPTIONAL<Show>& other_value);
Show_template(const Show_template& other_value);
~Show_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Show_template& operator=(template_sel other_value);
Show_template& operator=(int other_value);
Show_template& operator=(Show::enum_type other_value);
Show_template& operator=(const Show& other_value);
Show_template& operator=(const OPTIONAL<Show>& other_value);
Show_template& operator=(const Show_template& other_value);

boolean match(Show::enum_type other_value) const;
boolean match(const Show& other_value) const;
Show::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Show_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Show& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Status : public Base_Type {
  OPTIONAL<CHARSTRING> field_lang;
  UNIVERSAL_CHARSTRING field_base;
  boolean bound_flag;
public:
  Status();
  Status(const OPTIONAL<CHARSTRING>& par_lang,
    const UNIVERSAL_CHARSTRING& par_base);
  Status(const Status& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Status& operator=(const Status& other_value);
  boolean operator==(const Status& other_value) const;
  inline boolean operator!=(const Status& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<CHARSTRING>& lang()
    {return field_lang;}
  inline const OPTIONAL<CHARSTRING>& lang() const
    {return field_lang;}
  inline UNIVERSAL_CHARSTRING& base()
    {return field_base;}
  inline const UNIVERSAL_CHARSTRING& base() const
    {return field_base;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Status_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Status_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Status& other_value);
void copy_template(const Status_template& other_value);

public:
Status_template();
Status_template(template_sel other_value);
Status_template(const Status& other_value);
Status_template(const OPTIONAL<Status>& other_value);
Status_template(const Status_template& other_value);
~Status_template();
Status_template& operator=(template_sel other_value);
Status_template& operator=(const Status& other_value);
Status_template& operator=(const OPTIONAL<Status>& other_value);
Status_template& operator=(const Status_template& other_value);
boolean match(const Status& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Status valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Status_template& list_item(unsigned int list_index) const;
CHARSTRING_template& lang();
const CHARSTRING_template& lang() const;
UNIVERSAL_CHARSTRING_template& base();
const UNIVERSAL_CHARSTRING_template& base() const;
int size_of() const;
void log() const;
void log_match(const Status& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class Presence_elem__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
UNIVERSAL_CHARSTRING **value_elements;
} *val_ptr;

static const UNIVERSAL_CHARSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const Presence_elem__list& other_value);

public:
  typedef UNIVERSAL_CHARSTRING of_type;
Presence_elem__list();
Presence_elem__list(null_type other_value);
Presence_elem__list(const Presence_elem__list& other_value);
~Presence_elem__list();

void clean_up();
Presence_elem__list& operator=(null_type other_value);
Presence_elem__list& operator=(const Presence_elem__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const Presence_elem__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Presence_elem__list& other_value) const { return !(*this == other_value); }

UNIVERSAL_CHARSTRING& operator[](int index_value);
UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value) const;

Presence_elem__list operator<<=(int rotate_count) const;
Presence_elem__list operator<<=(const INTEGER& rotate_count) const;
Presence_elem__list operator>>=(int rotate_count) const;
Presence_elem__list operator>>=(const INTEGER& rotate_count) const;

Presence_elem__list operator+(const Presence_elem__list& other_value) const;

Presence_elem__list substr(int index, int returncount) const;

Presence_elem__list replace(int index, int len, const Presence_elem__list& repl) const;

Presence_elem__list replace(int index, int len, const Presence_elem__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Presence_elem__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
UNIVERSAL_CHARSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
Presence_elem__list_template *list_value;
} value_list;
};
void copy_value(const Presence_elem__list& other_value);
void copy_template(const Presence_elem__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
Presence_elem__list_template();
Presence_elem__list_template(template_sel other_value);
Presence_elem__list_template(null_type other_value);
Presence_elem__list_template(const Presence_elem__list& other_value);
Presence_elem__list_template(const OPTIONAL<Presence_elem__list>& other_value);
Presence_elem__list_template(const Presence_elem__list_template& other_value);
~Presence_elem__list_template();

void clean_up();
Presence_elem__list_template& operator=(template_sel other_value);
Presence_elem__list_template& operator=(null_type other_value);
Presence_elem__list_template& operator=(const Presence_elem__list& other_value);
Presence_elem__list_template& operator=(const OPTIONAL<Presence_elem__list>& other_value);
Presence_elem__list_template& operator=(const Presence_elem__list_template& other_value);

UNIVERSAL_CHARSTRING_template& operator[](int index_value);
UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING_template& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const Presence_elem__list& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
Presence_elem__list valueof() const;
Presence_elem__list substr(int index, int returncount) const;

Presence_elem__list replace(int index, int len, const Presence_elem__list_template& repl) const;

Presence_elem__list replace(int index, int len, const Presence_elem__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
Presence_elem__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Presence_elem__list& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Presence : public Base_Type {
  UNIVERSAL_CHARSTRING field_from__;
  OPTIONAL<UNIVERSAL_CHARSTRING> field_id;
  OPTIONAL<CHARSTRING> field_lang;
  UNIVERSAL_CHARSTRING field_to__;
  OPTIONAL<Presence_type__> field_type__;
  Presence_choice__list field_choice__list;
  Presence_elem__list field_elem__list;
  OPTIONAL<Error> field_error__;
  boolean bound_flag;
public:
  Presence();
  Presence(const UNIVERSAL_CHARSTRING& par_from__,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_id,
    const OPTIONAL<CHARSTRING>& par_lang,
    const UNIVERSAL_CHARSTRING& par_to__,
    const OPTIONAL<Presence_type__>& par_type__,
    const Presence_choice__list& par_choice__list,
    const Presence_elem__list& par_elem__list,
    const OPTIONAL<Error>& par_error__);
  Presence(const Presence& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Presence& operator=(const Presence& other_value);
  boolean operator==(const Presence& other_value) const;
  inline boolean operator!=(const Presence& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline UNIVERSAL_CHARSTRING& from__()
    {return field_from__;}
  inline const UNIVERSAL_CHARSTRING& from__() const
    {return field_from__;}
  inline OPTIONAL<UNIVERSAL_CHARSTRING>& id()
    {return field_id;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& id() const
    {return field_id;}
  inline OPTIONAL<CHARSTRING>& lang()
    {return field_lang;}
  inline const OPTIONAL<CHARSTRING>& lang() const
    {return field_lang;}
  inline UNIVERSAL_CHARSTRING& to__()
    {return field_to__;}
  inline const UNIVERSAL_CHARSTRING& to__() const
    {return field_to__;}
  inline OPTIONAL<Presence_type__>& type__()
    {return field_type__;}
  inline const OPTIONAL<Presence_type__>& type__() const
    {return field_type__;}
  inline Presence_choice__list& choice__list()
    {return field_choice__list;}
  inline const Presence_choice__list& choice__list() const
    {return field_choice__list;}
  inline Presence_elem__list& elem__list()
    {return field_elem__list;}
  inline const Presence_elem__list& elem__list() const
    {return field_elem__list;}
  inline OPTIONAL<Error>& error__()
    {return field_error__;}
  inline const OPTIONAL<Error>& error__() const
    {return field_error__;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Presence_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Presence_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Presence& other_value);
void copy_template(const Presence_template& other_value);

public:
Presence_template();
Presence_template(template_sel other_value);
Presence_template(const Presence& other_value);
Presence_template(const OPTIONAL<Presence>& other_value);
Presence_template(const Presence_template& other_value);
~Presence_template();
Presence_template& operator=(template_sel other_value);
Presence_template& operator=(const Presence& other_value);
Presence_template& operator=(const OPTIONAL<Presence>& other_value);
Presence_template& operator=(const Presence_template& other_value);
boolean match(const Presence& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Presence valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Presence_template& list_item(unsigned int list_index) const;
UNIVERSAL_CHARSTRING_template& from__();
const UNIVERSAL_CHARSTRING_template& from__() const;
UNIVERSAL_CHARSTRING_template& id();
const UNIVERSAL_CHARSTRING_template& id() const;
CHARSTRING_template& lang();
const CHARSTRING_template& lang() const;
UNIVERSAL_CHARSTRING_template& to__();
const UNIVERSAL_CHARSTRING_template& to__() const;
Presence_type___template& type__();
const Presence_type___template& type__() const;
Presence_choice__list_template& choice__list();
const Presence_choice__list_template& choice__list() const;
Presence_elem__list_template& elem__list();
const Presence_elem__list_template& elem__list() const;
Error_template& error__();
const Error_template& error__() const;
int size_of() const;
void log() const;
void log_match(const Presence& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class Presence_type__ : public Base_Type { // enum
friend class Presence_type___template;
public:
enum enum_type { error__ = 0, probe = 1, subscribe = 2, subscribed = 3, unavailable = 4, unsubscribe = 5, unsubscribed = 6, UNKNOWN_VALUE = 7, UNBOUND_VALUE = 8 };
private:
enum_type enum_value;

public:
Presence_type__();
Presence_type__(int other_value);
Presence_type__(enum_type other_value);
Presence_type__(const Presence_type__& other_value);

Presence_type__& operator=(int other_value);
Presence_type__& operator=(enum_type other_value);
Presence_type__& operator=(const Presence_type__& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Presence_type__& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Presence_type__& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Presence_type__& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Presence_type__& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Presence_type__& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Presence_type__& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Presence_type__& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Presence_type___template : public Base_Template {
union {
Presence_type__::enum_type single_value;
struct {
unsigned int n_values;
Presence_type___template *list_value;
} value_list;
};

void copy_template(const Presence_type___template& other_value);

public:
Presence_type___template();
Presence_type___template(template_sel other_value);
Presence_type___template(int other_value);
Presence_type___template(Presence_type__::enum_type other_value);
Presence_type___template(const Presence_type__& other_value);
Presence_type___template(const OPTIONAL<Presence_type__>& other_value);
Presence_type___template(const Presence_type___template& other_value);
~Presence_type___template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Presence_type___template& operator=(template_sel other_value);
Presence_type___template& operator=(int other_value);
Presence_type___template& operator=(Presence_type__::enum_type other_value);
Presence_type___template& operator=(const Presence_type__& other_value);
Presence_type___template& operator=(const OPTIONAL<Presence_type__>& other_value);
Presence_type___template& operator=(const Presence_type___template& other_value);

boolean match(Presence_type__::enum_type other_value) const;
boolean match(const Presence_type__& other_value) const;
Presence_type__::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Presence_type___template& list_item(unsigned int list_index);
void log() const;
void log_match(const Presence_type__& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Iq_type__ : public Base_Type { // enum
friend class Iq_type___template;
public:
enum enum_type { error__ = 0, get = 1, result = 2, set__ = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
Iq_type__();
Iq_type__(int other_value);
Iq_type__(enum_type other_value);
Iq_type__(const Iq_type__& other_value);

Iq_type__& operator=(int other_value);
Iq_type__& operator=(enum_type other_value);
Iq_type__& operator=(const Iq_type__& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Iq_type__& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Iq_type__& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Iq_type__& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Iq_type__& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Iq_type__& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Iq_type__& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Iq_type__& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Iq_type___template : public Base_Template {
union {
Iq_type__::enum_type single_value;
struct {
unsigned int n_values;
Iq_type___template *list_value;
} value_list;
};

void copy_template(const Iq_type___template& other_value);

public:
Iq_type___template();
Iq_type___template(template_sel other_value);
Iq_type___template(int other_value);
Iq_type___template(Iq_type__::enum_type other_value);
Iq_type___template(const Iq_type__& other_value);
Iq_type___template(const OPTIONAL<Iq_type__>& other_value);
Iq_type___template(const Iq_type___template& other_value);
~Iq_type___template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Iq_type___template& operator=(template_sel other_value);
Iq_type___template& operator=(int other_value);
Iq_type___template& operator=(Iq_type__::enum_type other_value);
Iq_type___template& operator=(const Iq_type__& other_value);
Iq_type___template& operator=(const OPTIONAL<Iq_type__>& other_value);
Iq_type___template& operator=(const Iq_type___template& other_value);

boolean match(Iq_type__::enum_type other_value) const;
boolean match(const Iq_type__& other_value) const;
Iq_type__::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Iq_type___template& list_item(unsigned int list_index);
void log() const;
void log_match(const Iq_type__& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Iq : public Base_Type {
  UNIVERSAL_CHARSTRING field_from__;
  UNIVERSAL_CHARSTRING field_id;
  OPTIONAL<CHARSTRING> field_lang;
  UNIVERSAL_CHARSTRING field_to__;
  Iq_type__ field_type__;
  OPTIONAL<UNIVERSAL_CHARSTRING> field_elem;
  OPTIONAL<Error> field_error__;
  boolean bound_flag;
public:
  Iq();
  Iq(const UNIVERSAL_CHARSTRING& par_from__,
    const UNIVERSAL_CHARSTRING& par_id,
    const OPTIONAL<CHARSTRING>& par_lang,
    const UNIVERSAL_CHARSTRING& par_to__,
    const Iq_type__& par_type__,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_elem,
    const OPTIONAL<Error>& par_error__);
  Iq(const Iq& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Iq& operator=(const Iq& other_value);
  boolean operator==(const Iq& other_value) const;
  inline boolean operator!=(const Iq& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline UNIVERSAL_CHARSTRING& from__()
    {return field_from__;}
  inline const UNIVERSAL_CHARSTRING& from__() const
    {return field_from__;}
  inline UNIVERSAL_CHARSTRING& id()
    {return field_id;}
  inline const UNIVERSAL_CHARSTRING& id() const
    {return field_id;}
  inline OPTIONAL<CHARSTRING>& lang()
    {return field_lang;}
  inline const OPTIONAL<CHARSTRING>& lang() const
    {return field_lang;}
  inline UNIVERSAL_CHARSTRING& to__()
    {return field_to__;}
  inline const UNIVERSAL_CHARSTRING& to__() const
    {return field_to__;}
  inline Iq_type__& type__()
    {return field_type__;}
  inline const Iq_type__& type__() const
    {return field_type__;}
  inline OPTIONAL<UNIVERSAL_CHARSTRING>& elem()
    {return field_elem;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& elem() const
    {return field_elem;}
  inline OPTIONAL<Error>& error__()
    {return field_error__;}
  inline const OPTIONAL<Error>& error__() const
    {return field_error__;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Iq_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Iq_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Iq& other_value);
void copy_template(const Iq_template& other_value);

public:
Iq_template();
Iq_template(template_sel other_value);
Iq_template(const Iq& other_value);
Iq_template(const OPTIONAL<Iq>& other_value);
Iq_template(const Iq_template& other_value);
~Iq_template();
Iq_template& operator=(template_sel other_value);
Iq_template& operator=(const Iq& other_value);
Iq_template& operator=(const OPTIONAL<Iq>& other_value);
Iq_template& operator=(const Iq_template& other_value);
boolean match(const Iq& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Iq valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Iq_template& list_item(unsigned int list_index) const;
UNIVERSAL_CHARSTRING_template& from__();
const UNIVERSAL_CHARSTRING_template& from__() const;
UNIVERSAL_CHARSTRING_template& id();
const UNIVERSAL_CHARSTRING_template& id() const;
CHARSTRING_template& lang();
const CHARSTRING_template& lang() const;
UNIVERSAL_CHARSTRING_template& to__();
const UNIVERSAL_CHARSTRING_template& to__() const;
Iq_type___template& type__();
const Iq_type___template& type__() const;
UNIVERSAL_CHARSTRING_template& elem();
const UNIVERSAL_CHARSTRING_template& elem() const;
Error_template& error__();
const Error_template& error__() const;
int size_of() const;
void log() const;
void log_match(const Iq& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const Message_choice__list& other_value);
inline boolean operator!=(null_type null_value, const Message_choice__list& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Message_elem__list& other_value);
inline boolean operator!=(null_type null_value, const Message_elem__list& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Presence_choice__list& other_value);
inline boolean operator!=(null_type null_value, const Presence_choice__list& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Presence_elem__list& other_value);
inline boolean operator!=(null_type null_value, const Presence_elem__list& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const XERdescriptor_t Message_from___xer_;
extern const TTCN_Typedescriptor_t Message_from___descr_;
extern const XERdescriptor_t Message_to___xer_;
extern const TTCN_Typedescriptor_t Message_to___descr_;
extern const XERdescriptor_t Message_choice__list_xer_;
extern const TTCN_JSONdescriptor_t Message_choice__list_json_;
extern const TTCN_Typedescriptor_t Message_choice__list_descr_;
extern const XERdescriptor_t Message_choice__list_0_xer_;
extern const TTCN_JSONdescriptor_t Message_choice__list_0_json_;
extern const TTCN_Typedescriptor_t Message_choice__list_0_descr_;
extern const XERdescriptor_t Subject_base_xer_;
extern const TTCN_Typedescriptor_t Subject_base_descr_;
extern const XERdescriptor_t Subject_xer_;
extern const TTCN_JSONdescriptor_t Subject_json_;
extern const TTCN_Typedescriptor_t Subject_descr_;
extern const XERdescriptor_t Subject_lang_xer_;
extern const TTCN_Typedescriptor_t Subject_lang_descr_;
extern const XERdescriptor_t Message_choice__list_0_subject_xer_;
extern const TTCN_Typedescriptor_t Message_choice__list_0_subject_descr_;
extern const XERdescriptor_t Body_base_xer_;
extern const TTCN_Typedescriptor_t Body_base_descr_;
extern const XERdescriptor_t Body_xer_;
extern const TTCN_JSONdescriptor_t Body_json_;
extern const TTCN_Typedescriptor_t Body_descr_;
extern const XERdescriptor_t Body_lang_xer_;
extern const TTCN_Typedescriptor_t Body_lang_descr_;
extern const XERdescriptor_t Message_choice__list_0_body_xer_;
extern const TTCN_Typedescriptor_t Message_choice__list_0_body_descr_;
extern const XERdescriptor_t Thread_base_xer_;
extern const TTCN_Typedescriptor_t Thread_base_descr_;
extern const XERdescriptor_t Thread_xer_;
extern const TTCN_JSONdescriptor_t Thread_json_;
extern const TTCN_Typedescriptor_t Thread_descr_;
extern const XERdescriptor_t Thread_parent_xer_;
extern const TTCN_Typedescriptor_t Thread_parent_descr_;
extern const XERdescriptor_t Message_choice__list_0_thread_xer_;
extern const TTCN_Typedescriptor_t Message_choice__list_0_thread_descr_;
extern const XERdescriptor_t Message_elem__list_xer_;
extern const TTCN_JSONdescriptor_t Message_elem__list_json_;
extern const TTCN_Typedescriptor_t Message_elem__list_descr_;
extern const XERdescriptor_t Message_elem__list_0_xer_;
extern const TTCN_Typedescriptor_t Message_elem__list_0_descr_;
extern const XERdescriptor_t Message_xer_;
extern const TTCN_JSONdescriptor_t Message_json_;
extern const TTCN_Typedescriptor_t Message_descr_;
extern const XERdescriptor_t Message_id_xer_;
extern const TTCN_Typedescriptor_t Message_id_descr_;
extern const XERdescriptor_t Message_lang_xer_;
extern const TTCN_Typedescriptor_t Message_lang_descr_;
extern const XERdescriptor_t Message_type___xer_;
extern Message_type__ Message_type___dfe;
extern const TTCN_JSONdescriptor_t Message_type___json_;
extern const TTCN_Typedescriptor_t Message_type___descr_;
extern const XERdescriptor_t Error_type___xer_;
extern const TTCN_JSONdescriptor_t Error_type___json_;
extern const TTCN_Typedescriptor_t Error_type___descr_;
extern const XERdescriptor_t Error_stanzaErrorGroup_xer_;
extern const TTCN_Typedescriptor_t Error_stanzaErrorGroup_descr_;
extern const XERdescriptor_t Error_xer_;
extern const TTCN_JSONdescriptor_t Error_json_;
extern const TTCN_Typedescriptor_t Error_descr_;
extern const XERdescriptor_t Error_by_xer_;
extern const TTCN_Typedescriptor_t Error_by_descr_;
extern const XERdescriptor_t Error_text_xer_;
extern const TTCN_Typedescriptor_t Error_text_descr_;
extern const XERdescriptor_t Message_error___xer_;
extern const TTCN_Typedescriptor_t Message_error___descr_;
extern const XERdescriptor_t Presence_from___xer_;
extern const TTCN_Typedescriptor_t Presence_from___descr_;
extern const XERdescriptor_t Presence_to___xer_;
extern const TTCN_Typedescriptor_t Presence_to___descr_;
extern const XERdescriptor_t Presence_choice__list_xer_;
extern const TTCN_JSONdescriptor_t Presence_choice__list_json_;
extern const TTCN_Typedescriptor_t Presence_choice__list_descr_;
extern const XERdescriptor_t Presence_choice__list_0_xer_;
extern const TTCN_JSONdescriptor_t Presence_choice__list_0_json_;
extern const TTCN_Typedescriptor_t Presence_choice__list_0_descr_;
extern const XERdescriptor_t Show_xer_;
extern const TTCN_JSONdescriptor_t Show_json_;
extern const TTCN_Typedescriptor_t Show_descr_;
extern const XERdescriptor_t Presence_choice__list_0_show_xer_;
extern const TTCN_Typedescriptor_t Presence_choice__list_0_show_descr_;
extern const XERdescriptor_t String1024_xer_;
extern const TTCN_Typedescriptor_t String1024_descr_;
extern const XERdescriptor_t Status_base_xer_;
extern const TTCN_Typedescriptor_t Status_base_descr_;
extern const XERdescriptor_t Status_xer_;
extern const TTCN_JSONdescriptor_t Status_json_;
extern const TTCN_Typedescriptor_t Status_descr_;
extern const XERdescriptor_t Status_lang_xer_;
extern const TTCN_Typedescriptor_t Status_lang_descr_;
extern const XERdescriptor_t Presence_choice__list_0_status_xer_;
extern const TTCN_Typedescriptor_t Presence_choice__list_0_status_descr_;
extern const XERdescriptor_t Priority_xer_;
extern INTEGER Priority_dfe;
extern const TTCN_Typedescriptor_t Priority_descr_;
extern const XERdescriptor_t Presence_choice__list_0_priority_xer_;
extern INTEGER Presence_choice__list_0_priority_dfe;
extern const TTCN_Typedescriptor_t Presence_choice__list_0_priority_descr_;
extern const XERdescriptor_t Presence_elem__list_xer_;
extern const TTCN_JSONdescriptor_t Presence_elem__list_json_;
extern const TTCN_Typedescriptor_t Presence_elem__list_descr_;
extern const XERdescriptor_t Presence_elem__list_0_xer_;
extern const TTCN_Typedescriptor_t Presence_elem__list_0_descr_;
extern const XERdescriptor_t Presence_xer_;
extern const TTCN_JSONdescriptor_t Presence_json_;
extern const TTCN_Typedescriptor_t Presence_descr_;
extern const XERdescriptor_t Presence_id_xer_;
extern const TTCN_Typedescriptor_t Presence_id_descr_;
extern const XERdescriptor_t Presence_lang_xer_;
extern const TTCN_Typedescriptor_t Presence_lang_descr_;
extern const XERdescriptor_t Presence_type___xer_;
extern const TTCN_JSONdescriptor_t Presence_type___json_;
extern const TTCN_Typedescriptor_t Presence_type___descr_;
extern const XERdescriptor_t Presence_error___xer_;
extern const TTCN_Typedescriptor_t Presence_error___descr_;
extern const XERdescriptor_t Iq_from___xer_;
extern const TTCN_Typedescriptor_t Iq_from___descr_;
extern const XERdescriptor_t Iq_id_xer_;
extern const TTCN_Typedescriptor_t Iq_id_descr_;
extern const XERdescriptor_t Iq_to___xer_;
extern const TTCN_Typedescriptor_t Iq_to___descr_;
extern const XERdescriptor_t Iq_type___xer_;
extern const TTCN_JSONdescriptor_t Iq_type___json_;
extern const TTCN_Typedescriptor_t Iq_type___descr_;
extern const XERdescriptor_t Iq_xer_;
extern const TTCN_JSONdescriptor_t Iq_json_;
extern const TTCN_Typedescriptor_t Iq_descr_;
extern const XERdescriptor_t Iq_lang_xer_;
extern const TTCN_Typedescriptor_t Iq_lang_descr_;
extern const XERdescriptor_t Iq_elem_xer_;
extern const TTCN_Typedescriptor_t Iq_elem_descr_;
extern const XERdescriptor_t Iq_error___xer_;
extern const TTCN_Typedescriptor_t Iq_error___descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
