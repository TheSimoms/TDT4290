// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for user (user@user-multicom) on Wed Sep 16 15:50:39 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "TCPasp_Types.hh"

namespace TCPasp__Types {

/* Prototypes of static functions */

static void pre_init_module();

/* Literal string constants */

static const CHARSTRING cs_0(7, "AF_INET"),
cs_2(8, "AF_INET6"),
cs_4(9, "AF_UNSPEC"),
cs_1(4, "IPv4"),
cs_3(4, "IPv6"),
cs_5(6, "UNSPEC");
static const unsigned char module_checksum[] = { 0x98, 0x12, 0x18, 0x06, 0x00, 0x63, 0x61, 0x3c, 0xbb, 0xb1, 0x5f, 0xe5, 0xdf, 0xac, 0xc5, 0x51 };

/* Global variable definitions */

const XERdescriptor_t       PDU__TCP_xer_ = { {"PDU_TCP>\n", "PDU_TCP>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PDU__TCP_descr_ = { "@TCPasp_Types.PDU_TCP", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &PDU__TCP_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP_data_xer_ = { {"data>\n", "data>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP_data_descr_ = { "@TCPasp_Types.ASP_TCP.data", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ASP__TCP_data_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__TCP
const TTCN_Typedescriptor_t ASP__TCP_descr_ = { "@TCPasp_Types.ASP_TCP", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP_client__id_xer_ = { {"client_id>\n", "client_id>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP_client__id_descr_ = { "@TCPasp_Types.ASP_TCP.client_id", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__TCP_client__id_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Connect_hostname_xer_ = { {"hostname>\n", "hostname>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Connect_hostname_descr_ = { "@TCPasp_Types.ASP_TCP_Connect.hostname", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__TCP__Connect_hostname_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Connect_portnumber_xer_ = { {"portnumber>\n", "portnumber>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Connect_portnumber_descr_ = { "@TCPasp_Types.ASP_TCP_Connect.portnumber", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__TCP__Connect_portnumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__TCP__Connect
const TTCN_Typedescriptor_t ASP__TCP__Connect_descr_ = { "@TCPasp_Types.ASP_TCP_Connect", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Connect_local__hostname_xer_ = { {"local_hostname>\n", "local_hostname>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Connect_local__hostname_descr_ = { "@TCPasp_Types.ASP_TCP_Connect.local_hostname", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__TCP__Connect_local__hostname_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Connect_local__portnumber_xer_ = { {"local_portnumber>\n", "local_portnumber>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Connect_local__portnumber_descr_ = { "@TCPasp_Types.ASP_TCP_Connect.local_portnumber", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__TCP__Connect_local__portnumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Connect__result_client__id_xer_ = { {"client_id>\n", "client_id>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Connect__result_client__id_descr_ = { "@TCPasp_Types.ASP_TCP_Connect_result.client_id", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__TCP__Connect__result_client__id_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__TCP__Connect__result
const TTCN_Typedescriptor_t ASP__TCP__Connect__result_descr_ = { "@TCPasp_Types.ASP_TCP_Connect_result", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Connected_hostname_xer_ = { {"hostname>\n", "hostname>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Connected_hostname_descr_ = { "@TCPasp_Types.ASP_TCP_Connected.hostname", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__TCP__Connected_hostname_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Connected_portnumber_xer_ = { {"portnumber>\n", "portnumber>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Connected_portnumber_descr_ = { "@TCPasp_Types.ASP_TCP_Connected.portnumber", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__TCP__Connected_portnumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Connected_client__id_xer_ = { {"client_id>\n", "client_id>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Connected_client__id_descr_ = { "@TCPasp_Types.ASP_TCP_Connected.client_id", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__TCP__Connected_client__id_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__TCP__Connected
const TTCN_Typedescriptor_t ASP__TCP__Connected_descr_ = { "@TCPasp_Types.ASP_TCP_Connected", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__TCP__Close
const TTCN_Typedescriptor_t ASP__TCP__Close_descr_ = { "@TCPasp_Types.ASP_TCP_Close", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Close_client__id_xer_ = { {"client_id>\n", "client_id>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Close_client__id_descr_ = { "@TCPasp_Types.ASP_TCP_Close.client_id", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__TCP__Close_client__id_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__TCP__Listen
const TTCN_Typedescriptor_t ASP__TCP__Listen_descr_ = { "@TCPasp_Types.ASP_TCP_Listen", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Listen_portnumber_xer_ = { {"portnumber>\n", "portnumber>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Listen_portnumber_descr_ = { "@TCPasp_Types.ASP_TCP_Listen.portnumber", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__TCP__Listen_portnumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Listen_local__hostname_xer_ = { {"local_hostname>\n", "local_hostname>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Listen_local__hostname_descr_ = { "@TCPasp_Types.ASP_TCP_Listen.local_hostname", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__TCP__Listen_local__hostname_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Listen__result_portnumber_xer_ = { {"portnumber>\n", "portnumber>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Listen__result_portnumber_descr_ = { "@TCPasp_Types.ASP_TCP_Listen_result.portnumber", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__TCP__Listen__result_portnumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__TCP__Listen__result
const TTCN_Typedescriptor_t ASP__TCP__Listen__result_descr_ = { "@TCPasp_Types.ASP_TCP_Listen_result", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__TCP__Shutdown
const TTCN_Typedescriptor_t ASP__TCP__Shutdown_descr_ = { "@TCPasp_Types.ASP_TCP_Shutdown", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for TCP__Send__error__types
const TTCN_Typedescriptor_t TCP__Send__error__types_descr_ = { "@TCPasp_Types.TCP_Send_error_types", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Send__error_data_xer_ = { {"data>\n", "data>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Send__error_data_descr_ = { "@TCPasp_Types.ASP_TCP_Send_error.data", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ASP__TCP__Send__error_data_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Send__error_sent__octets_xer_ = { {"sent_octets>\n", "sent_octets>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Send__error_sent__octets_descr_ = { "@TCPasp_Types.ASP_TCP_Send_error.sent_octets", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__TCP__Send__error_sent__octets_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Send__error_os__error__code_xer_ = { {"os_error_code>\n", "os_error_code>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Send__error_os__error__code_descr_ = { "@TCPasp_Types.ASP_TCP_Send_error.os_error_code", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__TCP__Send__error_os__error__code_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Send__error_os__error__text_xer_ = { {"os_error_text>\n", "os_error_text>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Send__error_os__error__text_descr_ = { "@TCPasp_Types.ASP_TCP_Send_error.os_error_text", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__TCP__Send__error_os__error__text_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Send__error_ttcn__error__text_xer_ = { {"ttcn_error_text>\n", "ttcn_error_text>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Send__error_ttcn__error__text_descr_ = { "@TCPasp_Types.ASP_TCP_Send_error.ttcn_error_text", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__TCP__Send__error_ttcn__error__text_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__TCP__Send__error
const TTCN_Typedescriptor_t ASP__TCP__Send__error_descr_ = { "@TCPasp_Types.ASP_TCP_Send_error", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__TCP__Send__error_client__id_xer_ = { {"client_id>\n", "client_id>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__Send__error_client__id_descr_ = { "@TCPasp_Types.ASP_TCP_Send_error.client_id", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__TCP__Send__error_client__id_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static CHARSTRING const_c__TCP__AF__INET;
const CHARSTRING& c__TCP__AF__INET = const_c__TCP__AF__INET;
static CHARSTRING const_c__TCP__IPv4;
const CHARSTRING& c__TCP__IPv4 = const_c__TCP__IPv4;
static CHARSTRING const_c__TCP__AF__INET6;
const CHARSTRING& c__TCP__AF__INET6 = const_c__TCP__AF__INET6;
static CHARSTRING const_c__TCP__IPv6;
const CHARSTRING& c__TCP__IPv6 = const_c__TCP__IPv6;
static CHARSTRING const_c__TCP__AF__UNSPEC;
const CHARSTRING& c__TCP__AF__UNSPEC = const_c__TCP__AF__UNSPEC;
static CHARSTRING const_c__TCP__UNSPEC;
const CHARSTRING& c__TCP__UNSPEC = const_c__TCP__UNSPEC;
const XERdescriptor_t       ASP__TCP__SetAddressFamily_xer_ = { {"ASP_TCP_SetAddressFamily>\n", "ASP_TCP_SetAddressFamily>\n"}, {26, 26}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__TCP__SetAddressFamily_descr_ = { "@TCPasp_Types.ASP_TCP_SetAddressFamily", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__TCP__SetAddressFamily_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 21;
static const namespace_t xml_namespaces[num_namespaces+1] = {
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { "", "" }
};

TTCN_Module module_object("TCPasp_Types", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 21LU, xml_namespaces, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_3,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

ASP__TCP::ASP__TCP()
{
  bound_flag = FALSE;
}

ASP__TCP::ASP__TCP(const OPTIONAL<INTEGER>& par_client__id,
    const OCTETSTRING& par_data)
  :   field_client__id(par_client__id),
  field_data(par_data)
{
  bound_flag = TRUE;
}

ASP__TCP::ASP__TCP(const ASP__TCP& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TCPasp_Types.ASP_TCP.");
bound_flag = TRUE;
if (other_value.client__id().is_bound()) field_client__id = other_value.client__id();
else field_client__id.clean_up();
if (other_value.data().is_bound()) field_data = other_value.data();
else field_data.clean_up();
}

void ASP__TCP::clean_up()
{
field_client__id.clean_up();
field_data.clean_up();
bound_flag = FALSE;
}

ASP__TCP& ASP__TCP::operator=(const ASP__TCP& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TCPasp_Types.ASP_TCP.");
  bound_flag = TRUE;
  if (other_value.client__id().is_bound()) field_client__id = other_value.client__id();
  else field_client__id.clean_up();
  if (other_value.data().is_bound()) field_data = other_value.data();
  else field_data.clean_up();
}
return *this;
}

boolean ASP__TCP::operator==(const ASP__TCP& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_client__id==other_value.field_client__id
  && field_data==other_value.field_data;
}

boolean ASP__TCP::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_client__id.get_selection() || field_client__id.is_bound()) return TRUE;
if(field_data.is_bound()) return TRUE;
return FALSE;
}
boolean ASP__TCP::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_client__id.get_selection() && !field_client__id.is_value()) return FALSE;
if(!field_data.is_value()) return FALSE;
return TRUE;
}
int ASP__TCP::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TCPasp_Types.ASP_TCP");
  int ret_val = 1;
  if (field_client__id.ispresent()) ret_val++;
  return ret_val;
}

void ASP__TCP::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ client_id := ");
field_client__id.log();
TTCN_Logger::log_event_str(", data := ");
field_data.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__TCP::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TCPasp_Types.ASP_TCP'");
    }
    if (strcmp("client_id", param_field) == 0) {
      client__id().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TCPasp_Types.ASP_TCP'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @TCPasp_Types.ASP_TCP has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) client__id().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "client_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          client__id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TCPasp_Types.ASP_TCP");
  }
}

void ASP__TCP::set_implicit_omit()
{
if (!client__id().is_bound()) client__id() = OMIT_VALUE;
else client__id().set_implicit_omit();
if (data().is_bound()) data().set_implicit_omit();
}

void ASP__TCP::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TCPasp_Types.ASP_TCP.");
field_client__id.encode_text(text_buf);
field_data.encode_text(text_buf);
}

void ASP__TCP::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_client__id.decode_text(text_buf);
field_data.decode_text(text_buf);
}

struct ASP__TCP_template::single_value_struct {
INTEGER_template field_client__id;
OCTETSTRING_template field_data;
};

void ASP__TCP_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_client__id = ANY_OR_OMIT;
single_value->field_data = ANY_VALUE;
}
}
}

void ASP__TCP_template::copy_value(const ASP__TCP& other_value)
{
single_value = new single_value_struct;
if (other_value.client__id().is_bound()) {
  if (other_value.client__id().ispresent()) single_value->field_client__id = other_value.client__id()();
  else single_value->field_client__id = OMIT_VALUE;
} else {
  single_value->field_client__id.clean_up();
}
if (other_value.data().is_bound()) {
  single_value->field_data = other_value.data();
} else {
  single_value->field_data.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__TCP_template::copy_template(const ASP__TCP_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.client__id().get_selection()) {
single_value->field_client__id = other_value.client__id();
} else {
single_value->field_client__id.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.data().get_selection()) {
single_value->field_data = other_value.data();
} else {
single_value->field_data.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__TCP_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP.");
break;
}
set_selection(other_value);
}

ASP__TCP_template::ASP__TCP_template()
{
}

ASP__TCP_template::ASP__TCP_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__TCP_template::ASP__TCP_template(const ASP__TCP& other_value)
{
copy_value(other_value);
}

ASP__TCP_template::ASP__TCP_template(const OPTIONAL<ASP__TCP>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TCPasp_Types.ASP_TCP from an unbound optional field.");
}
}

ASP__TCP_template::ASP__TCP_template(const ASP__TCP_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__TCP_template::~ASP__TCP_template()
{
clean_up();
}

ASP__TCP_template& ASP__TCP_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__TCP_template& ASP__TCP_template::operator=(const ASP__TCP& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__TCP_template& ASP__TCP_template::operator=(const OPTIONAL<ASP__TCP>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TCPasp_Types.ASP_TCP.");
}
return *this;
}

ASP__TCP_template& ASP__TCP_template::operator=(const ASP__TCP_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__TCP_template::match(const ASP__TCP& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.client__id().is_bound()) return FALSE;
if((other_value.client__id().ispresent() ? !single_value->field_client__id.match((const INTEGER&)other_value.client__id()) : !single_value->field_client__id.match_omit()))return FALSE;
if(!other_value.data().is_bound()) return FALSE;
if(!single_value->field_data.match(other_value.data()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP.");
}
return FALSE;
}

boolean ASP__TCP_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_client__id.is_omit() || single_value->field_client__id.is_bound()) return TRUE;
if (single_value->field_data.is_bound()) return TRUE;
return FALSE;
}

boolean ASP__TCP_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_client__id.is_omit() && !single_value->field_client__id.is_value()) return FALSE;
if (!single_value->field_data.is_value()) return FALSE;
return TRUE;
}

void ASP__TCP_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__TCP ASP__TCP_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TCPasp_Types.ASP_TCP.");
ASP__TCP ret_val;
if (single_value->field_client__id.is_omit()) ret_val.client__id() = OMIT_VALUE;
else if (single_value->field_client__id.is_bound()) {
ret_val.client__id() = single_value->field_client__id.valueof();
}
if (single_value->field_data.is_bound()) {
ret_val.data() = single_value->field_data.valueof();
}
return ret_val;
}

void ASP__TCP_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TCPasp_Types.ASP_TCP.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__TCP_template[list_length];
}

ASP__TCP_template& ASP__TCP_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TCPasp_Types.ASP_TCP.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TCPasp_Types.ASP_TCP.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__TCP_template::client__id()
{
set_specific();
return single_value->field_client__id;
}

const INTEGER_template& ASP__TCP_template::client__id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field client_id of a non-specific template of type @TCPasp_Types.ASP_TCP.");
return single_value->field_client__id;
}

OCTETSTRING_template& ASP__TCP_template::data()
{
set_specific();
return single_value->field_data;
}

const OCTETSTRING_template& ASP__TCP_template::data() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field data of a non-specific template of type @TCPasp_Types.ASP_TCP.");
return single_value->field_data;
}

int ASP__TCP_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_client__id.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP.");
  }
  return 0;
}

void ASP__TCP_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ client_id := ");
single_value->field_client__id.log();
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__TCP_template::log_match(const ASP__TCP& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.client__id().ispresent()){
if(!single_value->field_client__id.match(match_value.client__id())){
TTCN_Logger::log_logmatch_info(".client_id");
single_value->field_client__id.log_match(match_value.client__id());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_client__id.match_omit()){
 TTCN_Logger::log_logmatch_info(".client_id := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_client__id.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_data.match(match_value.data())){
TTCN_Logger::log_logmatch_info(".data");
single_value->field_data.log_match(match_value.data());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ client_id := ");
if (match_value.client__id().ispresent()) single_value->field_client__id.log_match(match_value.client__id());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_client__id.log();
if (single_value->field_client__id.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log_match(match_value.data());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__TCP_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_client__id.encode_text(text_buf);
single_value->field_data.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP.");
}
}

void ASP__TCP_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_client__id.decode_text(text_buf);
single_value->field_data.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__TCP_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TCPasp_Types.ASP_TCP.");
}
}

void ASP__TCP_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TCPasp_Types.ASP_TCP'");
    }
    if (strcmp("client_id", param_field) == 0) {
      client__id().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TCPasp_Types.ASP_TCP'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @TCPasp_Types.ASP_TCP has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) client__id().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "client_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          client__id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TCPasp_Types.ASP_TCP");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__TCP_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_client__id.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP");
single_value->field_data.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TCPasp_Types.ASP_TCP");
}

boolean ASP__TCP_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean ASP__TCP_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

ASP__TCP__Connect::ASP__TCP__Connect()
{
  bound_flag = FALSE;
}

ASP__TCP__Connect::ASP__TCP__Connect(const CHARSTRING& par_hostname,
    const INTEGER& par_portnumber,
    const OPTIONAL<CHARSTRING>& par_local__hostname,
    const OPTIONAL<INTEGER>& par_local__portnumber)
  :   field_hostname(par_hostname),
  field_portnumber(par_portnumber),
  field_local__hostname(par_local__hostname),
  field_local__portnumber(par_local__portnumber)
{
  bound_flag = TRUE;
}

ASP__TCP__Connect::ASP__TCP__Connect(const ASP__TCP__Connect& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TCPasp_Types.ASP_TCP_Connect.");
bound_flag = TRUE;
if (other_value.hostname().is_bound()) field_hostname = other_value.hostname();
else field_hostname.clean_up();
if (other_value.portnumber().is_bound()) field_portnumber = other_value.portnumber();
else field_portnumber.clean_up();
if (other_value.local__hostname().is_bound()) field_local__hostname = other_value.local__hostname();
else field_local__hostname.clean_up();
if (other_value.local__portnumber().is_bound()) field_local__portnumber = other_value.local__portnumber();
else field_local__portnumber.clean_up();
}

void ASP__TCP__Connect::clean_up()
{
field_hostname.clean_up();
field_portnumber.clean_up();
field_local__hostname.clean_up();
field_local__portnumber.clean_up();
bound_flag = FALSE;
}

ASP__TCP__Connect& ASP__TCP__Connect::operator=(const ASP__TCP__Connect& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TCPasp_Types.ASP_TCP_Connect.");
  bound_flag = TRUE;
  if (other_value.hostname().is_bound()) field_hostname = other_value.hostname();
  else field_hostname.clean_up();
  if (other_value.portnumber().is_bound()) field_portnumber = other_value.portnumber();
  else field_portnumber.clean_up();
  if (other_value.local__hostname().is_bound()) field_local__hostname = other_value.local__hostname();
  else field_local__hostname.clean_up();
  if (other_value.local__portnumber().is_bound()) field_local__portnumber = other_value.local__portnumber();
  else field_local__portnumber.clean_up();
}
return *this;
}

boolean ASP__TCP__Connect::operator==(const ASP__TCP__Connect& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_hostname==other_value.field_hostname
  && field_portnumber==other_value.field_portnumber
  && field_local__hostname==other_value.field_local__hostname
  && field_local__portnumber==other_value.field_local__portnumber;
}

boolean ASP__TCP__Connect::is_bound() const
{
if (bound_flag) return TRUE;
if(field_hostname.is_bound()) return TRUE;
if(field_portnumber.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_local__hostname.get_selection() || field_local__hostname.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_local__portnumber.get_selection() || field_local__portnumber.is_bound()) return TRUE;
return FALSE;
}
boolean ASP__TCP__Connect::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_hostname.is_value()) return FALSE;
if(!field_portnumber.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_local__hostname.get_selection() && !field_local__hostname.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_local__portnumber.get_selection() && !field_local__portnumber.is_value()) return FALSE;
return TRUE;
}
int ASP__TCP__Connect::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TCPasp_Types.ASP_TCP_Connect");
  int ret_val = 2;
  if (field_local__hostname.ispresent()) ret_val++;
  if (field_local__portnumber.ispresent()) ret_val++;
  return ret_val;
}

void ASP__TCP__Connect::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ hostname := ");
field_hostname.log();
TTCN_Logger::log_event_str(", portnumber := ");
field_portnumber.log();
TTCN_Logger::log_event_str(", local_hostname := ");
field_local__hostname.log();
TTCN_Logger::log_event_str(", local_portnumber := ");
field_local__portnumber.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__TCP__Connect::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TCPasp_Types.ASP_TCP_Connect'");
    }
    if (strcmp("hostname", param_field) == 0) {
      hostname().set_param(param);
      return;
    } else if (strcmp("portnumber", param_field) == 0) {
      portnumber().set_param(param);
      return;
    } else if (strcmp("local_hostname", param_field) == 0) {
      local__hostname().set_param(param);
      return;
    } else if (strcmp("local_portnumber", param_field) == 0) {
      local__portnumber().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TCPasp_Types.ASP_TCP_Connect'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record value of type @TCPasp_Types.ASP_TCP_Connect has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) hostname().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) portnumber().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) local__hostname().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) local__portnumber().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hostname")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hostname().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "portnumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          portnumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "local_hostname")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          local__hostname().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "local_portnumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          local__portnumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Connect: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TCPasp_Types.ASP_TCP_Connect");
  }
}

void ASP__TCP__Connect::set_implicit_omit()
{
if (hostname().is_bound()) hostname().set_implicit_omit();
if (portnumber().is_bound()) portnumber().set_implicit_omit();
if (!local__hostname().is_bound()) local__hostname() = OMIT_VALUE;
else local__hostname().set_implicit_omit();
if (!local__portnumber().is_bound()) local__portnumber() = OMIT_VALUE;
else local__portnumber().set_implicit_omit();
}

void ASP__TCP__Connect::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TCPasp_Types.ASP_TCP_Connect.");
field_hostname.encode_text(text_buf);
field_portnumber.encode_text(text_buf);
field_local__hostname.encode_text(text_buf);
field_local__portnumber.encode_text(text_buf);
}

void ASP__TCP__Connect::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_hostname.decode_text(text_buf);
field_portnumber.decode_text(text_buf);
field_local__hostname.decode_text(text_buf);
field_local__portnumber.decode_text(text_buf);
}

struct ASP__TCP__Connect_template::single_value_struct {
CHARSTRING_template field_hostname;
INTEGER_template field_portnumber;
CHARSTRING_template field_local__hostname;
INTEGER_template field_local__portnumber;
};

void ASP__TCP__Connect_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_hostname = ANY_VALUE;
single_value->field_portnumber = ANY_VALUE;
single_value->field_local__hostname = ANY_OR_OMIT;
single_value->field_local__portnumber = ANY_OR_OMIT;
}
}
}

void ASP__TCP__Connect_template::copy_value(const ASP__TCP__Connect& other_value)
{
single_value = new single_value_struct;
if (other_value.hostname().is_bound()) {
  single_value->field_hostname = other_value.hostname();
} else {
  single_value->field_hostname.clean_up();
}
if (other_value.portnumber().is_bound()) {
  single_value->field_portnumber = other_value.portnumber();
} else {
  single_value->field_portnumber.clean_up();
}
if (other_value.local__hostname().is_bound()) {
  if (other_value.local__hostname().ispresent()) single_value->field_local__hostname = other_value.local__hostname()();
  else single_value->field_local__hostname = OMIT_VALUE;
} else {
  single_value->field_local__hostname.clean_up();
}
if (other_value.local__portnumber().is_bound()) {
  if (other_value.local__portnumber().ispresent()) single_value->field_local__portnumber = other_value.local__portnumber()();
  else single_value->field_local__portnumber = OMIT_VALUE;
} else {
  single_value->field_local__portnumber.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__TCP__Connect_template::copy_template(const ASP__TCP__Connect_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.hostname().get_selection()) {
single_value->field_hostname = other_value.hostname();
} else {
single_value->field_hostname.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.portnumber().get_selection()) {
single_value->field_portnumber = other_value.portnumber();
} else {
single_value->field_portnumber.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.local__hostname().get_selection()) {
single_value->field_local__hostname = other_value.local__hostname();
} else {
single_value->field_local__hostname.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.local__portnumber().get_selection()) {
single_value->field_local__portnumber = other_value.local__portnumber();
} else {
single_value->field_local__portnumber.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__TCP__Connect_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Connect.");
break;
}
set_selection(other_value);
}

ASP__TCP__Connect_template::ASP__TCP__Connect_template()
{
}

ASP__TCP__Connect_template::ASP__TCP__Connect_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__TCP__Connect_template::ASP__TCP__Connect_template(const ASP__TCP__Connect& other_value)
{
copy_value(other_value);
}

ASP__TCP__Connect_template::ASP__TCP__Connect_template(const OPTIONAL<ASP__TCP__Connect>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Connect&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TCPasp_Types.ASP_TCP_Connect from an unbound optional field.");
}
}

ASP__TCP__Connect_template::ASP__TCP__Connect_template(const ASP__TCP__Connect_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__TCP__Connect_template::~ASP__TCP__Connect_template()
{
clean_up();
}

ASP__TCP__Connect_template& ASP__TCP__Connect_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__TCP__Connect_template& ASP__TCP__Connect_template::operator=(const ASP__TCP__Connect& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__TCP__Connect_template& ASP__TCP__Connect_template::operator=(const OPTIONAL<ASP__TCP__Connect>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Connect&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TCPasp_Types.ASP_TCP_Connect.");
}
return *this;
}

ASP__TCP__Connect_template& ASP__TCP__Connect_template::operator=(const ASP__TCP__Connect_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__TCP__Connect_template::match(const ASP__TCP__Connect& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.hostname().is_bound()) return FALSE;
if(!single_value->field_hostname.match(other_value.hostname()))return FALSE;
if(!other_value.portnumber().is_bound()) return FALSE;
if(!single_value->field_portnumber.match(other_value.portnumber()))return FALSE;
if(!other_value.local__hostname().is_bound()) return FALSE;
if((other_value.local__hostname().ispresent() ? !single_value->field_local__hostname.match((const CHARSTRING&)other_value.local__hostname()) : !single_value->field_local__hostname.match_omit()))return FALSE;
if(!other_value.local__portnumber().is_bound()) return FALSE;
if((other_value.local__portnumber().ispresent() ? !single_value->field_local__portnumber.match((const INTEGER&)other_value.local__portnumber()) : !single_value->field_local__portnumber.match_omit()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Connect.");
}
return FALSE;
}

boolean ASP__TCP__Connect_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_hostname.is_bound()) return TRUE;
if (single_value->field_portnumber.is_bound()) return TRUE;
if (single_value->field_local__hostname.is_omit() || single_value->field_local__hostname.is_bound()) return TRUE;
if (single_value->field_local__portnumber.is_omit() || single_value->field_local__portnumber.is_bound()) return TRUE;
return FALSE;
}

boolean ASP__TCP__Connect_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_hostname.is_value()) return FALSE;
if (!single_value->field_portnumber.is_value()) return FALSE;
if (!single_value->field_local__hostname.is_omit() && !single_value->field_local__hostname.is_value()) return FALSE;
if (!single_value->field_local__portnumber.is_omit() && !single_value->field_local__portnumber.is_value()) return FALSE;
return TRUE;
}

void ASP__TCP__Connect_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__TCP__Connect ASP__TCP__Connect_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TCPasp_Types.ASP_TCP_Connect.");
ASP__TCP__Connect ret_val;
if (single_value->field_hostname.is_bound()) {
ret_val.hostname() = single_value->field_hostname.valueof();
}
if (single_value->field_portnumber.is_bound()) {
ret_val.portnumber() = single_value->field_portnumber.valueof();
}
if (single_value->field_local__hostname.is_omit()) ret_val.local__hostname() = OMIT_VALUE;
else if (single_value->field_local__hostname.is_bound()) {
ret_val.local__hostname() = single_value->field_local__hostname.valueof();
}
if (single_value->field_local__portnumber.is_omit()) ret_val.local__portnumber() = OMIT_VALUE;
else if (single_value->field_local__portnumber.is_bound()) {
ret_val.local__portnumber() = single_value->field_local__portnumber.valueof();
}
return ret_val;
}

void ASP__TCP__Connect_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TCPasp_Types.ASP_TCP_Connect.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__TCP__Connect_template[list_length];
}

ASP__TCP__Connect_template& ASP__TCP__Connect_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TCPasp_Types.ASP_TCP_Connect.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TCPasp_Types.ASP_TCP_Connect.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__TCP__Connect_template::hostname()
{
set_specific();
return single_value->field_hostname;
}

const CHARSTRING_template& ASP__TCP__Connect_template::hostname() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field hostname of a non-specific template of type @TCPasp_Types.ASP_TCP_Connect.");
return single_value->field_hostname;
}

INTEGER_template& ASP__TCP__Connect_template::portnumber()
{
set_specific();
return single_value->field_portnumber;
}

const INTEGER_template& ASP__TCP__Connect_template::portnumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field portnumber of a non-specific template of type @TCPasp_Types.ASP_TCP_Connect.");
return single_value->field_portnumber;
}

CHARSTRING_template& ASP__TCP__Connect_template::local__hostname()
{
set_specific();
return single_value->field_local__hostname;
}

const CHARSTRING_template& ASP__TCP__Connect_template::local__hostname() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field local_hostname of a non-specific template of type @TCPasp_Types.ASP_TCP_Connect.");
return single_value->field_local__hostname;
}

INTEGER_template& ASP__TCP__Connect_template::local__portnumber()
{
set_specific();
return single_value->field_local__portnumber;
}

const INTEGER_template& ASP__TCP__Connect_template::local__portnumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field local_portnumber of a non-specific template of type @TCPasp_Types.ASP_TCP_Connect.");
return single_value->field_local__portnumber;
}

int ASP__TCP__Connect_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connect which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_local__hostname.is_present()) ret_val++;
      if (single_value->field_local__portnumber.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connect containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connect containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connect containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connect containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connect containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Connect.");
  }
  return 0;
}

void ASP__TCP__Connect_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ hostname := ");
single_value->field_hostname.log();
TTCN_Logger::log_event_str(", portnumber := ");
single_value->field_portnumber.log();
TTCN_Logger::log_event_str(", local_hostname := ");
single_value->field_local__hostname.log();
TTCN_Logger::log_event_str(", local_portnumber := ");
single_value->field_local__portnumber.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__TCP__Connect_template::log_match(const ASP__TCP__Connect& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_hostname.match(match_value.hostname())){
TTCN_Logger::log_logmatch_info(".hostname");
single_value->field_hostname.log_match(match_value.hostname());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_portnumber.match(match_value.portnumber())){
TTCN_Logger::log_logmatch_info(".portnumber");
single_value->field_portnumber.log_match(match_value.portnumber());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.local__hostname().ispresent()){
if(!single_value->field_local__hostname.match(match_value.local__hostname())){
TTCN_Logger::log_logmatch_info(".local_hostname");
single_value->field_local__hostname.log_match(match_value.local__hostname());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_local__hostname.match_omit()){
 TTCN_Logger::log_logmatch_info(".local_hostname := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_local__hostname.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.local__portnumber().ispresent()){
if(!single_value->field_local__portnumber.match(match_value.local__portnumber())){
TTCN_Logger::log_logmatch_info(".local_portnumber");
single_value->field_local__portnumber.log_match(match_value.local__portnumber());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_local__portnumber.match_omit()){
 TTCN_Logger::log_logmatch_info(".local_portnumber := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_local__portnumber.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ hostname := ");
single_value->field_hostname.log_match(match_value.hostname());
TTCN_Logger::log_event_str(", portnumber := ");
single_value->field_portnumber.log_match(match_value.portnumber());
TTCN_Logger::log_event_str(", local_hostname := ");
if (match_value.local__hostname().ispresent()) single_value->field_local__hostname.log_match(match_value.local__hostname());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_local__hostname.log();
if (single_value->field_local__hostname.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", local_portnumber := ");
if (match_value.local__portnumber().ispresent()) single_value->field_local__portnumber.log_match(match_value.local__portnumber());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_local__portnumber.log();
if (single_value->field_local__portnumber.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__TCP__Connect_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_hostname.encode_text(text_buf);
single_value->field_portnumber.encode_text(text_buf);
single_value->field_local__hostname.encode_text(text_buf);
single_value->field_local__portnumber.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Connect.");
}
}

void ASP__TCP__Connect_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_hostname.decode_text(text_buf);
single_value->field_portnumber.decode_text(text_buf);
single_value->field_local__hostname.decode_text(text_buf);
single_value->field_local__portnumber.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__TCP__Connect_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TCPasp_Types.ASP_TCP_Connect.");
}
}

void ASP__TCP__Connect_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TCPasp_Types.ASP_TCP_Connect'");
    }
    if (strcmp("hostname", param_field) == 0) {
      hostname().set_param(param);
      return;
    } else if (strcmp("portnumber", param_field) == 0) {
      portnumber().set_param(param);
      return;
    } else if (strcmp("local_hostname", param_field) == 0) {
      local__hostname().set_param(param);
      return;
    } else if (strcmp("local_portnumber", param_field) == 0) {
      local__portnumber().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TCPasp_Types.ASP_TCP_Connect'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record template of type @TCPasp_Types.ASP_TCP_Connect has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) hostname().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) portnumber().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) local__hostname().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) local__portnumber().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hostname")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hostname().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "portnumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          portnumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "local_hostname")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          local__hostname().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "local_portnumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          local__portnumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Connect: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TCPasp_Types.ASP_TCP_Connect");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__TCP__Connect_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_hostname.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Connect");
single_value->field_portnumber.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Connect");
single_value->field_local__hostname.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Connect");
single_value->field_local__portnumber.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Connect");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TCPasp_Types.ASP_TCP_Connect");
}

boolean ASP__TCP__Connect_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean ASP__TCP__Connect_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

ASP__TCP__Connect__result::ASP__TCP__Connect__result()
{
  bound_flag = FALSE;
}

ASP__TCP__Connect__result::ASP__TCP__Connect__result(const INTEGER& par_client__id)
  :   field_client__id(par_client__id)
{
  bound_flag = TRUE;
}

ASP__TCP__Connect__result::ASP__TCP__Connect__result(const ASP__TCP__Connect__result& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TCPasp_Types.ASP_TCP_Connect_result.");
bound_flag = TRUE;
if (other_value.client__id().is_bound()) field_client__id = other_value.client__id();
else field_client__id.clean_up();
}

void ASP__TCP__Connect__result::clean_up()
{
field_client__id.clean_up();
bound_flag = FALSE;
}

ASP__TCP__Connect__result& ASP__TCP__Connect__result::operator=(const ASP__TCP__Connect__result& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TCPasp_Types.ASP_TCP_Connect_result.");
  bound_flag = TRUE;
  if (other_value.client__id().is_bound()) field_client__id = other_value.client__id();
  else field_client__id.clean_up();
}
return *this;
}

boolean ASP__TCP__Connect__result::operator==(const ASP__TCP__Connect__result& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_client__id==other_value.field_client__id;
}

boolean ASP__TCP__Connect__result::is_bound() const
{
if (bound_flag) return TRUE;
if(field_client__id.is_bound()) return TRUE;
return FALSE;
}
boolean ASP__TCP__Connect__result::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_client__id.is_value()) return FALSE;
return TRUE;
}
int ASP__TCP__Connect__result::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TCPasp_Types.ASP_TCP_Connect_result");
  return 1;
}

void ASP__TCP__Connect__result::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ client_id := ");
field_client__id.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__TCP__Connect__result::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TCPasp_Types.ASP_TCP_Connect_result'");
    }
    if (strcmp("client_id", param_field) == 0) {
      client__id().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TCPasp_Types.ASP_TCP_Connect_result'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @TCPasp_Types.ASP_TCP_Connect_result has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) client__id().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "client_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          client__id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Connect_result: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TCPasp_Types.ASP_TCP_Connect_result");
  }
}

void ASP__TCP__Connect__result::set_implicit_omit()
{
if (client__id().is_bound()) client__id().set_implicit_omit();
}

void ASP__TCP__Connect__result::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TCPasp_Types.ASP_TCP_Connect_result.");
field_client__id.encode_text(text_buf);
}

void ASP__TCP__Connect__result::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_client__id.decode_text(text_buf);
}

struct ASP__TCP__Connect__result_template::single_value_struct {
INTEGER_template field_client__id;
};

void ASP__TCP__Connect__result_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_client__id = ANY_VALUE;
}
}
}

void ASP__TCP__Connect__result_template::copy_value(const ASP__TCP__Connect__result& other_value)
{
single_value = new single_value_struct;
if (other_value.client__id().is_bound()) {
  single_value->field_client__id = other_value.client__id();
} else {
  single_value->field_client__id.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__TCP__Connect__result_template::copy_template(const ASP__TCP__Connect__result_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.client__id().get_selection()) {
single_value->field_client__id = other_value.client__id();
} else {
single_value->field_client__id.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__TCP__Connect__result_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Connect_result.");
break;
}
set_selection(other_value);
}

ASP__TCP__Connect__result_template::ASP__TCP__Connect__result_template()
{
}

ASP__TCP__Connect__result_template::ASP__TCP__Connect__result_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__TCP__Connect__result_template::ASP__TCP__Connect__result_template(const ASP__TCP__Connect__result& other_value)
{
copy_value(other_value);
}

ASP__TCP__Connect__result_template::ASP__TCP__Connect__result_template(const OPTIONAL<ASP__TCP__Connect__result>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Connect__result&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TCPasp_Types.ASP_TCP_Connect_result from an unbound optional field.");
}
}

ASP__TCP__Connect__result_template::ASP__TCP__Connect__result_template(const ASP__TCP__Connect__result_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__TCP__Connect__result_template::~ASP__TCP__Connect__result_template()
{
clean_up();
}

ASP__TCP__Connect__result_template& ASP__TCP__Connect__result_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__TCP__Connect__result_template& ASP__TCP__Connect__result_template::operator=(const ASP__TCP__Connect__result& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__TCP__Connect__result_template& ASP__TCP__Connect__result_template::operator=(const OPTIONAL<ASP__TCP__Connect__result>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Connect__result&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TCPasp_Types.ASP_TCP_Connect_result.");
}
return *this;
}

ASP__TCP__Connect__result_template& ASP__TCP__Connect__result_template::operator=(const ASP__TCP__Connect__result_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__TCP__Connect__result_template::match(const ASP__TCP__Connect__result& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.client__id().is_bound()) return FALSE;
if(!single_value->field_client__id.match(other_value.client__id()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Connect_result.");
}
return FALSE;
}

boolean ASP__TCP__Connect__result_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_client__id.is_bound()) return TRUE;
return FALSE;
}

boolean ASP__TCP__Connect__result_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_client__id.is_value()) return FALSE;
return TRUE;
}

void ASP__TCP__Connect__result_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__TCP__Connect__result ASP__TCP__Connect__result_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TCPasp_Types.ASP_TCP_Connect_result.");
ASP__TCP__Connect__result ret_val;
if (single_value->field_client__id.is_bound()) {
ret_val.client__id() = single_value->field_client__id.valueof();
}
return ret_val;
}

void ASP__TCP__Connect__result_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TCPasp_Types.ASP_TCP_Connect_result.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__TCP__Connect__result_template[list_length];
}

ASP__TCP__Connect__result_template& ASP__TCP__Connect__result_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TCPasp_Types.ASP_TCP_Connect_result.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TCPasp_Types.ASP_TCP_Connect_result.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__TCP__Connect__result_template::client__id()
{
set_specific();
return single_value->field_client__id;
}

const INTEGER_template& ASP__TCP__Connect__result_template::client__id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field client_id of a non-specific template of type @TCPasp_Types.ASP_TCP_Connect_result.");
return single_value->field_client__id;
}

int ASP__TCP__Connect__result_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connect_result which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connect_result containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connect_result containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connect_result containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connect_result containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connect_result containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Connect_result.");
  }
  return 0;
}

void ASP__TCP__Connect__result_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ client_id := ");
single_value->field_client__id.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__TCP__Connect__result_template::log_match(const ASP__TCP__Connect__result& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_client__id.match(match_value.client__id())){
TTCN_Logger::log_logmatch_info(".client_id");
single_value->field_client__id.log_match(match_value.client__id());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ client_id := ");
single_value->field_client__id.log_match(match_value.client__id());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__TCP__Connect__result_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_client__id.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Connect_result.");
}
}

void ASP__TCP__Connect__result_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_client__id.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__TCP__Connect__result_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TCPasp_Types.ASP_TCP_Connect_result.");
}
}

void ASP__TCP__Connect__result_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TCPasp_Types.ASP_TCP_Connect_result'");
    }
    if (strcmp("client_id", param_field) == 0) {
      client__id().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TCPasp_Types.ASP_TCP_Connect_result'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @TCPasp_Types.ASP_TCP_Connect_result has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) client__id().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "client_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          client__id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Connect_result: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TCPasp_Types.ASP_TCP_Connect_result");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__TCP__Connect__result_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_client__id.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Connect_result");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TCPasp_Types.ASP_TCP_Connect_result");
}

boolean ASP__TCP__Connect__result_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean ASP__TCP__Connect__result_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

ASP__TCP__Connected::ASP__TCP__Connected()
{
  bound_flag = FALSE;
}

ASP__TCP__Connected::ASP__TCP__Connected(const CHARSTRING& par_hostname,
    const INTEGER& par_portnumber,
    const INTEGER& par_client__id)
  :   field_hostname(par_hostname),
  field_portnumber(par_portnumber),
  field_client__id(par_client__id)
{
  bound_flag = TRUE;
}

ASP__TCP__Connected::ASP__TCP__Connected(const ASP__TCP__Connected& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TCPasp_Types.ASP_TCP_Connected.");
bound_flag = TRUE;
if (other_value.hostname().is_bound()) field_hostname = other_value.hostname();
else field_hostname.clean_up();
if (other_value.portnumber().is_bound()) field_portnumber = other_value.portnumber();
else field_portnumber.clean_up();
if (other_value.client__id().is_bound()) field_client__id = other_value.client__id();
else field_client__id.clean_up();
}

void ASP__TCP__Connected::clean_up()
{
field_hostname.clean_up();
field_portnumber.clean_up();
field_client__id.clean_up();
bound_flag = FALSE;
}

ASP__TCP__Connected& ASP__TCP__Connected::operator=(const ASP__TCP__Connected& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TCPasp_Types.ASP_TCP_Connected.");
  bound_flag = TRUE;
  if (other_value.hostname().is_bound()) field_hostname = other_value.hostname();
  else field_hostname.clean_up();
  if (other_value.portnumber().is_bound()) field_portnumber = other_value.portnumber();
  else field_portnumber.clean_up();
  if (other_value.client__id().is_bound()) field_client__id = other_value.client__id();
  else field_client__id.clean_up();
}
return *this;
}

boolean ASP__TCP__Connected::operator==(const ASP__TCP__Connected& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_hostname==other_value.field_hostname
  && field_portnumber==other_value.field_portnumber
  && field_client__id==other_value.field_client__id;
}

boolean ASP__TCP__Connected::is_bound() const
{
if (bound_flag) return TRUE;
if(field_hostname.is_bound()) return TRUE;
if(field_portnumber.is_bound()) return TRUE;
if(field_client__id.is_bound()) return TRUE;
return FALSE;
}
boolean ASP__TCP__Connected::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_hostname.is_value()) return FALSE;
if(!field_portnumber.is_value()) return FALSE;
if(!field_client__id.is_value()) return FALSE;
return TRUE;
}
int ASP__TCP__Connected::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TCPasp_Types.ASP_TCP_Connected");
  return 3;
}

void ASP__TCP__Connected::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ hostname := ");
field_hostname.log();
TTCN_Logger::log_event_str(", portnumber := ");
field_portnumber.log();
TTCN_Logger::log_event_str(", client_id := ");
field_client__id.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__TCP__Connected::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TCPasp_Types.ASP_TCP_Connected'");
    }
    if (strcmp("hostname", param_field) == 0) {
      hostname().set_param(param);
      return;
    } else if (strcmp("portnumber", param_field) == 0) {
      portnumber().set_param(param);
      return;
    } else if (strcmp("client_id", param_field) == 0) {
      client__id().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TCPasp_Types.ASP_TCP_Connected'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @TCPasp_Types.ASP_TCP_Connected has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) hostname().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) portnumber().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) client__id().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hostname")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hostname().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "portnumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          portnumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "client_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          client__id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Connected: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TCPasp_Types.ASP_TCP_Connected");
  }
}

void ASP__TCP__Connected::set_implicit_omit()
{
if (hostname().is_bound()) hostname().set_implicit_omit();
if (portnumber().is_bound()) portnumber().set_implicit_omit();
if (client__id().is_bound()) client__id().set_implicit_omit();
}

void ASP__TCP__Connected::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TCPasp_Types.ASP_TCP_Connected.");
field_hostname.encode_text(text_buf);
field_portnumber.encode_text(text_buf);
field_client__id.encode_text(text_buf);
}

void ASP__TCP__Connected::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_hostname.decode_text(text_buf);
field_portnumber.decode_text(text_buf);
field_client__id.decode_text(text_buf);
}

struct ASP__TCP__Connected_template::single_value_struct {
CHARSTRING_template field_hostname;
INTEGER_template field_portnumber;
INTEGER_template field_client__id;
};

void ASP__TCP__Connected_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_hostname = ANY_VALUE;
single_value->field_portnumber = ANY_VALUE;
single_value->field_client__id = ANY_VALUE;
}
}
}

void ASP__TCP__Connected_template::copy_value(const ASP__TCP__Connected& other_value)
{
single_value = new single_value_struct;
if (other_value.hostname().is_bound()) {
  single_value->field_hostname = other_value.hostname();
} else {
  single_value->field_hostname.clean_up();
}
if (other_value.portnumber().is_bound()) {
  single_value->field_portnumber = other_value.portnumber();
} else {
  single_value->field_portnumber.clean_up();
}
if (other_value.client__id().is_bound()) {
  single_value->field_client__id = other_value.client__id();
} else {
  single_value->field_client__id.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__TCP__Connected_template::copy_template(const ASP__TCP__Connected_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.hostname().get_selection()) {
single_value->field_hostname = other_value.hostname();
} else {
single_value->field_hostname.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.portnumber().get_selection()) {
single_value->field_portnumber = other_value.portnumber();
} else {
single_value->field_portnumber.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.client__id().get_selection()) {
single_value->field_client__id = other_value.client__id();
} else {
single_value->field_client__id.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__TCP__Connected_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Connected.");
break;
}
set_selection(other_value);
}

ASP__TCP__Connected_template::ASP__TCP__Connected_template()
{
}

ASP__TCP__Connected_template::ASP__TCP__Connected_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__TCP__Connected_template::ASP__TCP__Connected_template(const ASP__TCP__Connected& other_value)
{
copy_value(other_value);
}

ASP__TCP__Connected_template::ASP__TCP__Connected_template(const OPTIONAL<ASP__TCP__Connected>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Connected&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TCPasp_Types.ASP_TCP_Connected from an unbound optional field.");
}
}

ASP__TCP__Connected_template::ASP__TCP__Connected_template(const ASP__TCP__Connected_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__TCP__Connected_template::~ASP__TCP__Connected_template()
{
clean_up();
}

ASP__TCP__Connected_template& ASP__TCP__Connected_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__TCP__Connected_template& ASP__TCP__Connected_template::operator=(const ASP__TCP__Connected& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__TCP__Connected_template& ASP__TCP__Connected_template::operator=(const OPTIONAL<ASP__TCP__Connected>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Connected&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TCPasp_Types.ASP_TCP_Connected.");
}
return *this;
}

ASP__TCP__Connected_template& ASP__TCP__Connected_template::operator=(const ASP__TCP__Connected_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__TCP__Connected_template::match(const ASP__TCP__Connected& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.hostname().is_bound()) return FALSE;
if(!single_value->field_hostname.match(other_value.hostname()))return FALSE;
if(!other_value.portnumber().is_bound()) return FALSE;
if(!single_value->field_portnumber.match(other_value.portnumber()))return FALSE;
if(!other_value.client__id().is_bound()) return FALSE;
if(!single_value->field_client__id.match(other_value.client__id()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Connected.");
}
return FALSE;
}

boolean ASP__TCP__Connected_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_hostname.is_bound()) return TRUE;
if (single_value->field_portnumber.is_bound()) return TRUE;
if (single_value->field_client__id.is_bound()) return TRUE;
return FALSE;
}

boolean ASP__TCP__Connected_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_hostname.is_value()) return FALSE;
if (!single_value->field_portnumber.is_value()) return FALSE;
if (!single_value->field_client__id.is_value()) return FALSE;
return TRUE;
}

void ASP__TCP__Connected_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__TCP__Connected ASP__TCP__Connected_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TCPasp_Types.ASP_TCP_Connected.");
ASP__TCP__Connected ret_val;
if (single_value->field_hostname.is_bound()) {
ret_val.hostname() = single_value->field_hostname.valueof();
}
if (single_value->field_portnumber.is_bound()) {
ret_val.portnumber() = single_value->field_portnumber.valueof();
}
if (single_value->field_client__id.is_bound()) {
ret_val.client__id() = single_value->field_client__id.valueof();
}
return ret_val;
}

void ASP__TCP__Connected_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TCPasp_Types.ASP_TCP_Connected.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__TCP__Connected_template[list_length];
}

ASP__TCP__Connected_template& ASP__TCP__Connected_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TCPasp_Types.ASP_TCP_Connected.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TCPasp_Types.ASP_TCP_Connected.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__TCP__Connected_template::hostname()
{
set_specific();
return single_value->field_hostname;
}

const CHARSTRING_template& ASP__TCP__Connected_template::hostname() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field hostname of a non-specific template of type @TCPasp_Types.ASP_TCP_Connected.");
return single_value->field_hostname;
}

INTEGER_template& ASP__TCP__Connected_template::portnumber()
{
set_specific();
return single_value->field_portnumber;
}

const INTEGER_template& ASP__TCP__Connected_template::portnumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field portnumber of a non-specific template of type @TCPasp_Types.ASP_TCP_Connected.");
return single_value->field_portnumber;
}

INTEGER_template& ASP__TCP__Connected_template::client__id()
{
set_specific();
return single_value->field_client__id;
}

const INTEGER_template& ASP__TCP__Connected_template::client__id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field client_id of a non-specific template of type @TCPasp_Types.ASP_TCP_Connected.");
return single_value->field_client__id;
}

int ASP__TCP__Connected_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connected which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connected containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connected containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connected containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connected containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Connected containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Connected.");
  }
  return 0;
}

void ASP__TCP__Connected_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ hostname := ");
single_value->field_hostname.log();
TTCN_Logger::log_event_str(", portnumber := ");
single_value->field_portnumber.log();
TTCN_Logger::log_event_str(", client_id := ");
single_value->field_client__id.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__TCP__Connected_template::log_match(const ASP__TCP__Connected& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_hostname.match(match_value.hostname())){
TTCN_Logger::log_logmatch_info(".hostname");
single_value->field_hostname.log_match(match_value.hostname());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_portnumber.match(match_value.portnumber())){
TTCN_Logger::log_logmatch_info(".portnumber");
single_value->field_portnumber.log_match(match_value.portnumber());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_client__id.match(match_value.client__id())){
TTCN_Logger::log_logmatch_info(".client_id");
single_value->field_client__id.log_match(match_value.client__id());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ hostname := ");
single_value->field_hostname.log_match(match_value.hostname());
TTCN_Logger::log_event_str(", portnumber := ");
single_value->field_portnumber.log_match(match_value.portnumber());
TTCN_Logger::log_event_str(", client_id := ");
single_value->field_client__id.log_match(match_value.client__id());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__TCP__Connected_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_hostname.encode_text(text_buf);
single_value->field_portnumber.encode_text(text_buf);
single_value->field_client__id.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Connected.");
}
}

void ASP__TCP__Connected_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_hostname.decode_text(text_buf);
single_value->field_portnumber.decode_text(text_buf);
single_value->field_client__id.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__TCP__Connected_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TCPasp_Types.ASP_TCP_Connected.");
}
}

void ASP__TCP__Connected_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TCPasp_Types.ASP_TCP_Connected'");
    }
    if (strcmp("hostname", param_field) == 0) {
      hostname().set_param(param);
      return;
    } else if (strcmp("portnumber", param_field) == 0) {
      portnumber().set_param(param);
      return;
    } else if (strcmp("client_id", param_field) == 0) {
      client__id().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TCPasp_Types.ASP_TCP_Connected'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @TCPasp_Types.ASP_TCP_Connected has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) hostname().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) portnumber().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) client__id().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hostname")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hostname().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "portnumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          portnumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "client_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          client__id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Connected: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TCPasp_Types.ASP_TCP_Connected");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__TCP__Connected_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_hostname.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Connected");
single_value->field_portnumber.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Connected");
single_value->field_client__id.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Connected");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TCPasp_Types.ASP_TCP_Connected");
}

boolean ASP__TCP__Connected_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean ASP__TCP__Connected_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

ASP__TCP__Close::ASP__TCP__Close()
{
  bound_flag = FALSE;
}

ASP__TCP__Close::ASP__TCP__Close(const OPTIONAL<INTEGER>& par_client__id)
  :   field_client__id(par_client__id)
{
  bound_flag = TRUE;
}

ASP__TCP__Close::ASP__TCP__Close(const ASP__TCP__Close& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TCPasp_Types.ASP_TCP_Close.");
bound_flag = TRUE;
if (other_value.client__id().is_bound()) field_client__id = other_value.client__id();
else field_client__id.clean_up();
}

void ASP__TCP__Close::clean_up()
{
field_client__id.clean_up();
bound_flag = FALSE;
}

ASP__TCP__Close& ASP__TCP__Close::operator=(const ASP__TCP__Close& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TCPasp_Types.ASP_TCP_Close.");
  bound_flag = TRUE;
  if (other_value.client__id().is_bound()) field_client__id = other_value.client__id();
  else field_client__id.clean_up();
}
return *this;
}

boolean ASP__TCP__Close::operator==(const ASP__TCP__Close& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_client__id==other_value.field_client__id;
}

boolean ASP__TCP__Close::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_client__id.get_selection() || field_client__id.is_bound()) return TRUE;
return FALSE;
}
boolean ASP__TCP__Close::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_client__id.get_selection() && !field_client__id.is_value()) return FALSE;
return TRUE;
}
int ASP__TCP__Close::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TCPasp_Types.ASP_TCP_Close");
  int ret_val = 0;
  if (field_client__id.ispresent()) ret_val++;
  return ret_val;
}

void ASP__TCP__Close::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ client_id := ");
field_client__id.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__TCP__Close::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TCPasp_Types.ASP_TCP_Close'");
    }
    if (strcmp("client_id", param_field) == 0) {
      client__id().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TCPasp_Types.ASP_TCP_Close'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @TCPasp_Types.ASP_TCP_Close has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) client__id().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "client_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          client__id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Close: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TCPasp_Types.ASP_TCP_Close");
  }
}

void ASP__TCP__Close::set_implicit_omit()
{
if (!client__id().is_bound()) client__id() = OMIT_VALUE;
else client__id().set_implicit_omit();
}

void ASP__TCP__Close::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TCPasp_Types.ASP_TCP_Close.");
field_client__id.encode_text(text_buf);
}

void ASP__TCP__Close::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_client__id.decode_text(text_buf);
}

struct ASP__TCP__Close_template::single_value_struct {
INTEGER_template field_client__id;
};

void ASP__TCP__Close_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_client__id = ANY_OR_OMIT;
}
}
}

void ASP__TCP__Close_template::copy_value(const ASP__TCP__Close& other_value)
{
single_value = new single_value_struct;
if (other_value.client__id().is_bound()) {
  if (other_value.client__id().ispresent()) single_value->field_client__id = other_value.client__id()();
  else single_value->field_client__id = OMIT_VALUE;
} else {
  single_value->field_client__id.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__TCP__Close_template::copy_template(const ASP__TCP__Close_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.client__id().get_selection()) {
single_value->field_client__id = other_value.client__id();
} else {
single_value->field_client__id.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__TCP__Close_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Close.");
break;
}
set_selection(other_value);
}

ASP__TCP__Close_template::ASP__TCP__Close_template()
{
}

ASP__TCP__Close_template::ASP__TCP__Close_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__TCP__Close_template::ASP__TCP__Close_template(const ASP__TCP__Close& other_value)
{
copy_value(other_value);
}

ASP__TCP__Close_template::ASP__TCP__Close_template(const OPTIONAL<ASP__TCP__Close>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Close&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TCPasp_Types.ASP_TCP_Close from an unbound optional field.");
}
}

ASP__TCP__Close_template::ASP__TCP__Close_template(const ASP__TCP__Close_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__TCP__Close_template::~ASP__TCP__Close_template()
{
clean_up();
}

ASP__TCP__Close_template& ASP__TCP__Close_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__TCP__Close_template& ASP__TCP__Close_template::operator=(const ASP__TCP__Close& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__TCP__Close_template& ASP__TCP__Close_template::operator=(const OPTIONAL<ASP__TCP__Close>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Close&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TCPasp_Types.ASP_TCP_Close.");
}
return *this;
}

ASP__TCP__Close_template& ASP__TCP__Close_template::operator=(const ASP__TCP__Close_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__TCP__Close_template::match(const ASP__TCP__Close& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.client__id().is_bound()) return FALSE;
if((other_value.client__id().ispresent() ? !single_value->field_client__id.match((const INTEGER&)other_value.client__id()) : !single_value->field_client__id.match_omit()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Close.");
}
return FALSE;
}

boolean ASP__TCP__Close_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_client__id.is_omit() || single_value->field_client__id.is_bound()) return TRUE;
return FALSE;
}

boolean ASP__TCP__Close_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_client__id.is_omit() && !single_value->field_client__id.is_value()) return FALSE;
return TRUE;
}

void ASP__TCP__Close_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__TCP__Close ASP__TCP__Close_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TCPasp_Types.ASP_TCP_Close.");
ASP__TCP__Close ret_val;
if (single_value->field_client__id.is_omit()) ret_val.client__id() = OMIT_VALUE;
else if (single_value->field_client__id.is_bound()) {
ret_val.client__id() = single_value->field_client__id.valueof();
}
return ret_val;
}

void ASP__TCP__Close_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TCPasp_Types.ASP_TCP_Close.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__TCP__Close_template[list_length];
}

ASP__TCP__Close_template& ASP__TCP__Close_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TCPasp_Types.ASP_TCP_Close.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TCPasp_Types.ASP_TCP_Close.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__TCP__Close_template::client__id()
{
set_specific();
return single_value->field_client__id;
}

const INTEGER_template& ASP__TCP__Close_template::client__id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field client_id of a non-specific template of type @TCPasp_Types.ASP_TCP_Close.");
return single_value->field_client__id;
}

int ASP__TCP__Close_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Close which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_client__id.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Close containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Close containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Close containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Close containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Close containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Close.");
  }
  return 0;
}

void ASP__TCP__Close_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ client_id := ");
single_value->field_client__id.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__TCP__Close_template::log_match(const ASP__TCP__Close& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.client__id().ispresent()){
if(!single_value->field_client__id.match(match_value.client__id())){
TTCN_Logger::log_logmatch_info(".client_id");
single_value->field_client__id.log_match(match_value.client__id());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_client__id.match_omit()){
 TTCN_Logger::log_logmatch_info(".client_id := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_client__id.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ client_id := ");
if (match_value.client__id().ispresent()) single_value->field_client__id.log_match(match_value.client__id());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_client__id.log();
if (single_value->field_client__id.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__TCP__Close_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_client__id.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Close.");
}
}

void ASP__TCP__Close_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_client__id.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__TCP__Close_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TCPasp_Types.ASP_TCP_Close.");
}
}

void ASP__TCP__Close_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TCPasp_Types.ASP_TCP_Close'");
    }
    if (strcmp("client_id", param_field) == 0) {
      client__id().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TCPasp_Types.ASP_TCP_Close'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @TCPasp_Types.ASP_TCP_Close has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) client__id().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "client_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          client__id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Close: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TCPasp_Types.ASP_TCP_Close");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__TCP__Close_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_client__id.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Close");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TCPasp_Types.ASP_TCP_Close");
}

boolean ASP__TCP__Close_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean ASP__TCP__Close_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

ASP__TCP__Listen::ASP__TCP__Listen()
{
  bound_flag = FALSE;
}

ASP__TCP__Listen::ASP__TCP__Listen(const OPTIONAL<INTEGER>& par_portnumber,
    const OPTIONAL<CHARSTRING>& par_local__hostname)
  :   field_portnumber(par_portnumber),
  field_local__hostname(par_local__hostname)
{
  bound_flag = TRUE;
}

ASP__TCP__Listen::ASP__TCP__Listen(const ASP__TCP__Listen& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TCPasp_Types.ASP_TCP_Listen.");
bound_flag = TRUE;
if (other_value.portnumber().is_bound()) field_portnumber = other_value.portnumber();
else field_portnumber.clean_up();
if (other_value.local__hostname().is_bound()) field_local__hostname = other_value.local__hostname();
else field_local__hostname.clean_up();
}

void ASP__TCP__Listen::clean_up()
{
field_portnumber.clean_up();
field_local__hostname.clean_up();
bound_flag = FALSE;
}

ASP__TCP__Listen& ASP__TCP__Listen::operator=(const ASP__TCP__Listen& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TCPasp_Types.ASP_TCP_Listen.");
  bound_flag = TRUE;
  if (other_value.portnumber().is_bound()) field_portnumber = other_value.portnumber();
  else field_portnumber.clean_up();
  if (other_value.local__hostname().is_bound()) field_local__hostname = other_value.local__hostname();
  else field_local__hostname.clean_up();
}
return *this;
}

boolean ASP__TCP__Listen::operator==(const ASP__TCP__Listen& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_portnumber==other_value.field_portnumber
  && field_local__hostname==other_value.field_local__hostname;
}

boolean ASP__TCP__Listen::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_portnumber.get_selection() || field_portnumber.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_local__hostname.get_selection() || field_local__hostname.is_bound()) return TRUE;
return FALSE;
}
boolean ASP__TCP__Listen::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_portnumber.get_selection() && !field_portnumber.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_local__hostname.get_selection() && !field_local__hostname.is_value()) return FALSE;
return TRUE;
}
int ASP__TCP__Listen::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TCPasp_Types.ASP_TCP_Listen");
  int ret_val = 0;
  if (field_portnumber.ispresent()) ret_val++;
  if (field_local__hostname.ispresent()) ret_val++;
  return ret_val;
}

void ASP__TCP__Listen::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ portnumber := ");
field_portnumber.log();
TTCN_Logger::log_event_str(", local_hostname := ");
field_local__hostname.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__TCP__Listen::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TCPasp_Types.ASP_TCP_Listen'");
    }
    if (strcmp("portnumber", param_field) == 0) {
      portnumber().set_param(param);
      return;
    } else if (strcmp("local_hostname", param_field) == 0) {
      local__hostname().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TCPasp_Types.ASP_TCP_Listen'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @TCPasp_Types.ASP_TCP_Listen has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) portnumber().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) local__hostname().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "portnumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          portnumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "local_hostname")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          local__hostname().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Listen: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TCPasp_Types.ASP_TCP_Listen");
  }
}

void ASP__TCP__Listen::set_implicit_omit()
{
if (!portnumber().is_bound()) portnumber() = OMIT_VALUE;
else portnumber().set_implicit_omit();
if (!local__hostname().is_bound()) local__hostname() = OMIT_VALUE;
else local__hostname().set_implicit_omit();
}

void ASP__TCP__Listen::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TCPasp_Types.ASP_TCP_Listen.");
field_portnumber.encode_text(text_buf);
field_local__hostname.encode_text(text_buf);
}

void ASP__TCP__Listen::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_portnumber.decode_text(text_buf);
field_local__hostname.decode_text(text_buf);
}

struct ASP__TCP__Listen_template::single_value_struct {
INTEGER_template field_portnumber;
CHARSTRING_template field_local__hostname;
};

void ASP__TCP__Listen_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_portnumber = ANY_OR_OMIT;
single_value->field_local__hostname = ANY_OR_OMIT;
}
}
}

void ASP__TCP__Listen_template::copy_value(const ASP__TCP__Listen& other_value)
{
single_value = new single_value_struct;
if (other_value.portnumber().is_bound()) {
  if (other_value.portnumber().ispresent()) single_value->field_portnumber = other_value.portnumber()();
  else single_value->field_portnumber = OMIT_VALUE;
} else {
  single_value->field_portnumber.clean_up();
}
if (other_value.local__hostname().is_bound()) {
  if (other_value.local__hostname().ispresent()) single_value->field_local__hostname = other_value.local__hostname()();
  else single_value->field_local__hostname = OMIT_VALUE;
} else {
  single_value->field_local__hostname.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__TCP__Listen_template::copy_template(const ASP__TCP__Listen_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.portnumber().get_selection()) {
single_value->field_portnumber = other_value.portnumber();
} else {
single_value->field_portnumber.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.local__hostname().get_selection()) {
single_value->field_local__hostname = other_value.local__hostname();
} else {
single_value->field_local__hostname.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__TCP__Listen_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Listen.");
break;
}
set_selection(other_value);
}

ASP__TCP__Listen_template::ASP__TCP__Listen_template()
{
}

ASP__TCP__Listen_template::ASP__TCP__Listen_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__TCP__Listen_template::ASP__TCP__Listen_template(const ASP__TCP__Listen& other_value)
{
copy_value(other_value);
}

ASP__TCP__Listen_template::ASP__TCP__Listen_template(const OPTIONAL<ASP__TCP__Listen>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Listen&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TCPasp_Types.ASP_TCP_Listen from an unbound optional field.");
}
}

ASP__TCP__Listen_template::ASP__TCP__Listen_template(const ASP__TCP__Listen_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__TCP__Listen_template::~ASP__TCP__Listen_template()
{
clean_up();
}

ASP__TCP__Listen_template& ASP__TCP__Listen_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__TCP__Listen_template& ASP__TCP__Listen_template::operator=(const ASP__TCP__Listen& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__TCP__Listen_template& ASP__TCP__Listen_template::operator=(const OPTIONAL<ASP__TCP__Listen>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Listen&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TCPasp_Types.ASP_TCP_Listen.");
}
return *this;
}

ASP__TCP__Listen_template& ASP__TCP__Listen_template::operator=(const ASP__TCP__Listen_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__TCP__Listen_template::match(const ASP__TCP__Listen& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.portnumber().is_bound()) return FALSE;
if((other_value.portnumber().ispresent() ? !single_value->field_portnumber.match((const INTEGER&)other_value.portnumber()) : !single_value->field_portnumber.match_omit()))return FALSE;
if(!other_value.local__hostname().is_bound()) return FALSE;
if((other_value.local__hostname().ispresent() ? !single_value->field_local__hostname.match((const CHARSTRING&)other_value.local__hostname()) : !single_value->field_local__hostname.match_omit()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Listen.");
}
return FALSE;
}

boolean ASP__TCP__Listen_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_portnumber.is_omit() || single_value->field_portnumber.is_bound()) return TRUE;
if (single_value->field_local__hostname.is_omit() || single_value->field_local__hostname.is_bound()) return TRUE;
return FALSE;
}

boolean ASP__TCP__Listen_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_portnumber.is_omit() && !single_value->field_portnumber.is_value()) return FALSE;
if (!single_value->field_local__hostname.is_omit() && !single_value->field_local__hostname.is_value()) return FALSE;
return TRUE;
}

void ASP__TCP__Listen_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__TCP__Listen ASP__TCP__Listen_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TCPasp_Types.ASP_TCP_Listen.");
ASP__TCP__Listen ret_val;
if (single_value->field_portnumber.is_omit()) ret_val.portnumber() = OMIT_VALUE;
else if (single_value->field_portnumber.is_bound()) {
ret_val.portnumber() = single_value->field_portnumber.valueof();
}
if (single_value->field_local__hostname.is_omit()) ret_val.local__hostname() = OMIT_VALUE;
else if (single_value->field_local__hostname.is_bound()) {
ret_val.local__hostname() = single_value->field_local__hostname.valueof();
}
return ret_val;
}

void ASP__TCP__Listen_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TCPasp_Types.ASP_TCP_Listen.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__TCP__Listen_template[list_length];
}

ASP__TCP__Listen_template& ASP__TCP__Listen_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TCPasp_Types.ASP_TCP_Listen.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TCPasp_Types.ASP_TCP_Listen.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__TCP__Listen_template::portnumber()
{
set_specific();
return single_value->field_portnumber;
}

const INTEGER_template& ASP__TCP__Listen_template::portnumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field portnumber of a non-specific template of type @TCPasp_Types.ASP_TCP_Listen.");
return single_value->field_portnumber;
}

CHARSTRING_template& ASP__TCP__Listen_template::local__hostname()
{
set_specific();
return single_value->field_local__hostname;
}

const CHARSTRING_template& ASP__TCP__Listen_template::local__hostname() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field local_hostname of a non-specific template of type @TCPasp_Types.ASP_TCP_Listen.");
return single_value->field_local__hostname;
}

int ASP__TCP__Listen_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Listen which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_portnumber.is_present()) ret_val++;
      if (single_value->field_local__hostname.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Listen containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Listen containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Listen containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Listen containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Listen containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Listen.");
  }
  return 0;
}

void ASP__TCP__Listen_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ portnumber := ");
single_value->field_portnumber.log();
TTCN_Logger::log_event_str(", local_hostname := ");
single_value->field_local__hostname.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__TCP__Listen_template::log_match(const ASP__TCP__Listen& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.portnumber().ispresent()){
if(!single_value->field_portnumber.match(match_value.portnumber())){
TTCN_Logger::log_logmatch_info(".portnumber");
single_value->field_portnumber.log_match(match_value.portnumber());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_portnumber.match_omit()){
 TTCN_Logger::log_logmatch_info(".portnumber := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_portnumber.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.local__hostname().ispresent()){
if(!single_value->field_local__hostname.match(match_value.local__hostname())){
TTCN_Logger::log_logmatch_info(".local_hostname");
single_value->field_local__hostname.log_match(match_value.local__hostname());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_local__hostname.match_omit()){
 TTCN_Logger::log_logmatch_info(".local_hostname := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_local__hostname.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ portnumber := ");
if (match_value.portnumber().ispresent()) single_value->field_portnumber.log_match(match_value.portnumber());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_portnumber.log();
if (single_value->field_portnumber.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", local_hostname := ");
if (match_value.local__hostname().ispresent()) single_value->field_local__hostname.log_match(match_value.local__hostname());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_local__hostname.log();
if (single_value->field_local__hostname.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__TCP__Listen_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_portnumber.encode_text(text_buf);
single_value->field_local__hostname.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Listen.");
}
}

void ASP__TCP__Listen_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_portnumber.decode_text(text_buf);
single_value->field_local__hostname.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__TCP__Listen_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TCPasp_Types.ASP_TCP_Listen.");
}
}

void ASP__TCP__Listen_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TCPasp_Types.ASP_TCP_Listen'");
    }
    if (strcmp("portnumber", param_field) == 0) {
      portnumber().set_param(param);
      return;
    } else if (strcmp("local_hostname", param_field) == 0) {
      local__hostname().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TCPasp_Types.ASP_TCP_Listen'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @TCPasp_Types.ASP_TCP_Listen has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) portnumber().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) local__hostname().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "portnumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          portnumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "local_hostname")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          local__hostname().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Listen: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TCPasp_Types.ASP_TCP_Listen");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__TCP__Listen_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_portnumber.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Listen");
single_value->field_local__hostname.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Listen");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TCPasp_Types.ASP_TCP_Listen");
}

boolean ASP__TCP__Listen_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean ASP__TCP__Listen_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

ASP__TCP__Listen__result::ASP__TCP__Listen__result()
{
  bound_flag = FALSE;
}

ASP__TCP__Listen__result::ASP__TCP__Listen__result(const INTEGER& par_portnumber)
  :   field_portnumber(par_portnumber)
{
  bound_flag = TRUE;
}

ASP__TCP__Listen__result::ASP__TCP__Listen__result(const ASP__TCP__Listen__result& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TCPasp_Types.ASP_TCP_Listen_result.");
bound_flag = TRUE;
if (other_value.portnumber().is_bound()) field_portnumber = other_value.portnumber();
else field_portnumber.clean_up();
}

void ASP__TCP__Listen__result::clean_up()
{
field_portnumber.clean_up();
bound_flag = FALSE;
}

ASP__TCP__Listen__result& ASP__TCP__Listen__result::operator=(const ASP__TCP__Listen__result& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TCPasp_Types.ASP_TCP_Listen_result.");
  bound_flag = TRUE;
  if (other_value.portnumber().is_bound()) field_portnumber = other_value.portnumber();
  else field_portnumber.clean_up();
}
return *this;
}

boolean ASP__TCP__Listen__result::operator==(const ASP__TCP__Listen__result& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_portnumber==other_value.field_portnumber;
}

boolean ASP__TCP__Listen__result::is_bound() const
{
if (bound_flag) return TRUE;
if(field_portnumber.is_bound()) return TRUE;
return FALSE;
}
boolean ASP__TCP__Listen__result::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_portnumber.is_value()) return FALSE;
return TRUE;
}
int ASP__TCP__Listen__result::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TCPasp_Types.ASP_TCP_Listen_result");
  return 1;
}

void ASP__TCP__Listen__result::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ portnumber := ");
field_portnumber.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__TCP__Listen__result::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TCPasp_Types.ASP_TCP_Listen_result'");
    }
    if (strcmp("portnumber", param_field) == 0) {
      portnumber().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TCPasp_Types.ASP_TCP_Listen_result'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @TCPasp_Types.ASP_TCP_Listen_result has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) portnumber().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "portnumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          portnumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Listen_result: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TCPasp_Types.ASP_TCP_Listen_result");
  }
}

void ASP__TCP__Listen__result::set_implicit_omit()
{
if (portnumber().is_bound()) portnumber().set_implicit_omit();
}

void ASP__TCP__Listen__result::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TCPasp_Types.ASP_TCP_Listen_result.");
field_portnumber.encode_text(text_buf);
}

void ASP__TCP__Listen__result::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_portnumber.decode_text(text_buf);
}

struct ASP__TCP__Listen__result_template::single_value_struct {
INTEGER_template field_portnumber;
};

void ASP__TCP__Listen__result_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_portnumber = ANY_VALUE;
}
}
}

void ASP__TCP__Listen__result_template::copy_value(const ASP__TCP__Listen__result& other_value)
{
single_value = new single_value_struct;
if (other_value.portnumber().is_bound()) {
  single_value->field_portnumber = other_value.portnumber();
} else {
  single_value->field_portnumber.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__TCP__Listen__result_template::copy_template(const ASP__TCP__Listen__result_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.portnumber().get_selection()) {
single_value->field_portnumber = other_value.portnumber();
} else {
single_value->field_portnumber.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__TCP__Listen__result_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Listen_result.");
break;
}
set_selection(other_value);
}

ASP__TCP__Listen__result_template::ASP__TCP__Listen__result_template()
{
}

ASP__TCP__Listen__result_template::ASP__TCP__Listen__result_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__TCP__Listen__result_template::ASP__TCP__Listen__result_template(const ASP__TCP__Listen__result& other_value)
{
copy_value(other_value);
}

ASP__TCP__Listen__result_template::ASP__TCP__Listen__result_template(const OPTIONAL<ASP__TCP__Listen__result>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Listen__result&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TCPasp_Types.ASP_TCP_Listen_result from an unbound optional field.");
}
}

ASP__TCP__Listen__result_template::ASP__TCP__Listen__result_template(const ASP__TCP__Listen__result_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__TCP__Listen__result_template::~ASP__TCP__Listen__result_template()
{
clean_up();
}

ASP__TCP__Listen__result_template& ASP__TCP__Listen__result_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__TCP__Listen__result_template& ASP__TCP__Listen__result_template::operator=(const ASP__TCP__Listen__result& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__TCP__Listen__result_template& ASP__TCP__Listen__result_template::operator=(const OPTIONAL<ASP__TCP__Listen__result>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Listen__result&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TCPasp_Types.ASP_TCP_Listen_result.");
}
return *this;
}

ASP__TCP__Listen__result_template& ASP__TCP__Listen__result_template::operator=(const ASP__TCP__Listen__result_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__TCP__Listen__result_template::match(const ASP__TCP__Listen__result& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.portnumber().is_bound()) return FALSE;
if(!single_value->field_portnumber.match(other_value.portnumber()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Listen_result.");
}
return FALSE;
}

boolean ASP__TCP__Listen__result_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_portnumber.is_bound()) return TRUE;
return FALSE;
}

boolean ASP__TCP__Listen__result_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_portnumber.is_value()) return FALSE;
return TRUE;
}

void ASP__TCP__Listen__result_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__TCP__Listen__result ASP__TCP__Listen__result_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TCPasp_Types.ASP_TCP_Listen_result.");
ASP__TCP__Listen__result ret_val;
if (single_value->field_portnumber.is_bound()) {
ret_val.portnumber() = single_value->field_portnumber.valueof();
}
return ret_val;
}

void ASP__TCP__Listen__result_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TCPasp_Types.ASP_TCP_Listen_result.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__TCP__Listen__result_template[list_length];
}

ASP__TCP__Listen__result_template& ASP__TCP__Listen__result_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TCPasp_Types.ASP_TCP_Listen_result.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TCPasp_Types.ASP_TCP_Listen_result.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__TCP__Listen__result_template::portnumber()
{
set_specific();
return single_value->field_portnumber;
}

const INTEGER_template& ASP__TCP__Listen__result_template::portnumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field portnumber of a non-specific template of type @TCPasp_Types.ASP_TCP_Listen_result.");
return single_value->field_portnumber;
}

int ASP__TCP__Listen__result_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Listen_result which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Listen_result containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Listen_result containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Listen_result containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Listen_result containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Listen_result containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Listen_result.");
  }
  return 0;
}

void ASP__TCP__Listen__result_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ portnumber := ");
single_value->field_portnumber.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__TCP__Listen__result_template::log_match(const ASP__TCP__Listen__result& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_portnumber.match(match_value.portnumber())){
TTCN_Logger::log_logmatch_info(".portnumber");
single_value->field_portnumber.log_match(match_value.portnumber());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ portnumber := ");
single_value->field_portnumber.log_match(match_value.portnumber());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__TCP__Listen__result_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_portnumber.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Listen_result.");
}
}

void ASP__TCP__Listen__result_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_portnumber.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__TCP__Listen__result_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TCPasp_Types.ASP_TCP_Listen_result.");
}
}

void ASP__TCP__Listen__result_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TCPasp_Types.ASP_TCP_Listen_result'");
    }
    if (strcmp("portnumber", param_field) == 0) {
      portnumber().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TCPasp_Types.ASP_TCP_Listen_result'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @TCPasp_Types.ASP_TCP_Listen_result has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) portnumber().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "portnumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          portnumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Listen_result: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TCPasp_Types.ASP_TCP_Listen_result");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__TCP__Listen__result_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_portnumber.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Listen_result");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TCPasp_Types.ASP_TCP_Listen_result");
}

boolean ASP__TCP__Listen__result_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean ASP__TCP__Listen__result_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

ASP__TCP__Shutdown::ASP__TCP__Shutdown()
{
bound_flag = FALSE;
}

ASP__TCP__Shutdown::ASP__TCP__Shutdown(null_type)
{
bound_flag = TRUE;
}

ASP__TCP__Shutdown::ASP__TCP__Shutdown(const ASP__TCP__Shutdown& other_value)
{
other_value.must_bound("Copying an unbound value of type @TCPasp_Types.ASP_TCP_Shutdown.");
bound_flag = TRUE;
}

ASP__TCP__Shutdown& ASP__TCP__Shutdown::operator=(null_type)
{
bound_flag = TRUE;
return *this;
}

ASP__TCP__Shutdown& ASP__TCP__Shutdown::operator=(const ASP__TCP__Shutdown& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @TCPasp_Types.ASP_TCP_Shutdown.");
bound_flag = TRUE;
return *this;
}

boolean ASP__TCP__Shutdown::operator==(null_type) const
{
must_bound("Comparison of an unbound value of type @TCPasp_Types.ASP_TCP_Shutdown.");
return TRUE;
}

boolean ASP__TCP__Shutdown::operator==(const ASP__TCP__Shutdown& other_value) const
{
must_bound("Comparison of an unbound value of type @TCPasp_Types.ASP_TCP_Shutdown.");
other_value.must_bound("Comparison of an unbound value of type @TCPasp_Types.ASP_TCP_Shutdown.");
return TRUE;
}

void ASP__TCP__Shutdown::log() const
{
if (bound_flag) TTCN_Logger::log_event_str("{ }");
else TTCN_Logger::log_event_unbound();
}

void ASP__TCP__Shutdown::set_param(const Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "empty record/set value (i.e. { })");
  if (param.get_type()!=Module_Param::MP_Value_List || param.get_size()>0) {
    param.type_error("empty record/set value (i.e. { })", "@TCPasp_Types.ASP_TCP_Shutdown");
  }
  bound_flag = TRUE;
}

void ASP__TCP__Shutdown::encode_text(Text_Buf& /*text_buf*/) const
{
must_bound("Text encoder: Encoding an unbound value of type @TCPasp_Types.ASP_TCP_Shutdown.");
}

void ASP__TCP__Shutdown::decode_text(Text_Buf& /*text_buf*/)
{
bound_flag = TRUE;
}

void ASP__TCP__Shutdown_template::copy_template(const ASP__TCP__Shutdown_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__TCP__Shutdown_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Shutdown.");
break;
}
}

ASP__TCP__Shutdown_template::ASP__TCP__Shutdown_template()
{
}

ASP__TCP__Shutdown_template::ASP__TCP__Shutdown_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__TCP__Shutdown_template::ASP__TCP__Shutdown_template(null_type)
 : Base_Template(SPECIFIC_VALUE)
{
}

ASP__TCP__Shutdown_template::ASP__TCP__Shutdown_template(const ASP__TCP__Shutdown& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound value of type @TCPasp_Types.ASP_TCP_Shutdown.");
}

ASP__TCP__Shutdown_template::ASP__TCP__Shutdown_template(const OPTIONAL<ASP__TCP__Shutdown>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TCPasp_Types.ASP_TCP_Shutdown from an unbound optional field.");
}
}

ASP__TCP__Shutdown_template::ASP__TCP__Shutdown_template(const ASP__TCP__Shutdown_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ASP__TCP__Shutdown_template::~ASP__TCP__Shutdown_template()
{
clean_up();
}

void ASP__TCP__Shutdown_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST)
delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__TCP__Shutdown_template& ASP__TCP__Shutdown_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__TCP__Shutdown_template& ASP__TCP__Shutdown_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

ASP__TCP__Shutdown_template& ASP__TCP__Shutdown_template::operator=(const ASP__TCP__Shutdown& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @TCPasp_Types.ASP_TCP_Shutdown to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

ASP__TCP__Shutdown_template& ASP__TCP__Shutdown_template::operator=(const OPTIONAL<ASP__TCP__Shutdown>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TCPasp_Types.ASP_TCP_Shutdown.");
}
return *this;
}

ASP__TCP__Shutdown_template& ASP__TCP__Shutdown_template::operator=(const ASP__TCP__Shutdown_template& other_value)
{
if (&other_value != this) {
clean_up();
set_selection(other_value);
}
return *this;
}

boolean ASP__TCP__Shutdown_template::match(null_type other_value) const
{
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
return TRUE;
case OMIT_VALUE:
return FALSE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Shutdown.");
}
return FALSE;
}

boolean ASP__TCP__Shutdown_template::match(const ASP__TCP__Shutdown& other_value) const
{
if (!other_value.is_bound()) return FALSE;return match(NULL_VALUE);
}

ASP__TCP__Shutdown ASP__TCP__Shutdown_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @TCPasp_Types.ASP_TCP_Shutdown.");
return NULL_VALUE;
}

void ASP__TCP__Shutdown_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TCPasp_Types.ASP_TCP_Shutdown.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__TCP__Shutdown_template[list_length];
}

ASP__TCP__Shutdown_template& ASP__TCP__Shutdown_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TCPasp_Types.ASP_TCP_Shutdown.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TCPasp_Types.ASP_TCP_Shutdown.");
return value_list.list_value[list_index];
}

void ASP__TCP__Shutdown_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__TCP__Shutdown_template::log_match(const ASP__TCP__Shutdown& match_value) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void ASP__TCP__Shutdown_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Shutdown.");
}
}

void ASP__TCP__Shutdown_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__TCP__Shutdown_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TCPasp_Types.ASP_TCP_Shutdown.");
}
}

void ASP__TCP__Shutdown_template::set_param(const Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "empty record/set template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (param.get_size()>0) param.type_error("empty record/set template", "@TCPasp_Types.ASP_TCP_Shutdown");
    *this = NULL_VALUE;
    break;
  default:
    param.type_error("empty record/set template", "@TCPasp_Types.ASP_TCP_Shutdown");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__TCP__Shutdown_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TCPasp_Types.ASP_TCP_Shutdown");
}

boolean ASP__TCP__Shutdown_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean ASP__TCP__Shutdown_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

TCP__Send__error__types::TCP__Send__error__types()
{
enum_value = UNBOUND_VALUE;
}

TCP__Send__error__types::TCP__Send__error__types(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @TCPasp_Types.TCP_Send_error_types with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

TCP__Send__error__types::TCP__Send__error__types(enum_type other_value)
{
enum_value = other_value;
}

TCP__Send__error__types::TCP__Send__error__types(const TCP__Send__error__types& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
enum_value = other_value.enum_value;
}

TCP__Send__error__types& TCP__Send__error__types::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @TCPasp_Types.TCP_Send_error_types.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

TCP__Send__error__types& TCP__Send__error__types::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

TCP__Send__error__types& TCP__Send__error__types::operator=(const TCP__Send__error__types& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
enum_value = other_value.enum_value;
return *this;
}

boolean TCP__Send__error__types::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
return enum_value == other_value;
}

boolean TCP__Send__error__types::operator==(const TCP__Send__error__types& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
return enum_value == other_value.enum_value;
}

boolean TCP__Send__error__types::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
return enum_value < other_value;
}

boolean TCP__Send__error__types::operator<(const TCP__Send__error__types& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
return enum_value < other_value.enum_value;
}

boolean TCP__Send__error__types::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
return enum_value > other_value;
}

boolean TCP__Send__error__types::operator>(const TCP__Send__error__types& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
return enum_value > other_value.enum_value;
}

const char *TCP__Send__error__types::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case TCP__SEND__INVALID__CLIENT__ID: return "TCP_SEND_INVALID_CLIENT_ID";
case TCP__SEND__ERROR: return "TCP_SEND_ERROR";
case TCP__SEND__MESSAGE__NOT__COMPLETE: return "TCP_SEND_MESSAGE_NOT_COMPLETE";
default: return "<unknown>";
}
}

TCP__Send__error__types::enum_type TCP__Send__error__types::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "TCP_SEND_INVALID_CLIENT_ID")) return TCP__SEND__INVALID__CLIENT__ID;
else if (!strcmp(str_par, "TCP_SEND_ERROR")) return TCP__SEND__ERROR;
else if (!strcmp(str_par, "TCP_SEND_MESSAGE_NOT_COMPLETE")) return TCP__SEND__MESSAGE__NOT__COMPLETE;
else return UNKNOWN_VALUE;
}

boolean TCP__Send__error__types::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
return TRUE;
default:
return FALSE;
}
}

int TCP__Send__error__types::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @TCPasp_Types.TCP_Send_error_types.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int TCP__Send__error__types::enum2int(const TCP__Send__error__types& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @TCPasp_Types.TCP_Send_error_types.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

TCP__Send__error__types::operator TCP__Send__error__types::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @TCPasp_Types.TCP_Send_error_types.");
return enum_value;
}

void TCP__Send__error__types::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void TCP__Send__error__types::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@TCPasp_Types.TCP_Send_error_types");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
     param.error("Invalid enumerated value for type @TCPasp_Types.TCP_Send_error_types.");
  }
}

void TCP__Send__error__types::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
text_buf.push_int(enum_value);
}

void TCP__Send__error__types::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @TCPasp_Types.TCP_Send_error_types.", enum_value);
}

void TCP__Send__error__types_template::copy_template(const TCP__Send__error__types_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TCP__Send__error__types_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @TCPasp_Types.TCP_Send_error_types.");
}
}

TCP__Send__error__types_template::TCP__Send__error__types_template()
{
}

TCP__Send__error__types_template::TCP__Send__error__types_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TCP__Send__error__types_template::TCP__Send__error__types_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!TCP__Send__error__types::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @TCPasp_Types.TCP_Send_error_types with unknown numeric value %d.", other_value);
single_value = (TCP__Send__error__types::enum_type)other_value;
}

TCP__Send__error__types_template::TCP__Send__error__types_template(TCP__Send__error__types::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

TCP__Send__error__types_template::TCP__Send__error__types_template(const TCP__Send__error__types& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == TCP__Send__error__types::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types.");
single_value = other_value.enum_value;
}

TCP__Send__error__types_template::TCP__Send__error__types_template(const OPTIONAL<TCP__Send__error__types>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (TCP__Send__error__types::enum_type)(const TCP__Send__error__types&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @TCPasp_Types.TCP_Send_error_types from an unbound optional field.");
}
}

TCP__Send__error__types_template::TCP__Send__error__types_template(const TCP__Send__error__types_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

TCP__Send__error__types_template::~TCP__Send__error__types_template()
{
clean_up();
}

boolean TCP__Send__error__types_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean TCP__Send__error__types_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != TCP__Send__error__types::UNBOUND_VALUE;
}

void TCP__Send__error__types_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

TCP__Send__error__types_template& TCP__Send__error__types_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TCP__Send__error__types_template& TCP__Send__error__types_template::operator=(int other_value)
{
if (!TCP__Send__error__types::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @TCPasp_Types.TCP_Send_error_types.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (TCP__Send__error__types::enum_type)other_value;
return *this;
}

TCP__Send__error__types_template& TCP__Send__error__types_template::operator=(TCP__Send__error__types::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

TCP__Send__error__types_template& TCP__Send__error__types_template::operator=(const TCP__Send__error__types& other_value)
{
if (other_value.enum_value == TCP__Send__error__types::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @TCPasp_Types.TCP_Send_error_types to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

TCP__Send__error__types_template& TCP__Send__error__types_template::operator=(const OPTIONAL<TCP__Send__error__types>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (TCP__Send__error__types::enum_type)(const TCP__Send__error__types&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @TCPasp_Types.TCP_Send_error_types.");
}
return *this;
}

TCP__Send__error__types_template& TCP__Send__error__types_template::operator=(const TCP__Send__error__types_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TCP__Send__error__types_template::match(TCP__Send__error__types::enum_type other_value) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @TCPasp_Types.TCP_Send_error_types.");
}
return FALSE;
}

boolean TCP__Send__error__types_template::match(const TCP__Send__error__types& other_value) const
{
if (other_value.enum_value == TCP__Send__error__types::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @TCPasp_Types.TCP_Send_error_types with an unbound value.");
return match(other_value.enum_value);
}

TCP__Send__error__types::enum_type TCP__Send__error__types_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @TCPasp_Types.TCP_Send_error_types.");
return single_value;
}

void TCP__Send__error__types_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @TCPasp_Types.TCP_Send_error_types.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TCP__Send__error__types_template[list_length];
}

TCP__Send__error__types_template& TCP__Send__error__types_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @TCPasp_Types.TCP_Send_error_types.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @TCPasp_Types.TCP_Send_error_types.");
return value_list.list_value[list_index];
}

void TCP__Send__error__types_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(TCP__Send__error__types::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TCP__Send__error__types_template::log_match(const TCP__Send__error__types& match_value) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void TCP__Send__error__types_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TCPasp_Types.TCP_Send_error_types.");
}
}

void TCP__Send__error__types_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (TCP__Send__error__types::enum_type)text_buf.pull_int().get_val();
if (!TCP__Send__error__types::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @TCPasp_Types.TCP_Send_error_types.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TCP__Send__error__types_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TCPasp_Types.TCP_Send_error_types.");
}
}

boolean TCP__Send__error__types_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean TCP__Send__error__types_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void TCP__Send__error__types_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Enumerated: {
    TCP__Send__error__types::enum_type enum_val = TCP__Send__error__types::str_to_enum(param.get_enumerated());
    if (!TCP__Send__error__types::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @TCPasp_Types.TCP_Send_error_types.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@TCPasp_Types.TCP_Send_error_types");
  }
  is_ifpresent = param.get_ifpresent();
}

void TCP__Send__error__types_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TCPasp_Types.TCP_Send_error_types");
}

ASP__TCP__Send__error::ASP__TCP__Send__error()
{
  bound_flag = FALSE;
}

ASP__TCP__Send__error::ASP__TCP__Send__error(const OPTIONAL<INTEGER>& par_client__id,
    const OCTETSTRING& par_data,
    const INTEGER& par_sent__octets,
    const TCP__Send__error__types& par_error__type,
    const INTEGER& par_os__error__code,
    const CHARSTRING& par_os__error__text,
    const CHARSTRING& par_ttcn__error__text)
  :   field_client__id(par_client__id),
  field_data(par_data),
  field_sent__octets(par_sent__octets),
  field_error__type(par_error__type),
  field_os__error__code(par_os__error__code),
  field_os__error__text(par_os__error__text),
  field_ttcn__error__text(par_ttcn__error__text)
{
  bound_flag = TRUE;
}

ASP__TCP__Send__error::ASP__TCP__Send__error(const ASP__TCP__Send__error& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TCPasp_Types.ASP_TCP_Send_error.");
bound_flag = TRUE;
if (other_value.client__id().is_bound()) field_client__id = other_value.client__id();
else field_client__id.clean_up();
if (other_value.data().is_bound()) field_data = other_value.data();
else field_data.clean_up();
if (other_value.sent__octets().is_bound()) field_sent__octets = other_value.sent__octets();
else field_sent__octets.clean_up();
if (other_value.error__type().is_bound()) field_error__type = other_value.error__type();
else field_error__type.clean_up();
if (other_value.os__error__code().is_bound()) field_os__error__code = other_value.os__error__code();
else field_os__error__code.clean_up();
if (other_value.os__error__text().is_bound()) field_os__error__text = other_value.os__error__text();
else field_os__error__text.clean_up();
if (other_value.ttcn__error__text().is_bound()) field_ttcn__error__text = other_value.ttcn__error__text();
else field_ttcn__error__text.clean_up();
}

void ASP__TCP__Send__error::clean_up()
{
field_client__id.clean_up();
field_data.clean_up();
field_sent__octets.clean_up();
field_error__type.clean_up();
field_os__error__code.clean_up();
field_os__error__text.clean_up();
field_ttcn__error__text.clean_up();
bound_flag = FALSE;
}

ASP__TCP__Send__error& ASP__TCP__Send__error::operator=(const ASP__TCP__Send__error& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TCPasp_Types.ASP_TCP_Send_error.");
  bound_flag = TRUE;
  if (other_value.client__id().is_bound()) field_client__id = other_value.client__id();
  else field_client__id.clean_up();
  if (other_value.data().is_bound()) field_data = other_value.data();
  else field_data.clean_up();
  if (other_value.sent__octets().is_bound()) field_sent__octets = other_value.sent__octets();
  else field_sent__octets.clean_up();
  if (other_value.error__type().is_bound()) field_error__type = other_value.error__type();
  else field_error__type.clean_up();
  if (other_value.os__error__code().is_bound()) field_os__error__code = other_value.os__error__code();
  else field_os__error__code.clean_up();
  if (other_value.os__error__text().is_bound()) field_os__error__text = other_value.os__error__text();
  else field_os__error__text.clean_up();
  if (other_value.ttcn__error__text().is_bound()) field_ttcn__error__text = other_value.ttcn__error__text();
  else field_ttcn__error__text.clean_up();
}
return *this;
}

boolean ASP__TCP__Send__error::operator==(const ASP__TCP__Send__error& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_client__id==other_value.field_client__id
  && field_data==other_value.field_data
  && field_sent__octets==other_value.field_sent__octets
  && field_error__type==other_value.field_error__type
  && field_os__error__code==other_value.field_os__error__code
  && field_os__error__text==other_value.field_os__error__text
  && field_ttcn__error__text==other_value.field_ttcn__error__text;
}

boolean ASP__TCP__Send__error::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_client__id.get_selection() || field_client__id.is_bound()) return TRUE;
if(field_data.is_bound()) return TRUE;
if(field_sent__octets.is_bound()) return TRUE;
if(field_error__type.is_bound()) return TRUE;
if(field_os__error__code.is_bound()) return TRUE;
if(field_os__error__text.is_bound()) return TRUE;
if(field_ttcn__error__text.is_bound()) return TRUE;
return FALSE;
}
boolean ASP__TCP__Send__error::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_client__id.get_selection() && !field_client__id.is_value()) return FALSE;
if(!field_data.is_value()) return FALSE;
if(!field_sent__octets.is_value()) return FALSE;
if(!field_error__type.is_value()) return FALSE;
if(!field_os__error__code.is_value()) return FALSE;
if(!field_os__error__text.is_value()) return FALSE;
if(!field_ttcn__error__text.is_value()) return FALSE;
return TRUE;
}
int ASP__TCP__Send__error::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TCPasp_Types.ASP_TCP_Send_error");
  int ret_val = 6;
  if (field_client__id.ispresent()) ret_val++;
  return ret_val;
}

void ASP__TCP__Send__error::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ client_id := ");
field_client__id.log();
TTCN_Logger::log_event_str(", data := ");
field_data.log();
TTCN_Logger::log_event_str(", sent_octets := ");
field_sent__octets.log();
TTCN_Logger::log_event_str(", error_type := ");
field_error__type.log();
TTCN_Logger::log_event_str(", os_error_code := ");
field_os__error__code.log();
TTCN_Logger::log_event_str(", os_error_text := ");
field_os__error__text.log();
TTCN_Logger::log_event_str(", ttcn_error_text := ");
field_ttcn__error__text.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__TCP__Send__error::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TCPasp_Types.ASP_TCP_Send_error'");
    }
    if (strcmp("client_id", param_field) == 0) {
      client__id().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else if (strcmp("sent_octets", param_field) == 0) {
      sent__octets().set_param(param);
      return;
    } else if (strcmp("error_type", param_field) == 0) {
      error__type().set_param(param);
      return;
    } else if (strcmp("os_error_code", param_field) == 0) {
      os__error__code().set_param(param);
      return;
    } else if (strcmp("os_error_text", param_field) == 0) {
      os__error__text().set_param(param);
      return;
    } else if (strcmp("ttcn_error_text", param_field) == 0) {
      ttcn__error__text().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TCPasp_Types.ASP_TCP_Send_error'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (7<param.get_size()) {
      param.error("record value of type @TCPasp_Types.ASP_TCP_Send_error has 7 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) client__id().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) sent__octets().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) error__type().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) os__error__code().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) os__error__text().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) ttcn__error__text().set_param(*param.get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "client_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          client__id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sent_octets")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sent__octets().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "error_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          error__type().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "os_error_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          os__error__code().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "os_error_text")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          os__error__text().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ttcn_error_text")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ttcn__error__text().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Send_error: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TCPasp_Types.ASP_TCP_Send_error");
  }
}

void ASP__TCP__Send__error::set_implicit_omit()
{
if (!client__id().is_bound()) client__id() = OMIT_VALUE;
else client__id().set_implicit_omit();
if (data().is_bound()) data().set_implicit_omit();
if (sent__octets().is_bound()) sent__octets().set_implicit_omit();
if (error__type().is_bound()) error__type().set_implicit_omit();
if (os__error__code().is_bound()) os__error__code().set_implicit_omit();
if (os__error__text().is_bound()) os__error__text().set_implicit_omit();
if (ttcn__error__text().is_bound()) ttcn__error__text().set_implicit_omit();
}

void ASP__TCP__Send__error::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TCPasp_Types.ASP_TCP_Send_error.");
field_client__id.encode_text(text_buf);
field_data.encode_text(text_buf);
field_sent__octets.encode_text(text_buf);
field_error__type.encode_text(text_buf);
field_os__error__code.encode_text(text_buf);
field_os__error__text.encode_text(text_buf);
field_ttcn__error__text.encode_text(text_buf);
}

void ASP__TCP__Send__error::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_client__id.decode_text(text_buf);
field_data.decode_text(text_buf);
field_sent__octets.decode_text(text_buf);
field_error__type.decode_text(text_buf);
field_os__error__code.decode_text(text_buf);
field_os__error__text.decode_text(text_buf);
field_ttcn__error__text.decode_text(text_buf);
}

struct ASP__TCP__Send__error_template::single_value_struct {
INTEGER_template field_client__id;
OCTETSTRING_template field_data;
INTEGER_template field_sent__octets;
TCP__Send__error__types_template field_error__type;
INTEGER_template field_os__error__code;
CHARSTRING_template field_os__error__text;
CHARSTRING_template field_ttcn__error__text;
};

void ASP__TCP__Send__error_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_client__id = ANY_OR_OMIT;
single_value->field_data = ANY_VALUE;
single_value->field_sent__octets = ANY_VALUE;
single_value->field_error__type = ANY_VALUE;
single_value->field_os__error__code = ANY_VALUE;
single_value->field_os__error__text = ANY_VALUE;
single_value->field_ttcn__error__text = ANY_VALUE;
}
}
}

void ASP__TCP__Send__error_template::copy_value(const ASP__TCP__Send__error& other_value)
{
single_value = new single_value_struct;
if (other_value.client__id().is_bound()) {
  if (other_value.client__id().ispresent()) single_value->field_client__id = other_value.client__id()();
  else single_value->field_client__id = OMIT_VALUE;
} else {
  single_value->field_client__id.clean_up();
}
if (other_value.data().is_bound()) {
  single_value->field_data = other_value.data();
} else {
  single_value->field_data.clean_up();
}
if (other_value.sent__octets().is_bound()) {
  single_value->field_sent__octets = other_value.sent__octets();
} else {
  single_value->field_sent__octets.clean_up();
}
if (other_value.error__type().is_bound()) {
  single_value->field_error__type = other_value.error__type();
} else {
  single_value->field_error__type.clean_up();
}
if (other_value.os__error__code().is_bound()) {
  single_value->field_os__error__code = other_value.os__error__code();
} else {
  single_value->field_os__error__code.clean_up();
}
if (other_value.os__error__text().is_bound()) {
  single_value->field_os__error__text = other_value.os__error__text();
} else {
  single_value->field_os__error__text.clean_up();
}
if (other_value.ttcn__error__text().is_bound()) {
  single_value->field_ttcn__error__text = other_value.ttcn__error__text();
} else {
  single_value->field_ttcn__error__text.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__TCP__Send__error_template::copy_template(const ASP__TCP__Send__error_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.client__id().get_selection()) {
single_value->field_client__id = other_value.client__id();
} else {
single_value->field_client__id.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.data().get_selection()) {
single_value->field_data = other_value.data();
} else {
single_value->field_data.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sent__octets().get_selection()) {
single_value->field_sent__octets = other_value.sent__octets();
} else {
single_value->field_sent__octets.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.error__type().get_selection()) {
single_value->field_error__type = other_value.error__type();
} else {
single_value->field_error__type.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.os__error__code().get_selection()) {
single_value->field_os__error__code = other_value.os__error__code();
} else {
single_value->field_os__error__code.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.os__error__text().get_selection()) {
single_value->field_os__error__text = other_value.os__error__text();
} else {
single_value->field_os__error__text.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ttcn__error__text().get_selection()) {
single_value->field_ttcn__error__text = other_value.ttcn__error__text();
} else {
single_value->field_ttcn__error__text.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__TCP__Send__error_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Send_error.");
break;
}
set_selection(other_value);
}

ASP__TCP__Send__error_template::ASP__TCP__Send__error_template()
{
}

ASP__TCP__Send__error_template::ASP__TCP__Send__error_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__TCP__Send__error_template::ASP__TCP__Send__error_template(const ASP__TCP__Send__error& other_value)
{
copy_value(other_value);
}

ASP__TCP__Send__error_template::ASP__TCP__Send__error_template(const OPTIONAL<ASP__TCP__Send__error>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Send__error&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TCPasp_Types.ASP_TCP_Send_error from an unbound optional field.");
}
}

ASP__TCP__Send__error_template::ASP__TCP__Send__error_template(const ASP__TCP__Send__error_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__TCP__Send__error_template::~ASP__TCP__Send__error_template()
{
clean_up();
}

ASP__TCP__Send__error_template& ASP__TCP__Send__error_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__TCP__Send__error_template& ASP__TCP__Send__error_template::operator=(const ASP__TCP__Send__error& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__TCP__Send__error_template& ASP__TCP__Send__error_template::operator=(const OPTIONAL<ASP__TCP__Send__error>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__TCP__Send__error&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TCPasp_Types.ASP_TCP_Send_error.");
}
return *this;
}

ASP__TCP__Send__error_template& ASP__TCP__Send__error_template::operator=(const ASP__TCP__Send__error_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__TCP__Send__error_template::match(const ASP__TCP__Send__error& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.client__id().is_bound()) return FALSE;
if((other_value.client__id().ispresent() ? !single_value->field_client__id.match((const INTEGER&)other_value.client__id()) : !single_value->field_client__id.match_omit()))return FALSE;
if(!other_value.data().is_bound()) return FALSE;
if(!single_value->field_data.match(other_value.data()))return FALSE;
if(!other_value.sent__octets().is_bound()) return FALSE;
if(!single_value->field_sent__octets.match(other_value.sent__octets()))return FALSE;
if(!other_value.error__type().is_bound()) return FALSE;
if(!single_value->field_error__type.match(other_value.error__type()))return FALSE;
if(!other_value.os__error__code().is_bound()) return FALSE;
if(!single_value->field_os__error__code.match(other_value.os__error__code()))return FALSE;
if(!other_value.os__error__text().is_bound()) return FALSE;
if(!single_value->field_os__error__text.match(other_value.os__error__text()))return FALSE;
if(!other_value.ttcn__error__text().is_bound()) return FALSE;
if(!single_value->field_ttcn__error__text.match(other_value.ttcn__error__text()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Send_error.");
}
return FALSE;
}

boolean ASP__TCP__Send__error_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_client__id.is_omit() || single_value->field_client__id.is_bound()) return TRUE;
if (single_value->field_data.is_bound()) return TRUE;
if (single_value->field_sent__octets.is_bound()) return TRUE;
if (single_value->field_error__type.is_bound()) return TRUE;
if (single_value->field_os__error__code.is_bound()) return TRUE;
if (single_value->field_os__error__text.is_bound()) return TRUE;
if (single_value->field_ttcn__error__text.is_bound()) return TRUE;
return FALSE;
}

boolean ASP__TCP__Send__error_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_client__id.is_omit() && !single_value->field_client__id.is_value()) return FALSE;
if (!single_value->field_data.is_value()) return FALSE;
if (!single_value->field_sent__octets.is_value()) return FALSE;
if (!single_value->field_error__type.is_value()) return FALSE;
if (!single_value->field_os__error__code.is_value()) return FALSE;
if (!single_value->field_os__error__text.is_value()) return FALSE;
if (!single_value->field_ttcn__error__text.is_value()) return FALSE;
return TRUE;
}

void ASP__TCP__Send__error_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__TCP__Send__error ASP__TCP__Send__error_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TCPasp_Types.ASP_TCP_Send_error.");
ASP__TCP__Send__error ret_val;
if (single_value->field_client__id.is_omit()) ret_val.client__id() = OMIT_VALUE;
else if (single_value->field_client__id.is_bound()) {
ret_val.client__id() = single_value->field_client__id.valueof();
}
if (single_value->field_data.is_bound()) {
ret_val.data() = single_value->field_data.valueof();
}
if (single_value->field_sent__octets.is_bound()) {
ret_val.sent__octets() = single_value->field_sent__octets.valueof();
}
if (single_value->field_error__type.is_bound()) {
ret_val.error__type() = single_value->field_error__type.valueof();
}
if (single_value->field_os__error__code.is_bound()) {
ret_val.os__error__code() = single_value->field_os__error__code.valueof();
}
if (single_value->field_os__error__text.is_bound()) {
ret_val.os__error__text() = single_value->field_os__error__text.valueof();
}
if (single_value->field_ttcn__error__text.is_bound()) {
ret_val.ttcn__error__text() = single_value->field_ttcn__error__text.valueof();
}
return ret_val;
}

void ASP__TCP__Send__error_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TCPasp_Types.ASP_TCP_Send_error.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__TCP__Send__error_template[list_length];
}

ASP__TCP__Send__error_template& ASP__TCP__Send__error_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TCPasp_Types.ASP_TCP_Send_error.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TCPasp_Types.ASP_TCP_Send_error.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__TCP__Send__error_template::client__id()
{
set_specific();
return single_value->field_client__id;
}

const INTEGER_template& ASP__TCP__Send__error_template::client__id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field client_id of a non-specific template of type @TCPasp_Types.ASP_TCP_Send_error.");
return single_value->field_client__id;
}

OCTETSTRING_template& ASP__TCP__Send__error_template::data()
{
set_specific();
return single_value->field_data;
}

const OCTETSTRING_template& ASP__TCP__Send__error_template::data() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field data of a non-specific template of type @TCPasp_Types.ASP_TCP_Send_error.");
return single_value->field_data;
}

INTEGER_template& ASP__TCP__Send__error_template::sent__octets()
{
set_specific();
return single_value->field_sent__octets;
}

const INTEGER_template& ASP__TCP__Send__error_template::sent__octets() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sent_octets of a non-specific template of type @TCPasp_Types.ASP_TCP_Send_error.");
return single_value->field_sent__octets;
}

TCP__Send__error__types_template& ASP__TCP__Send__error_template::error__type()
{
set_specific();
return single_value->field_error__type;
}

const TCP__Send__error__types_template& ASP__TCP__Send__error_template::error__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field error_type of a non-specific template of type @TCPasp_Types.ASP_TCP_Send_error.");
return single_value->field_error__type;
}

INTEGER_template& ASP__TCP__Send__error_template::os__error__code()
{
set_specific();
return single_value->field_os__error__code;
}

const INTEGER_template& ASP__TCP__Send__error_template::os__error__code() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field os_error_code of a non-specific template of type @TCPasp_Types.ASP_TCP_Send_error.");
return single_value->field_os__error__code;
}

CHARSTRING_template& ASP__TCP__Send__error_template::os__error__text()
{
set_specific();
return single_value->field_os__error__text;
}

const CHARSTRING_template& ASP__TCP__Send__error_template::os__error__text() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field os_error_text of a non-specific template of type @TCPasp_Types.ASP_TCP_Send_error.");
return single_value->field_os__error__text;
}

CHARSTRING_template& ASP__TCP__Send__error_template::ttcn__error__text()
{
set_specific();
return single_value->field_ttcn__error__text;
}

const CHARSTRING_template& ASP__TCP__Send__error_template::ttcn__error__text() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ttcn_error_text of a non-specific template of type @TCPasp_Types.ASP_TCP_Send_error.");
return single_value->field_ttcn__error__text;
}

int ASP__TCP__Send__error_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Send_error which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 6;
      if (single_value->field_client__id.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Send_error containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Send_error containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Send_error containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Send_error containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TCPasp_Types.ASP_TCP_Send_error containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Send_error.");
  }
  return 0;
}

void ASP__TCP__Send__error_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ client_id := ");
single_value->field_client__id.log();
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log();
TTCN_Logger::log_event_str(", sent_octets := ");
single_value->field_sent__octets.log();
TTCN_Logger::log_event_str(", error_type := ");
single_value->field_error__type.log();
TTCN_Logger::log_event_str(", os_error_code := ");
single_value->field_os__error__code.log();
TTCN_Logger::log_event_str(", os_error_text := ");
single_value->field_os__error__text.log();
TTCN_Logger::log_event_str(", ttcn_error_text := ");
single_value->field_ttcn__error__text.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__TCP__Send__error_template::log_match(const ASP__TCP__Send__error& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.client__id().ispresent()){
if(!single_value->field_client__id.match(match_value.client__id())){
TTCN_Logger::log_logmatch_info(".client_id");
single_value->field_client__id.log_match(match_value.client__id());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_client__id.match_omit()){
 TTCN_Logger::log_logmatch_info(".client_id := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_client__id.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_data.match(match_value.data())){
TTCN_Logger::log_logmatch_info(".data");
single_value->field_data.log_match(match_value.data());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_sent__octets.match(match_value.sent__octets())){
TTCN_Logger::log_logmatch_info(".sent_octets");
single_value->field_sent__octets.log_match(match_value.sent__octets());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_error__type.match(match_value.error__type())){
TTCN_Logger::log_logmatch_info(".error_type");
single_value->field_error__type.log_match(match_value.error__type());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_os__error__code.match(match_value.os__error__code())){
TTCN_Logger::log_logmatch_info(".os_error_code");
single_value->field_os__error__code.log_match(match_value.os__error__code());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_os__error__text.match(match_value.os__error__text())){
TTCN_Logger::log_logmatch_info(".os_error_text");
single_value->field_os__error__text.log_match(match_value.os__error__text());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ttcn__error__text.match(match_value.ttcn__error__text())){
TTCN_Logger::log_logmatch_info(".ttcn_error_text");
single_value->field_ttcn__error__text.log_match(match_value.ttcn__error__text());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ client_id := ");
if (match_value.client__id().ispresent()) single_value->field_client__id.log_match(match_value.client__id());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_client__id.log();
if (single_value->field_client__id.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log_match(match_value.data());
TTCN_Logger::log_event_str(", sent_octets := ");
single_value->field_sent__octets.log_match(match_value.sent__octets());
TTCN_Logger::log_event_str(", error_type := ");
single_value->field_error__type.log_match(match_value.error__type());
TTCN_Logger::log_event_str(", os_error_code := ");
single_value->field_os__error__code.log_match(match_value.os__error__code());
TTCN_Logger::log_event_str(", os_error_text := ");
single_value->field_os__error__text.log_match(match_value.os__error__text());
TTCN_Logger::log_event_str(", ttcn_error_text := ");
single_value->field_ttcn__error__text.log_match(match_value.ttcn__error__text());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__TCP__Send__error_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_client__id.encode_text(text_buf);
single_value->field_data.encode_text(text_buf);
single_value->field_sent__octets.encode_text(text_buf);
single_value->field_error__type.encode_text(text_buf);
single_value->field_os__error__code.encode_text(text_buf);
single_value->field_os__error__text.encode_text(text_buf);
single_value->field_ttcn__error__text.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TCPasp_Types.ASP_TCP_Send_error.");
}
}

void ASP__TCP__Send__error_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_client__id.decode_text(text_buf);
single_value->field_data.decode_text(text_buf);
single_value->field_sent__octets.decode_text(text_buf);
single_value->field_error__type.decode_text(text_buf);
single_value->field_os__error__code.decode_text(text_buf);
single_value->field_os__error__text.decode_text(text_buf);
single_value->field_ttcn__error__text.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__TCP__Send__error_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TCPasp_Types.ASP_TCP_Send_error.");
}
}

void ASP__TCP__Send__error_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TCPasp_Types.ASP_TCP_Send_error'");
    }
    if (strcmp("client_id", param_field) == 0) {
      client__id().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else if (strcmp("sent_octets", param_field) == 0) {
      sent__octets().set_param(param);
      return;
    } else if (strcmp("error_type", param_field) == 0) {
      error__type().set_param(param);
      return;
    } else if (strcmp("os_error_code", param_field) == 0) {
      os__error__code().set_param(param);
      return;
    } else if (strcmp("os_error_text", param_field) == 0) {
      os__error__text().set_param(param);
      return;
    } else if (strcmp("ttcn_error_text", param_field) == 0) {
      ttcn__error__text().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TCPasp_Types.ASP_TCP_Send_error'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (7<param.get_size()) {
      param.error("record template of type @TCPasp_Types.ASP_TCP_Send_error has 7 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) client__id().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) sent__octets().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) error__type().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) os__error__code().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) os__error__text().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) ttcn__error__text().set_param(*param.get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "client_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          client__id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sent_octets")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sent__octets().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "error_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          error__type().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "os_error_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          os__error__code().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "os_error_text")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          os__error__text().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ttcn_error_text")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ttcn__error__text().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @TCPasp_Types.ASP_TCP_Send_error: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TCPasp_Types.ASP_TCP_Send_error");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__TCP__Send__error_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_client__id.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Send_error");
single_value->field_data.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Send_error");
single_value->field_sent__octets.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Send_error");
single_value->field_error__type.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Send_error");
single_value->field_os__error__code.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Send_error");
single_value->field_os__error__text.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Send_error");
single_value->field_ttcn__error__text.check_restriction(t_res, t_name ? t_name : "@TCPasp_Types.ASP_TCP_Send_error");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TCPasp_Types.ASP_TCP_Send_error");
}

boolean ASP__TCP__Send__error_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean ASP__TCP__Send__error_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const ASP__TCP__Shutdown& other_value)
{
other_value.must_bound("Comparison of an unbound value of type @TCPasp_Types.ASP_TCP_Shutdown.");
return TRUE;
}


/* Bodies of static functions */

static void pre_init_module()
{
/* /work/TDT4290/src/skeleton/tcp_asp/TCPasp_Types.ttcn, line 105 */
const_c__TCP__AF__INET = cs_0;
/* /work/TDT4290/src/skeleton/tcp_asp/TCPasp_Types.ttcn, line 106 */
const_c__TCP__IPv4 = cs_1;
/* /work/TDT4290/src/skeleton/tcp_asp/TCPasp_Types.ttcn, line 107 */
const_c__TCP__AF__INET6 = cs_2;
/* /work/TDT4290/src/skeleton/tcp_asp/TCPasp_Types.ttcn, line 108 */
const_c__TCP__IPv6 = cs_3;
/* /work/TDT4290/src/skeleton/tcp_asp/TCPasp_Types.ttcn, line 109 */
const_c__TCP__AF__UNSPEC = cs_4;
/* /work/TDT4290/src/skeleton/tcp_asp/TCPasp_Types.ttcn, line 110 */
const_c__TCP__UNSPEC = cs_5;
}


} /* end of namespace */
