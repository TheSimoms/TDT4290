// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for user (user@user-multicom) on Wed Sep 16 13:40:58 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "WebSocket_Types.hh"

namespace WebSocket__Types {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();
static boolean set_module_param(Module_Param& param);
static void log_module_param();

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x94, 0x47, 0x5e, 0x7c, 0x10, 0xad, 0x9f, 0x51, 0xec, 0xbf, 0xfd, 0x86, 0xf1, 0x93, 0x3c, 0x3b };

/* Global variable definitions */

static BOOLEAN modulepar_m__Websocket__generate__masking__key;
const BOOLEAN& m__Websocket__generate__masking__key = modulepar_m__Websocket__generate__masking__key;
static BOOLEAN modulepar_m__Websocket__auto__masking;
const BOOLEAN& m__Websocket__auto__masking = modulepar_m__Websocket__auto__masking;
static BOOLEAN const_f__WebSocket__Encode_pl__gen__maks_defval;
const BOOLEAN& f__WebSocket__Encode_pl__gen__maks_defval = const_f__WebSocket__Encode_pl__gen__maks_defval;
static BOOLEAN const_f__WebSocket__Encode_pl__auto__maks_defval;
const BOOLEAN& f__WebSocket__Encode_pl__auto__maks_defval = const_f__WebSocket__Encode_pl__auto__maks_defval;
static BOOLEAN const_f__WebSocket__Decode_pl__auto__maks_defval;
const BOOLEAN& f__WebSocket__Decode_pl__auto__maks_defval = const_f__WebSocket__Decode_pl__auto__maks_defval;
const XERdescriptor_t       Websocket__close_status__code_xer_ = { {"status_code>\n", "status_code>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Websocket__close_status__code_descr_ = { "@WebSocket_Types.Websocket_close.status_code", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Websocket__close_status__code_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Websocket__close
const TTCN_Typedescriptor_t Websocket__close_descr_ = { "@WebSocket_Types.Websocket_close", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Websocket__close_data_xer_ = { {"data>\n", "data>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Websocket__close_data_descr_ = { "@WebSocket_Types.Websocket_close.data", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &Websocket__close_data_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for WebSocket__opcode
const TTCN_Typedescriptor_t WebSocket__opcode_descr_ = { "@WebSocket_Types.WebSocket_opcode", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for WebSocket__payloads
const TTCN_Typedescriptor_t WebSocket__payloads_descr_ = { "@WebSocket_Types.WebSocket_payloads", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       WebSocket__payloads_data_xer_ = { {"data>\n", "data>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t WebSocket__payloads_data_descr_ = { "@WebSocket_Types.WebSocket_payloads.data", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &WebSocket__payloads_data_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t WebSocket__PDU_fin__bit_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       WebSocket__PDU_fin__bit_xer_ = { {"fin_bit>\n", "fin_bit>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t WebSocket__PDU_fin__bit_descr_ = { "@WebSocket_Types.WebSocket_PDU.fin_bit", &BITSTRING_ber_, &WebSocket__PDU_fin__bit_raw_, NULL, &WebSocket__PDU_fin__bit_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t WebSocket__PDU_rsv1__bit_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       WebSocket__PDU_rsv1__bit_xer_ = { {"rsv1_bit>\n", "rsv1_bit>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t WebSocket__PDU_rsv1__bit_descr_ = { "@WebSocket_Types.WebSocket_PDU.rsv1_bit", &BITSTRING_ber_, &WebSocket__PDU_rsv1__bit_raw_, NULL, &WebSocket__PDU_rsv1__bit_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t WebSocket__PDU_rsv2__bit_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       WebSocket__PDU_rsv2__bit_xer_ = { {"rsv2_bit>\n", "rsv2_bit>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t WebSocket__PDU_rsv2__bit_descr_ = { "@WebSocket_Types.WebSocket_PDU.rsv2_bit", &BITSTRING_ber_, &WebSocket__PDU_rsv2__bit_raw_, NULL, &WebSocket__PDU_rsv2__bit_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t WebSocket__PDU_rsv3__bit_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       WebSocket__PDU_rsv3__bit_xer_ = { {"rsv3_bit>\n", "rsv3_bit>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t WebSocket__PDU_rsv3__bit_descr_ = { "@WebSocket_Types.WebSocket_PDU.rsv3_bit", &BITSTRING_ber_, &WebSocket__PDU_rsv3__bit_raw_, NULL, &WebSocket__PDU_rsv3__bit_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t WebSocket__PDU_mask__bit_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       WebSocket__PDU_mask__bit_xer_ = { {"mask_bit>\n", "mask_bit>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t WebSocket__PDU_mask__bit_descr_ = { "@WebSocket_Types.WebSocket_PDU.mask_bit", &BITSTRING_ber_, &WebSocket__PDU_mask__bit_raw_, NULL, &WebSocket__PDU_mask__bit_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       WebSocket__PDU_payload__len_xer_ = { {"payload_len>\n", "payload_len>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t WebSocket__PDU_payload__len_descr_ = { "@WebSocket_Types.WebSocket_PDU.payload_len", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &WebSocket__PDU_payload__len_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for WebSocket__PDU
const TTCN_Typedescriptor_t WebSocket__PDU_descr_ = { "@WebSocket_Types.WebSocket_PDU", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t WebSocket__PDU_masking__key_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       WebSocket__PDU_masking__key_xer_ = { {"masking_key>\n", "masking_key>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t WebSocket__PDU_masking__key_descr_ = { "@WebSocket_Types.WebSocket_PDU.masking_key", &OCTETSTRING_ber_, &WebSocket__PDU_masking__key_raw_, &OCTETSTRING_text_, &WebSocket__PDU_masking__key_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 21;
static const namespace_t xml_namespaces[num_namespaces+1] = {
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { "", "" }
};

TTCN_Module module_object("WebSocket_Types", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 21LU, xml_namespaces, post_init_module, set_module_param, log_module_param, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_3,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

Websocket__close::Websocket__close()
{
  bound_flag = FALSE;
}

Websocket__close::Websocket__close(const INTEGER& par_status__code,
    const OPTIONAL<OCTETSTRING>& par_data)
  :   field_status__code(par_status__code),
  field_data(par_data)
{
  bound_flag = TRUE;
}

Websocket__close::Websocket__close(const Websocket__close& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @WebSocket_Types.Websocket_close.");
bound_flag = TRUE;
if (other_value.status__code().is_bound()) field_status__code = other_value.status__code();
else field_status__code.clean_up();
if (other_value.data().is_bound()) field_data = other_value.data();
else field_data.clean_up();
}

void Websocket__close::clean_up()
{
field_status__code.clean_up();
field_data.clean_up();
bound_flag = FALSE;
}

Websocket__close& Websocket__close::operator=(const Websocket__close& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @WebSocket_Types.Websocket_close.");
  bound_flag = TRUE;
  if (other_value.status__code().is_bound()) field_status__code = other_value.status__code();
  else field_status__code.clean_up();
  if (other_value.data().is_bound()) field_data = other_value.data();
  else field_data.clean_up();
}
return *this;
}

boolean Websocket__close::operator==(const Websocket__close& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_status__code==other_value.field_status__code
  && field_data==other_value.field_data;
}

boolean Websocket__close::is_bound() const
{
if (bound_flag) return TRUE;
if(field_status__code.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_data.get_selection() || field_data.is_bound()) return TRUE;
return FALSE;
}
boolean Websocket__close::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_status__code.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_data.get_selection() && !field_data.is_value()) return FALSE;
return TRUE;
}
int Websocket__close::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @WebSocket_Types.Websocket_close");
  int ret_val = 1;
  if (field_data.ispresent()) ret_val++;
  return ret_val;
}

void Websocket__close::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ status_code := ");
field_status__code.log();
TTCN_Logger::log_event_str(", data := ");
field_data.log();
TTCN_Logger::log_event_str(" }");
}

void Websocket__close::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@WebSocket_Types.Websocket_close'");
    }
    if (strcmp("status_code", param_field) == 0) {
      status__code().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@WebSocket_Types.Websocket_close'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @WebSocket_Types.Websocket_close has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) status__code().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "status_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          status__code().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @WebSocket_Types.Websocket_close: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@WebSocket_Types.Websocket_close");
  }
}

void Websocket__close::set_implicit_omit()
{
if (status__code().is_bound()) status__code().set_implicit_omit();
if (!data().is_bound()) data() = OMIT_VALUE;
else data().set_implicit_omit();
}

void Websocket__close::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @WebSocket_Types.Websocket_close.");
field_status__code.encode_text(text_buf);
field_data.encode_text(text_buf);
}

void Websocket__close::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_status__code.decode_text(text_buf);
field_data.decode_text(text_buf);
}

struct Websocket__close_template::single_value_struct {
INTEGER_template field_status__code;
OCTETSTRING_template field_data;
};

void Websocket__close_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_status__code = ANY_VALUE;
single_value->field_data = ANY_OR_OMIT;
}
}
}

void Websocket__close_template::copy_value(const Websocket__close& other_value)
{
single_value = new single_value_struct;
if (other_value.status__code().is_bound()) {
  single_value->field_status__code = other_value.status__code();
} else {
  single_value->field_status__code.clean_up();
}
if (other_value.data().is_bound()) {
  if (other_value.data().ispresent()) single_value->field_data = other_value.data()();
  else single_value->field_data = OMIT_VALUE;
} else {
  single_value->field_data.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Websocket__close_template::copy_template(const Websocket__close_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.status__code().get_selection()) {
single_value->field_status__code = other_value.status__code();
} else {
single_value->field_status__code.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.data().get_selection()) {
single_value->field_data = other_value.data();
} else {
single_value->field_data.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Websocket__close_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @WebSocket_Types.Websocket_close.");
break;
}
set_selection(other_value);
}

Websocket__close_template::Websocket__close_template()
{
}

Websocket__close_template::Websocket__close_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Websocket__close_template::Websocket__close_template(const Websocket__close& other_value)
{
copy_value(other_value);
}

Websocket__close_template::Websocket__close_template(const OPTIONAL<Websocket__close>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Websocket__close&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @WebSocket_Types.Websocket_close from an unbound optional field.");
}
}

Websocket__close_template::Websocket__close_template(const Websocket__close_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Websocket__close_template::~Websocket__close_template()
{
clean_up();
}

Websocket__close_template& Websocket__close_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Websocket__close_template& Websocket__close_template::operator=(const Websocket__close& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Websocket__close_template& Websocket__close_template::operator=(const OPTIONAL<Websocket__close>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Websocket__close&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @WebSocket_Types.Websocket_close.");
}
return *this;
}

Websocket__close_template& Websocket__close_template::operator=(const Websocket__close_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Websocket__close_template::match(const Websocket__close& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.status__code().is_bound()) return FALSE;
if(!single_value->field_status__code.match(other_value.status__code()))return FALSE;
if(!other_value.data().is_bound()) return FALSE;
if((other_value.data().ispresent() ? !single_value->field_data.match((const OCTETSTRING&)other_value.data()) : !single_value->field_data.match_omit()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @WebSocket_Types.Websocket_close.");
}
return FALSE;
}

boolean Websocket__close_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_status__code.is_bound()) return TRUE;
if (single_value->field_data.is_omit() || single_value->field_data.is_bound()) return TRUE;
return FALSE;
}

boolean Websocket__close_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_status__code.is_value()) return FALSE;
if (!single_value->field_data.is_omit() && !single_value->field_data.is_value()) return FALSE;
return TRUE;
}

void Websocket__close_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Websocket__close Websocket__close_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @WebSocket_Types.Websocket_close.");
Websocket__close ret_val;
if (single_value->field_status__code.is_bound()) {
ret_val.status__code() = single_value->field_status__code.valueof();
}
if (single_value->field_data.is_omit()) ret_val.data() = OMIT_VALUE;
else if (single_value->field_data.is_bound()) {
ret_val.data() = single_value->field_data.valueof();
}
return ret_val;
}

void Websocket__close_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @WebSocket_Types.Websocket_close.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Websocket__close_template[list_length];
}

Websocket__close_template& Websocket__close_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @WebSocket_Types.Websocket_close.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @WebSocket_Types.Websocket_close.");
return value_list.list_value[list_index];
}

INTEGER_template& Websocket__close_template::status__code()
{
set_specific();
return single_value->field_status__code;
}

const INTEGER_template& Websocket__close_template::status__code() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field status_code of a non-specific template of type @WebSocket_Types.Websocket_close.");
return single_value->field_status__code;
}

OCTETSTRING_template& Websocket__close_template::data()
{
set_specific();
return single_value->field_data;
}

const OCTETSTRING_template& Websocket__close_template::data() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field data of a non-specific template of type @WebSocket_Types.Websocket_close.");
return single_value->field_data;
}

int Websocket__close_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @WebSocket_Types.Websocket_close which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_data.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @WebSocket_Types.Websocket_close containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @WebSocket_Types.Websocket_close containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @WebSocket_Types.Websocket_close containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @WebSocket_Types.Websocket_close containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @WebSocket_Types.Websocket_close containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @WebSocket_Types.Websocket_close.");
  }
  return 0;
}

void Websocket__close_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ status_code := ");
single_value->field_status__code.log();
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Websocket__close_template::log_match(const Websocket__close& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_status__code.match(match_value.status__code())){
TTCN_Logger::log_logmatch_info(".status_code");
single_value->field_status__code.log_match(match_value.status__code());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.data().ispresent()){
if(!single_value->field_data.match(match_value.data())){
TTCN_Logger::log_logmatch_info(".data");
single_value->field_data.log_match(match_value.data());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_data.match_omit()){
 TTCN_Logger::log_logmatch_info(".data := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_data.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ status_code := ");
single_value->field_status__code.log_match(match_value.status__code());
TTCN_Logger::log_event_str(", data := ");
if (match_value.data().ispresent()) single_value->field_data.log_match(match_value.data());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_data.log();
if (single_value->field_data.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Websocket__close_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_status__code.encode_text(text_buf);
single_value->field_data.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @WebSocket_Types.Websocket_close.");
}
}

void Websocket__close_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_status__code.decode_text(text_buf);
single_value->field_data.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Websocket__close_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @WebSocket_Types.Websocket_close.");
}
}

void Websocket__close_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@WebSocket_Types.Websocket_close'");
    }
    if (strcmp("status_code", param_field) == 0) {
      status__code().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@WebSocket_Types.Websocket_close'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @WebSocket_Types.Websocket_close has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) status__code().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "status_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          status__code().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @WebSocket_Types.Websocket_close: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@WebSocket_Types.Websocket_close");
  }
  is_ifpresent = param.get_ifpresent();
}

void Websocket__close_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_status__code.check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.Websocket_close");
single_value->field_data.check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.Websocket_close");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@WebSocket_Types.Websocket_close");
}

boolean Websocket__close_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean Websocket__close_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

WebSocket__opcode::WebSocket__opcode()
{
enum_value = UNBOUND_VALUE;
}

WebSocket__opcode::WebSocket__opcode(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @WebSocket_Types.WebSocket_opcode with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

WebSocket__opcode::WebSocket__opcode(enum_type other_value)
{
enum_value = other_value;
}

WebSocket__opcode::WebSocket__opcode(const WebSocket__opcode& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
enum_value = other_value.enum_value;
}

WebSocket__opcode& WebSocket__opcode::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @WebSocket_Types.WebSocket_opcode.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

WebSocket__opcode& WebSocket__opcode::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

WebSocket__opcode& WebSocket__opcode::operator=(const WebSocket__opcode& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
enum_value = other_value.enum_value;
return *this;
}

boolean WebSocket__opcode::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
return enum_value == other_value;
}

boolean WebSocket__opcode::operator==(const WebSocket__opcode& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
return enum_value == other_value.enum_value;
}

boolean WebSocket__opcode::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
return enum_value < other_value;
}

boolean WebSocket__opcode::operator<(const WebSocket__opcode& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
return enum_value < other_value.enum_value;
}

boolean WebSocket__opcode::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
return enum_value > other_value;
}

boolean WebSocket__opcode::operator>(const WebSocket__opcode& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
return enum_value > other_value.enum_value;
}

const char *WebSocket__opcode::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case Continuation__frame: return "Continuation_frame";
case Text__frame: return "Text_frame";
case Binary__frame: return "Binary_frame";
case Reserved__non__control3: return "Reserved_non_control3";
case Reserved__non__control4: return "Reserved_non_control4";
case Reserved__non__control5: return "Reserved_non_control5";
case Reserved__non__control6: return "Reserved_non_control6";
case Reserved__non__control7: return "Reserved_non_control7";
case Connection__Close: return "Connection_Close";
case Ping: return "Ping";
case Pong: return "Pong";
case Reserved__control11: return "Reserved_control11";
case Reserved__control12: return "Reserved_control12";
case Reserved__control13: return "Reserved_control13";
case Reserved__control14: return "Reserved_control14";
case Reserved__control15: return "Reserved_control15";
default: return "<unknown>";
}
}

WebSocket__opcode::enum_type WebSocket__opcode::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "Continuation_frame")) return Continuation__frame;
else if (!strcmp(str_par, "Text_frame")) return Text__frame;
else if (!strcmp(str_par, "Binary_frame")) return Binary__frame;
else if (!strcmp(str_par, "Reserved_non_control3")) return Reserved__non__control3;
else if (!strcmp(str_par, "Reserved_non_control4")) return Reserved__non__control4;
else if (!strcmp(str_par, "Reserved_non_control5")) return Reserved__non__control5;
else if (!strcmp(str_par, "Reserved_non_control6")) return Reserved__non__control6;
else if (!strcmp(str_par, "Reserved_non_control7")) return Reserved__non__control7;
else if (!strcmp(str_par, "Connection_Close")) return Connection__Close;
else if (!strcmp(str_par, "Ping")) return Ping;
else if (!strcmp(str_par, "Pong")) return Pong;
else if (!strcmp(str_par, "Reserved_control11")) return Reserved__control11;
else if (!strcmp(str_par, "Reserved_control12")) return Reserved__control12;
else if (!strcmp(str_par, "Reserved_control13")) return Reserved__control13;
else if (!strcmp(str_par, "Reserved_control14")) return Reserved__control14;
else if (!strcmp(str_par, "Reserved_control15")) return Reserved__control15;
else return UNKNOWN_VALUE;
}

boolean WebSocket__opcode::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
case 15:
return TRUE;
default:
return FALSE;
}
}

int WebSocket__opcode::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @WebSocket_Types.WebSocket_opcode.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int WebSocket__opcode::enum2int(const WebSocket__opcode& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @WebSocket_Types.WebSocket_opcode.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

WebSocket__opcode::operator WebSocket__opcode::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @WebSocket_Types.WebSocket_opcode.");
return enum_value;
}

void WebSocket__opcode::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void WebSocket__opcode::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@WebSocket_Types.WebSocket_opcode");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
     param.error("Invalid enumerated value for type @WebSocket_Types.WebSocket_opcode.");
  }
}

void WebSocket__opcode::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
text_buf.push_int(enum_value);
}

void WebSocket__opcode::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @WebSocket_Types.WebSocket_opcode.", enum_value);
}

void WebSocket__opcode_template::copy_template(const WebSocket__opcode_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new WebSocket__opcode_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @WebSocket_Types.WebSocket_opcode.");
}
}

WebSocket__opcode_template::WebSocket__opcode_template()
{
}

WebSocket__opcode_template::WebSocket__opcode_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

WebSocket__opcode_template::WebSocket__opcode_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!WebSocket__opcode::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @WebSocket_Types.WebSocket_opcode with unknown numeric value %d.", other_value);
single_value = (WebSocket__opcode::enum_type)other_value;
}

WebSocket__opcode_template::WebSocket__opcode_template(WebSocket__opcode::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

WebSocket__opcode_template::WebSocket__opcode_template(const WebSocket__opcode& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == WebSocket__opcode::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode.");
single_value = other_value.enum_value;
}

WebSocket__opcode_template::WebSocket__opcode_template(const OPTIONAL<WebSocket__opcode>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (WebSocket__opcode::enum_type)(const WebSocket__opcode&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @WebSocket_Types.WebSocket_opcode from an unbound optional field.");
}
}

WebSocket__opcode_template::WebSocket__opcode_template(const WebSocket__opcode_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

WebSocket__opcode_template::~WebSocket__opcode_template()
{
clean_up();
}

boolean WebSocket__opcode_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean WebSocket__opcode_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != WebSocket__opcode::UNBOUND_VALUE;
}

void WebSocket__opcode_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

WebSocket__opcode_template& WebSocket__opcode_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

WebSocket__opcode_template& WebSocket__opcode_template::operator=(int other_value)
{
if (!WebSocket__opcode::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @WebSocket_Types.WebSocket_opcode.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (WebSocket__opcode::enum_type)other_value;
return *this;
}

WebSocket__opcode_template& WebSocket__opcode_template::operator=(WebSocket__opcode::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

WebSocket__opcode_template& WebSocket__opcode_template::operator=(const WebSocket__opcode& other_value)
{
if (other_value.enum_value == WebSocket__opcode::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @WebSocket_Types.WebSocket_opcode to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

WebSocket__opcode_template& WebSocket__opcode_template::operator=(const OPTIONAL<WebSocket__opcode>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (WebSocket__opcode::enum_type)(const WebSocket__opcode&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @WebSocket_Types.WebSocket_opcode.");
}
return *this;
}

WebSocket__opcode_template& WebSocket__opcode_template::operator=(const WebSocket__opcode_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean WebSocket__opcode_template::match(WebSocket__opcode::enum_type other_value) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @WebSocket_Types.WebSocket_opcode.");
}
return FALSE;
}

boolean WebSocket__opcode_template::match(const WebSocket__opcode& other_value) const
{
if (other_value.enum_value == WebSocket__opcode::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @WebSocket_Types.WebSocket_opcode with an unbound value.");
return match(other_value.enum_value);
}

WebSocket__opcode::enum_type WebSocket__opcode_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @WebSocket_Types.WebSocket_opcode.");
return single_value;
}

void WebSocket__opcode_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @WebSocket_Types.WebSocket_opcode.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new WebSocket__opcode_template[list_length];
}

WebSocket__opcode_template& WebSocket__opcode_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @WebSocket_Types.WebSocket_opcode.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @WebSocket_Types.WebSocket_opcode.");
return value_list.list_value[list_index];
}

void WebSocket__opcode_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(WebSocket__opcode::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void WebSocket__opcode_template::log_match(const WebSocket__opcode& match_value) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void WebSocket__opcode_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @WebSocket_Types.WebSocket_opcode.");
}
}

void WebSocket__opcode_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (WebSocket__opcode::enum_type)text_buf.pull_int().get_val();
if (!WebSocket__opcode::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @WebSocket_Types.WebSocket_opcode.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new WebSocket__opcode_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @WebSocket_Types.WebSocket_opcode.");
}
}

boolean WebSocket__opcode_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean WebSocket__opcode_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void WebSocket__opcode_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Enumerated: {
    WebSocket__opcode::enum_type enum_val = WebSocket__opcode::str_to_enum(param.get_enumerated());
    if (!WebSocket__opcode::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @WebSocket_Types.WebSocket_opcode.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@WebSocket_Types.WebSocket_opcode");
  }
  is_ifpresent = param.get_ifpresent();
}

void WebSocket__opcode_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@WebSocket_Types.WebSocket_opcode");
}

void WebSocket__payloads::copy_value(const WebSocket__payloads& other_value)
{
switch (other_value.union_selection) {
case ALT_data:
field_data = new OCTETSTRING(*other_value.field_data);
break;
case ALT_close__data:
field_close__data = new Websocket__close(*other_value.field_close__data);
break;
default:
TTCN_error("Assignment of an unbound union value of type @WebSocket_Types.WebSocket_payloads.");
}
union_selection = other_value.union_selection;
}

WebSocket__payloads::WebSocket__payloads()
{
union_selection = UNBOUND_VALUE;
}

WebSocket__payloads::WebSocket__payloads(const WebSocket__payloads& other_value)
: Base_Type(){
copy_value(other_value);
}

WebSocket__payloads::~WebSocket__payloads()
{
clean_up();
}

WebSocket__payloads& WebSocket__payloads::operator=(const WebSocket__payloads& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean WebSocket__payloads::operator==(const WebSocket__payloads& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @WebSocket_Types.WebSocket_payloads.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @WebSocket_Types.WebSocket_payloads.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_data:
return *field_data == *other_value.field_data;
case ALT_close__data:
return *field_close__data == *other_value.field_close__data;
default:
return FALSE;
}
}

OCTETSTRING& WebSocket__payloads::data()
{
if (union_selection != ALT_data) {
clean_up();
field_data = new OCTETSTRING;
union_selection = ALT_data;
}
return *field_data;
}

const OCTETSTRING& WebSocket__payloads::data() const
{
if (union_selection != ALT_data) TTCN_error("Using non-selected field data in a value of union type @WebSocket_Types.WebSocket_payloads.");
return *field_data;
}

Websocket__close& WebSocket__payloads::close__data()
{
if (union_selection != ALT_close__data) {
clean_up();
field_close__data = new Websocket__close;
union_selection = ALT_close__data;
}
return *field_close__data;
}

const Websocket__close& WebSocket__payloads::close__data() const
{
if (union_selection != ALT_close__data) TTCN_error("Using non-selected field close_data in a value of union type @WebSocket_Types.WebSocket_payloads.");
return *field_close__data;
}

boolean WebSocket__payloads::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @WebSocket_Types.WebSocket_payloads.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @WebSocket_Types.WebSocket_payloads.");
return union_selection == checked_selection;
}

boolean WebSocket__payloads::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean WebSocket__payloads::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_data: return field_data->is_value();
case ALT_close__data: return field_close__data->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void WebSocket__payloads::clean_up()
{
switch (union_selection) {
case ALT_data:
  delete field_data;
  break;
case ALT_close__data:
  delete field_close__data;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void WebSocket__payloads::log() const
{
switch (union_selection) {
case ALT_data:
TTCN_Logger::log_event_str("{ data := ");
field_data->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_close__data:
TTCN_Logger::log_event_str("{ close_data := ");
field_close__data->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void WebSocket__payloads::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@WebSocket_Types.WebSocket_payloads'");
    }
    if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else if (strcmp("close_data", param_field) == 0) {
      close__data().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@WebSocket_Types.WebSocket_payloads'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) return;
  if (param.get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = param.get_elem(param.get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "data")) {
    data().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "close_data")) {
    close__data().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @WebSocket_Types.WebSocket_payloads.", mp_last->get_id()->get_name());
}

void WebSocket__payloads::set_implicit_omit()
{
switch (union_selection) {
case ALT_data:
field_data->set_implicit_omit(); break;
case ALT_close__data:
field_close__data->set_implicit_omit(); break;
default: break;
}
}

void WebSocket__payloads::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_data:
field_data->encode_text(text_buf);
break;
case ALT_close__data:
field_close__data->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @WebSocket_Types.WebSocket_payloads.");
}
}

void WebSocket__payloads::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_data:
data().decode_text(text_buf);
break;
case ALT_close__data:
close__data().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @WebSocket_Types.WebSocket_payloads.");
}
}

void WebSocket__payloads_template::copy_value(const WebSocket__payloads& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case WebSocket__payloads::ALT_data:
single_value.field_data = new OCTETSTRING_template(other_value.data());
break;
case WebSocket__payloads::ALT_close__data:
single_value.field_close__data = new Websocket__close_template(other_value.close__data());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @WebSocket_Types.WebSocket_payloads.");
}
set_selection(SPECIFIC_VALUE);
}

void WebSocket__payloads_template::copy_template(const WebSocket__payloads_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case WebSocket__payloads::ALT_data:
single_value.field_data = new OCTETSTRING_template(*other_value.single_value.field_data);
break;
case WebSocket__payloads::ALT_close__data:
single_value.field_close__data = new Websocket__close_template(*other_value.single_value.field_close__data);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @WebSocket_Types.WebSocket_payloads.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new WebSocket__payloads_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @WebSocket_Types.WebSocket_payloads.");
}
set_selection(other_value);
}

WebSocket__payloads_template::WebSocket__payloads_template()
{
}

WebSocket__payloads_template::WebSocket__payloads_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

WebSocket__payloads_template::WebSocket__payloads_template(const WebSocket__payloads& other_value)
{
copy_value(other_value);
}

WebSocket__payloads_template::WebSocket__payloads_template(const OPTIONAL<WebSocket__payloads>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const WebSocket__payloads&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @WebSocket_Types.WebSocket_payloads from an unbound optional field.");
}
}

WebSocket__payloads_template::WebSocket__payloads_template(const WebSocket__payloads_template& other_value)
: Base_Template(){
copy_template(other_value);
}

WebSocket__payloads_template::~WebSocket__payloads_template()
{
clean_up();
}

void WebSocket__payloads_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case WebSocket__payloads::ALT_data:
delete single_value.field_data;
break;
case WebSocket__payloads::ALT_close__data:
delete single_value.field_close__data;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

WebSocket__payloads_template& WebSocket__payloads_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

WebSocket__payloads_template& WebSocket__payloads_template::operator=(const WebSocket__payloads& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

WebSocket__payloads_template& WebSocket__payloads_template::operator=(const OPTIONAL<WebSocket__payloads>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const WebSocket__payloads&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @WebSocket_Types.WebSocket_payloads.");
}
return *this;
}

WebSocket__payloads_template& WebSocket__payloads_template::operator=(const WebSocket__payloads_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean WebSocket__payloads_template::match(const WebSocket__payloads& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
WebSocket__payloads::union_selection_type value_selection = other_value.get_selection();
if (value_selection == WebSocket__payloads::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case WebSocket__payloads::ALT_data:
return single_value.field_data->match(other_value.data());
case WebSocket__payloads::ALT_close__data:
return single_value.field_close__data->match(other_value.close__data());
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @WebSocket_Types.WebSocket_payloads.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @WebSocket_Types.WebSocket_payloads.");
}
return FALSE;
}

boolean WebSocket__payloads_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case WebSocket__payloads::ALT_data:
return single_value.field_data->is_value();
case WebSocket__payloads::ALT_close__data:
return single_value.field_close__data->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @WebSocket_Types.WebSocket_payloads.");
}
}

WebSocket__payloads WebSocket__payloads_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @WebSocket_Types.WebSocket_payloads.");
WebSocket__payloads ret_val;
switch (single_value.union_selection) {
case WebSocket__payloads::ALT_data:
ret_val.data() = single_value.field_data->valueof();
break;
case WebSocket__payloads::ALT_close__data:
ret_val.close__data() = single_value.field_close__data->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @WebSocket_Types.WebSocket_payloads.");
}
return ret_val;
}

WebSocket__payloads_template& WebSocket__payloads_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @WebSocket_Types.WebSocket_payloads.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @WebSocket_Types.WebSocket_payloads.");
return value_list.list_value[list_index];
}
void WebSocket__payloads_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @WebSocket_Types.WebSocket_payloads.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new WebSocket__payloads_template[list_length];
}

OCTETSTRING_template& WebSocket__payloads_template::data()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != WebSocket__payloads::ALT_data) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_data = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_data = new OCTETSTRING_template;
single_value.union_selection = WebSocket__payloads::ALT_data;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_data;
}

const OCTETSTRING_template& WebSocket__payloads_template::data() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field data in a non-specific template of union type @WebSocket_Types.WebSocket_payloads.");
if (single_value.union_selection != WebSocket__payloads::ALT_data) TTCN_error("Accessing non-selected field data in a template of union type @WebSocket_Types.WebSocket_payloads.");
return *single_value.field_data;
}

Websocket__close_template& WebSocket__payloads_template::close__data()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != WebSocket__payloads::ALT_close__data) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_close__data = new Websocket__close_template(ANY_VALUE);
else single_value.field_close__data = new Websocket__close_template;
single_value.union_selection = WebSocket__payloads::ALT_close__data;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_close__data;
}

const Websocket__close_template& WebSocket__payloads_template::close__data() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field close_data in a non-specific template of union type @WebSocket_Types.WebSocket_payloads.");
if (single_value.union_selection != WebSocket__payloads::ALT_close__data) TTCN_error("Accessing non-selected field close_data in a template of union type @WebSocket_Types.WebSocket_payloads.");
return *single_value.field_close__data;
}

boolean WebSocket__payloads_template::ischosen(WebSocket__payloads::union_selection_type checked_selection) const
{
if (checked_selection == WebSocket__payloads::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @WebSocket_Types.WebSocket_payloads.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == WebSocket__payloads::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @WebSocket_Types.WebSocket_payloads.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @WebSocket_Types.WebSocket_payloads containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @WebSocket_Types.WebSocket_payloads, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @WebSocket_Types.WebSocket_payloads");
}
return FALSE;
}

void WebSocket__payloads_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case WebSocket__payloads::ALT_data:
TTCN_Logger::log_event_str("{ data := ");
single_value.field_data->log();
TTCN_Logger::log_event_str(" }");
break;
case WebSocket__payloads::ALT_close__data:
TTCN_Logger::log_event_str("{ close_data := ");
single_value.field_close__data->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void WebSocket__payloads_template::log_match(const WebSocket__payloads& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case WebSocket__payloads::ALT_data:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".data");
single_value.field_data->log_match(match_value.data());
} else {
TTCN_Logger::log_event_str("{ data := ");
single_value.field_data->log_match(match_value.data());
TTCN_Logger::log_event_str(" }");
}
break;
case WebSocket__payloads::ALT_close__data:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".close_data");
single_value.field_close__data->log_match(match_value.close__data());
} else {
TTCN_Logger::log_event_str("{ close_data := ");
single_value.field_close__data->log_match(match_value.close__data());
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void WebSocket__payloads_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case WebSocket__payloads::ALT_data:
single_value.field_data->encode_text(text_buf);
break;
case WebSocket__payloads::ALT_close__data:
single_value.field_close__data->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @WebSocket_Types.WebSocket_payloads.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @WebSocket_Types.WebSocket_payloads.");
}
}

void WebSocket__payloads_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = WebSocket__payloads::UNBOUND_VALUE;
WebSocket__payloads::union_selection_type new_selection = (WebSocket__payloads::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case WebSocket__payloads::ALT_data:
single_value.field_data = new OCTETSTRING_template;
single_value.field_data->decode_text(text_buf);
break;
case WebSocket__payloads::ALT_close__data:
single_value.field_close__data = new Websocket__close_template;
single_value.field_close__data->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @WebSocket_Types.WebSocket_payloads.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new WebSocket__payloads_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @WebSocket_Types.WebSocket_payloads.");
}
}

boolean WebSocket__payloads_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean WebSocket__payloads_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void WebSocket__payloads_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@WebSocket_Types.WebSocket_payloads'");
    }
    if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else if (strcmp("close_data", param_field) == 0) {
      close__data().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@WebSocket_Types.WebSocket_payloads'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (param.get_size()==0) break;
    param.type_error("union template", "@WebSocket_Types.WebSocket_payloads");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = param.get_elem(param.get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "data")) {
      data().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "close_data")) {
      close__data().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @WebSocket_Types.WebSocket_payloads.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@WebSocket_Types.WebSocket_payloads");
  }
  is_ifpresent = param.get_ifpresent();
}

void WebSocket__payloads_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case WebSocket__payloads::ALT_data:
single_value.field_data->check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.WebSocket_payloads");
return;
case WebSocket__payloads::ALT_close__data:
single_value.field_close__data->check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.WebSocket_payloads");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @WebSocket_Types.WebSocket_payloads.");
}
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@WebSocket_Types.WebSocket_payloads");
}

WebSocket__PDU::WebSocket__PDU()
{
  bound_flag = FALSE;
}

WebSocket__PDU::WebSocket__PDU(const BITSTRING& par_fin__bit,
    const BITSTRING& par_rsv1__bit,
    const BITSTRING& par_rsv2__bit,
    const BITSTRING& par_rsv3__bit,
    const WebSocket__opcode& par_opcode,
    const BITSTRING& par_mask__bit,
    const INTEGER& par_payload__len,
    const OPTIONAL<OCTETSTRING>& par_masking__key,
    const OPTIONAL<WebSocket__payloads>& par_payload__data)
  :   field_fin__bit(par_fin__bit),
  field_rsv1__bit(par_rsv1__bit),
  field_rsv2__bit(par_rsv2__bit),
  field_rsv3__bit(par_rsv3__bit),
  field_opcode(par_opcode),
  field_mask__bit(par_mask__bit),
  field_payload__len(par_payload__len),
  field_masking__key(par_masking__key),
  field_payload__data(par_payload__data)
{
  bound_flag = TRUE;
}

WebSocket__PDU::WebSocket__PDU(const WebSocket__PDU& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @WebSocket_Types.WebSocket_PDU.");
bound_flag = TRUE;
if (other_value.fin__bit().is_bound()) field_fin__bit = other_value.fin__bit();
else field_fin__bit.clean_up();
if (other_value.rsv1__bit().is_bound()) field_rsv1__bit = other_value.rsv1__bit();
else field_rsv1__bit.clean_up();
if (other_value.rsv2__bit().is_bound()) field_rsv2__bit = other_value.rsv2__bit();
else field_rsv2__bit.clean_up();
if (other_value.rsv3__bit().is_bound()) field_rsv3__bit = other_value.rsv3__bit();
else field_rsv3__bit.clean_up();
if (other_value.opcode().is_bound()) field_opcode = other_value.opcode();
else field_opcode.clean_up();
if (other_value.mask__bit().is_bound()) field_mask__bit = other_value.mask__bit();
else field_mask__bit.clean_up();
if (other_value.payload__len().is_bound()) field_payload__len = other_value.payload__len();
else field_payload__len.clean_up();
if (other_value.masking__key().is_bound()) field_masking__key = other_value.masking__key();
else field_masking__key.clean_up();
if (other_value.payload__data().is_bound()) field_payload__data = other_value.payload__data();
else field_payload__data.clean_up();
}

void WebSocket__PDU::clean_up()
{
field_fin__bit.clean_up();
field_rsv1__bit.clean_up();
field_rsv2__bit.clean_up();
field_rsv3__bit.clean_up();
field_opcode.clean_up();
field_mask__bit.clean_up();
field_payload__len.clean_up();
field_masking__key.clean_up();
field_payload__data.clean_up();
bound_flag = FALSE;
}

WebSocket__PDU& WebSocket__PDU::operator=(const WebSocket__PDU& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @WebSocket_Types.WebSocket_PDU.");
  bound_flag = TRUE;
  if (other_value.fin__bit().is_bound()) field_fin__bit = other_value.fin__bit();
  else field_fin__bit.clean_up();
  if (other_value.rsv1__bit().is_bound()) field_rsv1__bit = other_value.rsv1__bit();
  else field_rsv1__bit.clean_up();
  if (other_value.rsv2__bit().is_bound()) field_rsv2__bit = other_value.rsv2__bit();
  else field_rsv2__bit.clean_up();
  if (other_value.rsv3__bit().is_bound()) field_rsv3__bit = other_value.rsv3__bit();
  else field_rsv3__bit.clean_up();
  if (other_value.opcode().is_bound()) field_opcode = other_value.opcode();
  else field_opcode.clean_up();
  if (other_value.mask__bit().is_bound()) field_mask__bit = other_value.mask__bit();
  else field_mask__bit.clean_up();
  if (other_value.payload__len().is_bound()) field_payload__len = other_value.payload__len();
  else field_payload__len.clean_up();
  if (other_value.masking__key().is_bound()) field_masking__key = other_value.masking__key();
  else field_masking__key.clean_up();
  if (other_value.payload__data().is_bound()) field_payload__data = other_value.payload__data();
  else field_payload__data.clean_up();
}
return *this;
}

boolean WebSocket__PDU::operator==(const WebSocket__PDU& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_fin__bit==other_value.field_fin__bit
  && field_rsv1__bit==other_value.field_rsv1__bit
  && field_rsv2__bit==other_value.field_rsv2__bit
  && field_rsv3__bit==other_value.field_rsv3__bit
  && field_opcode==other_value.field_opcode
  && field_mask__bit==other_value.field_mask__bit
  && field_payload__len==other_value.field_payload__len
  && field_masking__key==other_value.field_masking__key
  && field_payload__data==other_value.field_payload__data;
}

boolean WebSocket__PDU::is_bound() const
{
if (bound_flag) return TRUE;
if(field_fin__bit.is_bound()) return TRUE;
if(field_rsv1__bit.is_bound()) return TRUE;
if(field_rsv2__bit.is_bound()) return TRUE;
if(field_rsv3__bit.is_bound()) return TRUE;
if(field_opcode.is_bound()) return TRUE;
if(field_mask__bit.is_bound()) return TRUE;
if(field_payload__len.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_masking__key.get_selection() || field_masking__key.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_payload__data.get_selection() || field_payload__data.is_bound()) return TRUE;
return FALSE;
}
boolean WebSocket__PDU::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_fin__bit.is_value()) return FALSE;
if(!field_rsv1__bit.is_value()) return FALSE;
if(!field_rsv2__bit.is_value()) return FALSE;
if(!field_rsv3__bit.is_value()) return FALSE;
if(!field_opcode.is_value()) return FALSE;
if(!field_mask__bit.is_value()) return FALSE;
if(!field_payload__len.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_masking__key.get_selection() && !field_masking__key.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_payload__data.get_selection() && !field_payload__data.is_value()) return FALSE;
return TRUE;
}
int WebSocket__PDU::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @WebSocket_Types.WebSocket_PDU");
  int ret_val = 7;
  if (field_masking__key.ispresent()) ret_val++;
  if (field_payload__data.ispresent()) ret_val++;
  return ret_val;
}

void WebSocket__PDU::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ fin_bit := ");
field_fin__bit.log();
TTCN_Logger::log_event_str(", rsv1_bit := ");
field_rsv1__bit.log();
TTCN_Logger::log_event_str(", rsv2_bit := ");
field_rsv2__bit.log();
TTCN_Logger::log_event_str(", rsv3_bit := ");
field_rsv3__bit.log();
TTCN_Logger::log_event_str(", opcode := ");
field_opcode.log();
TTCN_Logger::log_event_str(", mask_bit := ");
field_mask__bit.log();
TTCN_Logger::log_event_str(", payload_len := ");
field_payload__len.log();
TTCN_Logger::log_event_str(", masking_key := ");
field_masking__key.log();
TTCN_Logger::log_event_str(", payload_data := ");
field_payload__data.log();
TTCN_Logger::log_event_str(" }");
}

void WebSocket__PDU::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@WebSocket_Types.WebSocket_PDU'");
    }
    if (strcmp("fin_bit", param_field) == 0) {
      fin__bit().set_param(param);
      return;
    } else if (strcmp("rsv1_bit", param_field) == 0) {
      rsv1__bit().set_param(param);
      return;
    } else if (strcmp("rsv2_bit", param_field) == 0) {
      rsv2__bit().set_param(param);
      return;
    } else if (strcmp("rsv3_bit", param_field) == 0) {
      rsv3__bit().set_param(param);
      return;
    } else if (strcmp("opcode", param_field) == 0) {
      opcode().set_param(param);
      return;
    } else if (strcmp("mask_bit", param_field) == 0) {
      mask__bit().set_param(param);
      return;
    } else if (strcmp("payload_len", param_field) == 0) {
      payload__len().set_param(param);
      return;
    } else if (strcmp("masking_key", param_field) == 0) {
      masking__key().set_param(param);
      return;
    } else if (strcmp("payload_data", param_field) == 0) {
      payload__data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@WebSocket_Types.WebSocket_PDU'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (9<param.get_size()) {
      param.error("record value of type @WebSocket_Types.WebSocket_PDU has 9 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) fin__bit().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) rsv1__bit().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) rsv2__bit().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) rsv3__bit().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) opcode().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) mask__bit().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) payload__len().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) masking__key().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) payload__data().set_param(*param.get_elem(8));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fin_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fin__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rsv1_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rsv1__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rsv2_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rsv2__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rsv3_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rsv3__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "opcode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          opcode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mask_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mask__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_len")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__len().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "masking_key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          masking__key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @WebSocket_Types.WebSocket_PDU: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@WebSocket_Types.WebSocket_PDU");
  }
}

void WebSocket__PDU::set_implicit_omit()
{
if (fin__bit().is_bound()) fin__bit().set_implicit_omit();
if (rsv1__bit().is_bound()) rsv1__bit().set_implicit_omit();
if (rsv2__bit().is_bound()) rsv2__bit().set_implicit_omit();
if (rsv3__bit().is_bound()) rsv3__bit().set_implicit_omit();
if (opcode().is_bound()) opcode().set_implicit_omit();
if (mask__bit().is_bound()) mask__bit().set_implicit_omit();
if (payload__len().is_bound()) payload__len().set_implicit_omit();
if (!masking__key().is_bound()) masking__key() = OMIT_VALUE;
else masking__key().set_implicit_omit();
if (!payload__data().is_bound()) payload__data() = OMIT_VALUE;
else payload__data().set_implicit_omit();
}

void WebSocket__PDU::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @WebSocket_Types.WebSocket_PDU.");
field_fin__bit.encode_text(text_buf);
field_rsv1__bit.encode_text(text_buf);
field_rsv2__bit.encode_text(text_buf);
field_rsv3__bit.encode_text(text_buf);
field_opcode.encode_text(text_buf);
field_mask__bit.encode_text(text_buf);
field_payload__len.encode_text(text_buf);
field_masking__key.encode_text(text_buf);
field_payload__data.encode_text(text_buf);
}

void WebSocket__PDU::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_fin__bit.decode_text(text_buf);
field_rsv1__bit.decode_text(text_buf);
field_rsv2__bit.decode_text(text_buf);
field_rsv3__bit.decode_text(text_buf);
field_opcode.decode_text(text_buf);
field_mask__bit.decode_text(text_buf);
field_payload__len.decode_text(text_buf);
field_masking__key.decode_text(text_buf);
field_payload__data.decode_text(text_buf);
}

struct WebSocket__PDU_template::single_value_struct {
BITSTRING_template field_fin__bit;
BITSTRING_template field_rsv1__bit;
BITSTRING_template field_rsv2__bit;
BITSTRING_template field_rsv3__bit;
WebSocket__opcode_template field_opcode;
BITSTRING_template field_mask__bit;
INTEGER_template field_payload__len;
OCTETSTRING_template field_masking__key;
WebSocket__payloads_template field_payload__data;
};

void WebSocket__PDU_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_fin__bit = ANY_VALUE;
single_value->field_rsv1__bit = ANY_VALUE;
single_value->field_rsv2__bit = ANY_VALUE;
single_value->field_rsv3__bit = ANY_VALUE;
single_value->field_opcode = ANY_VALUE;
single_value->field_mask__bit = ANY_VALUE;
single_value->field_payload__len = ANY_VALUE;
single_value->field_masking__key = ANY_OR_OMIT;
single_value->field_payload__data = ANY_OR_OMIT;
}
}
}

void WebSocket__PDU_template::copy_value(const WebSocket__PDU& other_value)
{
single_value = new single_value_struct;
if (other_value.fin__bit().is_bound()) {
  single_value->field_fin__bit = other_value.fin__bit();
} else {
  single_value->field_fin__bit.clean_up();
}
if (other_value.rsv1__bit().is_bound()) {
  single_value->field_rsv1__bit = other_value.rsv1__bit();
} else {
  single_value->field_rsv1__bit.clean_up();
}
if (other_value.rsv2__bit().is_bound()) {
  single_value->field_rsv2__bit = other_value.rsv2__bit();
} else {
  single_value->field_rsv2__bit.clean_up();
}
if (other_value.rsv3__bit().is_bound()) {
  single_value->field_rsv3__bit = other_value.rsv3__bit();
} else {
  single_value->field_rsv3__bit.clean_up();
}
if (other_value.opcode().is_bound()) {
  single_value->field_opcode = other_value.opcode();
} else {
  single_value->field_opcode.clean_up();
}
if (other_value.mask__bit().is_bound()) {
  single_value->field_mask__bit = other_value.mask__bit();
} else {
  single_value->field_mask__bit.clean_up();
}
if (other_value.payload__len().is_bound()) {
  single_value->field_payload__len = other_value.payload__len();
} else {
  single_value->field_payload__len.clean_up();
}
if (other_value.masking__key().is_bound()) {
  if (other_value.masking__key().ispresent()) single_value->field_masking__key = other_value.masking__key()();
  else single_value->field_masking__key = OMIT_VALUE;
} else {
  single_value->field_masking__key.clean_up();
}
if (other_value.payload__data().is_bound()) {
  if (other_value.payload__data().ispresent()) single_value->field_payload__data = other_value.payload__data()();
  else single_value->field_payload__data = OMIT_VALUE;
} else {
  single_value->field_payload__data.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void WebSocket__PDU_template::copy_template(const WebSocket__PDU_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.fin__bit().get_selection()) {
single_value->field_fin__bit = other_value.fin__bit();
} else {
single_value->field_fin__bit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rsv1__bit().get_selection()) {
single_value->field_rsv1__bit = other_value.rsv1__bit();
} else {
single_value->field_rsv1__bit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rsv2__bit().get_selection()) {
single_value->field_rsv2__bit = other_value.rsv2__bit();
} else {
single_value->field_rsv2__bit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rsv3__bit().get_selection()) {
single_value->field_rsv3__bit = other_value.rsv3__bit();
} else {
single_value->field_rsv3__bit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.opcode().get_selection()) {
single_value->field_opcode = other_value.opcode();
} else {
single_value->field_opcode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mask__bit().get_selection()) {
single_value->field_mask__bit = other_value.mask__bit();
} else {
single_value->field_mask__bit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload__len().get_selection()) {
single_value->field_payload__len = other_value.payload__len();
} else {
single_value->field_payload__len.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.masking__key().get_selection()) {
single_value->field_masking__key = other_value.masking__key();
} else {
single_value->field_masking__key.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload__data().get_selection()) {
single_value->field_payload__data = other_value.payload__data();
} else {
single_value->field_payload__data.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new WebSocket__PDU_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @WebSocket_Types.WebSocket_PDU.");
break;
}
set_selection(other_value);
}

WebSocket__PDU_template::WebSocket__PDU_template()
{
}

WebSocket__PDU_template::WebSocket__PDU_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

WebSocket__PDU_template::WebSocket__PDU_template(const WebSocket__PDU& other_value)
{
copy_value(other_value);
}

WebSocket__PDU_template::WebSocket__PDU_template(const OPTIONAL<WebSocket__PDU>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const WebSocket__PDU&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @WebSocket_Types.WebSocket_PDU from an unbound optional field.");
}
}

WebSocket__PDU_template::WebSocket__PDU_template(const WebSocket__PDU_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

WebSocket__PDU_template::~WebSocket__PDU_template()
{
clean_up();
}

WebSocket__PDU_template& WebSocket__PDU_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

WebSocket__PDU_template& WebSocket__PDU_template::operator=(const WebSocket__PDU& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

WebSocket__PDU_template& WebSocket__PDU_template::operator=(const OPTIONAL<WebSocket__PDU>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const WebSocket__PDU&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @WebSocket_Types.WebSocket_PDU.");
}
return *this;
}

WebSocket__PDU_template& WebSocket__PDU_template::operator=(const WebSocket__PDU_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean WebSocket__PDU_template::match(const WebSocket__PDU& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.fin__bit().is_bound()) return FALSE;
if(!single_value->field_fin__bit.match(other_value.fin__bit()))return FALSE;
if(!other_value.rsv1__bit().is_bound()) return FALSE;
if(!single_value->field_rsv1__bit.match(other_value.rsv1__bit()))return FALSE;
if(!other_value.rsv2__bit().is_bound()) return FALSE;
if(!single_value->field_rsv2__bit.match(other_value.rsv2__bit()))return FALSE;
if(!other_value.rsv3__bit().is_bound()) return FALSE;
if(!single_value->field_rsv3__bit.match(other_value.rsv3__bit()))return FALSE;
if(!other_value.opcode().is_bound()) return FALSE;
if(!single_value->field_opcode.match(other_value.opcode()))return FALSE;
if(!other_value.mask__bit().is_bound()) return FALSE;
if(!single_value->field_mask__bit.match(other_value.mask__bit()))return FALSE;
if(!other_value.payload__len().is_bound()) return FALSE;
if(!single_value->field_payload__len.match(other_value.payload__len()))return FALSE;
if(!other_value.masking__key().is_bound()) return FALSE;
if((other_value.masking__key().ispresent() ? !single_value->field_masking__key.match((const OCTETSTRING&)other_value.masking__key()) : !single_value->field_masking__key.match_omit()))return FALSE;
if(!other_value.payload__data().is_bound()) return FALSE;
if((other_value.payload__data().ispresent() ? !single_value->field_payload__data.match((const WebSocket__payloads&)other_value.payload__data()) : !single_value->field_payload__data.match_omit()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @WebSocket_Types.WebSocket_PDU.");
}
return FALSE;
}

boolean WebSocket__PDU_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_fin__bit.is_bound()) return TRUE;
if (single_value->field_rsv1__bit.is_bound()) return TRUE;
if (single_value->field_rsv2__bit.is_bound()) return TRUE;
if (single_value->field_rsv3__bit.is_bound()) return TRUE;
if (single_value->field_opcode.is_bound()) return TRUE;
if (single_value->field_mask__bit.is_bound()) return TRUE;
if (single_value->field_payload__len.is_bound()) return TRUE;
if (single_value->field_masking__key.is_omit() || single_value->field_masking__key.is_bound()) return TRUE;
if (single_value->field_payload__data.is_omit() || single_value->field_payload__data.is_bound()) return TRUE;
return FALSE;
}

boolean WebSocket__PDU_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_fin__bit.is_value()) return FALSE;
if (!single_value->field_rsv1__bit.is_value()) return FALSE;
if (!single_value->field_rsv2__bit.is_value()) return FALSE;
if (!single_value->field_rsv3__bit.is_value()) return FALSE;
if (!single_value->field_opcode.is_value()) return FALSE;
if (!single_value->field_mask__bit.is_value()) return FALSE;
if (!single_value->field_payload__len.is_value()) return FALSE;
if (!single_value->field_masking__key.is_omit() && !single_value->field_masking__key.is_value()) return FALSE;
if (!single_value->field_payload__data.is_omit() && !single_value->field_payload__data.is_value()) return FALSE;
return TRUE;
}

void WebSocket__PDU_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

WebSocket__PDU WebSocket__PDU_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @WebSocket_Types.WebSocket_PDU.");
WebSocket__PDU ret_val;
if (single_value->field_fin__bit.is_bound()) {
ret_val.fin__bit() = single_value->field_fin__bit.valueof();
}
if (single_value->field_rsv1__bit.is_bound()) {
ret_val.rsv1__bit() = single_value->field_rsv1__bit.valueof();
}
if (single_value->field_rsv2__bit.is_bound()) {
ret_val.rsv2__bit() = single_value->field_rsv2__bit.valueof();
}
if (single_value->field_rsv3__bit.is_bound()) {
ret_val.rsv3__bit() = single_value->field_rsv3__bit.valueof();
}
if (single_value->field_opcode.is_bound()) {
ret_val.opcode() = single_value->field_opcode.valueof();
}
if (single_value->field_mask__bit.is_bound()) {
ret_val.mask__bit() = single_value->field_mask__bit.valueof();
}
if (single_value->field_payload__len.is_bound()) {
ret_val.payload__len() = single_value->field_payload__len.valueof();
}
if (single_value->field_masking__key.is_omit()) ret_val.masking__key() = OMIT_VALUE;
else if (single_value->field_masking__key.is_bound()) {
ret_val.masking__key() = single_value->field_masking__key.valueof();
}
if (single_value->field_payload__data.is_omit()) ret_val.payload__data() = OMIT_VALUE;
else if (single_value->field_payload__data.is_bound()) {
ret_val.payload__data() = single_value->field_payload__data.valueof();
}
return ret_val;
}

void WebSocket__PDU_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @WebSocket_Types.WebSocket_PDU.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new WebSocket__PDU_template[list_length];
}

WebSocket__PDU_template& WebSocket__PDU_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @WebSocket_Types.WebSocket_PDU.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @WebSocket_Types.WebSocket_PDU.");
return value_list.list_value[list_index];
}

BITSTRING_template& WebSocket__PDU_template::fin__bit()
{
set_specific();
return single_value->field_fin__bit;
}

const BITSTRING_template& WebSocket__PDU_template::fin__bit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field fin_bit of a non-specific template of type @WebSocket_Types.WebSocket_PDU.");
return single_value->field_fin__bit;
}

BITSTRING_template& WebSocket__PDU_template::rsv1__bit()
{
set_specific();
return single_value->field_rsv1__bit;
}

const BITSTRING_template& WebSocket__PDU_template::rsv1__bit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rsv1_bit of a non-specific template of type @WebSocket_Types.WebSocket_PDU.");
return single_value->field_rsv1__bit;
}

BITSTRING_template& WebSocket__PDU_template::rsv2__bit()
{
set_specific();
return single_value->field_rsv2__bit;
}

const BITSTRING_template& WebSocket__PDU_template::rsv2__bit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rsv2_bit of a non-specific template of type @WebSocket_Types.WebSocket_PDU.");
return single_value->field_rsv2__bit;
}

BITSTRING_template& WebSocket__PDU_template::rsv3__bit()
{
set_specific();
return single_value->field_rsv3__bit;
}

const BITSTRING_template& WebSocket__PDU_template::rsv3__bit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rsv3_bit of a non-specific template of type @WebSocket_Types.WebSocket_PDU.");
return single_value->field_rsv3__bit;
}

WebSocket__opcode_template& WebSocket__PDU_template::opcode()
{
set_specific();
return single_value->field_opcode;
}

const WebSocket__opcode_template& WebSocket__PDU_template::opcode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field opcode of a non-specific template of type @WebSocket_Types.WebSocket_PDU.");
return single_value->field_opcode;
}

BITSTRING_template& WebSocket__PDU_template::mask__bit()
{
set_specific();
return single_value->field_mask__bit;
}

const BITSTRING_template& WebSocket__PDU_template::mask__bit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mask_bit of a non-specific template of type @WebSocket_Types.WebSocket_PDU.");
return single_value->field_mask__bit;
}

INTEGER_template& WebSocket__PDU_template::payload__len()
{
set_specific();
return single_value->field_payload__len;
}

const INTEGER_template& WebSocket__PDU_template::payload__len() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload_len of a non-specific template of type @WebSocket_Types.WebSocket_PDU.");
return single_value->field_payload__len;
}

OCTETSTRING_template& WebSocket__PDU_template::masking__key()
{
set_specific();
return single_value->field_masking__key;
}

const OCTETSTRING_template& WebSocket__PDU_template::masking__key() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field masking_key of a non-specific template of type @WebSocket_Types.WebSocket_PDU.");
return single_value->field_masking__key;
}

WebSocket__payloads_template& WebSocket__PDU_template::payload__data()
{
set_specific();
return single_value->field_payload__data;
}

const WebSocket__payloads_template& WebSocket__PDU_template::payload__data() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload_data of a non-specific template of type @WebSocket_Types.WebSocket_PDU.");
return single_value->field_payload__data;
}

int WebSocket__PDU_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @WebSocket_Types.WebSocket_PDU which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 7;
      if (single_value->field_masking__key.is_present()) ret_val++;
      if (single_value->field_payload__data.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @WebSocket_Types.WebSocket_PDU containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @WebSocket_Types.WebSocket_PDU containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @WebSocket_Types.WebSocket_PDU containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @WebSocket_Types.WebSocket_PDU containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @WebSocket_Types.WebSocket_PDU containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @WebSocket_Types.WebSocket_PDU.");
  }
  return 0;
}

void WebSocket__PDU_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ fin_bit := ");
single_value->field_fin__bit.log();
TTCN_Logger::log_event_str(", rsv1_bit := ");
single_value->field_rsv1__bit.log();
TTCN_Logger::log_event_str(", rsv2_bit := ");
single_value->field_rsv2__bit.log();
TTCN_Logger::log_event_str(", rsv3_bit := ");
single_value->field_rsv3__bit.log();
TTCN_Logger::log_event_str(", opcode := ");
single_value->field_opcode.log();
TTCN_Logger::log_event_str(", mask_bit := ");
single_value->field_mask__bit.log();
TTCN_Logger::log_event_str(", payload_len := ");
single_value->field_payload__len.log();
TTCN_Logger::log_event_str(", masking_key := ");
single_value->field_masking__key.log();
TTCN_Logger::log_event_str(", payload_data := ");
single_value->field_payload__data.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void WebSocket__PDU_template::log_match(const WebSocket__PDU& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_fin__bit.match(match_value.fin__bit())){
TTCN_Logger::log_logmatch_info(".fin_bit");
single_value->field_fin__bit.log_match(match_value.fin__bit());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rsv1__bit.match(match_value.rsv1__bit())){
TTCN_Logger::log_logmatch_info(".rsv1_bit");
single_value->field_rsv1__bit.log_match(match_value.rsv1__bit());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rsv2__bit.match(match_value.rsv2__bit())){
TTCN_Logger::log_logmatch_info(".rsv2_bit");
single_value->field_rsv2__bit.log_match(match_value.rsv2__bit());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rsv3__bit.match(match_value.rsv3__bit())){
TTCN_Logger::log_logmatch_info(".rsv3_bit");
single_value->field_rsv3__bit.log_match(match_value.rsv3__bit());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_opcode.match(match_value.opcode())){
TTCN_Logger::log_logmatch_info(".opcode");
single_value->field_opcode.log_match(match_value.opcode());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mask__bit.match(match_value.mask__bit())){
TTCN_Logger::log_logmatch_info(".mask_bit");
single_value->field_mask__bit.log_match(match_value.mask__bit());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload__len.match(match_value.payload__len())){
TTCN_Logger::log_logmatch_info(".payload_len");
single_value->field_payload__len.log_match(match_value.payload__len());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.masking__key().ispresent()){
if(!single_value->field_masking__key.match(match_value.masking__key())){
TTCN_Logger::log_logmatch_info(".masking_key");
single_value->field_masking__key.log_match(match_value.masking__key());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_masking__key.match_omit()){
 TTCN_Logger::log_logmatch_info(".masking_key := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_masking__key.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.payload__data().ispresent()){
if(!single_value->field_payload__data.match(match_value.payload__data())){
TTCN_Logger::log_logmatch_info(".payload_data");
single_value->field_payload__data.log_match(match_value.payload__data());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_payload__data.match_omit()){
 TTCN_Logger::log_logmatch_info(".payload_data := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_payload__data.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ fin_bit := ");
single_value->field_fin__bit.log_match(match_value.fin__bit());
TTCN_Logger::log_event_str(", rsv1_bit := ");
single_value->field_rsv1__bit.log_match(match_value.rsv1__bit());
TTCN_Logger::log_event_str(", rsv2_bit := ");
single_value->field_rsv2__bit.log_match(match_value.rsv2__bit());
TTCN_Logger::log_event_str(", rsv3_bit := ");
single_value->field_rsv3__bit.log_match(match_value.rsv3__bit());
TTCN_Logger::log_event_str(", opcode := ");
single_value->field_opcode.log_match(match_value.opcode());
TTCN_Logger::log_event_str(", mask_bit := ");
single_value->field_mask__bit.log_match(match_value.mask__bit());
TTCN_Logger::log_event_str(", payload_len := ");
single_value->field_payload__len.log_match(match_value.payload__len());
TTCN_Logger::log_event_str(", masking_key := ");
if (match_value.masking__key().ispresent()) single_value->field_masking__key.log_match(match_value.masking__key());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_masking__key.log();
if (single_value->field_masking__key.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", payload_data := ");
if (match_value.payload__data().ispresent()) single_value->field_payload__data.log_match(match_value.payload__data());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_payload__data.log();
if (single_value->field_payload__data.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void WebSocket__PDU_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_fin__bit.encode_text(text_buf);
single_value->field_rsv1__bit.encode_text(text_buf);
single_value->field_rsv2__bit.encode_text(text_buf);
single_value->field_rsv3__bit.encode_text(text_buf);
single_value->field_opcode.encode_text(text_buf);
single_value->field_mask__bit.encode_text(text_buf);
single_value->field_payload__len.encode_text(text_buf);
single_value->field_masking__key.encode_text(text_buf);
single_value->field_payload__data.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @WebSocket_Types.WebSocket_PDU.");
}
}

void WebSocket__PDU_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_fin__bit.decode_text(text_buf);
single_value->field_rsv1__bit.decode_text(text_buf);
single_value->field_rsv2__bit.decode_text(text_buf);
single_value->field_rsv3__bit.decode_text(text_buf);
single_value->field_opcode.decode_text(text_buf);
single_value->field_mask__bit.decode_text(text_buf);
single_value->field_payload__len.decode_text(text_buf);
single_value->field_masking__key.decode_text(text_buf);
single_value->field_payload__data.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new WebSocket__PDU_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @WebSocket_Types.WebSocket_PDU.");
}
}

void WebSocket__PDU_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@WebSocket_Types.WebSocket_PDU'");
    }
    if (strcmp("fin_bit", param_field) == 0) {
      fin__bit().set_param(param);
      return;
    } else if (strcmp("rsv1_bit", param_field) == 0) {
      rsv1__bit().set_param(param);
      return;
    } else if (strcmp("rsv2_bit", param_field) == 0) {
      rsv2__bit().set_param(param);
      return;
    } else if (strcmp("rsv3_bit", param_field) == 0) {
      rsv3__bit().set_param(param);
      return;
    } else if (strcmp("opcode", param_field) == 0) {
      opcode().set_param(param);
      return;
    } else if (strcmp("mask_bit", param_field) == 0) {
      mask__bit().set_param(param);
      return;
    } else if (strcmp("payload_len", param_field) == 0) {
      payload__len().set_param(param);
      return;
    } else if (strcmp("masking_key", param_field) == 0) {
      masking__key().set_param(param);
      return;
    } else if (strcmp("payload_data", param_field) == 0) {
      payload__data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@WebSocket_Types.WebSocket_PDU'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (9<param.get_size()) {
      param.error("record template of type @WebSocket_Types.WebSocket_PDU has 9 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) fin__bit().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) rsv1__bit().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) rsv2__bit().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) rsv3__bit().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) opcode().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) mask__bit().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) payload__len().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) masking__key().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) payload__data().set_param(*param.get_elem(8));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fin_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fin__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rsv1_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rsv1__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rsv2_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rsv2__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rsv3_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rsv3__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "opcode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          opcode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mask_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mask__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_len")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__len().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "masking_key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          masking__key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @WebSocket_Types.WebSocket_PDU: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@WebSocket_Types.WebSocket_PDU");
  }
  is_ifpresent = param.get_ifpresent();
}

void WebSocket__PDU_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_fin__bit.check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.WebSocket_PDU");
single_value->field_rsv1__bit.check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.WebSocket_PDU");
single_value->field_rsv2__bit.check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.WebSocket_PDU");
single_value->field_rsv3__bit.check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.WebSocket_PDU");
single_value->field_opcode.check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.WebSocket_PDU");
single_value->field_mask__bit.check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.WebSocket_PDU");
single_value->field_payload__len.check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.WebSocket_PDU");
single_value->field_masking__key.check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.WebSocket_PDU");
single_value->field_payload__data.check_restriction(t_res, t_name ? t_name : "@WebSocket_Types.WebSocket_PDU");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@WebSocket_Types.WebSocket_PDU");
}

boolean WebSocket__PDU_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean WebSocket__PDU_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}


/* Bodies of static functions */

static void pre_init_module()
{
/* /work/TDT4290/src/skeleton/web_socket/WebSocket_Types.ttcn, line 19 */
modulepar_m__Websocket__generate__masking__key = TRUE;
/* /work/TDT4290/src/skeleton/web_socket/WebSocket_Types.ttcn, line 20 */
modulepar_m__Websocket__auto__masking = TRUE;
module_object.add_function("f_WebSocket_Encode", (genericfunc_t)&f__WebSocket__Encode, NULL);
module_object.add_function("f_WebSocket_Decode", (genericfunc_t)&f__WebSocket__Decode, NULL);
module_object.add_function("f_WebSocket_calc_length", (genericfunc_t)&f__WebSocket__calc__length, NULL);
module_object.add_function("f_WebSocket_Generate_Masking_Key", (genericfunc_t)&f__WebSocket__Generate__Masking__Key, NULL);
}

static void post_init_module()
{
const_f__WebSocket__Encode_pl__gen__maks_defval = m__Websocket__generate__masking__key;
const_f__WebSocket__Encode_pl__auto__maks_defval = m__Websocket__auto__masking;
const_f__WebSocket__Decode_pl__auto__maks_defval = m__Websocket__auto__masking;
}

static boolean set_module_param(Module_Param& param)
{
const char* const par_name = param.get_id()->get_current_name();
if (!strcmp(par_name, "m_Websocket_generate_masking_key")) {
modulepar_m__Websocket__generate__masking__key.set_param(param);
return TRUE;
} else if (!strcmp(par_name, "m_Websocket_auto_masking")) {
modulepar_m__Websocket__auto__masking.set_param(param);
return TRUE;
} else return FALSE;
}

static void log_module_param()
{
TTCN_Logger::log_event_str("m_Websocket_generate_masking_key := ");
m__Websocket__generate__masking__key.log();
TTCN_Logger::log_event_str(", m_Websocket_auto_masking := ");
m__Websocket__auto__masking.log();
}


} /* end of namespace */
