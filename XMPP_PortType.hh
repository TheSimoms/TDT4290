// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for user (user@user-multicom) on Fri Oct  9 11:34:10 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

#ifndef XMPP__PortType_HH
#define XMPP__PortType_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "XMPP_Types.hh"
#include "XMPP_PT.hh"

#if TTCN3_VERSION != 50300
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef XMPP__PortType_HH
#endif

namespace XMPP__PortType {

/* Forward declarations of classes */

class XMPP__PT;

} /* end of namespace */

#ifndef XMPP__PortType_HH
#define XMPP__PortType_HH

namespace XMPP__PortType {

/* Class definitions */

class XMPP__PT : public XMPP__PT_PROVIDER {
enum msg_selection { MESSAGE_0, MESSAGE_1, MESSAGE_2, MESSAGE_3, MESSAGE_4, MESSAGE_5 };
struct msg_queue_item : public msg_queue_item_base {
msg_selection item_selection;
union {
XMPP__Types::XMPP__Connect__result *message_0;
XMPP__Types::XMPP__Connected *message_1;
XMPP__Types::XMPP__Listen__result *message_2;
XMPP__Types::XMPP__Send__error *message_3;
http__etherx__jabber__org__streams::Stream *message_4;
XMPP__Types::XMPP__Close *message_5;
};
component sender_component;
};

void remove_msg_queue_head();
protected:
void clear_queue();
public:
XMPP__PT(const char *par_port_name = NULL);
~XMPP__PT();
void send(const XMPP__Types::XMPP__Connect& send_par, const COMPONENT& destination_component);
void send(const XMPP__Types::XMPP__Connect& send_par);
void send(const XMPP__Types::XMPP__Connect_template& send_par, const COMPONENT& destination_component);
void send(const XMPP__Types::XMPP__Connect_template& send_par);
void send(const XMPP__Types::XMPP__Listen& send_par, const COMPONENT& destination_component);
void send(const XMPP__Types::XMPP__Listen& send_par);
void send(const XMPP__Types::XMPP__Listen_template& send_par, const COMPONENT& destination_component);
void send(const XMPP__Types::XMPP__Listen_template& send_par);
void send(const XMPP__Types::XMPP__Shutdown& send_par, const COMPONENT& destination_component);
void send(const XMPP__Types::XMPP__Shutdown& send_par);
void send(const XMPP__Types::XMPP__Shutdown_template& send_par, const COMPONENT& destination_component);
void send(const XMPP__Types::XMPP__Shutdown_template& send_par);
void send(const CHARSTRING& send_par, const COMPONENT& destination_component);
void send(const CHARSTRING& send_par);
void send(const CHARSTRING_template& send_par, const COMPONENT& destination_component);
void send(const CHARSTRING_template& send_par);
void send(const http__etherx__jabber__org__streams::Stream& send_par, const COMPONENT& destination_component);
void send(const http__etherx__jabber__org__streams::Stream& send_par);
void send(const http__etherx__jabber__org__streams::Stream_template& send_par, const COMPONENT& destination_component);
void send(const http__etherx__jabber__org__streams::Stream_template& send_par);
void send(const XMPP__Types::XMPP__Close& send_par, const COMPONENT& destination_component);
void send(const XMPP__Types::XMPP__Close& send_par);
void send(const XMPP__Types::XMPP__Close_template& send_par, const COMPONENT& destination_component);
void send(const XMPP__Types::XMPP__Close_template& send_par);
alt_status receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status receive(const XMPP__Types::XMPP__Connect__result_template& value_template, XMPP__Types::XMPP__Connect__result *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const XMPP__Types::XMPP__Connect__result_template& value_template, XMPP__Types::XMPP__Connect__result *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const XMPP__Types::XMPP__Connect__result_template& value_template, XMPP__Types::XMPP__Connect__result *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status receive(const XMPP__Types::XMPP__Connected_template& value_template, XMPP__Types::XMPP__Connected *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const XMPP__Types::XMPP__Connected_template& value_template, XMPP__Types::XMPP__Connected *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const XMPP__Types::XMPP__Connected_template& value_template, XMPP__Types::XMPP__Connected *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status receive(const XMPP__Types::XMPP__Listen__result_template& value_template, XMPP__Types::XMPP__Listen__result *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const XMPP__Types::XMPP__Listen__result_template& value_template, XMPP__Types::XMPP__Listen__result *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const XMPP__Types::XMPP__Listen__result_template& value_template, XMPP__Types::XMPP__Listen__result *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status receive(const XMPP__Types::XMPP__Send__error_template& value_template, XMPP__Types::XMPP__Send__error *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const XMPP__Types::XMPP__Send__error_template& value_template, XMPP__Types::XMPP__Send__error *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const XMPP__Types::XMPP__Send__error_template& value_template, XMPP__Types::XMPP__Send__error *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status receive(const http__etherx__jabber__org__streams::Stream_template& value_template, http__etherx__jabber__org__streams::Stream *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const http__etherx__jabber__org__streams::Stream_template& value_template, http__etherx__jabber__org__streams::Stream *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const http__etherx__jabber__org__streams::Stream_template& value_template, http__etherx__jabber__org__streams::Stream *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status receive(const XMPP__Types::XMPP__Close_template& value_template, XMPP__Types::XMPP__Close *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const XMPP__Types::XMPP__Close_template& value_template, XMPP__Types::XMPP__Close *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const XMPP__Types::XMPP__Close_template& value_template, XMPP__Types::XMPP__Close *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
private:
void incoming_message(const XMPP__Types::XMPP__Connect__result& incoming_par, component sender_component);
void incoming_message(const XMPP__Types::XMPP__Connected& incoming_par, component sender_component);
void incoming_message(const XMPP__Types::XMPP__Listen__result& incoming_par, component sender_component);
void incoming_message(const XMPP__Types::XMPP__Send__error& incoming_par, component sender_component);
void incoming_message(const http__etherx__jabber__org__streams::Stream& incoming_par, component sender_component);
void incoming_message(const XMPP__Types::XMPP__Close& incoming_par, component sender_component);
protected:
void incoming_message(const XMPP__Types::XMPP__Connect__result& incoming_par);
void incoming_message(const XMPP__Types::XMPP__Connected& incoming_par);
void incoming_message(const XMPP__Types::XMPP__Listen__result& incoming_par);
void incoming_message(const XMPP__Types::XMPP__Send__error& incoming_par);
void incoming_message(const http__etherx__jabber__org__streams::Stream& incoming_par);
void incoming_message(const XMPP__Types::XMPP__Close& incoming_par);
boolean process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING& slider);
};


/* Global variable declarations */

extern TTCN_Module module_object;

} /* end of namespace */

#endif
