// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for user (user@user-multicom) on Fri Sep 25 13:42:36 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "IP_Types.hh"

namespace IP__Types {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const unsigned char bs_0_bits[] = { 1 };
static const BITSTRING bs_0(1, bs_0_bits);
static const unsigned char module_checksum[] = { 0x1b, 0xb5, 0x12, 0xbf, 0xc5, 0xba, 0x47, 0x5e, 0x7a, 0x40, 0x51, 0xdb, 0x7d, 0xc2, 0x6c, 0xcf };

/* Global variable definitions */

const TTCN_RAWdescriptor_t BIT7__BO__LAST_raw_ = {7,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       BIT7__BO__LAST_xer_ = { {"BIT7_BO_LAST>\n", "BIT7_BO_LAST>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BIT7__BO__LAST_descr_ = { "@IP_Types.BIT7_BO_LAST", &BITSTRING_ber_, &BIT7__BO__LAST_raw_, NULL, &BIT7__BO__LAST_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static INTEGER const_c__ip__proto__ipv4;
const INTEGER& c__ip__proto__ipv4 = const_c__ip__proto__ipv4;
static INTEGER const_c__ip__proto__ipv6;
const INTEGER& c__ip__proto__ipv6 = const_c__ip__proto__ipv6;
static INTEGER const_c__ip__proto__gre2;
const INTEGER& c__ip__proto__gre2 = const_c__ip__proto__gre2;
static INTEGER const_c__ip__proto__esp;
const INTEGER& c__ip__proto__esp = const_c__ip__proto__esp;
static INTEGER const_c__ip__proto__ah;
const INTEGER& c__ip__proto__ah = const_c__ip__proto__ah;
static INTEGER const_c__ip__proto__mine;
const INTEGER& c__ip__proto__mine = const_c__ip__proto__mine;
static INTEGER const_c__ip__proto__ipv6__hopopt;
const INTEGER& c__ip__proto__ipv6__hopopt = const_c__ip__proto__ipv6__hopopt;
static INTEGER const_c__ip__proto__ipv6__route;
const INTEGER& c__ip__proto__ipv6__route = const_c__ip__proto__ipv6__route;
static INTEGER const_c__ip__proto__ipv6__frag;
const INTEGER& c__ip__proto__ipv6__frag = const_c__ip__proto__ipv6__frag;
static INTEGER const_c__ip__proto__ipv6__dest;
const INTEGER& c__ip__proto__ipv6__dest = const_c__ip__proto__ipv6__dest;
static INTEGER const_c__ip__proto__ipv6__nonext;
const INTEGER& c__ip__proto__ipv6__nonext = const_c__ip__proto__ipv6__nonext;
static INTEGER const_c__ip__proto__udp;
const INTEGER& c__ip__proto__udp = const_c__ip__proto__udp;
static INTEGER const_c__ip__proto__tcp;
const INTEGER& c__ip__proto__tcp = const_c__ip__proto__tcp;
static INTEGER const_c__ip__proto__mobility;
const INTEGER& c__ip__proto__mobility = const_c__ip__proto__mobility;
static INTEGER const_c__ip__gre__proto__ipv4;
const INTEGER& c__ip__gre__proto__ipv4 = const_c__ip__gre__proto__ipv4;
static INTEGER const_c__ip__gre__proto__ipv6;
const INTEGER& c__ip__gre__proto__ipv6 = const_c__ip__gre__proto__ipv6;
static INTEGER const_c__ip__gre__proto__transparentEthernetBridging;
const INTEGER& c__ip__gre__proto__transparentEthernetBridging = const_c__ip__gre__proto__transparentEthernetBridging;
static INTEGER const_c__ip__version__ipv4;
const INTEGER& c__ip__version__ipv4 = const_c__ip__version__ipv4;
static INTEGER const_c__ip__version__ipv6;
const INTEGER& c__ip__version__ipv6 = const_c__ip__version__ipv6;
static INTEGER const_c__ip__proto__icmp;
const INTEGER& c__ip__proto__icmp = const_c__ip__proto__icmp;
static INTEGER const_c__ip__proto__icmpv6;
const INTEGER& c__ip__proto__icmpv6 = const_c__ip__proto__icmpv6;
const TTCN_RAWdescriptor_t IP__MINE__header_protocol_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IP__MINE__header_protocol_xer_ = { {"protocol>\n", "protocol>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__MINE__header_protocol_descr_ = { "@IP_Types.IP_MINE_header.protocol", &INTEGER_ber_, &IP__MINE__header_protocol_raw_, &INTEGER_text_, &IP__MINE__header_protocol_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__MINE__header_s__bit_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,1};
const XERdescriptor_t       IP__MINE__header_s__bit_xer_ = { {"s_bit>\n", "s_bit>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__MINE__header_s__bit_descr_ = { "@IP_Types.IP_MINE_header.s_bit", &BITSTRING_ber_, &IP__MINE__header_s__bit_raw_, NULL, &IP__MINE__header_s__bit_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__MINE__header_reserved_raw_ = {7,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IP__MINE__header_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__MINE__header_reserved_descr_ = { "@IP_Types.IP_MINE_header.reserved", &BITSTRING_ber_, &IP__MINE__header_reserved_raw_, NULL, &IP__MINE__header_reserved_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__MINE__header_cksum_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IP__MINE__header_cksum_xer_ = { {"cksum>\n", "cksum>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__MINE__header_cksum_descr_ = { "@IP_Types.IP_MINE_header.cksum", &INTEGER_ber_, &IP__MINE__header_cksum_raw_, &INTEGER_text_, &IP__MINE__header_cksum_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__MINE__header_dstaddr_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,4};
const XERdescriptor_t       IP__MINE__header_dstaddr_xer_ = { {"dstaddr>\n", "dstaddr>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__MINE__header_dstaddr_descr_ = { "@IP_Types.IP_MINE_header.dstaddr", &OCTETSTRING_ber_, &IP__MINE__header_dstaddr_raw_, &OCTETSTRING_text_, &IP__MINE__header_dstaddr_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__MINE__header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IP__MINE__header
const TTCN_JSONdescriptor_t IP__MINE__header_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IP__MINE__header_descr_ = { "@IP_Types.IP_MINE_header", NULL, &IP__MINE__header_raw_, NULL, NULL, &IP__MINE__header_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__MINE__header_srcaddr_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,4};
const XERdescriptor_t       IP__MINE__header_srcaddr_xer_ = { {"srcaddr>\n", "srcaddr>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__MINE__header_srcaddr_descr_ = { "@IP_Types.IP_MINE_header.srcaddr", &OCTETSTRING_ber_, &IP__MINE__header_srcaddr_raw_, &OCTETSTRING_text_, &IP__MINE__header_srcaddr_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IP__AH__header_next__hdr_xer_ = { {"next_hdr>\n", "next_hdr>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__AH__header_next__hdr_descr_ = { "@IP_Types.IP_AH_header.next_hdr", &INTEGER_ber_, &General__Types::LIN1_raw_, &INTEGER_text_, &IP__AH__header_next__hdr_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__AH__header_payload__len_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,32,0,NULL,-1};
const XERdescriptor_t       IP__AH__header_payload__len_xer_ = { {"payload_len>\n", "payload_len>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__AH__header_payload__len_descr_ = { "@IP_Types.IP_AH_header.payload_len", &INTEGER_ber_, &IP__AH__header_payload__len_raw_, &INTEGER_text_, &IP__AH__header_payload__len_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IP__AH__header_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__AH__header_reserved_descr_ = { "@IP_Types.IP_AH_header.reserved", &OCTETSTRING_ber_, &General__Types::OCT2_raw_, &OCTETSTRING_text_, &IP__AH__header_reserved_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IP__AH__header_spi_xer_ = { {"spi>\n", "spi>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__AH__header_spi_descr_ = { "@IP_Types.IP_AH_header.spi", &INTEGER_ber_, &General__Types::LIN4__BO__LAST_raw_, &INTEGER_text_, &IP__AH__header_spi_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IP__AH__header_sn_xer_ = { {"sn>\n", "sn>\n"}, {4, 4}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__AH__header_sn_descr_ = { "@IP_Types.IP_AH_header.sn", &BITSTRING_ber_, &General__Types::BIT32__BO__LAST_raw_, NULL, &IP__AH__header_sn_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IP__AH__header_auth__data_xer_ = { {"auth_data>\n", "auth_data>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__AH__header_auth__data_descr_ = { "@IP_Types.IP_AH_header.auth_data", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &IP__AH__header_auth__data_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__AH__header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IP__AH__header
const TTCN_JSONdescriptor_t IP__AH__header_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IP__AH__header_descr_ = { "@IP_Types.IP_AH_header", NULL, &IP__AH__header_raw_, NULL, NULL, &IP__AH__header_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IP__ESP__header__part_spi_xer_ = { {"spi>\n", "spi>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__ESP__header__part_spi_descr_ = { "@IP_Types.IP_ESP_header_part.spi", &INTEGER_ber_, &General__Types::LIN4__BO__LAST_raw_, &INTEGER_text_, &IP__ESP__header__part_spi_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IP__ESP__header__part_sn_xer_ = { {"sn>\n", "sn>\n"}, {4, 4}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__ESP__header__part_sn_descr_ = { "@IP_Types.IP_ESP_header_part.sn", &BITSTRING_ber_, &General__Types::BIT32__BO__LAST_raw_, NULL, &IP__ESP__header__part_sn_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__ESP__header__part_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IP__ESP__header__part
const TTCN_JSONdescriptor_t IP__ESP__header__part_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IP__ESP__header__part_descr_ = { "@IP_Types.IP_ESP_header_part", NULL, &IP__ESP__header__part_raw_, NULL, NULL, &IP__ESP__header__part_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__ESP__NULL__tail_pad__length_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IP__ESP__NULL__tail_pad__length_xer_ = { {"pad_length>\n", "pad_length>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__ESP__NULL__tail_pad__length_descr_ = { "@IP_Types.IP_ESP_NULL_tail.pad_length", &INTEGER_ber_, &IP__ESP__NULL__tail_pad__length_raw_, &INTEGER_text_, &IP__ESP__NULL__tail_pad__length_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IP__ESP__NULL__tail_next__hdr_xer_ = { {"next_hdr>\n", "next_hdr>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__ESP__NULL__tail_next__hdr_descr_ = { "@IP_Types.IP_ESP_NULL_tail.next_hdr", &INTEGER_ber_, &General__Types::LIN1_raw_, &INTEGER_text_, &IP__ESP__NULL__tail_next__hdr_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IP__ESP__NULL__tail_auth__data_xer_ = { {"auth_data>\n", "auth_data>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__ESP__NULL__tail_auth__data_descr_ = { "@IP_Types.IP_ESP_NULL_tail.auth_data", &OCTETSTRING_ber_, &General__Types::OCT12n_raw_, &OCTETSTRING_text_, &IP__ESP__NULL__tail_auth__data_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__ESP__NULL__tail_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IP__ESP__NULL__tail
const TTCN_JSONdescriptor_t IP__ESP__NULL__tail_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IP__ESP__NULL__tail_descr_ = { "@IP_Types.IP_ESP_NULL_tail", NULL, &IP__ESP__NULL__tail_raw_, NULL, NULL, &IP__ESP__NULL__tail_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IP__ESP__NULL__tail_padding_xer_ = { {"padding>\n", "padding>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__ESP__NULL__tail_padding_descr_ = { "@IP_Types.IP_ESP_NULL_tail.padding", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &IP__ESP__NULL__tail_padding_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__ESP__tail__part_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IP__ESP__tail__part
const TTCN_JSONdescriptor_t IP__ESP__tail__part_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IP__ESP__tail__part_descr_ = { "@IP_Types.IP_ESP_tail_part", NULL, &IP__ESP__tail__part_raw_, NULL, NULL, &IP__ESP__tail__part_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IP__ESP__tail__part_raw__data_xer_ = { {"raw_data>\n", "raw_data>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__ESP__tail__part_raw__data_descr_ = { "@IP_Types.IP_ESP_tail_part.raw_data", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &IP__ESP__tail__part_raw__data_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__ESP__header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IP__ESP__header
const TTCN_JSONdescriptor_t IP__ESP__header_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IP__ESP__header_descr_ = { "@IP_Types.IP_ESP_header", NULL, &IP__ESP__header_raw_, NULL, NULL, &IP__ESP__header_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__GRE2__header_c_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,1};
const XERdescriptor_t       IP__GRE2__header_c_xer_ = { {"c>\n", "c>\n"}, {3, 3}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__GRE2__header_c_descr_ = { "@IP_Types.IP_GRE2_header.c", &BITSTRING_ber_, &IP__GRE2__header_c_raw_, NULL, &IP__GRE2__header_c_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__GRE2__header_reserved__bit_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,1};
const XERdescriptor_t       IP__GRE2__header_reserved__bit_xer_ = { {"reserved_bit>\n", "reserved_bit>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__GRE2__header_reserved__bit_descr_ = { "@IP_Types.IP_GRE2_header.reserved_bit", &BITSTRING_ber_, &IP__GRE2__header_reserved__bit_raw_, NULL, &IP__GRE2__header_reserved__bit_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__GRE2__header_k_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,1};
const XERdescriptor_t       IP__GRE2__header_k_xer_ = { {"k>\n", "k>\n"}, {3, 3}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__GRE2__header_k_descr_ = { "@IP_Types.IP_GRE2_header.k", &BITSTRING_ber_, &IP__GRE2__header_k_raw_, NULL, &IP__GRE2__header_k_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__GRE2__header_s_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,1};
const XERdescriptor_t       IP__GRE2__header_s_xer_ = { {"s>\n", "s>\n"}, {3, 3}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__GRE2__header_s_descr_ = { "@IP_Types.IP_GRE2_header.s", &BITSTRING_ber_, &IP__GRE2__header_s_raw_, NULL, &IP__GRE2__header_s_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__GRE2__header_reserved0_raw_ = {9,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,9};
const XERdescriptor_t       IP__GRE2__header_reserved0_xer_ = { {"reserved0>\n", "reserved0>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__GRE2__header_reserved0_descr_ = { "@IP_Types.IP_GRE2_header.reserved0", &BITSTRING_ber_, &IP__GRE2__header_reserved0_raw_, NULL, &IP__GRE2__header_reserved0_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__GRE2__header_version_raw_ = {3,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,3};
const XERdescriptor_t       IP__GRE2__header_version_xer_ = { {"version>\n", "version>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__GRE2__header_version_descr_ = { "@IP_Types.IP_GRE2_header.version", &BITSTRING_ber_, &IP__GRE2__header_version_raw_, NULL, &IP__GRE2__header_version_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__GRE2__header_protocol__type_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IP__GRE2__header_protocol__type_xer_ = { {"protocol_type>\n", "protocol_type>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__GRE2__header_protocol__type_descr_ = { "@IP_Types.IP_GRE2_header.protocol_type", &INTEGER_ber_, &IP__GRE2__header_protocol__type_raw_, &INTEGER_text_, &IP__GRE2__header_protocol__type_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__GRE2__header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IP__GRE2__header
const TTCN_JSONdescriptor_t IP__GRE2__header_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IP__GRE2__header_descr_ = { "@IP_Types.IP_GRE2_header", NULL, &IP__GRE2__header_raw_, NULL, NULL, &IP__GRE2__header_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__GRE2__header_checksum_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IP__GRE2__header_checksum_xer_ = { {"checksum>\n", "checksum>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__GRE2__header_checksum_descr_ = { "@IP_Types.IP_GRE2_header.checksum", &INTEGER_ber_, &IP__GRE2__header_checksum_raw_, &INTEGER_text_, &IP__GRE2__header_checksum_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__GRE2__header_reserved1_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IP__GRE2__header_reserved1_xer_ = { {"reserved1>\n", "reserved1>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__GRE2__header_reserved1_descr_ = { "@IP_Types.IP_GRE2_header.reserved1", &INTEGER_ber_, &IP__GRE2__header_reserved1_raw_, &INTEGER_text_, &IP__GRE2__header_reserved1_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__GRE2__header_key_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IP__GRE2__header_key_xer_ = { {"key>\n", "key>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__GRE2__header_key_descr_ = { "@IP_Types.IP_GRE2_header.key", &INTEGER_ber_, &IP__GRE2__header_key_raw_, &INTEGER_text_, &IP__GRE2__header_key_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IP__GRE2__header_sn_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IP__GRE2__header_sn_xer_ = { {"sn>\n", "sn>\n"}, {4, 4}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IP__GRE2__header_sn_descr_ = { "@IP_Types.IP_GRE2_header.sn", &BITSTRING_ber_, &IP__GRE2__header_sn_raw_, NULL, &IP__GRE2__header_sn_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__extension__headers_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv4__extension__headers
const TTCN_JSONdescriptor_t IPv4__extension__headers_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IPv4__extension__headers_descr_ = { "@IP_Types.IPv4_extension_headers", NULL, &IPv4__extension__headers_raw_, NULL, NULL, &IPv4__extension__headers_json_, &IPv4__extension__header_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__extension__header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv4__extension__header
const TTCN_JSONdescriptor_t IPv4__extension__header_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IPv4__extension__header_descr_ = { "@IP_Types.IPv4_extension_header", NULL, &IPv4__extension__header_raw_, NULL, NULL, &IPv4__extension__header_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPv4__extension__header_raw__hdr_xer_ = { {"raw_hdr>\n", "raw_hdr>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__extension__header_raw__hdr_descr_ = { "@IP_Types.IPv4_extension_header.raw_hdr", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &IPv4__extension__header_raw__hdr_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPV4ADDR_xer_ = { {"IPV4ADDR>\n", "IPV4ADDR>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPV4ADDR_descr_ = { "@IP_Types.IPV4ADDR", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &IPV4ADDR_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_ver_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv4__header_ver_xer_ = { {"ver>\n", "ver>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_ver_descr_ = { "@IP_Types.IPv4_header.ver", &INTEGER_ber_, &IPv4__header_ver_raw_, &INTEGER_text_, &IPv4__header_ver_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_hlen_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv4__header_hlen_xer_ = { {"hlen>\n", "hlen>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_hlen_descr_ = { "@IP_Types.IPv4_header.hlen", &INTEGER_ber_, &IPv4__header_hlen_raw_, &INTEGER_text_, &IPv4__header_hlen_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_tos_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv4__header_tos_xer_ = { {"tos>\n", "tos>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_tos_descr_ = { "@IP_Types.IPv4_header.tos", &INTEGER_ber_, &IPv4__header_tos_raw_, &INTEGER_text_, &IPv4__header_tos_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_tlen_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv4__header_tlen_xer_ = { {"tlen>\n", "tlen>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_tlen_descr_ = { "@IP_Types.IPv4_header.tlen", &INTEGER_ber_, &IPv4__header_tlen_raw_, &INTEGER_text_, &IPv4__header_tlen_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_id_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv4__header_id_xer_ = { {"id>\n", "id>\n"}, {4, 4}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_id_descr_ = { "@IP_Types.IPv4_header.id", &INTEGER_ber_, &IPv4__header_id_raw_, &INTEGER_text_, &IPv4__header_id_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_res_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,1};
const XERdescriptor_t       IPv4__header_res_xer_ = { {"res>\n", "res>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_res_descr_ = { "@IP_Types.IPv4_header.res", &BITSTRING_ber_, &IPv4__header_res_raw_, NULL, &IPv4__header_res_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_dfrag_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,1};
const XERdescriptor_t       IPv4__header_dfrag_xer_ = { {"dfrag>\n", "dfrag>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_dfrag_descr_ = { "@IP_Types.IPv4_header.dfrag", &BITSTRING_ber_, &IPv4__header_dfrag_raw_, NULL, &IPv4__header_dfrag_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_mfrag_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,1};
const XERdescriptor_t       IPv4__header_mfrag_xer_ = { {"mfrag>\n", "mfrag>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_mfrag_descr_ = { "@IP_Types.IPv4_header.mfrag", &BITSTRING_ber_, &IPv4__header_mfrag_raw_, NULL, &IPv4__header_mfrag_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_foffset_raw_ = {13,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv4__header_foffset_xer_ = { {"foffset>\n", "foffset>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_foffset_descr_ = { "@IP_Types.IPv4_header.foffset", &INTEGER_ber_, &IPv4__header_foffset_raw_, &INTEGER_text_, &IPv4__header_foffset_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_ttl_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv4__header_ttl_xer_ = { {"ttl>\n", "ttl>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_ttl_descr_ = { "@IP_Types.IPv4_header.ttl", &INTEGER_ber_, &IPv4__header_ttl_raw_, &INTEGER_text_, &IPv4__header_ttl_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_proto_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv4__header_proto_xer_ = { {"proto>\n", "proto>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_proto_descr_ = { "@IP_Types.IPv4_header.proto", &INTEGER_ber_, &IPv4__header_proto_raw_, &INTEGER_text_, &IPv4__header_proto_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_cksum_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv4__header_cksum_xer_ = { {"cksum>\n", "cksum>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_cksum_descr_ = { "@IP_Types.IPv4_header.cksum", &INTEGER_ber_, &IPv4__header_cksum_raw_, &INTEGER_text_, &IPv4__header_cksum_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_srcaddr_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,4};
const XERdescriptor_t       IPv4__header_srcaddr_xer_ = { {"srcaddr>\n", "srcaddr>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_srcaddr_descr_ = { "@IP_Types.IPv4_header.srcaddr", &OCTETSTRING_ber_, &IPv4__header_srcaddr_raw_, &OCTETSTRING_text_, &IPv4__header_srcaddr_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_dstaddr_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,4};
const XERdescriptor_t       IPv4__header_dstaddr_xer_ = { {"dstaddr>\n", "dstaddr>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__header_dstaddr_descr_ = { "@IP_Types.IPv4_header.dstaddr", &OCTETSTRING_ber_, &IPv4__header_dstaddr_raw_, &OCTETSTRING_text_, &IPv4__header_dstaddr_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv4__header
const TTCN_JSONdescriptor_t IPv4__header_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IPv4__header_descr_ = { "@IP_Types.IPv4_header", NULL, &IPv4__header_raw_, NULL, NULL, &IPv4__header_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__packet_header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv4__packet_header
const TTCN_Typedescriptor_t IPv4__packet_header_descr_ = { "@IP_Types.IPv4_packet.header", NULL, &IPv4__packet_header_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__packet_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv4__packet
const TTCN_JSONdescriptor_t IPv4__packet_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IPv4__packet_descr_ = { "@IP_Types.IPv4_packet", NULL, &IPv4__packet_raw_, NULL, NULL, &IPv4__packet_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__packet_ext__headers_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv4__packet_ext__headers
const TTCN_Typedescriptor_t IPv4__packet_ext__headers_descr_ = { "@IP_Types.IPv4_packet.ext_headers", NULL, &IPv4__packet_ext__headers_raw_, NULL, NULL, NULL, &IPv4__extension__header_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv4__packet_payload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv4__packet_payload_xer_ = { {"payload>\n", "payload>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv4__packet_payload_descr_ = { "@IP_Types.IPv4_packet.payload", &OCTETSTRING_ber_, &IPv4__packet_payload_raw_, &OCTETSTRING_text_, &IPv4__packet_payload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__IPv4_cksum__calc_xer_ = { {"cksum_calc>\n", "cksum_calc>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ASP__IPv4_cksum__calc_descr_ = { "@IP_Types.ASP_IPv4.cksum_calc", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &ASP__IPv4_cksum__calc_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__IPv4
const TTCN_Typedescriptor_t ASP__IPv4_descr_ = { "@IP_Types.ASP_IPv4", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPv6__Fragment__header_next__hdr_xer_ = { {"next_hdr>\n", "next_hdr>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__Fragment__header_next__hdr_descr_ = { "@IP_Types.IPv6_Fragment_header.next_hdr", &INTEGER_ber_, &General__Types::LIN1_raw_, &INTEGER_text_, &IPv6__Fragment__header_next__hdr_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPv6__Fragment__header_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__Fragment__header_reserved_descr_ = { "@IP_Types.IPv6_Fragment_header.reserved", &OCTETSTRING_ber_, &General__Types::OCT1_raw_, &OCTETSTRING_text_, &IPv6__Fragment__header_reserved_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__Fragment__header_fragmentOffset_raw_ = {13,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv6__Fragment__header_fragmentOffset_xer_ = { {"fragmentOffset>\n", "fragmentOffset>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__Fragment__header_fragmentOffset_descr_ = { "@IP_Types.IPv6_Fragment_header.fragmentOffset", &INTEGER_ber_, &IPv6__Fragment__header_fragmentOffset_raw_, &INTEGER_text_, &IPv6__Fragment__header_fragmentOffset_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__Fragment__header_reserved2_raw_ = {2,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,2};
const XERdescriptor_t       IPv6__Fragment__header_reserved2_xer_ = { {"reserved2>\n", "reserved2>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__Fragment__header_reserved2_descr_ = { "@IP_Types.IPv6_Fragment_header.reserved2", &BITSTRING_ber_, &IPv6__Fragment__header_reserved2_raw_, NULL, &IPv6__Fragment__header_reserved2_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__Fragment__header_mFlag_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,1};
const XERdescriptor_t       IPv6__Fragment__header_mFlag_xer_ = { {"mFlag>\n", "mFlag>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__Fragment__header_mFlag_descr_ = { "@IP_Types.IPv6_Fragment_header.mFlag", &BITSTRING_ber_, &IPv6__Fragment__header_mFlag_raw_, NULL, &IPv6__Fragment__header_mFlag_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPv6__Fragment__header_identification_xer_ = { {"identification>\n", "identification>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__Fragment__header_identification_descr_ = { "@IP_Types.IPv6_Fragment_header.identification", &OCTETSTRING_ber_, &General__Types::OCT4_raw_, &OCTETSTRING_text_, &IPv6__Fragment__header_identification_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__Fragment__header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv6__Fragment__header
const TTCN_JSONdescriptor_t IPv6__Fragment__header_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IPv6__Fragment__header_descr_ = { "@IP_Types.IPv6_Fragment_header", NULL, &IPv6__Fragment__header_raw_, NULL, NULL, &IPv6__Fragment__header_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__extension__headers_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv6__extension__headers
const TTCN_JSONdescriptor_t IPv6__extension__headers_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IPv6__extension__headers_descr_ = { "@IP_Types.IPv6_extension_headers", NULL, &IPv6__extension__headers_raw_, NULL, NULL, &IPv6__extension__headers_json_, &IPv6__extension__header_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__extension__header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv6__extension__header
const TTCN_JSONdescriptor_t IPv6__extension__header_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IPv6__extension__header_descr_ = { "@IP_Types.IPv6_extension_header", NULL, &IPv6__extension__header_raw_, NULL, NULL, &IPv6__extension__header_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPv6__general__IPv6__extension__header_next__header_xer_ = { {"next_header>\n", "next_header>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__general__IPv6__extension__header_next__header_descr_ = { "@IP_Types.IPv6_general_IPv6_extension_header.next_header", &INTEGER_ber_, &General__Types::LIN1_raw_, &INTEGER_text_, &IPv6__general__IPv6__extension__header_next__header_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__general__IPv6__extension__header_exthdr__length_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv6__general__IPv6__extension__header_exthdr__length_xer_ = { {"exthdr_length>\n", "exthdr_length>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__general__IPv6__extension__header_exthdr__length_descr_ = { "@IP_Types.IPv6_general_IPv6_extension_header.exthdr_length", &INTEGER_ber_, &IPv6__general__IPv6__extension__header_exthdr__length_raw_, &INTEGER_text_, &IPv6__general__IPv6__extension__header_exthdr__length_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPv6__general__IPv6__extension__header_data_xer_ = { {"data>\n", "data>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__general__IPv6__extension__header_data_descr_ = { "@IP_Types.IPv6_general_IPv6_extension_header.data", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &IPv6__general__IPv6__extension__header_data_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__general__IPv6__extension__header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv6__general__IPv6__extension__header
const TTCN_JSONdescriptor_t IPv6__general__IPv6__extension__header_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IPv6__general__IPv6__extension__header_descr_ = { "@IP_Types.IPv6_general_IPv6_extension_header", NULL, &IPv6__general__IPv6__extension__header_raw_, NULL, NULL, &IPv6__general__IPv6__extension__header_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPv6__extension__header_raw__hdr_xer_ = { {"raw_hdr>\n", "raw_hdr>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__extension__header_raw__hdr_descr_ = { "@IP_Types.IPv6_extension_header.raw_hdr", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &IPv6__extension__header_raw__hdr_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__header_ver_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv6__header_ver_xer_ = { {"ver>\n", "ver>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__header_ver_descr_ = { "@IP_Types.IPv6_header.ver", &INTEGER_ber_, &IPv6__header_ver_raw_, &INTEGER_text_, &IPv6__header_ver_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__header_trclass_raw_ = {8,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv6__header_trclass_xer_ = { {"trclass>\n", "trclass>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__header_trclass_descr_ = { "@IP_Types.IPv6_header.trclass", &INTEGER_ber_, &IPv6__header_trclass_raw_, &INTEGER_text_, &IPv6__header_trclass_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__header_flabel_raw_ = {20,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv6__header_flabel_xer_ = { {"flabel>\n", "flabel>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__header_flabel_descr_ = { "@IP_Types.IPv6_header.flabel", &INTEGER_ber_, &IPv6__header_flabel_raw_, &INTEGER_text_, &IPv6__header_flabel_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__header_plen_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv6__header_plen_xer_ = { {"plen>\n", "plen>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__header_plen_descr_ = { "@IP_Types.IPv6_header.plen", &INTEGER_ber_, &IPv6__header_plen_raw_, &INTEGER_text_, &IPv6__header_plen_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__header_nexthead_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv6__header_nexthead_xer_ = { {"nexthead>\n", "nexthead>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__header_nexthead_descr_ = { "@IP_Types.IPv6_header.nexthead", &INTEGER_ber_, &IPv6__header_nexthead_raw_, &INTEGER_text_, &IPv6__header_nexthead_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__header_hlim_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv6__header_hlim_xer_ = { {"hlim>\n", "hlim>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__header_hlim_descr_ = { "@IP_Types.IPv6_header.hlim", &INTEGER_ber_, &IPv6__header_hlim_raw_, &INTEGER_text_, &IPv6__header_hlim_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__header_srcaddr_raw_ = {128,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,16};
const XERdescriptor_t       IPv6__header_srcaddr_xer_ = { {"srcaddr>\n", "srcaddr>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__header_srcaddr_descr_ = { "@IP_Types.IPv6_header.srcaddr", &OCTETSTRING_ber_, &IPv6__header_srcaddr_raw_, &OCTETSTRING_text_, &IPv6__header_srcaddr_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__header_dstaddr_raw_ = {128,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,16};
const XERdescriptor_t       IPv6__header_dstaddr_xer_ = { {"dstaddr>\n", "dstaddr>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__header_dstaddr_descr_ = { "@IP_Types.IPv6_header.dstaddr", &OCTETSTRING_ber_, &IPv6__header_dstaddr_raw_, &OCTETSTRING_text_, &IPv6__header_dstaddr_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv6__header
const TTCN_JSONdescriptor_t IPv6__header_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IPv6__header_descr_ = { "@IP_Types.IPv6_header", NULL, &IPv6__header_raw_, NULL, NULL, &IPv6__header_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__packet_header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv6__packet_header
const TTCN_Typedescriptor_t IPv6__packet_header_descr_ = { "@IP_Types.IPv6_packet.header", NULL, &IPv6__packet_header_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__packet_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv6__packet
const TTCN_JSONdescriptor_t IPv6__packet_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t IPv6__packet_descr_ = { "@IP_Types.IPv6_packet", NULL, &IPv6__packet_raw_, NULL, NULL, &IPv6__packet_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__packet_ext__headers_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IPv6__packet_ext__headers
const TTCN_Typedescriptor_t IPv6__packet_ext__headers_descr_ = { "@IP_Types.IPv6_packet.ext_headers", NULL, &IPv6__packet_ext__headers_raw_, NULL, NULL, NULL, &IPv6__extension__header_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IPv6__packet_payload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IPv6__packet_payload_xer_ = { {"payload>\n", "payload>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IPv6__packet_payload_descr_ = { "@IP_Types.IPv6_packet.payload", &OCTETSTRING_ber_, &IPv6__packet_payload_raw_, &OCTETSTRING_text_, &IPv6__packet_payload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 21;
static const namespace_t xml_namespaces[num_namespaces+1] = {
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { "", "" }
};

TTCN_Module module_object("IP_Types", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 21LU, xml_namespaces, post_init_module, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_3,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

IP__MINE__header::IP__MINE__header()
{
  bound_flag = FALSE;
}

IP__MINE__header::IP__MINE__header(const INTEGER& par_protocol,
    const BITSTRING& par_s__bit,
    const BITSTRING& par_reserved,
    const INTEGER& par_cksum,
    const OCTETSTRING& par_dstaddr,
    const OPTIONAL<OCTETSTRING>& par_srcaddr)
  :   field_protocol(par_protocol),
  field_s__bit(par_s__bit),
  field_reserved(par_reserved),
  field_cksum(par_cksum),
  field_dstaddr(par_dstaddr),
  field_srcaddr(par_srcaddr)
{
  bound_flag = TRUE;
}

IP__MINE__header::IP__MINE__header(const IP__MINE__header& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IP_MINE_header.");
bound_flag = TRUE;
if (other_value.protocol().is_bound()) field_protocol = other_value.protocol();
else field_protocol.clean_up();
if (other_value.s__bit().is_bound()) field_s__bit = other_value.s__bit();
else field_s__bit.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.cksum().is_bound()) field_cksum = other_value.cksum();
else field_cksum.clean_up();
if (other_value.dstaddr().is_bound()) field_dstaddr = other_value.dstaddr();
else field_dstaddr.clean_up();
if (other_value.srcaddr().is_bound()) field_srcaddr = other_value.srcaddr();
else field_srcaddr.clean_up();
}

void IP__MINE__header::clean_up()
{
field_protocol.clean_up();
field_s__bit.clean_up();
field_reserved.clean_up();
field_cksum.clean_up();
field_dstaddr.clean_up();
field_srcaddr.clean_up();
bound_flag = FALSE;
}

IP__MINE__header& IP__MINE__header::operator=(const IP__MINE__header& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.IP_MINE_header.");
  bound_flag = TRUE;
  if (other_value.protocol().is_bound()) field_protocol = other_value.protocol();
  else field_protocol.clean_up();
  if (other_value.s__bit().is_bound()) field_s__bit = other_value.s__bit();
  else field_s__bit.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.cksum().is_bound()) field_cksum = other_value.cksum();
  else field_cksum.clean_up();
  if (other_value.dstaddr().is_bound()) field_dstaddr = other_value.dstaddr();
  else field_dstaddr.clean_up();
  if (other_value.srcaddr().is_bound()) field_srcaddr = other_value.srcaddr();
  else field_srcaddr.clean_up();
}
return *this;
}

boolean IP__MINE__header::operator==(const IP__MINE__header& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_protocol==other_value.field_protocol
  && field_s__bit==other_value.field_s__bit
  && field_reserved==other_value.field_reserved
  && field_cksum==other_value.field_cksum
  && field_dstaddr==other_value.field_dstaddr
  && field_srcaddr==other_value.field_srcaddr;
}

boolean IP__MINE__header::is_bound() const
{
if (bound_flag) return TRUE;
if(field_protocol.is_bound()) return TRUE;
if(field_s__bit.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_cksum.is_bound()) return TRUE;
if(field_dstaddr.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_srcaddr.get_selection() || field_srcaddr.is_bound()) return TRUE;
return FALSE;
}
boolean IP__MINE__header::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_protocol.is_value()) return FALSE;
if(!field_s__bit.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_cksum.is_value()) return FALSE;
if(!field_dstaddr.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_srcaddr.get_selection() && !field_srcaddr.is_value()) return FALSE;
return TRUE;
}
int IP__MINE__header::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.IP_MINE_header");
  int ret_val = 5;
  if (field_srcaddr.ispresent()) ret_val++;
  return ret_val;
}

void IP__MINE__header::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ protocol := ");
field_protocol.log();
TTCN_Logger::log_event_str(", s_bit := ");
field_s__bit.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", cksum := ");
field_cksum.log();
TTCN_Logger::log_event_str(", dstaddr := ");
field_dstaddr.log();
TTCN_Logger::log_event_str(", srcaddr := ");
field_srcaddr.log();
TTCN_Logger::log_event_str(" }");
}

void IP__MINE__header::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.IP_MINE_header'");
    }
    if (strcmp("protocol", param_field) == 0) {
      protocol().set_param(param);
      return;
    } else if (strcmp("s_bit", param_field) == 0) {
      s__bit().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("cksum", param_field) == 0) {
      cksum().set_param(param);
      return;
    } else if (strcmp("dstaddr", param_field) == 0) {
      dstaddr().set_param(param);
      return;
    } else if (strcmp("srcaddr", param_field) == 0) {
      srcaddr().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.IP_MINE_header'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (6<param.get_size()) {
      param.error("record value of type @IP_Types.IP_MINE_header has 6 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protocol().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) s__bit().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) cksum().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) dstaddr().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) srcaddr().set_param(*param.get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protocol")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protocol().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "s_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          s__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cksum")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cksum().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dstaddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dstaddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcaddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcaddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IP_MINE_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.IP_MINE_header");
  }
}

void IP__MINE__header::set_implicit_omit()
{
if (protocol().is_bound()) protocol().set_implicit_omit();
if (s__bit().is_bound()) s__bit().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (cksum().is_bound()) cksum().set_implicit_omit();
if (dstaddr().is_bound()) dstaddr().set_implicit_omit();
if (!srcaddr().is_bound()) srcaddr() = OMIT_VALUE;
else srcaddr().set_implicit_omit();
}

void IP__MINE__header::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.IP_MINE_header.");
field_protocol.encode_text(text_buf);
field_s__bit.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_cksum.encode_text(text_buf);
field_dstaddr.encode_text(text_buf);
field_srcaddr.encode_text(text_buf);
}

void IP__MINE__header::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_protocol.decode_text(text_buf);
field_s__bit.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_cksum.decode_text(text_buf);
field_dstaddr.decode_text(text_buf);
field_srcaddr.decode_text(text_buf);
}

void IP__MINE__header::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IP__MINE__header::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IP__MINE__header::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_protocol.RAW_decode(IP__MINE__header_protocol_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_s__bit.RAW_decode(IP__MINE__header_s__bit_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(IP__MINE__header_reserved_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_cksum.RAW_decode(IP__MINE__header_cksum_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_dstaddr.RAW_decode(IP__MINE__header_dstaddr_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0 && field_s__bit ==  bs_0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_srcaddr().RAW_decode(IP__MINE__header_srcaddr_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_srcaddr = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_srcaddr=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IP__MINE__header::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 6;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(6);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, IP__MINE__header_protocol_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, IP__MINE__header_s__bit_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, IP__MINE__header_reserved_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, IP__MINE__header_cksum_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, IP__MINE__header_dstaddr_descr_.raw);
  if (field_srcaddr.ispresent()) {
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, IP__MINE__header_srcaddr_descr_.raw);
  }
  else myleaf.body.node.nodes[5] = NULL;
  encoded_length += field_protocol.RAW_encode(IP__MINE__header_protocol_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_s__bit.RAW_encode(IP__MINE__header_s__bit_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_reserved.RAW_encode(IP__MINE__header_reserved_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_cksum.RAW_encode(IP__MINE__header_cksum_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_dstaddr.RAW_encode(IP__MINE__header_dstaddr_descr_, *myleaf.body.node.nodes[4]);
  if (field_srcaddr.ispresent()) {
  encoded_length += field_srcaddr().RAW_encode(IP__MINE__header_srcaddr_descr_, *myleaf.body.node.nodes[5]);
  }
  if (field_srcaddr.ispresent() && (field_s__bit !=  bs_0)) {
  RAW_enc_tree* temp_leaf;
  {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level=myleaf.curr_pos.level+1;
  int new_pos[]={1};
  pr_pos.pos=init_new_tree_pos(myleaf.curr_pos,1,new_pos);
  temp_leaf = myleaf.get_node(pr_pos);
  if(temp_leaf != NULL){
   bs_0.RAW_encode(IP__MINE__header_s__bit_descr_,*temp_leaf);
  } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  }
  free_tree_pos(pr_pos.pos);
  }
  }
  return myleaf.length = encoded_length;
}

int IP__MINE__header::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IP_MINE_header.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protocol");
    enc_len += field_protocol.JSON_encode(IP__MINE__header_protocol_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "s_bit");
    enc_len += field_s__bit.JSON_encode(IP__MINE__header_s__bit_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(IP__MINE__header_reserved_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "cksum");
    enc_len += field_cksum.JSON_encode(IP__MINE__header_cksum_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dstaddr");
    enc_len += field_dstaddr.JSON_encode(IP__MINE__header_dstaddr_descr_, p_tok);
  }

  if (field_srcaddr.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "srcaddr");
    enc_len += field_srcaddr.JSON_encode(IP__MINE__header_srcaddr_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IP__MINE__header::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (8 == name_len && 0 == strncmp(fld_name, "protocol", name_len)) {
        int ret_val = field_protocol.JSON_decode(IP__MINE__header_protocol_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protocol");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (5 == name_len && 0 == strncmp(fld_name, "s_bit", name_len)) {
        int ret_val = field_s__bit.JSON_decode(IP__MINE__header_s__bit_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "s_bit");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
        int ret_val = field_reserved.JSON_decode(IP__MINE__header_reserved_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (5 == name_len && 0 == strncmp(fld_name, "cksum", name_len)) {
        int ret_val = field_cksum.JSON_decode(IP__MINE__header_cksum_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "cksum");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (7 == name_len && 0 == strncmp(fld_name, "dstaddr", name_len)) {
        int ret_val = field_dstaddr.JSON_decode(IP__MINE__header_dstaddr_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dstaddr");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (7 == name_len && 0 == strncmp(fld_name, "srcaddr", name_len)) {
        int ret_val = field_srcaddr.JSON_decode(IP__MINE__header_srcaddr_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "srcaddr");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_protocol.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "protocol");
    return JSON_ERROR_FATAL;
  }
  if (!field_s__bit.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "s_bit");
    return JSON_ERROR_FATAL;
  }
  if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
  if (!field_cksum.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "cksum");
    return JSON_ERROR_FATAL;
  }
  if (!field_dstaddr.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "dstaddr");
    return JSON_ERROR_FATAL;
  }
  if (!field_srcaddr.is_bound()) {
    field_srcaddr = OMIT_VALUE;
  }

  return dec_len;
}

struct IP__MINE__header_template::single_value_struct {
INTEGER_template field_protocol;
BITSTRING_template field_s__bit;
BITSTRING_template field_reserved;
INTEGER_template field_cksum;
OCTETSTRING_template field_dstaddr;
OCTETSTRING_template field_srcaddr;
};

void IP__MINE__header_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_protocol = ANY_VALUE;
single_value->field_s__bit = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_cksum = ANY_VALUE;
single_value->field_dstaddr = ANY_VALUE;
single_value->field_srcaddr = ANY_OR_OMIT;
}
}
}

void IP__MINE__header_template::copy_value(const IP__MINE__header& other_value)
{
single_value = new single_value_struct;
if (other_value.protocol().is_bound()) {
  single_value->field_protocol = other_value.protocol();
} else {
  single_value->field_protocol.clean_up();
}
if (other_value.s__bit().is_bound()) {
  single_value->field_s__bit = other_value.s__bit();
} else {
  single_value->field_s__bit.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.cksum().is_bound()) {
  single_value->field_cksum = other_value.cksum();
} else {
  single_value->field_cksum.clean_up();
}
if (other_value.dstaddr().is_bound()) {
  single_value->field_dstaddr = other_value.dstaddr();
} else {
  single_value->field_dstaddr.clean_up();
}
if (other_value.srcaddr().is_bound()) {
  if (other_value.srcaddr().ispresent()) single_value->field_srcaddr = other_value.srcaddr()();
  else single_value->field_srcaddr = OMIT_VALUE;
} else {
  single_value->field_srcaddr.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IP__MINE__header_template::copy_template(const IP__MINE__header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.protocol().get_selection()) {
single_value->field_protocol = other_value.protocol();
} else {
single_value->field_protocol.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.s__bit().get_selection()) {
single_value->field_s__bit = other_value.s__bit();
} else {
single_value->field_s__bit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cksum().get_selection()) {
single_value->field_cksum = other_value.cksum();
} else {
single_value->field_cksum.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dstaddr().get_selection()) {
single_value->field_dstaddr = other_value.dstaddr();
} else {
single_value->field_dstaddr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.srcaddr().get_selection()) {
single_value->field_srcaddr = other_value.srcaddr();
} else {
single_value->field_srcaddr.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IP__MINE__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IP_MINE_header.");
break;
}
set_selection(other_value);
}

IP__MINE__header_template::IP__MINE__header_template()
{
}

IP__MINE__header_template::IP__MINE__header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IP__MINE__header_template::IP__MINE__header_template(const IP__MINE__header& other_value)
{
copy_value(other_value);
}

IP__MINE__header_template::IP__MINE__header_template(const OPTIONAL<IP__MINE__header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__MINE__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IP_MINE_header from an unbound optional field.");
}
}

IP__MINE__header_template::IP__MINE__header_template(const IP__MINE__header_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IP__MINE__header_template::~IP__MINE__header_template()
{
clean_up();
}

IP__MINE__header_template& IP__MINE__header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IP__MINE__header_template& IP__MINE__header_template::operator=(const IP__MINE__header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IP__MINE__header_template& IP__MINE__header_template::operator=(const OPTIONAL<IP__MINE__header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__MINE__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IP_MINE_header.");
}
return *this;
}

IP__MINE__header_template& IP__MINE__header_template::operator=(const IP__MINE__header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IP__MINE__header_template::match(const IP__MINE__header& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.protocol().is_bound()) return FALSE;
if(!single_value->field_protocol.match(other_value.protocol()))return FALSE;
if(!other_value.s__bit().is_bound()) return FALSE;
if(!single_value->field_s__bit.match(other_value.s__bit()))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved()))return FALSE;
if(!other_value.cksum().is_bound()) return FALSE;
if(!single_value->field_cksum.match(other_value.cksum()))return FALSE;
if(!other_value.dstaddr().is_bound()) return FALSE;
if(!single_value->field_dstaddr.match(other_value.dstaddr()))return FALSE;
if(!other_value.srcaddr().is_bound()) return FALSE;
if((other_value.srcaddr().ispresent() ? !single_value->field_srcaddr.match((const OCTETSTRING&)other_value.srcaddr()) : !single_value->field_srcaddr.match_omit()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.IP_MINE_header.");
}
return FALSE;
}

boolean IP__MINE__header_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_protocol.is_bound()) return TRUE;
if (single_value->field_s__bit.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_cksum.is_bound()) return TRUE;
if (single_value->field_dstaddr.is_bound()) return TRUE;
if (single_value->field_srcaddr.is_omit() || single_value->field_srcaddr.is_bound()) return TRUE;
return FALSE;
}

boolean IP__MINE__header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_protocol.is_value()) return FALSE;
if (!single_value->field_s__bit.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_cksum.is_value()) return FALSE;
if (!single_value->field_dstaddr.is_value()) return FALSE;
if (!single_value->field_srcaddr.is_omit() && !single_value->field_srcaddr.is_value()) return FALSE;
return TRUE;
}

void IP__MINE__header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IP__MINE__header IP__MINE__header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.IP_MINE_header.");
IP__MINE__header ret_val;
if (single_value->field_protocol.is_bound()) {
ret_val.protocol() = single_value->field_protocol.valueof();
}
if (single_value->field_s__bit.is_bound()) {
ret_val.s__bit() = single_value->field_s__bit.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_cksum.is_bound()) {
ret_val.cksum() = single_value->field_cksum.valueof();
}
if (single_value->field_dstaddr.is_bound()) {
ret_val.dstaddr() = single_value->field_dstaddr.valueof();
}
if (single_value->field_srcaddr.is_omit()) ret_val.srcaddr() = OMIT_VALUE;
else if (single_value->field_srcaddr.is_bound()) {
ret_val.srcaddr() = single_value->field_srcaddr.valueof();
}
return ret_val;
}

void IP__MINE__header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.IP_MINE_header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IP__MINE__header_template[list_length];
}

IP__MINE__header_template& IP__MINE__header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.IP_MINE_header.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.IP_MINE_header.");
return value_list.list_value[list_index];
}

INTEGER_template& IP__MINE__header_template::protocol()
{
set_specific();
return single_value->field_protocol;
}

const INTEGER_template& IP__MINE__header_template::protocol() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protocol of a non-specific template of type @IP_Types.IP_MINE_header.");
return single_value->field_protocol;
}

BITSTRING_template& IP__MINE__header_template::s__bit()
{
set_specific();
return single_value->field_s__bit;
}

const BITSTRING_template& IP__MINE__header_template::s__bit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field s_bit of a non-specific template of type @IP_Types.IP_MINE_header.");
return single_value->field_s__bit;
}

BITSTRING_template& IP__MINE__header_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const BITSTRING_template& IP__MINE__header_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @IP_Types.IP_MINE_header.");
return single_value->field_reserved;
}

INTEGER_template& IP__MINE__header_template::cksum()
{
set_specific();
return single_value->field_cksum;
}

const INTEGER_template& IP__MINE__header_template::cksum() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cksum of a non-specific template of type @IP_Types.IP_MINE_header.");
return single_value->field_cksum;
}

OCTETSTRING_template& IP__MINE__header_template::dstaddr()
{
set_specific();
return single_value->field_dstaddr;
}

const OCTETSTRING_template& IP__MINE__header_template::dstaddr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dstaddr of a non-specific template of type @IP_Types.IP_MINE_header.");
return single_value->field_dstaddr;
}

OCTETSTRING_template& IP__MINE__header_template::srcaddr()
{
set_specific();
return single_value->field_srcaddr;
}

const OCTETSTRING_template& IP__MINE__header_template::srcaddr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field srcaddr of a non-specific template of type @IP_Types.IP_MINE_header.");
return single_value->field_srcaddr;
}

int IP__MINE__header_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_MINE_header which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 5;
      if (single_value->field_srcaddr.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.IP_MINE_header containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_MINE_header containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_MINE_header containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_MINE_header containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_MINE_header containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.IP_MINE_header.");
  }
  return 0;
}

void IP__MINE__header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ protocol := ");
single_value->field_protocol.log();
TTCN_Logger::log_event_str(", s_bit := ");
single_value->field_s__bit.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", cksum := ");
single_value->field_cksum.log();
TTCN_Logger::log_event_str(", dstaddr := ");
single_value->field_dstaddr.log();
TTCN_Logger::log_event_str(", srcaddr := ");
single_value->field_srcaddr.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IP__MINE__header_template::log_match(const IP__MINE__header& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_protocol.match(match_value.protocol())){
TTCN_Logger::log_logmatch_info(".protocol");
single_value->field_protocol.log_match(match_value.protocol());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_s__bit.match(match_value.s__bit())){
TTCN_Logger::log_logmatch_info(".s_bit");
single_value->field_s__bit.log_match(match_value.s__bit());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved())){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_cksum.match(match_value.cksum())){
TTCN_Logger::log_logmatch_info(".cksum");
single_value->field_cksum.log_match(match_value.cksum());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_dstaddr.match(match_value.dstaddr())){
TTCN_Logger::log_logmatch_info(".dstaddr");
single_value->field_dstaddr.log_match(match_value.dstaddr());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.srcaddr().ispresent()){
if(!single_value->field_srcaddr.match(match_value.srcaddr())){
TTCN_Logger::log_logmatch_info(".srcaddr");
single_value->field_srcaddr.log_match(match_value.srcaddr());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_srcaddr.match_omit()){
 TTCN_Logger::log_logmatch_info(".srcaddr := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_srcaddr.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ protocol := ");
single_value->field_protocol.log_match(match_value.protocol());
TTCN_Logger::log_event_str(", s_bit := ");
single_value->field_s__bit.log_match(match_value.s__bit());
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved());
TTCN_Logger::log_event_str(", cksum := ");
single_value->field_cksum.log_match(match_value.cksum());
TTCN_Logger::log_event_str(", dstaddr := ");
single_value->field_dstaddr.log_match(match_value.dstaddr());
TTCN_Logger::log_event_str(", srcaddr := ");
if (match_value.srcaddr().ispresent()) single_value->field_srcaddr.log_match(match_value.srcaddr());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_srcaddr.log();
if (single_value->field_srcaddr.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IP__MINE__header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_protocol.encode_text(text_buf);
single_value->field_s__bit.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_cksum.encode_text(text_buf);
single_value->field_dstaddr.encode_text(text_buf);
single_value->field_srcaddr.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IP_MINE_header.");
}
}

void IP__MINE__header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_protocol.decode_text(text_buf);
single_value->field_s__bit.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_cksum.decode_text(text_buf);
single_value->field_dstaddr.decode_text(text_buf);
single_value->field_srcaddr.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IP__MINE__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.IP_MINE_header.");
}
}

void IP__MINE__header_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.IP_MINE_header'");
    }
    if (strcmp("protocol", param_field) == 0) {
      protocol().set_param(param);
      return;
    } else if (strcmp("s_bit", param_field) == 0) {
      s__bit().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("cksum", param_field) == 0) {
      cksum().set_param(param);
      return;
    } else if (strcmp("dstaddr", param_field) == 0) {
      dstaddr().set_param(param);
      return;
    } else if (strcmp("srcaddr", param_field) == 0) {
      srcaddr().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.IP_MINE_header'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (6<param.get_size()) {
      param.error("record template of type @IP_Types.IP_MINE_header has 6 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protocol().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) s__bit().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) cksum().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) dstaddr().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) srcaddr().set_param(*param.get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protocol")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protocol().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "s_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          s__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cksum")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cksum().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dstaddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dstaddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcaddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcaddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IP_MINE_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.IP_MINE_header");
  }
  is_ifpresent = param.get_ifpresent();
}

void IP__MINE__header_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_protocol.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_MINE_header");
single_value->field_s__bit.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_MINE_header");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_MINE_header");
single_value->field_cksum.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_MINE_header");
single_value->field_dstaddr.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_MINE_header");
single_value->field_srcaddr.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_MINE_header");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IP_MINE_header");
}

boolean IP__MINE__header_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IP__MINE__header_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

IP__AH__header::IP__AH__header()
{
  bound_flag = FALSE;
}

IP__AH__header::IP__AH__header(const INTEGER& par_next__hdr,
    const INTEGER& par_payload__len,
    const OCTETSTRING& par_reserved,
    const INTEGER& par_spi,
    const BITSTRING& par_sn,
    const OCTETSTRING& par_auth__data)
  :   field_next__hdr(par_next__hdr),
  field_payload__len(par_payload__len),
  field_reserved(par_reserved),
  field_spi(par_spi),
  field_sn(par_sn),
  field_auth__data(par_auth__data)
{
  bound_flag = TRUE;
}

IP__AH__header::IP__AH__header(const IP__AH__header& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IP_AH_header.");
bound_flag = TRUE;
if (other_value.next__hdr().is_bound()) field_next__hdr = other_value.next__hdr();
else field_next__hdr.clean_up();
if (other_value.payload__len().is_bound()) field_payload__len = other_value.payload__len();
else field_payload__len.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.spi().is_bound()) field_spi = other_value.spi();
else field_spi.clean_up();
if (other_value.sn().is_bound()) field_sn = other_value.sn();
else field_sn.clean_up();
if (other_value.auth__data().is_bound()) field_auth__data = other_value.auth__data();
else field_auth__data.clean_up();
}

void IP__AH__header::clean_up()
{
field_next__hdr.clean_up();
field_payload__len.clean_up();
field_reserved.clean_up();
field_spi.clean_up();
field_sn.clean_up();
field_auth__data.clean_up();
bound_flag = FALSE;
}

IP__AH__header& IP__AH__header::operator=(const IP__AH__header& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.IP_AH_header.");
  bound_flag = TRUE;
  if (other_value.next__hdr().is_bound()) field_next__hdr = other_value.next__hdr();
  else field_next__hdr.clean_up();
  if (other_value.payload__len().is_bound()) field_payload__len = other_value.payload__len();
  else field_payload__len.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.spi().is_bound()) field_spi = other_value.spi();
  else field_spi.clean_up();
  if (other_value.sn().is_bound()) field_sn = other_value.sn();
  else field_sn.clean_up();
  if (other_value.auth__data().is_bound()) field_auth__data = other_value.auth__data();
  else field_auth__data.clean_up();
}
return *this;
}

boolean IP__AH__header::operator==(const IP__AH__header& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_next__hdr==other_value.field_next__hdr
  && field_payload__len==other_value.field_payload__len
  && field_reserved==other_value.field_reserved
  && field_spi==other_value.field_spi
  && field_sn==other_value.field_sn
  && field_auth__data==other_value.field_auth__data;
}

boolean IP__AH__header::is_bound() const
{
if (bound_flag) return TRUE;
if(field_next__hdr.is_bound()) return TRUE;
if(field_payload__len.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_spi.is_bound()) return TRUE;
if(field_sn.is_bound()) return TRUE;
if(field_auth__data.is_bound()) return TRUE;
return FALSE;
}
boolean IP__AH__header::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_next__hdr.is_value()) return FALSE;
if(!field_payload__len.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_spi.is_value()) return FALSE;
if(!field_sn.is_value()) return FALSE;
if(!field_auth__data.is_value()) return FALSE;
return TRUE;
}
int IP__AH__header::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.IP_AH_header");
  return 6;
}

void IP__AH__header::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ next_hdr := ");
field_next__hdr.log();
TTCN_Logger::log_event_str(", payload_len := ");
field_payload__len.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", spi := ");
field_spi.log();
TTCN_Logger::log_event_str(", sn := ");
field_sn.log();
TTCN_Logger::log_event_str(", auth_data := ");
field_auth__data.log();
TTCN_Logger::log_event_str(" }");
}

void IP__AH__header::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.IP_AH_header'");
    }
    if (strcmp("next_hdr", param_field) == 0) {
      next__hdr().set_param(param);
      return;
    } else if (strcmp("payload_len", param_field) == 0) {
      payload__len().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("spi", param_field) == 0) {
      spi().set_param(param);
      return;
    } else if (strcmp("sn", param_field) == 0) {
      sn().set_param(param);
      return;
    } else if (strcmp("auth_data", param_field) == 0) {
      auth__data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.IP_AH_header'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (6<param.get_size()) {
      param.error("record value of type @IP_Types.IP_AH_header has 6 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) next__hdr().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) payload__len().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) spi().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) sn().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) auth__data().set_param(*param.get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "next_hdr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          next__hdr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_len")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__len().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spi().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "auth_data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          auth__data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IP_AH_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.IP_AH_header");
  }
}

void IP__AH__header::set_implicit_omit()
{
if (next__hdr().is_bound()) next__hdr().set_implicit_omit();
if (payload__len().is_bound()) payload__len().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (spi().is_bound()) spi().set_implicit_omit();
if (sn().is_bound()) sn().set_implicit_omit();
if (auth__data().is_bound()) auth__data().set_implicit_omit();
}

void IP__AH__header::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.IP_AH_header.");
field_next__hdr.encode_text(text_buf);
field_payload__len.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_spi.encode_text(text_buf);
field_sn.encode_text(text_buf);
field_auth__data.encode_text(text_buf);
}

void IP__AH__header::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_next__hdr.decode_text(text_buf);
field_payload__len.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_spi.decode_text(text_buf);
field_sn.decode_text(text_buf);
field_auth__data.decode_text(text_buf);
}

void IP__AH__header::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IP__AH__header::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IP__AH__header::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  int value_of_length_field1 = 0;
  decoded_field_length = field_next__hdr.RAW_decode(General__Types::LIN1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_payload__len.RAW_decode(IP__AH__header_payload__len_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field1+=(int)field_payload__len*32;
  decoded_field_length = field_reserved.RAW_decode(General__Types::OCT2_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_spi.RAW_decode(General__Types::LIN4__BO__LAST_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_sn.RAW_decode(General__Types::BIT32__BO__LAST_descr_, p_buf, min_of_ints(2, limit, value_of_length_field1), local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field1 -= decoded_field_length;
  decoded_field_length = field_auth__data.RAW_decode(OCTETSTRING_descr_, p_buf, min_of_ints(2, limit, value_of_length_field1), local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field1 -= decoded_field_length;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IP__AH__header::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 6;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(6);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, General__Types::LIN1_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, IP__AH__header_payload__len_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, General__Types::OCT2_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, General__Types::LIN4__BO__LAST_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, General__Types::BIT32__BO__LAST_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, OCTETSTRING_descr_.raw);
  encoded_length += field_next__hdr.RAW_encode(General__Types::LIN1_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += 8;
  myleaf.body.node.nodes[1]->calc = CALC_LENGTH;
  myleaf.body.node.nodes[1]->coding_descr = &IP__AH__header_payload__len_descr_;
  myleaf.body.node.nodes[1]->calcof.lengthto.num_of_fields = 2;
  myleaf.body.node.nodes[1]->calcof.lengthto.unit = 32;
  myleaf.body.node.nodes[1]->calcof.lengthto.fields = init_lengthto_fields_list(2);
  myleaf.body.node.nodes[1]->length = 8;
  myleaf.body.node.nodes[1]->calcof.lengthto.fields[0].level = myleaf.body.node.nodes[4]->curr_pos.level;
  myleaf.body.node.nodes[1]->calcof.lengthto.fields[0].pos = myleaf.body.node.nodes[4]->curr_pos.pos;
  myleaf.body.node.nodes[1]->calcof.lengthto.fields[1].level = myleaf.body.node.nodes[5]->curr_pos.level;
  myleaf.body.node.nodes[1]->calcof.lengthto.fields[1].pos = myleaf.body.node.nodes[5]->curr_pos.pos;
  encoded_length += field_reserved.RAW_encode(General__Types::OCT2_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_spi.RAW_encode(General__Types::LIN4__BO__LAST_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_sn.RAW_encode(General__Types::BIT32__BO__LAST_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_auth__data.RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[5]);
  return myleaf.length = encoded_length;
}

int IP__AH__header::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IP_AH_header.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "next_hdr");
    enc_len += field_next__hdr.JSON_encode(General__Types::LIN1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload_len");
    enc_len += field_payload__len.JSON_encode(IP__AH__header_payload__len_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(General__Types::OCT2_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "spi");
    enc_len += field_spi.JSON_encode(General__Types::LIN4__BO__LAST_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "sn");
    enc_len += field_sn.JSON_encode(General__Types::BIT32__BO__LAST_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "auth_data");
    enc_len += field_auth__data.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IP__AH__header::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (8 == name_len && 0 == strncmp(fld_name, "next_hdr", name_len)) {
        int ret_val = field_next__hdr.JSON_decode(General__Types::LIN1_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "next_hdr");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (11 == name_len && 0 == strncmp(fld_name, "payload_len", name_len)) {
        int ret_val = field_payload__len.JSON_decode(IP__AH__header_payload__len_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload_len");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
        int ret_val = field_reserved.JSON_decode(General__Types::OCT2_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (3 == name_len && 0 == strncmp(fld_name, "spi", name_len)) {
        int ret_val = field_spi.JSON_decode(General__Types::LIN4__BO__LAST_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "spi");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (2 == name_len && 0 == strncmp(fld_name, "sn", name_len)) {
        int ret_val = field_sn.JSON_decode(General__Types::BIT32__BO__LAST_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "sn");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (9 == name_len && 0 == strncmp(fld_name, "auth_data", name_len)) {
        int ret_val = field_auth__data.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "auth_data");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_next__hdr.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "next_hdr");
    return JSON_ERROR_FATAL;
  }
  if (!field_payload__len.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "payload_len");
    return JSON_ERROR_FATAL;
  }
  if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
  if (!field_spi.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "spi");
    return JSON_ERROR_FATAL;
  }
  if (!field_sn.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "sn");
    return JSON_ERROR_FATAL;
  }
  if (!field_auth__data.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "auth_data");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct IP__AH__header_template::single_value_struct {
INTEGER_template field_next__hdr;
INTEGER_template field_payload__len;
OCTETSTRING_template field_reserved;
INTEGER_template field_spi;
BITSTRING_template field_sn;
OCTETSTRING_template field_auth__data;
};

void IP__AH__header_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_next__hdr = ANY_VALUE;
single_value->field_payload__len = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_spi = ANY_VALUE;
single_value->field_sn = ANY_VALUE;
single_value->field_auth__data = ANY_VALUE;
}
}
}

void IP__AH__header_template::copy_value(const IP__AH__header& other_value)
{
single_value = new single_value_struct;
if (other_value.next__hdr().is_bound()) {
  single_value->field_next__hdr = other_value.next__hdr();
} else {
  single_value->field_next__hdr.clean_up();
}
if (other_value.payload__len().is_bound()) {
  single_value->field_payload__len = other_value.payload__len();
} else {
  single_value->field_payload__len.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.spi().is_bound()) {
  single_value->field_spi = other_value.spi();
} else {
  single_value->field_spi.clean_up();
}
if (other_value.sn().is_bound()) {
  single_value->field_sn = other_value.sn();
} else {
  single_value->field_sn.clean_up();
}
if (other_value.auth__data().is_bound()) {
  single_value->field_auth__data = other_value.auth__data();
} else {
  single_value->field_auth__data.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IP__AH__header_template::copy_template(const IP__AH__header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.next__hdr().get_selection()) {
single_value->field_next__hdr = other_value.next__hdr();
} else {
single_value->field_next__hdr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload__len().get_selection()) {
single_value->field_payload__len = other_value.payload__len();
} else {
single_value->field_payload__len.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.spi().get_selection()) {
single_value->field_spi = other_value.spi();
} else {
single_value->field_spi.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sn().get_selection()) {
single_value->field_sn = other_value.sn();
} else {
single_value->field_sn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.auth__data().get_selection()) {
single_value->field_auth__data = other_value.auth__data();
} else {
single_value->field_auth__data.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IP__AH__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IP_AH_header.");
break;
}
set_selection(other_value);
}

IP__AH__header_template::IP__AH__header_template()
{
}

IP__AH__header_template::IP__AH__header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IP__AH__header_template::IP__AH__header_template(const IP__AH__header& other_value)
{
copy_value(other_value);
}

IP__AH__header_template::IP__AH__header_template(const OPTIONAL<IP__AH__header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__AH__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IP_AH_header from an unbound optional field.");
}
}

IP__AH__header_template::IP__AH__header_template(const IP__AH__header_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IP__AH__header_template::~IP__AH__header_template()
{
clean_up();
}

IP__AH__header_template& IP__AH__header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IP__AH__header_template& IP__AH__header_template::operator=(const IP__AH__header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IP__AH__header_template& IP__AH__header_template::operator=(const OPTIONAL<IP__AH__header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__AH__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IP_AH_header.");
}
return *this;
}

IP__AH__header_template& IP__AH__header_template::operator=(const IP__AH__header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IP__AH__header_template::match(const IP__AH__header& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.next__hdr().is_bound()) return FALSE;
if(!single_value->field_next__hdr.match(other_value.next__hdr()))return FALSE;
if(!other_value.payload__len().is_bound()) return FALSE;
if(!single_value->field_payload__len.match(other_value.payload__len()))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved()))return FALSE;
if(!other_value.spi().is_bound()) return FALSE;
if(!single_value->field_spi.match(other_value.spi()))return FALSE;
if(!other_value.sn().is_bound()) return FALSE;
if(!single_value->field_sn.match(other_value.sn()))return FALSE;
if(!other_value.auth__data().is_bound()) return FALSE;
if(!single_value->field_auth__data.match(other_value.auth__data()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.IP_AH_header.");
}
return FALSE;
}

boolean IP__AH__header_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_next__hdr.is_bound()) return TRUE;
if (single_value->field_payload__len.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_spi.is_bound()) return TRUE;
if (single_value->field_sn.is_bound()) return TRUE;
if (single_value->field_auth__data.is_bound()) return TRUE;
return FALSE;
}

boolean IP__AH__header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_next__hdr.is_value()) return FALSE;
if (!single_value->field_payload__len.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_spi.is_value()) return FALSE;
if (!single_value->field_sn.is_value()) return FALSE;
if (!single_value->field_auth__data.is_value()) return FALSE;
return TRUE;
}

void IP__AH__header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IP__AH__header IP__AH__header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.IP_AH_header.");
IP__AH__header ret_val;
if (single_value->field_next__hdr.is_bound()) {
ret_val.next__hdr() = single_value->field_next__hdr.valueof();
}
if (single_value->field_payload__len.is_bound()) {
ret_val.payload__len() = single_value->field_payload__len.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_spi.is_bound()) {
ret_val.spi() = single_value->field_spi.valueof();
}
if (single_value->field_sn.is_bound()) {
ret_val.sn() = single_value->field_sn.valueof();
}
if (single_value->field_auth__data.is_bound()) {
ret_val.auth__data() = single_value->field_auth__data.valueof();
}
return ret_val;
}

void IP__AH__header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.IP_AH_header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IP__AH__header_template[list_length];
}

IP__AH__header_template& IP__AH__header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.IP_AH_header.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.IP_AH_header.");
return value_list.list_value[list_index];
}

INTEGER_template& IP__AH__header_template::next__hdr()
{
set_specific();
return single_value->field_next__hdr;
}

const INTEGER_template& IP__AH__header_template::next__hdr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field next_hdr of a non-specific template of type @IP_Types.IP_AH_header.");
return single_value->field_next__hdr;
}

INTEGER_template& IP__AH__header_template::payload__len()
{
set_specific();
return single_value->field_payload__len;
}

const INTEGER_template& IP__AH__header_template::payload__len() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload_len of a non-specific template of type @IP_Types.IP_AH_header.");
return single_value->field_payload__len;
}

OCTETSTRING_template& IP__AH__header_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const OCTETSTRING_template& IP__AH__header_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @IP_Types.IP_AH_header.");
return single_value->field_reserved;
}

INTEGER_template& IP__AH__header_template::spi()
{
set_specific();
return single_value->field_spi;
}

const INTEGER_template& IP__AH__header_template::spi() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field spi of a non-specific template of type @IP_Types.IP_AH_header.");
return single_value->field_spi;
}

BITSTRING_template& IP__AH__header_template::sn()
{
set_specific();
return single_value->field_sn;
}

const BITSTRING_template& IP__AH__header_template::sn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sn of a non-specific template of type @IP_Types.IP_AH_header.");
return single_value->field_sn;
}

OCTETSTRING_template& IP__AH__header_template::auth__data()
{
set_specific();
return single_value->field_auth__data;
}

const OCTETSTRING_template& IP__AH__header_template::auth__data() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field auth_data of a non-specific template of type @IP_Types.IP_AH_header.");
return single_value->field_auth__data;
}

int IP__AH__header_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_AH_header which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 6;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.IP_AH_header containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_AH_header containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_AH_header containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_AH_header containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_AH_header containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.IP_AH_header.");
  }
  return 0;
}

void IP__AH__header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ next_hdr := ");
single_value->field_next__hdr.log();
TTCN_Logger::log_event_str(", payload_len := ");
single_value->field_payload__len.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", spi := ");
single_value->field_spi.log();
TTCN_Logger::log_event_str(", sn := ");
single_value->field_sn.log();
TTCN_Logger::log_event_str(", auth_data := ");
single_value->field_auth__data.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IP__AH__header_template::log_match(const IP__AH__header& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_next__hdr.match(match_value.next__hdr())){
TTCN_Logger::log_logmatch_info(".next_hdr");
single_value->field_next__hdr.log_match(match_value.next__hdr());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload__len.match(match_value.payload__len())){
TTCN_Logger::log_logmatch_info(".payload_len");
single_value->field_payload__len.log_match(match_value.payload__len());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved())){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_spi.match(match_value.spi())){
TTCN_Logger::log_logmatch_info(".spi");
single_value->field_spi.log_match(match_value.spi());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_sn.match(match_value.sn())){
TTCN_Logger::log_logmatch_info(".sn");
single_value->field_sn.log_match(match_value.sn());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_auth__data.match(match_value.auth__data())){
TTCN_Logger::log_logmatch_info(".auth_data");
single_value->field_auth__data.log_match(match_value.auth__data());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ next_hdr := ");
single_value->field_next__hdr.log_match(match_value.next__hdr());
TTCN_Logger::log_event_str(", payload_len := ");
single_value->field_payload__len.log_match(match_value.payload__len());
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved());
TTCN_Logger::log_event_str(", spi := ");
single_value->field_spi.log_match(match_value.spi());
TTCN_Logger::log_event_str(", sn := ");
single_value->field_sn.log_match(match_value.sn());
TTCN_Logger::log_event_str(", auth_data := ");
single_value->field_auth__data.log_match(match_value.auth__data());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IP__AH__header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_next__hdr.encode_text(text_buf);
single_value->field_payload__len.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_spi.encode_text(text_buf);
single_value->field_sn.encode_text(text_buf);
single_value->field_auth__data.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IP_AH_header.");
}
}

void IP__AH__header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_next__hdr.decode_text(text_buf);
single_value->field_payload__len.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_spi.decode_text(text_buf);
single_value->field_sn.decode_text(text_buf);
single_value->field_auth__data.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IP__AH__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.IP_AH_header.");
}
}

void IP__AH__header_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.IP_AH_header'");
    }
    if (strcmp("next_hdr", param_field) == 0) {
      next__hdr().set_param(param);
      return;
    } else if (strcmp("payload_len", param_field) == 0) {
      payload__len().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("spi", param_field) == 0) {
      spi().set_param(param);
      return;
    } else if (strcmp("sn", param_field) == 0) {
      sn().set_param(param);
      return;
    } else if (strcmp("auth_data", param_field) == 0) {
      auth__data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.IP_AH_header'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (6<param.get_size()) {
      param.error("record template of type @IP_Types.IP_AH_header has 6 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) next__hdr().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) payload__len().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) spi().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) sn().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) auth__data().set_param(*param.get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "next_hdr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          next__hdr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_len")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__len().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spi().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "auth_data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          auth__data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IP_AH_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.IP_AH_header");
  }
  is_ifpresent = param.get_ifpresent();
}

void IP__AH__header_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_next__hdr.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_AH_header");
single_value->field_payload__len.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_AH_header");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_AH_header");
single_value->field_spi.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_AH_header");
single_value->field_sn.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_AH_header");
single_value->field_auth__data.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_AH_header");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IP_AH_header");
}

boolean IP__AH__header_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IP__AH__header_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

IP__ESP__header__part::IP__ESP__header__part()
{
  bound_flag = FALSE;
}

IP__ESP__header__part::IP__ESP__header__part(const INTEGER& par_spi,
    const BITSTRING& par_sn)
  :   field_spi(par_spi),
  field_sn(par_sn)
{
  bound_flag = TRUE;
}

IP__ESP__header__part::IP__ESP__header__part(const IP__ESP__header__part& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IP_ESP_header_part.");
bound_flag = TRUE;
if (other_value.spi().is_bound()) field_spi = other_value.spi();
else field_spi.clean_up();
if (other_value.sn().is_bound()) field_sn = other_value.sn();
else field_sn.clean_up();
}

void IP__ESP__header__part::clean_up()
{
field_spi.clean_up();
field_sn.clean_up();
bound_flag = FALSE;
}

IP__ESP__header__part& IP__ESP__header__part::operator=(const IP__ESP__header__part& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.IP_ESP_header_part.");
  bound_flag = TRUE;
  if (other_value.spi().is_bound()) field_spi = other_value.spi();
  else field_spi.clean_up();
  if (other_value.sn().is_bound()) field_sn = other_value.sn();
  else field_sn.clean_up();
}
return *this;
}

boolean IP__ESP__header__part::operator==(const IP__ESP__header__part& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_spi==other_value.field_spi
  && field_sn==other_value.field_sn;
}

boolean IP__ESP__header__part::is_bound() const
{
if (bound_flag) return TRUE;
if(field_spi.is_bound()) return TRUE;
if(field_sn.is_bound()) return TRUE;
return FALSE;
}
boolean IP__ESP__header__part::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_spi.is_value()) return FALSE;
if(!field_sn.is_value()) return FALSE;
return TRUE;
}
int IP__ESP__header__part::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.IP_ESP_header_part");
  return 2;
}

void IP__ESP__header__part::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ spi := ");
field_spi.log();
TTCN_Logger::log_event_str(", sn := ");
field_sn.log();
TTCN_Logger::log_event_str(" }");
}

void IP__ESP__header__part::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.IP_ESP_header_part'");
    }
    if (strcmp("spi", param_field) == 0) {
      spi().set_param(param);
      return;
    } else if (strcmp("sn", param_field) == 0) {
      sn().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.IP_ESP_header_part'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @IP_Types.IP_ESP_header_part has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) spi().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sn().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spi().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IP_ESP_header_part: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.IP_ESP_header_part");
  }
}

void IP__ESP__header__part::set_implicit_omit()
{
if (spi().is_bound()) spi().set_implicit_omit();
if (sn().is_bound()) sn().set_implicit_omit();
}

void IP__ESP__header__part::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.IP_ESP_header_part.");
field_spi.encode_text(text_buf);
field_sn.encode_text(text_buf);
}

void IP__ESP__header__part::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_spi.decode_text(text_buf);
field_sn.decode_text(text_buf);
}

void IP__ESP__header__part::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IP__ESP__header__part::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IP__ESP__header__part::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_spi.RAW_decode(General__Types::LIN4__BO__LAST_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_sn.RAW_decode(General__Types::BIT32__BO__LAST_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IP__ESP__header__part::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, General__Types::LIN4__BO__LAST_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, General__Types::BIT32__BO__LAST_descr_.raw);
  encoded_length += field_spi.RAW_encode(General__Types::LIN4__BO__LAST_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_sn.RAW_encode(General__Types::BIT32__BO__LAST_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int IP__ESP__header__part::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IP_ESP_header_part.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "spi");
    enc_len += field_spi.JSON_encode(General__Types::LIN4__BO__LAST_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "sn");
    enc_len += field_sn.JSON_encode(General__Types::BIT32__BO__LAST_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IP__ESP__header__part::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (3 == name_len && 0 == strncmp(fld_name, "spi", name_len)) {
        int ret_val = field_spi.JSON_decode(General__Types::LIN4__BO__LAST_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "spi");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (2 == name_len && 0 == strncmp(fld_name, "sn", name_len)) {
        int ret_val = field_sn.JSON_decode(General__Types::BIT32__BO__LAST_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "sn");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_spi.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "spi");
    return JSON_ERROR_FATAL;
  }
  if (!field_sn.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "sn");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct IP__ESP__header__part_template::single_value_struct {
INTEGER_template field_spi;
BITSTRING_template field_sn;
};

void IP__ESP__header__part_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_spi = ANY_VALUE;
single_value->field_sn = ANY_VALUE;
}
}
}

void IP__ESP__header__part_template::copy_value(const IP__ESP__header__part& other_value)
{
single_value = new single_value_struct;
if (other_value.spi().is_bound()) {
  single_value->field_spi = other_value.spi();
} else {
  single_value->field_spi.clean_up();
}
if (other_value.sn().is_bound()) {
  single_value->field_sn = other_value.sn();
} else {
  single_value->field_sn.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IP__ESP__header__part_template::copy_template(const IP__ESP__header__part_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.spi().get_selection()) {
single_value->field_spi = other_value.spi();
} else {
single_value->field_spi.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sn().get_selection()) {
single_value->field_sn = other_value.sn();
} else {
single_value->field_sn.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IP__ESP__header__part_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IP_ESP_header_part.");
break;
}
set_selection(other_value);
}

IP__ESP__header__part_template::IP__ESP__header__part_template()
{
}

IP__ESP__header__part_template::IP__ESP__header__part_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IP__ESP__header__part_template::IP__ESP__header__part_template(const IP__ESP__header__part& other_value)
{
copy_value(other_value);
}

IP__ESP__header__part_template::IP__ESP__header__part_template(const OPTIONAL<IP__ESP__header__part>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__ESP__header__part&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IP_ESP_header_part from an unbound optional field.");
}
}

IP__ESP__header__part_template::IP__ESP__header__part_template(const IP__ESP__header__part_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IP__ESP__header__part_template::~IP__ESP__header__part_template()
{
clean_up();
}

IP__ESP__header__part_template& IP__ESP__header__part_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IP__ESP__header__part_template& IP__ESP__header__part_template::operator=(const IP__ESP__header__part& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IP__ESP__header__part_template& IP__ESP__header__part_template::operator=(const OPTIONAL<IP__ESP__header__part>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__ESP__header__part&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IP_ESP_header_part.");
}
return *this;
}

IP__ESP__header__part_template& IP__ESP__header__part_template::operator=(const IP__ESP__header__part_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IP__ESP__header__part_template::match(const IP__ESP__header__part& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.spi().is_bound()) return FALSE;
if(!single_value->field_spi.match(other_value.spi()))return FALSE;
if(!other_value.sn().is_bound()) return FALSE;
if(!single_value->field_sn.match(other_value.sn()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.IP_ESP_header_part.");
}
return FALSE;
}

boolean IP__ESP__header__part_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_spi.is_bound()) return TRUE;
if (single_value->field_sn.is_bound()) return TRUE;
return FALSE;
}

boolean IP__ESP__header__part_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_spi.is_value()) return FALSE;
if (!single_value->field_sn.is_value()) return FALSE;
return TRUE;
}

void IP__ESP__header__part_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IP__ESP__header__part IP__ESP__header__part_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.IP_ESP_header_part.");
IP__ESP__header__part ret_val;
if (single_value->field_spi.is_bound()) {
ret_val.spi() = single_value->field_spi.valueof();
}
if (single_value->field_sn.is_bound()) {
ret_val.sn() = single_value->field_sn.valueof();
}
return ret_val;
}

void IP__ESP__header__part_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.IP_ESP_header_part.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IP__ESP__header__part_template[list_length];
}

IP__ESP__header__part_template& IP__ESP__header__part_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.IP_ESP_header_part.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.IP_ESP_header_part.");
return value_list.list_value[list_index];
}

INTEGER_template& IP__ESP__header__part_template::spi()
{
set_specific();
return single_value->field_spi;
}

const INTEGER_template& IP__ESP__header__part_template::spi() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field spi of a non-specific template of type @IP_Types.IP_ESP_header_part.");
return single_value->field_spi;
}

BITSTRING_template& IP__ESP__header__part_template::sn()
{
set_specific();
return single_value->field_sn;
}

const BITSTRING_template& IP__ESP__header__part_template::sn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sn of a non-specific template of type @IP_Types.IP_ESP_header_part.");
return single_value->field_sn;
}

int IP__ESP__header__part_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_header_part which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.IP_ESP_header_part containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_header_part containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_header_part containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_header_part containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_header_part containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.IP_ESP_header_part.");
  }
  return 0;
}

void IP__ESP__header__part_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ spi := ");
single_value->field_spi.log();
TTCN_Logger::log_event_str(", sn := ");
single_value->field_sn.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IP__ESP__header__part_template::log_match(const IP__ESP__header__part& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_spi.match(match_value.spi())){
TTCN_Logger::log_logmatch_info(".spi");
single_value->field_spi.log_match(match_value.spi());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_sn.match(match_value.sn())){
TTCN_Logger::log_logmatch_info(".sn");
single_value->field_sn.log_match(match_value.sn());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ spi := ");
single_value->field_spi.log_match(match_value.spi());
TTCN_Logger::log_event_str(", sn := ");
single_value->field_sn.log_match(match_value.sn());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IP__ESP__header__part_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_spi.encode_text(text_buf);
single_value->field_sn.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IP_ESP_header_part.");
}
}

void IP__ESP__header__part_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_spi.decode_text(text_buf);
single_value->field_sn.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IP__ESP__header__part_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.IP_ESP_header_part.");
}
}

void IP__ESP__header__part_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.IP_ESP_header_part'");
    }
    if (strcmp("spi", param_field) == 0) {
      spi().set_param(param);
      return;
    } else if (strcmp("sn", param_field) == 0) {
      sn().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.IP_ESP_header_part'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @IP_Types.IP_ESP_header_part has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) spi().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sn().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spi().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IP_ESP_header_part: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.IP_ESP_header_part");
  }
  is_ifpresent = param.get_ifpresent();
}

void IP__ESP__header__part_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_spi.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_ESP_header_part");
single_value->field_sn.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_ESP_header_part");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IP_ESP_header_part");
}

boolean IP__ESP__header__part_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IP__ESP__header__part_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

IP__ESP__NULL__tail::IP__ESP__NULL__tail()
{
  bound_flag = FALSE;
}

IP__ESP__NULL__tail::IP__ESP__NULL__tail(const OPTIONAL<OCTETSTRING>& par_padding,
    const INTEGER& par_pad__length,
    const INTEGER& par_next__hdr,
    const OCTETSTRING& par_auth__data)
  :   field_padding(par_padding),
  field_pad__length(par_pad__length),
  field_next__hdr(par_next__hdr),
  field_auth__data(par_auth__data)
{
  bound_flag = TRUE;
}

IP__ESP__NULL__tail::IP__ESP__NULL__tail(const IP__ESP__NULL__tail& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IP_ESP_NULL_tail.");
bound_flag = TRUE;
if (other_value.padding().is_bound()) field_padding = other_value.padding();
else field_padding.clean_up();
if (other_value.pad__length().is_bound()) field_pad__length = other_value.pad__length();
else field_pad__length.clean_up();
if (other_value.next__hdr().is_bound()) field_next__hdr = other_value.next__hdr();
else field_next__hdr.clean_up();
if (other_value.auth__data().is_bound()) field_auth__data = other_value.auth__data();
else field_auth__data.clean_up();
}

void IP__ESP__NULL__tail::clean_up()
{
field_padding.clean_up();
field_pad__length.clean_up();
field_next__hdr.clean_up();
field_auth__data.clean_up();
bound_flag = FALSE;
}

IP__ESP__NULL__tail& IP__ESP__NULL__tail::operator=(const IP__ESP__NULL__tail& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.IP_ESP_NULL_tail.");
  bound_flag = TRUE;
  if (other_value.padding().is_bound()) field_padding = other_value.padding();
  else field_padding.clean_up();
  if (other_value.pad__length().is_bound()) field_pad__length = other_value.pad__length();
  else field_pad__length.clean_up();
  if (other_value.next__hdr().is_bound()) field_next__hdr = other_value.next__hdr();
  else field_next__hdr.clean_up();
  if (other_value.auth__data().is_bound()) field_auth__data = other_value.auth__data();
  else field_auth__data.clean_up();
}
return *this;
}

boolean IP__ESP__NULL__tail::operator==(const IP__ESP__NULL__tail& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_padding==other_value.field_padding
  && field_pad__length==other_value.field_pad__length
  && field_next__hdr==other_value.field_next__hdr
  && field_auth__data==other_value.field_auth__data;
}

boolean IP__ESP__NULL__tail::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_padding.get_selection() || field_padding.is_bound()) return TRUE;
if(field_pad__length.is_bound()) return TRUE;
if(field_next__hdr.is_bound()) return TRUE;
if(field_auth__data.is_bound()) return TRUE;
return FALSE;
}
boolean IP__ESP__NULL__tail::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_padding.get_selection() && !field_padding.is_value()) return FALSE;
if(!field_pad__length.is_value()) return FALSE;
if(!field_next__hdr.is_value()) return FALSE;
if(!field_auth__data.is_value()) return FALSE;
return TRUE;
}
int IP__ESP__NULL__tail::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.IP_ESP_NULL_tail");
  int ret_val = 3;
  if (field_padding.ispresent()) ret_val++;
  return ret_val;
}

void IP__ESP__NULL__tail::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ padding := ");
field_padding.log();
TTCN_Logger::log_event_str(", pad_length := ");
field_pad__length.log();
TTCN_Logger::log_event_str(", next_hdr := ");
field_next__hdr.log();
TTCN_Logger::log_event_str(", auth_data := ");
field_auth__data.log();
TTCN_Logger::log_event_str(" }");
}

void IP__ESP__NULL__tail::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.IP_ESP_NULL_tail'");
    }
    if (strcmp("padding", param_field) == 0) {
      padding().set_param(param);
      return;
    } else if (strcmp("pad_length", param_field) == 0) {
      pad__length().set_param(param);
      return;
    } else if (strcmp("next_hdr", param_field) == 0) {
      next__hdr().set_param(param);
      return;
    } else if (strcmp("auth_data", param_field) == 0) {
      auth__data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.IP_ESP_NULL_tail'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record value of type @IP_Types.IP_ESP_NULL_tail has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) padding().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) pad__length().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) next__hdr().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) auth__data().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "padding")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          padding().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pad_length")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pad__length().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "next_hdr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          next__hdr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "auth_data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          auth__data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IP_ESP_NULL_tail: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.IP_ESP_NULL_tail");
  }
}

void IP__ESP__NULL__tail::set_implicit_omit()
{
if (!padding().is_bound()) padding() = OMIT_VALUE;
else padding().set_implicit_omit();
if (pad__length().is_bound()) pad__length().set_implicit_omit();
if (next__hdr().is_bound()) next__hdr().set_implicit_omit();
if (auth__data().is_bound()) auth__data().set_implicit_omit();
}

void IP__ESP__NULL__tail::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.IP_ESP_NULL_tail.");
field_padding.encode_text(text_buf);
field_pad__length.encode_text(text_buf);
field_next__hdr.encode_text(text_buf);
field_auth__data.encode_text(text_buf);
}

void IP__ESP__NULL__tail::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_padding.decode_text(text_buf);
field_pad__length.decode_text(text_buf);
field_next__hdr.decode_text(text_buf);
field_auth__data.decode_text(text_buf);
}

void IP__ESP__NULL__tail::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IP__ESP__NULL__tail::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IP__ESP__NULL__tail::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  int value_of_length_field1 = 0;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_padding().RAW_decode(OCTETSTRING_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_padding = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field1 -= decoded_field_length;
  }
  }
  else field_padding=OMIT_VALUE;
  decoded_field_length = field_pad__length.RAW_decode(IP__ESP__NULL__tail_pad__length_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field1+=(int)field_pad__length*8;
  decoded_field_length = field_next__hdr.RAW_decode(General__Types::LIN1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_auth__data.RAW_decode(General__Types::OCT12n_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IP__ESP__NULL__tail::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 4;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  if (field_padding.ispresent()) {
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, OCTETSTRING_descr_.raw);
  }
  else myleaf.body.node.nodes[0] = NULL;
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, IP__ESP__NULL__tail_pad__length_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, General__Types::LIN1_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, General__Types::OCT12n_descr_.raw);
  if (field_padding.ispresent()) {
  encoded_length += field_padding().RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[0]);
  }
  encoded_length += 8;
  myleaf.body.node.nodes[1]->calc = CALC_LENGTH;
  myleaf.body.node.nodes[1]->coding_descr = &IP__ESP__NULL__tail_pad__length_descr_;
  myleaf.body.node.nodes[1]->calcof.lengthto.num_of_fields = 1;
  myleaf.body.node.nodes[1]->calcof.lengthto.unit = 8;
  myleaf.body.node.nodes[1]->calcof.lengthto.fields = init_lengthto_fields_list(1);
  myleaf.body.node.nodes[1]->length = 8;
  if (field_padding.ispresent()) {
  myleaf.body.node.nodes[1]->calcof.lengthto.fields[0].level = myleaf.body.node.nodes[0]->curr_pos.level;
  myleaf.body.node.nodes[1]->calcof.lengthto.fields[0].pos = myleaf.body.node.nodes[0]->curr_pos.pos;
  } else {
  myleaf.body.node.nodes[1]->calcof.lengthto.fields[0].level = 0;
  myleaf.body.node.nodes[1]->calcof.lengthto.fields[0].pos = 0;
  }
  encoded_length += field_next__hdr.RAW_encode(General__Types::LIN1_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_auth__data.RAW_encode(General__Types::OCT12n_descr_, *myleaf.body.node.nodes[3]);
  return myleaf.length = encoded_length;
}

int IP__ESP__NULL__tail::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IP_ESP_NULL_tail.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_padding.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "padding");
    enc_len += field_padding.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "pad_length");
    enc_len += field_pad__length.JSON_encode(IP__ESP__NULL__tail_pad__length_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "next_hdr");
    enc_len += field_next__hdr.JSON_encode(General__Types::LIN1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "auth_data");
    enc_len += field_auth__data.JSON_encode(General__Types::OCT12n_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IP__ESP__NULL__tail::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "padding", name_len)) {
        int ret_val = field_padding.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "padding");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (10 == name_len && 0 == strncmp(fld_name, "pad_length", name_len)) {
        int ret_val = field_pad__length.JSON_decode(IP__ESP__NULL__tail_pad__length_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "pad_length");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (8 == name_len && 0 == strncmp(fld_name, "next_hdr", name_len)) {
        int ret_val = field_next__hdr.JSON_decode(General__Types::LIN1_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "next_hdr");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (9 == name_len && 0 == strncmp(fld_name, "auth_data", name_len)) {
        int ret_val = field_auth__data.JSON_decode(General__Types::OCT12n_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "auth_data");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_padding.is_bound()) {
    field_padding = OMIT_VALUE;
  }
  if (!field_pad__length.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "pad_length");
    return JSON_ERROR_FATAL;
  }
  if (!field_next__hdr.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "next_hdr");
    return JSON_ERROR_FATAL;
  }
  if (!field_auth__data.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "auth_data");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct IP__ESP__NULL__tail_template::single_value_struct {
OCTETSTRING_template field_padding;
INTEGER_template field_pad__length;
INTEGER_template field_next__hdr;
OCTETSTRING_template field_auth__data;
};

void IP__ESP__NULL__tail_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_padding = ANY_OR_OMIT;
single_value->field_pad__length = ANY_VALUE;
single_value->field_next__hdr = ANY_VALUE;
single_value->field_auth__data = ANY_VALUE;
}
}
}

void IP__ESP__NULL__tail_template::copy_value(const IP__ESP__NULL__tail& other_value)
{
single_value = new single_value_struct;
if (other_value.padding().is_bound()) {
  if (other_value.padding().ispresent()) single_value->field_padding = other_value.padding()();
  else single_value->field_padding = OMIT_VALUE;
} else {
  single_value->field_padding.clean_up();
}
if (other_value.pad__length().is_bound()) {
  single_value->field_pad__length = other_value.pad__length();
} else {
  single_value->field_pad__length.clean_up();
}
if (other_value.next__hdr().is_bound()) {
  single_value->field_next__hdr = other_value.next__hdr();
} else {
  single_value->field_next__hdr.clean_up();
}
if (other_value.auth__data().is_bound()) {
  single_value->field_auth__data = other_value.auth__data();
} else {
  single_value->field_auth__data.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IP__ESP__NULL__tail_template::copy_template(const IP__ESP__NULL__tail_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.padding().get_selection()) {
single_value->field_padding = other_value.padding();
} else {
single_value->field_padding.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.pad__length().get_selection()) {
single_value->field_pad__length = other_value.pad__length();
} else {
single_value->field_pad__length.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.next__hdr().get_selection()) {
single_value->field_next__hdr = other_value.next__hdr();
} else {
single_value->field_next__hdr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.auth__data().get_selection()) {
single_value->field_auth__data = other_value.auth__data();
} else {
single_value->field_auth__data.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IP__ESP__NULL__tail_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IP_ESP_NULL_tail.");
break;
}
set_selection(other_value);
}

IP__ESP__NULL__tail_template::IP__ESP__NULL__tail_template()
{
}

IP__ESP__NULL__tail_template::IP__ESP__NULL__tail_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IP__ESP__NULL__tail_template::IP__ESP__NULL__tail_template(const IP__ESP__NULL__tail& other_value)
{
copy_value(other_value);
}

IP__ESP__NULL__tail_template::IP__ESP__NULL__tail_template(const OPTIONAL<IP__ESP__NULL__tail>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__ESP__NULL__tail&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IP_ESP_NULL_tail from an unbound optional field.");
}
}

IP__ESP__NULL__tail_template::IP__ESP__NULL__tail_template(const IP__ESP__NULL__tail_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IP__ESP__NULL__tail_template::~IP__ESP__NULL__tail_template()
{
clean_up();
}

IP__ESP__NULL__tail_template& IP__ESP__NULL__tail_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IP__ESP__NULL__tail_template& IP__ESP__NULL__tail_template::operator=(const IP__ESP__NULL__tail& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IP__ESP__NULL__tail_template& IP__ESP__NULL__tail_template::operator=(const OPTIONAL<IP__ESP__NULL__tail>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__ESP__NULL__tail&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IP_ESP_NULL_tail.");
}
return *this;
}

IP__ESP__NULL__tail_template& IP__ESP__NULL__tail_template::operator=(const IP__ESP__NULL__tail_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IP__ESP__NULL__tail_template::match(const IP__ESP__NULL__tail& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.padding().is_bound()) return FALSE;
if((other_value.padding().ispresent() ? !single_value->field_padding.match((const OCTETSTRING&)other_value.padding()) : !single_value->field_padding.match_omit()))return FALSE;
if(!other_value.pad__length().is_bound()) return FALSE;
if(!single_value->field_pad__length.match(other_value.pad__length()))return FALSE;
if(!other_value.next__hdr().is_bound()) return FALSE;
if(!single_value->field_next__hdr.match(other_value.next__hdr()))return FALSE;
if(!other_value.auth__data().is_bound()) return FALSE;
if(!single_value->field_auth__data.match(other_value.auth__data()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.IP_ESP_NULL_tail.");
}
return FALSE;
}

boolean IP__ESP__NULL__tail_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_padding.is_omit() || single_value->field_padding.is_bound()) return TRUE;
if (single_value->field_pad__length.is_bound()) return TRUE;
if (single_value->field_next__hdr.is_bound()) return TRUE;
if (single_value->field_auth__data.is_bound()) return TRUE;
return FALSE;
}

boolean IP__ESP__NULL__tail_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_padding.is_omit() && !single_value->field_padding.is_value()) return FALSE;
if (!single_value->field_pad__length.is_value()) return FALSE;
if (!single_value->field_next__hdr.is_value()) return FALSE;
if (!single_value->field_auth__data.is_value()) return FALSE;
return TRUE;
}

void IP__ESP__NULL__tail_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IP__ESP__NULL__tail IP__ESP__NULL__tail_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.IP_ESP_NULL_tail.");
IP__ESP__NULL__tail ret_val;
if (single_value->field_padding.is_omit()) ret_val.padding() = OMIT_VALUE;
else if (single_value->field_padding.is_bound()) {
ret_val.padding() = single_value->field_padding.valueof();
}
if (single_value->field_pad__length.is_bound()) {
ret_val.pad__length() = single_value->field_pad__length.valueof();
}
if (single_value->field_next__hdr.is_bound()) {
ret_val.next__hdr() = single_value->field_next__hdr.valueof();
}
if (single_value->field_auth__data.is_bound()) {
ret_val.auth__data() = single_value->field_auth__data.valueof();
}
return ret_val;
}

void IP__ESP__NULL__tail_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.IP_ESP_NULL_tail.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IP__ESP__NULL__tail_template[list_length];
}

IP__ESP__NULL__tail_template& IP__ESP__NULL__tail_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.IP_ESP_NULL_tail.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.IP_ESP_NULL_tail.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& IP__ESP__NULL__tail_template::padding()
{
set_specific();
return single_value->field_padding;
}

const OCTETSTRING_template& IP__ESP__NULL__tail_template::padding() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field padding of a non-specific template of type @IP_Types.IP_ESP_NULL_tail.");
return single_value->field_padding;
}

INTEGER_template& IP__ESP__NULL__tail_template::pad__length()
{
set_specific();
return single_value->field_pad__length;
}

const INTEGER_template& IP__ESP__NULL__tail_template::pad__length() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field pad_length of a non-specific template of type @IP_Types.IP_ESP_NULL_tail.");
return single_value->field_pad__length;
}

INTEGER_template& IP__ESP__NULL__tail_template::next__hdr()
{
set_specific();
return single_value->field_next__hdr;
}

const INTEGER_template& IP__ESP__NULL__tail_template::next__hdr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field next_hdr of a non-specific template of type @IP_Types.IP_ESP_NULL_tail.");
return single_value->field_next__hdr;
}

OCTETSTRING_template& IP__ESP__NULL__tail_template::auth__data()
{
set_specific();
return single_value->field_auth__data;
}

const OCTETSTRING_template& IP__ESP__NULL__tail_template::auth__data() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field auth_data of a non-specific template of type @IP_Types.IP_ESP_NULL_tail.");
return single_value->field_auth__data;
}

int IP__ESP__NULL__tail_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_NULL_tail which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 3;
      if (single_value->field_padding.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.IP_ESP_NULL_tail containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_NULL_tail containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_NULL_tail containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_NULL_tail containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_NULL_tail containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.IP_ESP_NULL_tail.");
  }
  return 0;
}

void IP__ESP__NULL__tail_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ padding := ");
single_value->field_padding.log();
TTCN_Logger::log_event_str(", pad_length := ");
single_value->field_pad__length.log();
TTCN_Logger::log_event_str(", next_hdr := ");
single_value->field_next__hdr.log();
TTCN_Logger::log_event_str(", auth_data := ");
single_value->field_auth__data.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IP__ESP__NULL__tail_template::log_match(const IP__ESP__NULL__tail& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.padding().ispresent()){
if(!single_value->field_padding.match(match_value.padding())){
TTCN_Logger::log_logmatch_info(".padding");
single_value->field_padding.log_match(match_value.padding());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_padding.match_omit()){
 TTCN_Logger::log_logmatch_info(".padding := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_padding.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_pad__length.match(match_value.pad__length())){
TTCN_Logger::log_logmatch_info(".pad_length");
single_value->field_pad__length.log_match(match_value.pad__length());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_next__hdr.match(match_value.next__hdr())){
TTCN_Logger::log_logmatch_info(".next_hdr");
single_value->field_next__hdr.log_match(match_value.next__hdr());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_auth__data.match(match_value.auth__data())){
TTCN_Logger::log_logmatch_info(".auth_data");
single_value->field_auth__data.log_match(match_value.auth__data());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ padding := ");
if (match_value.padding().ispresent()) single_value->field_padding.log_match(match_value.padding());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_padding.log();
if (single_value->field_padding.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", pad_length := ");
single_value->field_pad__length.log_match(match_value.pad__length());
TTCN_Logger::log_event_str(", next_hdr := ");
single_value->field_next__hdr.log_match(match_value.next__hdr());
TTCN_Logger::log_event_str(", auth_data := ");
single_value->field_auth__data.log_match(match_value.auth__data());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IP__ESP__NULL__tail_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_padding.encode_text(text_buf);
single_value->field_pad__length.encode_text(text_buf);
single_value->field_next__hdr.encode_text(text_buf);
single_value->field_auth__data.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IP_ESP_NULL_tail.");
}
}

void IP__ESP__NULL__tail_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_padding.decode_text(text_buf);
single_value->field_pad__length.decode_text(text_buf);
single_value->field_next__hdr.decode_text(text_buf);
single_value->field_auth__data.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IP__ESP__NULL__tail_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.IP_ESP_NULL_tail.");
}
}

void IP__ESP__NULL__tail_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.IP_ESP_NULL_tail'");
    }
    if (strcmp("padding", param_field) == 0) {
      padding().set_param(param);
      return;
    } else if (strcmp("pad_length", param_field) == 0) {
      pad__length().set_param(param);
      return;
    } else if (strcmp("next_hdr", param_field) == 0) {
      next__hdr().set_param(param);
      return;
    } else if (strcmp("auth_data", param_field) == 0) {
      auth__data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.IP_ESP_NULL_tail'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record template of type @IP_Types.IP_ESP_NULL_tail has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) padding().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) pad__length().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) next__hdr().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) auth__data().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "padding")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          padding().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pad_length")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pad__length().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "next_hdr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          next__hdr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "auth_data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          auth__data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IP_ESP_NULL_tail: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.IP_ESP_NULL_tail");
  }
  is_ifpresent = param.get_ifpresent();
}

void IP__ESP__NULL__tail_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_padding.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_ESP_NULL_tail");
single_value->field_pad__length.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_ESP_NULL_tail");
single_value->field_next__hdr.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_ESP_NULL_tail");
single_value->field_auth__data.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_ESP_NULL_tail");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IP_ESP_NULL_tail");
}

boolean IP__ESP__NULL__tail_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IP__ESP__NULL__tail_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void IP__ESP__tail__part::copy_value(const IP__ESP__tail__part& other_value)
{
switch (other_value.union_selection) {
case ALT_esp__null__tail:
field_esp__null__tail = new IP__ESP__NULL__tail(*other_value.field_esp__null__tail);
break;
case ALT_raw__data:
field_raw__data = new OCTETSTRING(*other_value.field_raw__data);
break;
default:
TTCN_error("Assignment of an unbound union value of type @IP_Types.IP_ESP_tail_part.");
}
union_selection = other_value.union_selection;
}

IP__ESP__tail__part::IP__ESP__tail__part()
{
union_selection = UNBOUND_VALUE;
}

IP__ESP__tail__part::IP__ESP__tail__part(const IP__ESP__tail__part& other_value)
: Base_Type(){
copy_value(other_value);
}

IP__ESP__tail__part::~IP__ESP__tail__part()
{
clean_up();
}

IP__ESP__tail__part& IP__ESP__tail__part::operator=(const IP__ESP__tail__part& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean IP__ESP__tail__part::operator==(const IP__ESP__tail__part& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @IP_Types.IP_ESP_tail_part.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @IP_Types.IP_ESP_tail_part.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_esp__null__tail:
return *field_esp__null__tail == *other_value.field_esp__null__tail;
case ALT_raw__data:
return *field_raw__data == *other_value.field_raw__data;
default:
return FALSE;
}
}

IP__ESP__NULL__tail& IP__ESP__tail__part::esp__null__tail()
{
if (union_selection != ALT_esp__null__tail) {
clean_up();
field_esp__null__tail = new IP__ESP__NULL__tail;
union_selection = ALT_esp__null__tail;
}
return *field_esp__null__tail;
}

const IP__ESP__NULL__tail& IP__ESP__tail__part::esp__null__tail() const
{
if (union_selection != ALT_esp__null__tail) TTCN_error("Using non-selected field esp_null_tail in a value of union type @IP_Types.IP_ESP_tail_part.");
return *field_esp__null__tail;
}

OCTETSTRING& IP__ESP__tail__part::raw__data()
{
if (union_selection != ALT_raw__data) {
clean_up();
field_raw__data = new OCTETSTRING;
union_selection = ALT_raw__data;
}
return *field_raw__data;
}

const OCTETSTRING& IP__ESP__tail__part::raw__data() const
{
if (union_selection != ALT_raw__data) TTCN_error("Using non-selected field raw_data in a value of union type @IP_Types.IP_ESP_tail_part.");
return *field_raw__data;
}

boolean IP__ESP__tail__part::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @IP_Types.IP_ESP_tail_part.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @IP_Types.IP_ESP_tail_part.");
return union_selection == checked_selection;
}

boolean IP__ESP__tail__part::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean IP__ESP__tail__part::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_esp__null__tail: return field_esp__null__tail->is_value();
case ALT_raw__data: return field_raw__data->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void IP__ESP__tail__part::clean_up()
{
switch (union_selection) {
case ALT_esp__null__tail:
  delete field_esp__null__tail;
  break;
case ALT_raw__data:
  delete field_raw__data;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void IP__ESP__tail__part::log() const
{
switch (union_selection) {
case ALT_esp__null__tail:
TTCN_Logger::log_event_str("{ esp_null_tail := ");
field_esp__null__tail->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_raw__data:
TTCN_Logger::log_event_str("{ raw_data := ");
field_raw__data->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void IP__ESP__tail__part::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@IP_Types.IP_ESP_tail_part'");
    }
    if (strcmp("esp_null_tail", param_field) == 0) {
      esp__null__tail().set_param(param);
      return;
    } else if (strcmp("raw_data", param_field) == 0) {
      raw__data().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@IP_Types.IP_ESP_tail_part'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) return;
  if (param.get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = param.get_elem(param.get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "esp_null_tail")) {
    esp__null__tail().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "raw_data")) {
    raw__data().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @IP_Types.IP_ESP_tail_part.", mp_last->get_id()->get_name());
}

void IP__ESP__tail__part::set_implicit_omit()
{
switch (union_selection) {
case ALT_esp__null__tail:
field_esp__null__tail->set_implicit_omit(); break;
case ALT_raw__data:
field_raw__data->set_implicit_omit(); break;
default: break;
}
}

void IP__ESP__tail__part::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_esp__null__tail:
field_esp__null__tail->encode_text(text_buf);
break;
case ALT_raw__data:
field_raw__data->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @IP_Types.IP_ESP_tail_part.");
}
}

void IP__ESP__tail__part::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_esp__null__tail:
esp__null__tail().decode_text(text_buf);
break;
case ALT_raw__data:
raw__data().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @IP_Types.IP_ESP_tail_part.");
}
}

void IP__ESP__tail__part::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IP__ESP__tail__part::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IP__ESP__tail__part::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = esp__null__tail().RAW_decode(IP__ESP__NULL__tail_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = raw__data().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = esp__null__tail().RAW_decode(IP__ESP__NULL__tail_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = raw__data().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int IP__ESP__tail__part::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_esp__null__tail:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, IP__ESP__NULL__tail_descr_.raw);
    encoded_length = field_esp__null__tail->RAW_encode(IP__ESP__NULL__tail_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &IP__ESP__NULL__tail_descr_;
    break;
  case ALT_raw__data:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, OCTETSTRING_descr_.raw);
    encoded_length = field_raw__data->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int IP__ESP__tail__part::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_esp__null__tail:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "esp_null_tail");
    enc_len += field_esp__null__tail->JSON_encode(IP__ESP__NULL__tail_descr_, p_tok);
    break;
  case ALT_raw__data:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "raw_data");
    enc_len += field_raw__data->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @IP_Types.IP_ESP_tail_part.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IP__ESP__tail__part::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "esp_null_tail", name_len)) {
      int ret_val = esp__null__tail().JSON_decode(IP__ESP__NULL__tail_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "esp_null_tail");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "raw_data", name_len)) {
      int ret_val = raw__data().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "raw_data");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void IP__ESP__tail__part_template::copy_value(const IP__ESP__tail__part& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case IP__ESP__tail__part::ALT_esp__null__tail:
single_value.field_esp__null__tail = new IP__ESP__NULL__tail_template(other_value.esp__null__tail());
break;
case IP__ESP__tail__part::ALT_raw__data:
single_value.field_raw__data = new OCTETSTRING_template(other_value.raw__data());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @IP_Types.IP_ESP_tail_part.");
}
set_selection(SPECIFIC_VALUE);
}

void IP__ESP__tail__part_template::copy_template(const IP__ESP__tail__part_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case IP__ESP__tail__part::ALT_esp__null__tail:
single_value.field_esp__null__tail = new IP__ESP__NULL__tail_template(*other_value.single_value.field_esp__null__tail);
break;
case IP__ESP__tail__part::ALT_raw__data:
single_value.field_raw__data = new OCTETSTRING_template(*other_value.single_value.field_raw__data);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @IP_Types.IP_ESP_tail_part.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IP__ESP__tail__part_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @IP_Types.IP_ESP_tail_part.");
}
set_selection(other_value);
}

IP__ESP__tail__part_template::IP__ESP__tail__part_template()
{
}

IP__ESP__tail__part_template::IP__ESP__tail__part_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IP__ESP__tail__part_template::IP__ESP__tail__part_template(const IP__ESP__tail__part& other_value)
{
copy_value(other_value);
}

IP__ESP__tail__part_template::IP__ESP__tail__part_template(const OPTIONAL<IP__ESP__tail__part>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__ESP__tail__part&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @IP_Types.IP_ESP_tail_part from an unbound optional field.");
}
}

IP__ESP__tail__part_template::IP__ESP__tail__part_template(const IP__ESP__tail__part_template& other_value)
: Base_Template(){
copy_template(other_value);
}

IP__ESP__tail__part_template::~IP__ESP__tail__part_template()
{
clean_up();
}

void IP__ESP__tail__part_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case IP__ESP__tail__part::ALT_esp__null__tail:
delete single_value.field_esp__null__tail;
break;
case IP__ESP__tail__part::ALT_raw__data:
delete single_value.field_raw__data;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IP__ESP__tail__part_template& IP__ESP__tail__part_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IP__ESP__tail__part_template& IP__ESP__tail__part_template::operator=(const IP__ESP__tail__part& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IP__ESP__tail__part_template& IP__ESP__tail__part_template::operator=(const OPTIONAL<IP__ESP__tail__part>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__ESP__tail__part&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @IP_Types.IP_ESP_tail_part.");
}
return *this;
}

IP__ESP__tail__part_template& IP__ESP__tail__part_template::operator=(const IP__ESP__tail__part_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IP__ESP__tail__part_template::match(const IP__ESP__tail__part& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
IP__ESP__tail__part::union_selection_type value_selection = other_value.get_selection();
if (value_selection == IP__ESP__tail__part::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case IP__ESP__tail__part::ALT_esp__null__tail:
return single_value.field_esp__null__tail->match(other_value.esp__null__tail());
case IP__ESP__tail__part::ALT_raw__data:
return single_value.field_raw__data->match(other_value.raw__data());
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @IP_Types.IP_ESP_tail_part.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @IP_Types.IP_ESP_tail_part.");
}
return FALSE;
}

boolean IP__ESP__tail__part_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case IP__ESP__tail__part::ALT_esp__null__tail:
return single_value.field_esp__null__tail->is_value();
case IP__ESP__tail__part::ALT_raw__data:
return single_value.field_raw__data->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @IP_Types.IP_ESP_tail_part.");
}
}

IP__ESP__tail__part IP__ESP__tail__part_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @IP_Types.IP_ESP_tail_part.");
IP__ESP__tail__part ret_val;
switch (single_value.union_selection) {
case IP__ESP__tail__part::ALT_esp__null__tail:
ret_val.esp__null__tail() = single_value.field_esp__null__tail->valueof();
break;
case IP__ESP__tail__part::ALT_raw__data:
ret_val.raw__data() = single_value.field_raw__data->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @IP_Types.IP_ESP_tail_part.");
}
return ret_val;
}

IP__ESP__tail__part_template& IP__ESP__tail__part_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @IP_Types.IP_ESP_tail_part.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @IP_Types.IP_ESP_tail_part.");
return value_list.list_value[list_index];
}
void IP__ESP__tail__part_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @IP_Types.IP_ESP_tail_part.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IP__ESP__tail__part_template[list_length];
}

IP__ESP__NULL__tail_template& IP__ESP__tail__part_template::esp__null__tail()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IP__ESP__tail__part::ALT_esp__null__tail) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_esp__null__tail = new IP__ESP__NULL__tail_template(ANY_VALUE);
else single_value.field_esp__null__tail = new IP__ESP__NULL__tail_template;
single_value.union_selection = IP__ESP__tail__part::ALT_esp__null__tail;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_esp__null__tail;
}

const IP__ESP__NULL__tail_template& IP__ESP__tail__part_template::esp__null__tail() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field esp_null_tail in a non-specific template of union type @IP_Types.IP_ESP_tail_part.");
if (single_value.union_selection != IP__ESP__tail__part::ALT_esp__null__tail) TTCN_error("Accessing non-selected field esp_null_tail in a template of union type @IP_Types.IP_ESP_tail_part.");
return *single_value.field_esp__null__tail;
}

OCTETSTRING_template& IP__ESP__tail__part_template::raw__data()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IP__ESP__tail__part::ALT_raw__data) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_raw__data = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_raw__data = new OCTETSTRING_template;
single_value.union_selection = IP__ESP__tail__part::ALT_raw__data;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_raw__data;
}

const OCTETSTRING_template& IP__ESP__tail__part_template::raw__data() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field raw_data in a non-specific template of union type @IP_Types.IP_ESP_tail_part.");
if (single_value.union_selection != IP__ESP__tail__part::ALT_raw__data) TTCN_error("Accessing non-selected field raw_data in a template of union type @IP_Types.IP_ESP_tail_part.");
return *single_value.field_raw__data;
}

boolean IP__ESP__tail__part_template::ischosen(IP__ESP__tail__part::union_selection_type checked_selection) const
{
if (checked_selection == IP__ESP__tail__part::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @IP_Types.IP_ESP_tail_part.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == IP__ESP__tail__part::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @IP_Types.IP_ESP_tail_part.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @IP_Types.IP_ESP_tail_part containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @IP_Types.IP_ESP_tail_part, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @IP_Types.IP_ESP_tail_part");
}
return FALSE;
}

void IP__ESP__tail__part_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case IP__ESP__tail__part::ALT_esp__null__tail:
TTCN_Logger::log_event_str("{ esp_null_tail := ");
single_value.field_esp__null__tail->log();
TTCN_Logger::log_event_str(" }");
break;
case IP__ESP__tail__part::ALT_raw__data:
TTCN_Logger::log_event_str("{ raw_data := ");
single_value.field_raw__data->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IP__ESP__tail__part_template::log_match(const IP__ESP__tail__part& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case IP__ESP__tail__part::ALT_esp__null__tail:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".esp_null_tail");
single_value.field_esp__null__tail->log_match(match_value.esp__null__tail());
} else {
TTCN_Logger::log_event_str("{ esp_null_tail := ");
single_value.field_esp__null__tail->log_match(match_value.esp__null__tail());
TTCN_Logger::log_event_str(" }");
}
break;
case IP__ESP__tail__part::ALT_raw__data:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".raw_data");
single_value.field_raw__data->log_match(match_value.raw__data());
} else {
TTCN_Logger::log_event_str("{ raw_data := ");
single_value.field_raw__data->log_match(match_value.raw__data());
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IP__ESP__tail__part_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case IP__ESP__tail__part::ALT_esp__null__tail:
single_value.field_esp__null__tail->encode_text(text_buf);
break;
case IP__ESP__tail__part::ALT_raw__data:
single_value.field_raw__data->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @IP_Types.IP_ESP_tail_part.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @IP_Types.IP_ESP_tail_part.");
}
}

void IP__ESP__tail__part_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = IP__ESP__tail__part::UNBOUND_VALUE;
IP__ESP__tail__part::union_selection_type new_selection = (IP__ESP__tail__part::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case IP__ESP__tail__part::ALT_esp__null__tail:
single_value.field_esp__null__tail = new IP__ESP__NULL__tail_template;
single_value.field_esp__null__tail->decode_text(text_buf);
break;
case IP__ESP__tail__part::ALT_raw__data:
single_value.field_raw__data = new OCTETSTRING_template;
single_value.field_raw__data->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @IP_Types.IP_ESP_tail_part.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IP__ESP__tail__part_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @IP_Types.IP_ESP_tail_part.");
}
}

boolean IP__ESP__tail__part_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IP__ESP__tail__part_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void IP__ESP__tail__part_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@IP_Types.IP_ESP_tail_part'");
    }
    if (strcmp("esp_null_tail", param_field) == 0) {
      esp__null__tail().set_param(param);
      return;
    } else if (strcmp("raw_data", param_field) == 0) {
      raw__data().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@IP_Types.IP_ESP_tail_part'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (param.get_size()==0) break;
    param.type_error("union template", "@IP_Types.IP_ESP_tail_part");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = param.get_elem(param.get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "esp_null_tail")) {
      esp__null__tail().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "raw_data")) {
      raw__data().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @IP_Types.IP_ESP_tail_part.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@IP_Types.IP_ESP_tail_part");
  }
  is_ifpresent = param.get_ifpresent();
}

void IP__ESP__tail__part_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case IP__ESP__tail__part::ALT_esp__null__tail:
single_value.field_esp__null__tail->check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_ESP_tail_part");
return;
case IP__ESP__tail__part::ALT_raw__data:
single_value.field_raw__data->check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_ESP_tail_part");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @IP_Types.IP_ESP_tail_part.");
}
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IP_ESP_tail_part");
}

IP__ESP__header::IP__ESP__header()
{
  bound_flag = FALSE;
}

IP__ESP__header::IP__ESP__header(const IP__ESP__header__part& par_header,
    const IP__ESP__tail__part& par_tail)
  :   field_header(par_header),
  field_tail(par_tail)
{
  bound_flag = TRUE;
}

IP__ESP__header::IP__ESP__header(const IP__ESP__header& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IP_ESP_header.");
bound_flag = TRUE;
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.tail().is_bound()) field_tail = other_value.tail();
else field_tail.clean_up();
}

void IP__ESP__header::clean_up()
{
field_header.clean_up();
field_tail.clean_up();
bound_flag = FALSE;
}

IP__ESP__header& IP__ESP__header::operator=(const IP__ESP__header& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.IP_ESP_header.");
  bound_flag = TRUE;
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.tail().is_bound()) field_tail = other_value.tail();
  else field_tail.clean_up();
}
return *this;
}

boolean IP__ESP__header::operator==(const IP__ESP__header& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_header==other_value.field_header
  && field_tail==other_value.field_tail;
}

boolean IP__ESP__header::is_bound() const
{
if (bound_flag) return TRUE;
if(field_header.is_bound()) return TRUE;
if(field_tail.is_bound()) return TRUE;
return FALSE;
}
boolean IP__ESP__header::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_header.is_value()) return FALSE;
if(!field_tail.is_value()) return FALSE;
return TRUE;
}
int IP__ESP__header::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.IP_ESP_header");
  return 2;
}

void IP__ESP__header::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", tail := ");
field_tail.log();
TTCN_Logger::log_event_str(" }");
}

void IP__ESP__header::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.IP_ESP_header'");
    }
    if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("tail", param_field) == 0) {
      tail().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.IP_ESP_header'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @IP_Types.IP_ESP_header has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) tail().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tail")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tail().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IP_ESP_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.IP_ESP_header");
  }
}

void IP__ESP__header::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (tail().is_bound()) tail().set_implicit_omit();
}

void IP__ESP__header::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.IP_ESP_header.");
field_header.encode_text(text_buf);
field_tail.encode_text(text_buf);
}

void IP__ESP__header::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_header.decode_text(text_buf);
field_tail.decode_text(text_buf);
}

void IP__ESP__header::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IP__ESP__header::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IP__ESP__header::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_header.RAW_decode(IP__ESP__header__part_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_tail.RAW_decode(IP__ESP__tail__part_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IP__ESP__header::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, IP__ESP__header__part_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, IP__ESP__tail__part_descr_.raw);
  encoded_length += field_header.RAW_encode(IP__ESP__header__part_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_tail.RAW_encode(IP__ESP__tail__part_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int IP__ESP__header::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IP_ESP_header.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "header");
    enc_len += field_header.JSON_encode(IP__ESP__header__part_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "tail");
    enc_len += field_tail.JSON_encode(IP__ESP__tail__part_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IP__ESP__header::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "header", name_len)) {
        int ret_val = field_header.JSON_decode(IP__ESP__header__part_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "header");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (4 == name_len && 0 == strncmp(fld_name, "tail", name_len)) {
        int ret_val = field_tail.JSON_decode(IP__ESP__tail__part_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "tail");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_header.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "header");
    return JSON_ERROR_FATAL;
  }
  if (!field_tail.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "tail");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct IP__ESP__header_template::single_value_struct {
IP__ESP__header__part_template field_header;
IP__ESP__tail__part_template field_tail;
};

void IP__ESP__header_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_tail = ANY_VALUE;
}
}
}

void IP__ESP__header_template::copy_value(const IP__ESP__header& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.tail().is_bound()) {
  single_value->field_tail = other_value.tail();
} else {
  single_value->field_tail.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IP__ESP__header_template::copy_template(const IP__ESP__header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.tail().get_selection()) {
single_value->field_tail = other_value.tail();
} else {
single_value->field_tail.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IP__ESP__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IP_ESP_header.");
break;
}
set_selection(other_value);
}

IP__ESP__header_template::IP__ESP__header_template()
{
}

IP__ESP__header_template::IP__ESP__header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IP__ESP__header_template::IP__ESP__header_template(const IP__ESP__header& other_value)
{
copy_value(other_value);
}

IP__ESP__header_template::IP__ESP__header_template(const OPTIONAL<IP__ESP__header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__ESP__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IP_ESP_header from an unbound optional field.");
}
}

IP__ESP__header_template::IP__ESP__header_template(const IP__ESP__header_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IP__ESP__header_template::~IP__ESP__header_template()
{
clean_up();
}

IP__ESP__header_template& IP__ESP__header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IP__ESP__header_template& IP__ESP__header_template::operator=(const IP__ESP__header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IP__ESP__header_template& IP__ESP__header_template::operator=(const OPTIONAL<IP__ESP__header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__ESP__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IP_ESP_header.");
}
return *this;
}

IP__ESP__header_template& IP__ESP__header_template::operator=(const IP__ESP__header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IP__ESP__header_template::match(const IP__ESP__header& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header()))return FALSE;
if(!other_value.tail().is_bound()) return FALSE;
if(!single_value->field_tail.match(other_value.tail()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.IP_ESP_header.");
}
return FALSE;
}

boolean IP__ESP__header_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_tail.is_bound()) return TRUE;
return FALSE;
}

boolean IP__ESP__header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_tail.is_value()) return FALSE;
return TRUE;
}

void IP__ESP__header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IP__ESP__header IP__ESP__header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.IP_ESP_header.");
IP__ESP__header ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_tail.is_bound()) {
ret_val.tail() = single_value->field_tail.valueof();
}
return ret_val;
}

void IP__ESP__header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.IP_ESP_header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IP__ESP__header_template[list_length];
}

IP__ESP__header_template& IP__ESP__header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.IP_ESP_header.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.IP_ESP_header.");
return value_list.list_value[list_index];
}

IP__ESP__header__part_template& IP__ESP__header_template::header()
{
set_specific();
return single_value->field_header;
}

const IP__ESP__header__part_template& IP__ESP__header_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @IP_Types.IP_ESP_header.");
return single_value->field_header;
}

IP__ESP__tail__part_template& IP__ESP__header_template::tail()
{
set_specific();
return single_value->field_tail;
}

const IP__ESP__tail__part_template& IP__ESP__header_template::tail() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field tail of a non-specific template of type @IP_Types.IP_ESP_header.");
return single_value->field_tail;
}

int IP__ESP__header_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_header which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.IP_ESP_header containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_header containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_header containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_header containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_ESP_header containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.IP_ESP_header.");
  }
  return 0;
}

void IP__ESP__header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", tail := ");
single_value->field_tail.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IP__ESP__header_template::log_match(const IP__ESP__header& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header())){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_tail.match(match_value.tail())){
TTCN_Logger::log_logmatch_info(".tail");
single_value->field_tail.log_match(match_value.tail());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header());
TTCN_Logger::log_event_str(", tail := ");
single_value->field_tail.log_match(match_value.tail());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IP__ESP__header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_tail.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IP_ESP_header.");
}
}

void IP__ESP__header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_tail.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IP__ESP__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.IP_ESP_header.");
}
}

void IP__ESP__header_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.IP_ESP_header'");
    }
    if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("tail", param_field) == 0) {
      tail().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.IP_ESP_header'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @IP_Types.IP_ESP_header has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) tail().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tail")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tail().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IP_ESP_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.IP_ESP_header");
  }
  is_ifpresent = param.get_ifpresent();
}

void IP__ESP__header_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_ESP_header");
single_value->field_tail.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_ESP_header");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IP_ESP_header");
}

boolean IP__ESP__header_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IP__ESP__header_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

IP__GRE2__header::IP__GRE2__header()
{
  bound_flag = FALSE;
}

IP__GRE2__header::IP__GRE2__header(const BITSTRING& par_c,
    const BITSTRING& par_reserved__bit,
    const BITSTRING& par_k,
    const BITSTRING& par_s,
    const BITSTRING& par_reserved0,
    const BITSTRING& par_version,
    const INTEGER& par_protocol__type,
    const OPTIONAL<INTEGER>& par_checksum,
    const OPTIONAL<INTEGER>& par_reserved1,
    const OPTIONAL<INTEGER>& par_key,
    const OPTIONAL<BITSTRING>& par_sn)
  :   field_c(par_c),
  field_reserved__bit(par_reserved__bit),
  field_k(par_k),
  field_s(par_s),
  field_reserved0(par_reserved0),
  field_version(par_version),
  field_protocol__type(par_protocol__type),
  field_checksum(par_checksum),
  field_reserved1(par_reserved1),
  field_key(par_key),
  field_sn(par_sn)
{
  bound_flag = TRUE;
}

IP__GRE2__header::IP__GRE2__header(const IP__GRE2__header& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IP_GRE2_header.");
bound_flag = TRUE;
if (other_value.c().is_bound()) field_c = other_value.c();
else field_c.clean_up();
if (other_value.reserved__bit().is_bound()) field_reserved__bit = other_value.reserved__bit();
else field_reserved__bit.clean_up();
if (other_value.k().is_bound()) field_k = other_value.k();
else field_k.clean_up();
if (other_value.s().is_bound()) field_s = other_value.s();
else field_s.clean_up();
if (other_value.reserved0().is_bound()) field_reserved0 = other_value.reserved0();
else field_reserved0.clean_up();
if (other_value.version().is_bound()) field_version = other_value.version();
else field_version.clean_up();
if (other_value.protocol__type().is_bound()) field_protocol__type = other_value.protocol__type();
else field_protocol__type.clean_up();
if (other_value.checksum().is_bound()) field_checksum = other_value.checksum();
else field_checksum.clean_up();
if (other_value.reserved1().is_bound()) field_reserved1 = other_value.reserved1();
else field_reserved1.clean_up();
if (other_value.key().is_bound()) field_key = other_value.key();
else field_key.clean_up();
if (other_value.sn().is_bound()) field_sn = other_value.sn();
else field_sn.clean_up();
}

void IP__GRE2__header::clean_up()
{
field_c.clean_up();
field_reserved__bit.clean_up();
field_k.clean_up();
field_s.clean_up();
field_reserved0.clean_up();
field_version.clean_up();
field_protocol__type.clean_up();
field_checksum.clean_up();
field_reserved1.clean_up();
field_key.clean_up();
field_sn.clean_up();
bound_flag = FALSE;
}

IP__GRE2__header& IP__GRE2__header::operator=(const IP__GRE2__header& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.IP_GRE2_header.");
  bound_flag = TRUE;
  if (other_value.c().is_bound()) field_c = other_value.c();
  else field_c.clean_up();
  if (other_value.reserved__bit().is_bound()) field_reserved__bit = other_value.reserved__bit();
  else field_reserved__bit.clean_up();
  if (other_value.k().is_bound()) field_k = other_value.k();
  else field_k.clean_up();
  if (other_value.s().is_bound()) field_s = other_value.s();
  else field_s.clean_up();
  if (other_value.reserved0().is_bound()) field_reserved0 = other_value.reserved0();
  else field_reserved0.clean_up();
  if (other_value.version().is_bound()) field_version = other_value.version();
  else field_version.clean_up();
  if (other_value.protocol__type().is_bound()) field_protocol__type = other_value.protocol__type();
  else field_protocol__type.clean_up();
  if (other_value.checksum().is_bound()) field_checksum = other_value.checksum();
  else field_checksum.clean_up();
  if (other_value.reserved1().is_bound()) field_reserved1 = other_value.reserved1();
  else field_reserved1.clean_up();
  if (other_value.key().is_bound()) field_key = other_value.key();
  else field_key.clean_up();
  if (other_value.sn().is_bound()) field_sn = other_value.sn();
  else field_sn.clean_up();
}
return *this;
}

boolean IP__GRE2__header::operator==(const IP__GRE2__header& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_c==other_value.field_c
  && field_reserved__bit==other_value.field_reserved__bit
  && field_k==other_value.field_k
  && field_s==other_value.field_s
  && field_reserved0==other_value.field_reserved0
  && field_version==other_value.field_version
  && field_protocol__type==other_value.field_protocol__type
  && field_checksum==other_value.field_checksum
  && field_reserved1==other_value.field_reserved1
  && field_key==other_value.field_key
  && field_sn==other_value.field_sn;
}

boolean IP__GRE2__header::is_bound() const
{
if (bound_flag) return TRUE;
if(field_c.is_bound()) return TRUE;
if(field_reserved__bit.is_bound()) return TRUE;
if(field_k.is_bound()) return TRUE;
if(field_s.is_bound()) return TRUE;
if(field_reserved0.is_bound()) return TRUE;
if(field_version.is_bound()) return TRUE;
if(field_protocol__type.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_checksum.get_selection() || field_checksum.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_reserved1.get_selection() || field_reserved1.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_key.get_selection() || field_key.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_sn.get_selection() || field_sn.is_bound()) return TRUE;
return FALSE;
}
boolean IP__GRE2__header::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_c.is_value()) return FALSE;
if(!field_reserved__bit.is_value()) return FALSE;
if(!field_k.is_value()) return FALSE;
if(!field_s.is_value()) return FALSE;
if(!field_reserved0.is_value()) return FALSE;
if(!field_version.is_value()) return FALSE;
if(!field_protocol__type.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_checksum.get_selection() && !field_checksum.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_reserved1.get_selection() && !field_reserved1.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_key.get_selection() && !field_key.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_sn.get_selection() && !field_sn.is_value()) return FALSE;
return TRUE;
}
int IP__GRE2__header::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.IP_GRE2_header");
  int ret_val = 7;
  if (field_checksum.ispresent()) ret_val++;
  if (field_reserved1.ispresent()) ret_val++;
  if (field_key.ispresent()) ret_val++;
  if (field_sn.ispresent()) ret_val++;
  return ret_val;
}

void IP__GRE2__header::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ c := ");
field_c.log();
TTCN_Logger::log_event_str(", reserved_bit := ");
field_reserved__bit.log();
TTCN_Logger::log_event_str(", k := ");
field_k.log();
TTCN_Logger::log_event_str(", s := ");
field_s.log();
TTCN_Logger::log_event_str(", reserved0 := ");
field_reserved0.log();
TTCN_Logger::log_event_str(", version := ");
field_version.log();
TTCN_Logger::log_event_str(", protocol_type := ");
field_protocol__type.log();
TTCN_Logger::log_event_str(", checksum := ");
field_checksum.log();
TTCN_Logger::log_event_str(", reserved1 := ");
field_reserved1.log();
TTCN_Logger::log_event_str(", key := ");
field_key.log();
TTCN_Logger::log_event_str(", sn := ");
field_sn.log();
TTCN_Logger::log_event_str(" }");
}

void IP__GRE2__header::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.IP_GRE2_header'");
    }
    if (strcmp("c", param_field) == 0) {
      c().set_param(param);
      return;
    } else if (strcmp("reserved_bit", param_field) == 0) {
      reserved__bit().set_param(param);
      return;
    } else if (strcmp("k", param_field) == 0) {
      k().set_param(param);
      return;
    } else if (strcmp("s", param_field) == 0) {
      s().set_param(param);
      return;
    } else if (strcmp("reserved0", param_field) == 0) {
      reserved0().set_param(param);
      return;
    } else if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("protocol_type", param_field) == 0) {
      protocol__type().set_param(param);
      return;
    } else if (strcmp("checksum", param_field) == 0) {
      checksum().set_param(param);
      return;
    } else if (strcmp("reserved1", param_field) == 0) {
      reserved1().set_param(param);
      return;
    } else if (strcmp("key", param_field) == 0) {
      key().set_param(param);
      return;
    } else if (strcmp("sn", param_field) == 0) {
      sn().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.IP_GRE2_header'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (11<param.get_size()) {
      param.error("record value of type @IP_Types.IP_GRE2_header has 11 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) c().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved__bit().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) k().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) s().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) reserved0().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) protocol__type().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) checksum().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) reserved1().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) key().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) sn().set_param(*param.get_elem(10));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "c")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          c().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "k")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          k().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "s")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          s().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved0")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved0().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protocol_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protocol__type().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "checksum")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          checksum().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved1")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved1().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IP_GRE2_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.IP_GRE2_header");
  }
}

void IP__GRE2__header::set_implicit_omit()
{
if (c().is_bound()) c().set_implicit_omit();
if (reserved__bit().is_bound()) reserved__bit().set_implicit_omit();
if (k().is_bound()) k().set_implicit_omit();
if (s().is_bound()) s().set_implicit_omit();
if (reserved0().is_bound()) reserved0().set_implicit_omit();
if (version().is_bound()) version().set_implicit_omit();
if (protocol__type().is_bound()) protocol__type().set_implicit_omit();
if (!checksum().is_bound()) checksum() = OMIT_VALUE;
else checksum().set_implicit_omit();
if (!reserved1().is_bound()) reserved1() = OMIT_VALUE;
else reserved1().set_implicit_omit();
if (!key().is_bound()) key() = OMIT_VALUE;
else key().set_implicit_omit();
if (!sn().is_bound()) sn() = OMIT_VALUE;
else sn().set_implicit_omit();
}

void IP__GRE2__header::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.IP_GRE2_header.");
field_c.encode_text(text_buf);
field_reserved__bit.encode_text(text_buf);
field_k.encode_text(text_buf);
field_s.encode_text(text_buf);
field_reserved0.encode_text(text_buf);
field_version.encode_text(text_buf);
field_protocol__type.encode_text(text_buf);
field_checksum.encode_text(text_buf);
field_reserved1.encode_text(text_buf);
field_key.encode_text(text_buf);
field_sn.encode_text(text_buf);
}

void IP__GRE2__header::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_c.decode_text(text_buf);
field_reserved__bit.decode_text(text_buf);
field_k.decode_text(text_buf);
field_s.decode_text(text_buf);
field_reserved0.decode_text(text_buf);
field_version.decode_text(text_buf);
field_protocol__type.decode_text(text_buf);
field_checksum.decode_text(text_buf);
field_reserved1.decode_text(text_buf);
field_key.decode_text(text_buf);
field_sn.decode_text(text_buf);
}

void IP__GRE2__header::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IP__GRE2__header::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IP__GRE2__header::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_c.RAW_decode(IP__GRE2__header_c_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved__bit.RAW_decode(IP__GRE2__header_reserved__bit_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_k.RAW_decode(IP__GRE2__header_k_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_s.RAW_decode(IP__GRE2__header_s_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved0.RAW_decode(IP__GRE2__header_reserved0_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_version.RAW_decode(IP__GRE2__header_version_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_protocol__type.RAW_decode(IP__GRE2__header_protocol__type_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0 && field_c ==  bs_0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_checksum().RAW_decode(IP__GRE2__header_checksum_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_checksum = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_checksum=OMIT_VALUE;
  if (limit > 0 && field_c ==  bs_0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_reserved1().RAW_decode(IP__GRE2__header_reserved1_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_reserved1 = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_reserved1=OMIT_VALUE;
  if (limit > 0 && field_k ==  bs_0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_key().RAW_decode(IP__GRE2__header_key_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_key = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_key=OMIT_VALUE;
  if (limit > 0 && field_s ==  bs_0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_sn().RAW_decode(IP__GRE2__header_sn_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_sn = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_sn=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IP__GRE2__header::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 11;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(11);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, IP__GRE2__header_c_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, IP__GRE2__header_reserved__bit_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, IP__GRE2__header_k_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, IP__GRE2__header_s_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, IP__GRE2__header_reserved0_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, IP__GRE2__header_version_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, IP__GRE2__header_protocol__type_descr_.raw);
  if (field_checksum.ispresent()) {
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, IP__GRE2__header_checksum_descr_.raw);
  }
  else myleaf.body.node.nodes[7] = NULL;
  if (field_reserved1.ispresent()) {
  myleaf.body.node.nodes[8] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 8, IP__GRE2__header_reserved1_descr_.raw);
  }
  else myleaf.body.node.nodes[8] = NULL;
  if (field_key.ispresent()) {
  myleaf.body.node.nodes[9] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 9, IP__GRE2__header_key_descr_.raw);
  }
  else myleaf.body.node.nodes[9] = NULL;
  if (field_sn.ispresent()) {
  myleaf.body.node.nodes[10] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 10, IP__GRE2__header_sn_descr_.raw);
  }
  else myleaf.body.node.nodes[10] = NULL;
  encoded_length += field_c.RAW_encode(IP__GRE2__header_c_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_reserved__bit.RAW_encode(IP__GRE2__header_reserved__bit_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_k.RAW_encode(IP__GRE2__header_k_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_s.RAW_encode(IP__GRE2__header_s_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_reserved0.RAW_encode(IP__GRE2__header_reserved0_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_version.RAW_encode(IP__GRE2__header_version_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_protocol__type.RAW_encode(IP__GRE2__header_protocol__type_descr_, *myleaf.body.node.nodes[6]);
  if (field_checksum.ispresent()) {
  encoded_length += field_checksum().RAW_encode(IP__GRE2__header_checksum_descr_, *myleaf.body.node.nodes[7]);
  }
  if (field_reserved1.ispresent()) {
  encoded_length += field_reserved1().RAW_encode(IP__GRE2__header_reserved1_descr_, *myleaf.body.node.nodes[8]);
  }
  if (field_key.ispresent()) {
  encoded_length += field_key().RAW_encode(IP__GRE2__header_key_descr_, *myleaf.body.node.nodes[9]);
  }
  if (field_sn.ispresent()) {
  encoded_length += field_sn().RAW_encode(IP__GRE2__header_sn_descr_, *myleaf.body.node.nodes[10]);
  }
  if (field_checksum.ispresent() && (field_c !=  bs_0)) {
  RAW_enc_tree* temp_leaf;
  {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level=myleaf.curr_pos.level+1;
  int new_pos[]={0};
  pr_pos.pos=init_new_tree_pos(myleaf.curr_pos,1,new_pos);
  temp_leaf = myleaf.get_node(pr_pos);
  if(temp_leaf != NULL){
   bs_0.RAW_encode(IP__GRE2__header_c_descr_,*temp_leaf);
  } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  }
  free_tree_pos(pr_pos.pos);
  }
  }
  if (field_reserved1.ispresent() && (field_c !=  bs_0)) {
  RAW_enc_tree* temp_leaf;
  {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level=myleaf.curr_pos.level+1;
  int new_pos[]={0};
  pr_pos.pos=init_new_tree_pos(myleaf.curr_pos,1,new_pos);
  temp_leaf = myleaf.get_node(pr_pos);
  if(temp_leaf != NULL){
   bs_0.RAW_encode(IP__GRE2__header_c_descr_,*temp_leaf);
  } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  }
  free_tree_pos(pr_pos.pos);
  }
  }
  if (field_key.ispresent() && (field_k !=  bs_0)) {
  RAW_enc_tree* temp_leaf;
  {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level=myleaf.curr_pos.level+1;
  int new_pos[]={2};
  pr_pos.pos=init_new_tree_pos(myleaf.curr_pos,1,new_pos);
  temp_leaf = myleaf.get_node(pr_pos);
  if(temp_leaf != NULL){
   bs_0.RAW_encode(IP__GRE2__header_k_descr_,*temp_leaf);
  } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  }
  free_tree_pos(pr_pos.pos);
  }
  }
  if (field_sn.ispresent() && (field_s !=  bs_0)) {
  RAW_enc_tree* temp_leaf;
  {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level=myleaf.curr_pos.level+1;
  int new_pos[]={3};
  pr_pos.pos=init_new_tree_pos(myleaf.curr_pos,1,new_pos);
  temp_leaf = myleaf.get_node(pr_pos);
  if(temp_leaf != NULL){
   bs_0.RAW_encode(IP__GRE2__header_s_descr_,*temp_leaf);
  } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  }
  free_tree_pos(pr_pos.pos);
  }
  }
  return myleaf.length = encoded_length;
}

int IP__GRE2__header::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IP_GRE2_header.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "c");
    enc_len += field_c.JSON_encode(IP__GRE2__header_c_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved_bit");
    enc_len += field_reserved__bit.JSON_encode(IP__GRE2__header_reserved__bit_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "k");
    enc_len += field_k.JSON_encode(IP__GRE2__header_k_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "s");
    enc_len += field_s.JSON_encode(IP__GRE2__header_s_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved0");
    enc_len += field_reserved0.JSON_encode(IP__GRE2__header_reserved0_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "version");
    enc_len += field_version.JSON_encode(IP__GRE2__header_version_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protocol_type");
    enc_len += field_protocol__type.JSON_encode(IP__GRE2__header_protocol__type_descr_, p_tok);
  }

  if (field_checksum.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "checksum");
    enc_len += field_checksum.JSON_encode(IP__GRE2__header_checksum_descr_, p_tok);
  }

  if (field_reserved1.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved1");
    enc_len += field_reserved1.JSON_encode(IP__GRE2__header_reserved1_descr_, p_tok);
  }

  if (field_key.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "key");
    enc_len += field_key.JSON_encode(IP__GRE2__header_key_descr_, p_tok);
  }

  if (field_sn.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "sn");
    enc_len += field_sn.JSON_encode(IP__GRE2__header_sn_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IP__GRE2__header::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (1 == name_len && 0 == strncmp(fld_name, "c", name_len)) {
        int ret_val = field_c.JSON_decode(IP__GRE2__header_c_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "c");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (12 == name_len && 0 == strncmp(fld_name, "reserved_bit", name_len)) {
        int ret_val = field_reserved__bit.JSON_decode(IP__GRE2__header_reserved__bit_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved_bit");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (1 == name_len && 0 == strncmp(fld_name, "k", name_len)) {
        int ret_val = field_k.JSON_decode(IP__GRE2__header_k_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "k");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (1 == name_len && 0 == strncmp(fld_name, "s", name_len)) {
        int ret_val = field_s.JSON_decode(IP__GRE2__header_s_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "s");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (9 == name_len && 0 == strncmp(fld_name, "reserved0", name_len)) {
        int ret_val = field_reserved0.JSON_decode(IP__GRE2__header_reserved0_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved0");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (7 == name_len && 0 == strncmp(fld_name, "version", name_len)) {
        int ret_val = field_version.JSON_decode(IP__GRE2__header_version_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "version");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (13 == name_len && 0 == strncmp(fld_name, "protocol_type", name_len)) {
        int ret_val = field_protocol__type.JSON_decode(IP__GRE2__header_protocol__type_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protocol_type");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (8 == name_len && 0 == strncmp(fld_name, "checksum", name_len)) {
        int ret_val = field_checksum.JSON_decode(IP__GRE2__header_checksum_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "checksum");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (9 == name_len && 0 == strncmp(fld_name, "reserved1", name_len)) {
        int ret_val = field_reserved1.JSON_decode(IP__GRE2__header_reserved1_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved1");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (3 == name_len && 0 == strncmp(fld_name, "key", name_len)) {
        int ret_val = field_key.JSON_decode(IP__GRE2__header_key_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "key");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (2 == name_len && 0 == strncmp(fld_name, "sn", name_len)) {
        int ret_val = field_sn.JSON_decode(IP__GRE2__header_sn_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "sn");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_c.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "c");
    return JSON_ERROR_FATAL;
  }
  if (!field_reserved__bit.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved_bit");
    return JSON_ERROR_FATAL;
  }
  if (!field_k.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "k");
    return JSON_ERROR_FATAL;
  }
  if (!field_s.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "s");
    return JSON_ERROR_FATAL;
  }
  if (!field_reserved0.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved0");
    return JSON_ERROR_FATAL;
  }
  if (!field_version.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "version");
    return JSON_ERROR_FATAL;
  }
  if (!field_protocol__type.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "protocol_type");
    return JSON_ERROR_FATAL;
  }
  if (!field_checksum.is_bound()) {
    field_checksum = OMIT_VALUE;
  }
  if (!field_reserved1.is_bound()) {
    field_reserved1 = OMIT_VALUE;
  }
  if (!field_key.is_bound()) {
    field_key = OMIT_VALUE;
  }
  if (!field_sn.is_bound()) {
    field_sn = OMIT_VALUE;
  }

  return dec_len;
}

struct IP__GRE2__header_template::single_value_struct {
BITSTRING_template field_c;
BITSTRING_template field_reserved__bit;
BITSTRING_template field_k;
BITSTRING_template field_s;
BITSTRING_template field_reserved0;
BITSTRING_template field_version;
INTEGER_template field_protocol__type;
INTEGER_template field_checksum;
INTEGER_template field_reserved1;
INTEGER_template field_key;
BITSTRING_template field_sn;
};

void IP__GRE2__header_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_c = ANY_VALUE;
single_value->field_reserved__bit = ANY_VALUE;
single_value->field_k = ANY_VALUE;
single_value->field_s = ANY_VALUE;
single_value->field_reserved0 = ANY_VALUE;
single_value->field_version = ANY_VALUE;
single_value->field_protocol__type = ANY_VALUE;
single_value->field_checksum = ANY_OR_OMIT;
single_value->field_reserved1 = ANY_OR_OMIT;
single_value->field_key = ANY_OR_OMIT;
single_value->field_sn = ANY_OR_OMIT;
}
}
}

void IP__GRE2__header_template::copy_value(const IP__GRE2__header& other_value)
{
single_value = new single_value_struct;
if (other_value.c().is_bound()) {
  single_value->field_c = other_value.c();
} else {
  single_value->field_c.clean_up();
}
if (other_value.reserved__bit().is_bound()) {
  single_value->field_reserved__bit = other_value.reserved__bit();
} else {
  single_value->field_reserved__bit.clean_up();
}
if (other_value.k().is_bound()) {
  single_value->field_k = other_value.k();
} else {
  single_value->field_k.clean_up();
}
if (other_value.s().is_bound()) {
  single_value->field_s = other_value.s();
} else {
  single_value->field_s.clean_up();
}
if (other_value.reserved0().is_bound()) {
  single_value->field_reserved0 = other_value.reserved0();
} else {
  single_value->field_reserved0.clean_up();
}
if (other_value.version().is_bound()) {
  single_value->field_version = other_value.version();
} else {
  single_value->field_version.clean_up();
}
if (other_value.protocol__type().is_bound()) {
  single_value->field_protocol__type = other_value.protocol__type();
} else {
  single_value->field_protocol__type.clean_up();
}
if (other_value.checksum().is_bound()) {
  if (other_value.checksum().ispresent()) single_value->field_checksum = other_value.checksum()();
  else single_value->field_checksum = OMIT_VALUE;
} else {
  single_value->field_checksum.clean_up();
}
if (other_value.reserved1().is_bound()) {
  if (other_value.reserved1().ispresent()) single_value->field_reserved1 = other_value.reserved1()();
  else single_value->field_reserved1 = OMIT_VALUE;
} else {
  single_value->field_reserved1.clean_up();
}
if (other_value.key().is_bound()) {
  if (other_value.key().ispresent()) single_value->field_key = other_value.key()();
  else single_value->field_key = OMIT_VALUE;
} else {
  single_value->field_key.clean_up();
}
if (other_value.sn().is_bound()) {
  if (other_value.sn().ispresent()) single_value->field_sn = other_value.sn()();
  else single_value->field_sn = OMIT_VALUE;
} else {
  single_value->field_sn.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IP__GRE2__header_template::copy_template(const IP__GRE2__header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.c().get_selection()) {
single_value->field_c = other_value.c();
} else {
single_value->field_c.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved__bit().get_selection()) {
single_value->field_reserved__bit = other_value.reserved__bit();
} else {
single_value->field_reserved__bit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.k().get_selection()) {
single_value->field_k = other_value.k();
} else {
single_value->field_k.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.s().get_selection()) {
single_value->field_s = other_value.s();
} else {
single_value->field_s.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved0().get_selection()) {
single_value->field_reserved0 = other_value.reserved0();
} else {
single_value->field_reserved0.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.version().get_selection()) {
single_value->field_version = other_value.version();
} else {
single_value->field_version.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.protocol__type().get_selection()) {
single_value->field_protocol__type = other_value.protocol__type();
} else {
single_value->field_protocol__type.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.checksum().get_selection()) {
single_value->field_checksum = other_value.checksum();
} else {
single_value->field_checksum.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved1().get_selection()) {
single_value->field_reserved1 = other_value.reserved1();
} else {
single_value->field_reserved1.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.key().get_selection()) {
single_value->field_key = other_value.key();
} else {
single_value->field_key.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sn().get_selection()) {
single_value->field_sn = other_value.sn();
} else {
single_value->field_sn.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IP__GRE2__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IP_GRE2_header.");
break;
}
set_selection(other_value);
}

IP__GRE2__header_template::IP__GRE2__header_template()
{
}

IP__GRE2__header_template::IP__GRE2__header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IP__GRE2__header_template::IP__GRE2__header_template(const IP__GRE2__header& other_value)
{
copy_value(other_value);
}

IP__GRE2__header_template::IP__GRE2__header_template(const OPTIONAL<IP__GRE2__header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__GRE2__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IP_GRE2_header from an unbound optional field.");
}
}

IP__GRE2__header_template::IP__GRE2__header_template(const IP__GRE2__header_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IP__GRE2__header_template::~IP__GRE2__header_template()
{
clean_up();
}

IP__GRE2__header_template& IP__GRE2__header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IP__GRE2__header_template& IP__GRE2__header_template::operator=(const IP__GRE2__header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IP__GRE2__header_template& IP__GRE2__header_template::operator=(const OPTIONAL<IP__GRE2__header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IP__GRE2__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IP_GRE2_header.");
}
return *this;
}

IP__GRE2__header_template& IP__GRE2__header_template::operator=(const IP__GRE2__header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IP__GRE2__header_template::match(const IP__GRE2__header& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.c().is_bound()) return FALSE;
if(!single_value->field_c.match(other_value.c()))return FALSE;
if(!other_value.reserved__bit().is_bound()) return FALSE;
if(!single_value->field_reserved__bit.match(other_value.reserved__bit()))return FALSE;
if(!other_value.k().is_bound()) return FALSE;
if(!single_value->field_k.match(other_value.k()))return FALSE;
if(!other_value.s().is_bound()) return FALSE;
if(!single_value->field_s.match(other_value.s()))return FALSE;
if(!other_value.reserved0().is_bound()) return FALSE;
if(!single_value->field_reserved0.match(other_value.reserved0()))return FALSE;
if(!other_value.version().is_bound()) return FALSE;
if(!single_value->field_version.match(other_value.version()))return FALSE;
if(!other_value.protocol__type().is_bound()) return FALSE;
if(!single_value->field_protocol__type.match(other_value.protocol__type()))return FALSE;
if(!other_value.checksum().is_bound()) return FALSE;
if((other_value.checksum().ispresent() ? !single_value->field_checksum.match((const INTEGER&)other_value.checksum()) : !single_value->field_checksum.match_omit()))return FALSE;
if(!other_value.reserved1().is_bound()) return FALSE;
if((other_value.reserved1().ispresent() ? !single_value->field_reserved1.match((const INTEGER&)other_value.reserved1()) : !single_value->field_reserved1.match_omit()))return FALSE;
if(!other_value.key().is_bound()) return FALSE;
if((other_value.key().ispresent() ? !single_value->field_key.match((const INTEGER&)other_value.key()) : !single_value->field_key.match_omit()))return FALSE;
if(!other_value.sn().is_bound()) return FALSE;
if((other_value.sn().ispresent() ? !single_value->field_sn.match((const BITSTRING&)other_value.sn()) : !single_value->field_sn.match_omit()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.IP_GRE2_header.");
}
return FALSE;
}

boolean IP__GRE2__header_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_c.is_bound()) return TRUE;
if (single_value->field_reserved__bit.is_bound()) return TRUE;
if (single_value->field_k.is_bound()) return TRUE;
if (single_value->field_s.is_bound()) return TRUE;
if (single_value->field_reserved0.is_bound()) return TRUE;
if (single_value->field_version.is_bound()) return TRUE;
if (single_value->field_protocol__type.is_bound()) return TRUE;
if (single_value->field_checksum.is_omit() || single_value->field_checksum.is_bound()) return TRUE;
if (single_value->field_reserved1.is_omit() || single_value->field_reserved1.is_bound()) return TRUE;
if (single_value->field_key.is_omit() || single_value->field_key.is_bound()) return TRUE;
if (single_value->field_sn.is_omit() || single_value->field_sn.is_bound()) return TRUE;
return FALSE;
}

boolean IP__GRE2__header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_c.is_value()) return FALSE;
if (!single_value->field_reserved__bit.is_value()) return FALSE;
if (!single_value->field_k.is_value()) return FALSE;
if (!single_value->field_s.is_value()) return FALSE;
if (!single_value->field_reserved0.is_value()) return FALSE;
if (!single_value->field_version.is_value()) return FALSE;
if (!single_value->field_protocol__type.is_value()) return FALSE;
if (!single_value->field_checksum.is_omit() && !single_value->field_checksum.is_value()) return FALSE;
if (!single_value->field_reserved1.is_omit() && !single_value->field_reserved1.is_value()) return FALSE;
if (!single_value->field_key.is_omit() && !single_value->field_key.is_value()) return FALSE;
if (!single_value->field_sn.is_omit() && !single_value->field_sn.is_value()) return FALSE;
return TRUE;
}

void IP__GRE2__header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IP__GRE2__header IP__GRE2__header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.IP_GRE2_header.");
IP__GRE2__header ret_val;
if (single_value->field_c.is_bound()) {
ret_val.c() = single_value->field_c.valueof();
}
if (single_value->field_reserved__bit.is_bound()) {
ret_val.reserved__bit() = single_value->field_reserved__bit.valueof();
}
if (single_value->field_k.is_bound()) {
ret_val.k() = single_value->field_k.valueof();
}
if (single_value->field_s.is_bound()) {
ret_val.s() = single_value->field_s.valueof();
}
if (single_value->field_reserved0.is_bound()) {
ret_val.reserved0() = single_value->field_reserved0.valueof();
}
if (single_value->field_version.is_bound()) {
ret_val.version() = single_value->field_version.valueof();
}
if (single_value->field_protocol__type.is_bound()) {
ret_val.protocol__type() = single_value->field_protocol__type.valueof();
}
if (single_value->field_checksum.is_omit()) ret_val.checksum() = OMIT_VALUE;
else if (single_value->field_checksum.is_bound()) {
ret_val.checksum() = single_value->field_checksum.valueof();
}
if (single_value->field_reserved1.is_omit()) ret_val.reserved1() = OMIT_VALUE;
else if (single_value->field_reserved1.is_bound()) {
ret_val.reserved1() = single_value->field_reserved1.valueof();
}
if (single_value->field_key.is_omit()) ret_val.key() = OMIT_VALUE;
else if (single_value->field_key.is_bound()) {
ret_val.key() = single_value->field_key.valueof();
}
if (single_value->field_sn.is_omit()) ret_val.sn() = OMIT_VALUE;
else if (single_value->field_sn.is_bound()) {
ret_val.sn() = single_value->field_sn.valueof();
}
return ret_val;
}

void IP__GRE2__header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.IP_GRE2_header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IP__GRE2__header_template[list_length];
}

IP__GRE2__header_template& IP__GRE2__header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.IP_GRE2_header.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.IP_GRE2_header.");
return value_list.list_value[list_index];
}

BITSTRING_template& IP__GRE2__header_template::c()
{
set_specific();
return single_value->field_c;
}

const BITSTRING_template& IP__GRE2__header_template::c() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field c of a non-specific template of type @IP_Types.IP_GRE2_header.");
return single_value->field_c;
}

BITSTRING_template& IP__GRE2__header_template::reserved__bit()
{
set_specific();
return single_value->field_reserved__bit;
}

const BITSTRING_template& IP__GRE2__header_template::reserved__bit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved_bit of a non-specific template of type @IP_Types.IP_GRE2_header.");
return single_value->field_reserved__bit;
}

BITSTRING_template& IP__GRE2__header_template::k()
{
set_specific();
return single_value->field_k;
}

const BITSTRING_template& IP__GRE2__header_template::k() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field k of a non-specific template of type @IP_Types.IP_GRE2_header.");
return single_value->field_k;
}

BITSTRING_template& IP__GRE2__header_template::s()
{
set_specific();
return single_value->field_s;
}

const BITSTRING_template& IP__GRE2__header_template::s() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field s of a non-specific template of type @IP_Types.IP_GRE2_header.");
return single_value->field_s;
}

BITSTRING_template& IP__GRE2__header_template::reserved0()
{
set_specific();
return single_value->field_reserved0;
}

const BITSTRING_template& IP__GRE2__header_template::reserved0() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved0 of a non-specific template of type @IP_Types.IP_GRE2_header.");
return single_value->field_reserved0;
}

BITSTRING_template& IP__GRE2__header_template::version()
{
set_specific();
return single_value->field_version;
}

const BITSTRING_template& IP__GRE2__header_template::version() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field version of a non-specific template of type @IP_Types.IP_GRE2_header.");
return single_value->field_version;
}

INTEGER_template& IP__GRE2__header_template::protocol__type()
{
set_specific();
return single_value->field_protocol__type;
}

const INTEGER_template& IP__GRE2__header_template::protocol__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protocol_type of a non-specific template of type @IP_Types.IP_GRE2_header.");
return single_value->field_protocol__type;
}

INTEGER_template& IP__GRE2__header_template::checksum()
{
set_specific();
return single_value->field_checksum;
}

const INTEGER_template& IP__GRE2__header_template::checksum() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field checksum of a non-specific template of type @IP_Types.IP_GRE2_header.");
return single_value->field_checksum;
}

INTEGER_template& IP__GRE2__header_template::reserved1()
{
set_specific();
return single_value->field_reserved1;
}

const INTEGER_template& IP__GRE2__header_template::reserved1() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved1 of a non-specific template of type @IP_Types.IP_GRE2_header.");
return single_value->field_reserved1;
}

INTEGER_template& IP__GRE2__header_template::key()
{
set_specific();
return single_value->field_key;
}

const INTEGER_template& IP__GRE2__header_template::key() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field key of a non-specific template of type @IP_Types.IP_GRE2_header.");
return single_value->field_key;
}

BITSTRING_template& IP__GRE2__header_template::sn()
{
set_specific();
return single_value->field_sn;
}

const BITSTRING_template& IP__GRE2__header_template::sn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sn of a non-specific template of type @IP_Types.IP_GRE2_header.");
return single_value->field_sn;
}

int IP__GRE2__header_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_GRE2_header which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 7;
      if (single_value->field_checksum.is_present()) ret_val++;
      if (single_value->field_reserved1.is_present()) ret_val++;
      if (single_value->field_key.is_present()) ret_val++;
      if (single_value->field_sn.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.IP_GRE2_header containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_GRE2_header containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_GRE2_header containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_GRE2_header containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IP_GRE2_header containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.IP_GRE2_header.");
  }
  return 0;
}

void IP__GRE2__header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ c := ");
single_value->field_c.log();
TTCN_Logger::log_event_str(", reserved_bit := ");
single_value->field_reserved__bit.log();
TTCN_Logger::log_event_str(", k := ");
single_value->field_k.log();
TTCN_Logger::log_event_str(", s := ");
single_value->field_s.log();
TTCN_Logger::log_event_str(", reserved0 := ");
single_value->field_reserved0.log();
TTCN_Logger::log_event_str(", version := ");
single_value->field_version.log();
TTCN_Logger::log_event_str(", protocol_type := ");
single_value->field_protocol__type.log();
TTCN_Logger::log_event_str(", checksum := ");
single_value->field_checksum.log();
TTCN_Logger::log_event_str(", reserved1 := ");
single_value->field_reserved1.log();
TTCN_Logger::log_event_str(", key := ");
single_value->field_key.log();
TTCN_Logger::log_event_str(", sn := ");
single_value->field_sn.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IP__GRE2__header_template::log_match(const IP__GRE2__header& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_c.match(match_value.c())){
TTCN_Logger::log_logmatch_info(".c");
single_value->field_c.log_match(match_value.c());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved__bit.match(match_value.reserved__bit())){
TTCN_Logger::log_logmatch_info(".reserved_bit");
single_value->field_reserved__bit.log_match(match_value.reserved__bit());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_k.match(match_value.k())){
TTCN_Logger::log_logmatch_info(".k");
single_value->field_k.log_match(match_value.k());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_s.match(match_value.s())){
TTCN_Logger::log_logmatch_info(".s");
single_value->field_s.log_match(match_value.s());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved0.match(match_value.reserved0())){
TTCN_Logger::log_logmatch_info(".reserved0");
single_value->field_reserved0.log_match(match_value.reserved0());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_version.match(match_value.version())){
TTCN_Logger::log_logmatch_info(".version");
single_value->field_version.log_match(match_value.version());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_protocol__type.match(match_value.protocol__type())){
TTCN_Logger::log_logmatch_info(".protocol_type");
single_value->field_protocol__type.log_match(match_value.protocol__type());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.checksum().ispresent()){
if(!single_value->field_checksum.match(match_value.checksum())){
TTCN_Logger::log_logmatch_info(".checksum");
single_value->field_checksum.log_match(match_value.checksum());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_checksum.match_omit()){
 TTCN_Logger::log_logmatch_info(".checksum := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_checksum.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.reserved1().ispresent()){
if(!single_value->field_reserved1.match(match_value.reserved1())){
TTCN_Logger::log_logmatch_info(".reserved1");
single_value->field_reserved1.log_match(match_value.reserved1());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_reserved1.match_omit()){
 TTCN_Logger::log_logmatch_info(".reserved1 := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_reserved1.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.key().ispresent()){
if(!single_value->field_key.match(match_value.key())){
TTCN_Logger::log_logmatch_info(".key");
single_value->field_key.log_match(match_value.key());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_key.match_omit()){
 TTCN_Logger::log_logmatch_info(".key := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_key.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.sn().ispresent()){
if(!single_value->field_sn.match(match_value.sn())){
TTCN_Logger::log_logmatch_info(".sn");
single_value->field_sn.log_match(match_value.sn());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sn.match_omit()){
 TTCN_Logger::log_logmatch_info(".sn := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sn.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ c := ");
single_value->field_c.log_match(match_value.c());
TTCN_Logger::log_event_str(", reserved_bit := ");
single_value->field_reserved__bit.log_match(match_value.reserved__bit());
TTCN_Logger::log_event_str(", k := ");
single_value->field_k.log_match(match_value.k());
TTCN_Logger::log_event_str(", s := ");
single_value->field_s.log_match(match_value.s());
TTCN_Logger::log_event_str(", reserved0 := ");
single_value->field_reserved0.log_match(match_value.reserved0());
TTCN_Logger::log_event_str(", version := ");
single_value->field_version.log_match(match_value.version());
TTCN_Logger::log_event_str(", protocol_type := ");
single_value->field_protocol__type.log_match(match_value.protocol__type());
TTCN_Logger::log_event_str(", checksum := ");
if (match_value.checksum().ispresent()) single_value->field_checksum.log_match(match_value.checksum());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_checksum.log();
if (single_value->field_checksum.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", reserved1 := ");
if (match_value.reserved1().ispresent()) single_value->field_reserved1.log_match(match_value.reserved1());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_reserved1.log();
if (single_value->field_reserved1.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", key := ");
if (match_value.key().ispresent()) single_value->field_key.log_match(match_value.key());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_key.log();
if (single_value->field_key.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", sn := ");
if (match_value.sn().ispresent()) single_value->field_sn.log_match(match_value.sn());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sn.log();
if (single_value->field_sn.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IP__GRE2__header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_c.encode_text(text_buf);
single_value->field_reserved__bit.encode_text(text_buf);
single_value->field_k.encode_text(text_buf);
single_value->field_s.encode_text(text_buf);
single_value->field_reserved0.encode_text(text_buf);
single_value->field_version.encode_text(text_buf);
single_value->field_protocol__type.encode_text(text_buf);
single_value->field_checksum.encode_text(text_buf);
single_value->field_reserved1.encode_text(text_buf);
single_value->field_key.encode_text(text_buf);
single_value->field_sn.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IP_GRE2_header.");
}
}

void IP__GRE2__header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_c.decode_text(text_buf);
single_value->field_reserved__bit.decode_text(text_buf);
single_value->field_k.decode_text(text_buf);
single_value->field_s.decode_text(text_buf);
single_value->field_reserved0.decode_text(text_buf);
single_value->field_version.decode_text(text_buf);
single_value->field_protocol__type.decode_text(text_buf);
single_value->field_checksum.decode_text(text_buf);
single_value->field_reserved1.decode_text(text_buf);
single_value->field_key.decode_text(text_buf);
single_value->field_sn.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IP__GRE2__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.IP_GRE2_header.");
}
}

void IP__GRE2__header_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.IP_GRE2_header'");
    }
    if (strcmp("c", param_field) == 0) {
      c().set_param(param);
      return;
    } else if (strcmp("reserved_bit", param_field) == 0) {
      reserved__bit().set_param(param);
      return;
    } else if (strcmp("k", param_field) == 0) {
      k().set_param(param);
      return;
    } else if (strcmp("s", param_field) == 0) {
      s().set_param(param);
      return;
    } else if (strcmp("reserved0", param_field) == 0) {
      reserved0().set_param(param);
      return;
    } else if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("protocol_type", param_field) == 0) {
      protocol__type().set_param(param);
      return;
    } else if (strcmp("checksum", param_field) == 0) {
      checksum().set_param(param);
      return;
    } else if (strcmp("reserved1", param_field) == 0) {
      reserved1().set_param(param);
      return;
    } else if (strcmp("key", param_field) == 0) {
      key().set_param(param);
      return;
    } else if (strcmp("sn", param_field) == 0) {
      sn().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.IP_GRE2_header'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (11<param.get_size()) {
      param.error("record template of type @IP_Types.IP_GRE2_header has 11 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) c().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved__bit().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) k().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) s().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) reserved0().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) protocol__type().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) checksum().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) reserved1().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) key().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) sn().set_param(*param.get_elem(10));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "c")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          c().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved_bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved__bit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "k")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          k().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "s")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          s().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved0")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved0().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protocol_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protocol__type().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "checksum")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          checksum().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved1")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved1().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IP_GRE2_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.IP_GRE2_header");
  }
  is_ifpresent = param.get_ifpresent();
}

void IP__GRE2__header_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_c.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_GRE2_header");
single_value->field_reserved__bit.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_GRE2_header");
single_value->field_k.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_GRE2_header");
single_value->field_s.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_GRE2_header");
single_value->field_reserved0.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_GRE2_header");
single_value->field_version.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_GRE2_header");
single_value->field_protocol__type.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_GRE2_header");
single_value->field_checksum.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_GRE2_header");
single_value->field_reserved1.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_GRE2_header");
single_value->field_key.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_GRE2_header");
single_value->field_sn.check_restriction(t_res, t_name ? t_name : "@IP_Types.IP_GRE2_header");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IP_GRE2_header");
}

boolean IP__GRE2__header_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IP__GRE2__header_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}


const IPv4__extension__header IPv4__extension__headers::UNBOUND_ELEM;
IPv4__extension__headers::IPv4__extension__headers()
{
val_ptr = NULL;
}

IPv4__extension__headers::IPv4__extension__headers(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

IPv4__extension__headers::IPv4__extension__headers(const IPv4__extension__headers& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IPv4_extension_headers.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

IPv4__extension__headers::~IPv4__extension__headers()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void IPv4__extension__headers::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

IPv4__extension__headers& IPv4__extension__headers::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

IPv4__extension__headers& IPv4__extension__headers::operator=(const IPv4__extension__headers& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @IP_Types.IPv4_extension_headers.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean IPv4__extension__headers::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @IP_Types.IPv4_extension_headers.");
return val_ptr->n_elements == 0 ;
}

boolean IPv4__extension__headers::operator==(const IPv4__extension__headers& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @IP_Types.IPv4_extension_headers.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @IP_Types.IPv4_extension_headers.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

IPv4__extension__header& IPv4__extension__headers::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @IP_Types.IPv4_extension_headers using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (IPv4__extension__header**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new IPv4__extension__header(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new IPv4__extension__header;
}
return *val_ptr->value_elements[index_value];
}

IPv4__extension__header& IPv4__extension__headers::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @IP_Types.IPv4_extension_headers.");
return (*this)[(int)index_value];
}

const IPv4__extension__header& IPv4__extension__headers::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @IP_Types.IPv4_extension_headers.");
if (index_value < 0) TTCN_error("Accessing an element of type @IP_Types.IPv4_extension_headers using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @IP_Types.IPv4_extension_headers: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const IPv4__extension__header& IPv4__extension__headers::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @IP_Types.IPv4_extension_headers.");
return (*this)[(int)index_value];
}

IPv4__extension__headers IPv4__extension__headers::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

IPv4__extension__headers IPv4__extension__headers::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

IPv4__extension__headers IPv4__extension__headers::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

IPv4__extension__headers IPv4__extension__headers::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @IP_Types.IPv4_extension_headers.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
IPv4__extension__headers ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new IPv4__extension__header(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

IPv4__extension__headers IPv4__extension__headers::operator+(const IPv4__extension__headers& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @IP_Types.IPv4_extension_headers concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
IPv4__extension__headers ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new IPv4__extension__header(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new IPv4__extension__header(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

IPv4__extension__headers IPv4__extension__headers::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @IP_Types.IPv4_extension_headers.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@IP_Types.IPv4_extension_headers","element");
IPv4__extension__headers ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new IPv4__extension__header(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

IPv4__extension__headers IPv4__extension__headers::replace(int index, int len, const IPv4__extension__headers& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @IP_Types.IPv4_extension_headers.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @IP_Types.IPv4_extension_headers.");
check_replace_arguments(val_ptr->n_elements, index, len, "@IP_Types.IPv4_extension_headers","element");
IPv4__extension__headers ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new IPv4__extension__header(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new IPv4__extension__header(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new IPv4__extension__header(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

IPv4__extension__headers IPv4__extension__headers::replace(int index, int len, const IPv4__extension__headers_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void IPv4__extension__headers::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @IP_Types.IPv4_extension_headers.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (IPv4__extension__header**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new IPv4__extension__header(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (IPv4__extension__header**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @IP_Types.IPv4_extension_headers: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (IPv4__extension__header**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean IPv4__extension__headers::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int IPv4__extension__headers::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @IP_Types.IPv4_extension_headers.");
return val_ptr->n_elements;
}

int IPv4__extension__headers::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @IP_Types.IPv4_extension_headers.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void IPv4__extension__headers::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void IPv4__extension__headers::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@IP_Types.IPv4_extension_headers'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (param.get_type()) {
    case Module_Param::MP_Value_List:
      set_size(param.get_size());
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@IP_Types.IPv4_extension_headers");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (param.get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@IP_Types.IPv4_extension_headers");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}
void IPv4__extension__headers::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void IPv4__extension__headers::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @IP_Types.IPv4_extension_headers.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void IPv4__extension__headers::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @IP_Types.IPv4_extension_headers.");
val_ptr->value_elements = (IPv4__extension__header**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new IPv4__extension__header;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void IPv4__extension__headers::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IPv4__extension__headers::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IPv4__extension__headers::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int IPv4__extension__headers::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int IPv4__extension__headers::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IPv4_extension_headers.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int IPv4__extension__headers::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    IPv4__extension__header* val = new IPv4__extension__header;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (IPv4__extension__header**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void IPv4__extension__headers_template::copy_value(const IPv4__extension__headers& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @IP_Types.IPv4_extension_headers with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (IPv4__extension__header_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new IPv4__extension__header_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new IPv4__extension__header_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void IPv4__extension__headers_template::copy_template(const IPv4__extension__headers_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (IPv4__extension__header_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new IPv4__extension__header_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new IPv4__extension__header_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPv4__extension__headers_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IPv4_extension_headers.");
break;
}
set_selection(other_value);
}

boolean IPv4__extension__headers_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index)
{
if (value_index >= 0) return ((const IPv4__extension__headers_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const IPv4__extension__headers*)value_ptr)[value_index]);
else return ((const IPv4__extension__headers_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

IPv4__extension__headers_template::IPv4__extension__headers_template()
{
}

IPv4__extension__headers_template::IPv4__extension__headers_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

IPv4__extension__headers_template::IPv4__extension__headers_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

IPv4__extension__headers_template::IPv4__extension__headers_template(const IPv4__extension__headers& other_value)
{
copy_value(other_value);
}

IPv4__extension__headers_template::IPv4__extension__headers_template(const OPTIONAL<IPv4__extension__headers>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv4__extension__headers&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IPv4_extension_headers from an unbound optional field.");
}
}

IPv4__extension__headers_template::IPv4__extension__headers_template(const IPv4__extension__headers_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

IPv4__extension__headers_template::~IPv4__extension__headers_template()
{
clean_up();
}

void IPv4__extension__headers_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IPv4__extension__headers_template& IPv4__extension__headers_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPv4__extension__headers_template& IPv4__extension__headers_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

IPv4__extension__headers_template& IPv4__extension__headers_template::operator=(const IPv4__extension__headers& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IPv4__extension__headers_template& IPv4__extension__headers_template::operator=(const OPTIONAL<IPv4__extension__headers>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv4__extension__headers&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IPv4_extension_headers.");
}
return *this;
}

IPv4__extension__headers_template& IPv4__extension__headers_template::operator=(const IPv4__extension__headers_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

IPv4__extension__header_template& IPv4__extension__headers_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @IP_Types.IPv4_extension_headers using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @IP_Types.IPv4_extension_headers.");
    break;
}
return *single_value.value_elements[index_value];
}

IPv4__extension__header_template& IPv4__extension__headers_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @IP_Types.IPv4_extension_headers.");
return (*this)[(int)index_value];
}

const IPv4__extension__header_template& IPv4__extension__headers_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @IP_Types.IPv4_extension_headers using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @IP_Types.IPv4_extension_headers.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @IP_Types.IPv4_extension_headers: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const IPv4__extension__header_template& IPv4__extension__headers_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @IP_Types.IPv4_extension_headers.");
return (*this)[(int)index_value];
}

void IPv4__extension__headers_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @IP_Types.IPv4_extension_headers.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (IPv4__extension__header_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new IPv4__extension__header_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new IPv4__extension__header_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (IPv4__extension__header_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int IPv4__extension__headers_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int IPv4__extension__headers_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @IP_Types.IPv4_extension_headers which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @IP_Types.IPv4_extension_headers containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @IP_Types.IPv4_extension_headers containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @IP_Types.IPv4_extension_headers containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @IP_Types.IPv4_extension_headers containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @IP_Types.IPv4_extension_headers containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @IP_Types.IPv4_extension_headers.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @IP_Types.IPv4_extension_headers");
}

boolean IPv4__extension__headers_template::match(const IPv4__extension__headers& other_value) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @IP_Types.IPv4_extension_headers.");
}
return FALSE;
}

boolean IPv4__extension__headers_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

IPv4__extension__headers IPv4__extension__headers_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @IP_Types.IPv4_extension_headers.");
IPv4__extension__headers ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

IPv4__extension__headers IPv4__extension__headers_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

IPv4__extension__headers IPv4__extension__headers_template::replace(int index, int len, const IPv4__extension__headers_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

IPv4__extension__headers IPv4__extension__headers_template::replace(int index, int len, const IPv4__extension__headers& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void IPv4__extension__headers_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new IPv4__extension__headers_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @IP_Types.IPv4_extension_headers.");
}
set_selection(template_type);
}

IPv4__extension__headers_template& IPv4__extension__headers_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @IP_Types.IPv4_extension_headers.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @IP_Types.IPv4_extension_headers.");
return value_list.list_value[list_index];
}

void IPv4__extension__headers_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void IPv4__extension__headers_template::log_match(const IPv4__extension__headers& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count])){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count]);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count]);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IPv4__extension__headers_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IPv4_extension_headers.");
}
}

void IPv4__extension__headers_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @IP_Types.IPv4_extension_headers.");
single_value.value_elements = (IPv4__extension__header_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new IPv4__extension__header_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPv4__extension__headers_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @IP_Types.IPv4_extension_headers.");
}
}

boolean IPv4__extension__headers_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IPv4__extension__headers_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void IPv4__extension__headers_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@IP_Types.IPv4_extension_headers'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      (*this)[(int)(param.get_elem(p_i)->get_id()->get_index())].set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(param.get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      switch (param.get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<param.get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(param.get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*param.get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@IP_Types.IPv4_extension_headers");
  }
  is_ifpresent = param.get_ifpresent();
  set_length_range(param);
}

void IPv4__extension__headers_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_extension_headers");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IPv4_extension_headers");
}

void IPv4__extension__header::copy_value(const IPv4__extension__header& other_value)
{
switch (other_value.union_selection) {
case ALT_mine__hdr:
field_mine__hdr = new IP__MINE__header(*other_value.field_mine__hdr);
break;
case ALT_ah__hdr:
field_ah__hdr = new IP__AH__header(*other_value.field_ah__hdr);
break;
case ALT_esp__hdr:
field_esp__hdr = new IP__ESP__header(*other_value.field_esp__hdr);
break;
case ALT_gre2__hdr:
field_gre2__hdr = new IP__GRE2__header(*other_value.field_gre2__hdr);
break;
case ALT_raw__hdr:
field_raw__hdr = new OCTETSTRING(*other_value.field_raw__hdr);
break;
default:
TTCN_error("Assignment of an unbound union value of type @IP_Types.IPv4_extension_header.");
}
union_selection = other_value.union_selection;
}

IPv4__extension__header::IPv4__extension__header()
{
union_selection = UNBOUND_VALUE;
}

IPv4__extension__header::IPv4__extension__header(const IPv4__extension__header& other_value)
: Base_Type(){
copy_value(other_value);
}

IPv4__extension__header::~IPv4__extension__header()
{
clean_up();
}

IPv4__extension__header& IPv4__extension__header::operator=(const IPv4__extension__header& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean IPv4__extension__header::operator==(const IPv4__extension__header& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @IP_Types.IPv4_extension_header.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @IP_Types.IPv4_extension_header.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_mine__hdr:
return *field_mine__hdr == *other_value.field_mine__hdr;
case ALT_ah__hdr:
return *field_ah__hdr == *other_value.field_ah__hdr;
case ALT_esp__hdr:
return *field_esp__hdr == *other_value.field_esp__hdr;
case ALT_gre2__hdr:
return *field_gre2__hdr == *other_value.field_gre2__hdr;
case ALT_raw__hdr:
return *field_raw__hdr == *other_value.field_raw__hdr;
default:
return FALSE;
}
}

IP__MINE__header& IPv4__extension__header::mine__hdr()
{
if (union_selection != ALT_mine__hdr) {
clean_up();
field_mine__hdr = new IP__MINE__header;
union_selection = ALT_mine__hdr;
}
return *field_mine__hdr;
}

const IP__MINE__header& IPv4__extension__header::mine__hdr() const
{
if (union_selection != ALT_mine__hdr) TTCN_error("Using non-selected field mine_hdr in a value of union type @IP_Types.IPv4_extension_header.");
return *field_mine__hdr;
}

IP__AH__header& IPv4__extension__header::ah__hdr()
{
if (union_selection != ALT_ah__hdr) {
clean_up();
field_ah__hdr = new IP__AH__header;
union_selection = ALT_ah__hdr;
}
return *field_ah__hdr;
}

const IP__AH__header& IPv4__extension__header::ah__hdr() const
{
if (union_selection != ALT_ah__hdr) TTCN_error("Using non-selected field ah_hdr in a value of union type @IP_Types.IPv4_extension_header.");
return *field_ah__hdr;
}

IP__ESP__header& IPv4__extension__header::esp__hdr()
{
if (union_selection != ALT_esp__hdr) {
clean_up();
field_esp__hdr = new IP__ESP__header;
union_selection = ALT_esp__hdr;
}
return *field_esp__hdr;
}

const IP__ESP__header& IPv4__extension__header::esp__hdr() const
{
if (union_selection != ALT_esp__hdr) TTCN_error("Using non-selected field esp_hdr in a value of union type @IP_Types.IPv4_extension_header.");
return *field_esp__hdr;
}

IP__GRE2__header& IPv4__extension__header::gre2__hdr()
{
if (union_selection != ALT_gre2__hdr) {
clean_up();
field_gre2__hdr = new IP__GRE2__header;
union_selection = ALT_gre2__hdr;
}
return *field_gre2__hdr;
}

const IP__GRE2__header& IPv4__extension__header::gre2__hdr() const
{
if (union_selection != ALT_gre2__hdr) TTCN_error("Using non-selected field gre2_hdr in a value of union type @IP_Types.IPv4_extension_header.");
return *field_gre2__hdr;
}

OCTETSTRING& IPv4__extension__header::raw__hdr()
{
if (union_selection != ALT_raw__hdr) {
clean_up();
field_raw__hdr = new OCTETSTRING;
union_selection = ALT_raw__hdr;
}
return *field_raw__hdr;
}

const OCTETSTRING& IPv4__extension__header::raw__hdr() const
{
if (union_selection != ALT_raw__hdr) TTCN_error("Using non-selected field raw_hdr in a value of union type @IP_Types.IPv4_extension_header.");
return *field_raw__hdr;
}

boolean IPv4__extension__header::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @IP_Types.IPv4_extension_header.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @IP_Types.IPv4_extension_header.");
return union_selection == checked_selection;
}

boolean IPv4__extension__header::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean IPv4__extension__header::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_mine__hdr: return field_mine__hdr->is_value();
case ALT_ah__hdr: return field_ah__hdr->is_value();
case ALT_esp__hdr: return field_esp__hdr->is_value();
case ALT_gre2__hdr: return field_gre2__hdr->is_value();
case ALT_raw__hdr: return field_raw__hdr->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void IPv4__extension__header::clean_up()
{
switch (union_selection) {
case ALT_mine__hdr:
  delete field_mine__hdr;
  break;
case ALT_ah__hdr:
  delete field_ah__hdr;
  break;
case ALT_esp__hdr:
  delete field_esp__hdr;
  break;
case ALT_gre2__hdr:
  delete field_gre2__hdr;
  break;
case ALT_raw__hdr:
  delete field_raw__hdr;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void IPv4__extension__header::log() const
{
switch (union_selection) {
case ALT_mine__hdr:
TTCN_Logger::log_event_str("{ mine_hdr := ");
field_mine__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_ah__hdr:
TTCN_Logger::log_event_str("{ ah_hdr := ");
field_ah__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_esp__hdr:
TTCN_Logger::log_event_str("{ esp_hdr := ");
field_esp__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_gre2__hdr:
TTCN_Logger::log_event_str("{ gre2_hdr := ");
field_gre2__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_raw__hdr:
TTCN_Logger::log_event_str("{ raw_hdr := ");
field_raw__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void IPv4__extension__header::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@IP_Types.IPv4_extension_header'");
    }
    if (strcmp("mine_hdr", param_field) == 0) {
      mine__hdr().set_param(param);
      return;
    } else if (strcmp("ah_hdr", param_field) == 0) {
      ah__hdr().set_param(param);
      return;
    } else if (strcmp("esp_hdr", param_field) == 0) {
      esp__hdr().set_param(param);
      return;
    } else if (strcmp("gre2_hdr", param_field) == 0) {
      gre2__hdr().set_param(param);
      return;
    } else if (strcmp("raw_hdr", param_field) == 0) {
      raw__hdr().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@IP_Types.IPv4_extension_header'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) return;
  if (param.get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = param.get_elem(param.get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "mine_hdr")) {
    mine__hdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "ah_hdr")) {
    ah__hdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "esp_hdr")) {
    esp__hdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "gre2_hdr")) {
    gre2__hdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "raw_hdr")) {
    raw__hdr().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @IP_Types.IPv4_extension_header.", mp_last->get_id()->get_name());
}

void IPv4__extension__header::set_implicit_omit()
{
switch (union_selection) {
case ALT_mine__hdr:
field_mine__hdr->set_implicit_omit(); break;
case ALT_ah__hdr:
field_ah__hdr->set_implicit_omit(); break;
case ALT_esp__hdr:
field_esp__hdr->set_implicit_omit(); break;
case ALT_gre2__hdr:
field_gre2__hdr->set_implicit_omit(); break;
case ALT_raw__hdr:
field_raw__hdr->set_implicit_omit(); break;
default: break;
}
}

void IPv4__extension__header::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_mine__hdr:
field_mine__hdr->encode_text(text_buf);
break;
case ALT_ah__hdr:
field_ah__hdr->encode_text(text_buf);
break;
case ALT_esp__hdr:
field_esp__hdr->encode_text(text_buf);
break;
case ALT_gre2__hdr:
field_gre2__hdr->encode_text(text_buf);
break;
case ALT_raw__hdr:
field_raw__hdr->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @IP_Types.IPv4_extension_header.");
}
}

void IPv4__extension__header::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_mine__hdr:
mine__hdr().decode_text(text_buf);
break;
case ALT_ah__hdr:
ah__hdr().decode_text(text_buf);
break;
case ALT_esp__hdr:
esp__hdr().decode_text(text_buf);
break;
case ALT_gre2__hdr:
gre2__hdr().decode_text(text_buf);
break;
case ALT_raw__hdr:
raw__hdr().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @IP_Types.IPv4_extension_header.");
}
}

void IPv4__extension__header::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IPv4__extension__header::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IPv4__extension__header::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = mine__hdr().RAW_decode(IP__MINE__header_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = ah__hdr().RAW_decode(IP__AH__header_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = esp__hdr().RAW_decode(IP__ESP__header_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = gre2__hdr().RAW_decode(IP__GRE2__header_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = raw__hdr().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = mine__hdr().RAW_decode(IP__MINE__header_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = ah__hdr().RAW_decode(IP__AH__header_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = esp__hdr().RAW_decode(IP__ESP__header_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = gre2__hdr().RAW_decode(IP__GRE2__header_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = raw__hdr().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int IPv4__extension__header::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 5;  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  memset(myleaf.body.node.nodes, 0, 5 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_mine__hdr:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, IP__MINE__header_descr_.raw);
    encoded_length = field_mine__hdr->RAW_encode(IP__MINE__header_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &IP__MINE__header_descr_;
    break;
  case ALT_ah__hdr:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, IP__AH__header_descr_.raw);
    encoded_length = field_ah__hdr->RAW_encode(IP__AH__header_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &IP__AH__header_descr_;
    break;
  case ALT_esp__hdr:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, IP__ESP__header_descr_.raw);
    encoded_length = field_esp__hdr->RAW_encode(IP__ESP__header_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &IP__ESP__header_descr_;
    break;
  case ALT_gre2__hdr:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, IP__GRE2__header_descr_.raw);
    encoded_length = field_gre2__hdr->RAW_encode(IP__GRE2__header_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &IP__GRE2__header_descr_;
    break;
  case ALT_raw__hdr:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, OCTETSTRING_descr_.raw);
    encoded_length = field_raw__hdr->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int IPv4__extension__header::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_mine__hdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "mine_hdr");
    enc_len += field_mine__hdr->JSON_encode(IP__MINE__header_descr_, p_tok);
    break;
  case ALT_ah__hdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ah_hdr");
    enc_len += field_ah__hdr->JSON_encode(IP__AH__header_descr_, p_tok);
    break;
  case ALT_esp__hdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "esp_hdr");
    enc_len += field_esp__hdr->JSON_encode(IP__ESP__header_descr_, p_tok);
    break;
  case ALT_gre2__hdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gre2_hdr");
    enc_len += field_gre2__hdr->JSON_encode(IP__GRE2__header_descr_, p_tok);
    break;
  case ALT_raw__hdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "raw_hdr");
    enc_len += field_raw__hdr->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @IP_Types.IPv4_extension_header.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IPv4__extension__header::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "mine_hdr", name_len)) {
      int ret_val = mine__hdr().JSON_decode(IP__MINE__header_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "mine_hdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "ah_hdr", name_len)) {
      int ret_val = ah__hdr().JSON_decode(IP__AH__header_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ah_hdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "esp_hdr", name_len)) {
      int ret_val = esp__hdr().JSON_decode(IP__ESP__header_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "esp_hdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "gre2_hdr", name_len)) {
      int ret_val = gre2__hdr().JSON_decode(IP__GRE2__header_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gre2_hdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "raw_hdr", name_len)) {
      int ret_val = raw__hdr().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "raw_hdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void IPv4__extension__header_template::copy_value(const IPv4__extension__header& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case IPv4__extension__header::ALT_mine__hdr:
single_value.field_mine__hdr = new IP__MINE__header_template(other_value.mine__hdr());
break;
case IPv4__extension__header::ALT_ah__hdr:
single_value.field_ah__hdr = new IP__AH__header_template(other_value.ah__hdr());
break;
case IPv4__extension__header::ALT_esp__hdr:
single_value.field_esp__hdr = new IP__ESP__header_template(other_value.esp__hdr());
break;
case IPv4__extension__header::ALT_gre2__hdr:
single_value.field_gre2__hdr = new IP__GRE2__header_template(other_value.gre2__hdr());
break;
case IPv4__extension__header::ALT_raw__hdr:
single_value.field_raw__hdr = new OCTETSTRING_template(other_value.raw__hdr());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @IP_Types.IPv4_extension_header.");
}
set_selection(SPECIFIC_VALUE);
}

void IPv4__extension__header_template::copy_template(const IPv4__extension__header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case IPv4__extension__header::ALT_mine__hdr:
single_value.field_mine__hdr = new IP__MINE__header_template(*other_value.single_value.field_mine__hdr);
break;
case IPv4__extension__header::ALT_ah__hdr:
single_value.field_ah__hdr = new IP__AH__header_template(*other_value.single_value.field_ah__hdr);
break;
case IPv4__extension__header::ALT_esp__hdr:
single_value.field_esp__hdr = new IP__ESP__header_template(*other_value.single_value.field_esp__hdr);
break;
case IPv4__extension__header::ALT_gre2__hdr:
single_value.field_gre2__hdr = new IP__GRE2__header_template(*other_value.single_value.field_gre2__hdr);
break;
case IPv4__extension__header::ALT_raw__hdr:
single_value.field_raw__hdr = new OCTETSTRING_template(*other_value.single_value.field_raw__hdr);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @IP_Types.IPv4_extension_header.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPv4__extension__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @IP_Types.IPv4_extension_header.");
}
set_selection(other_value);
}

IPv4__extension__header_template::IPv4__extension__header_template()
{
}

IPv4__extension__header_template::IPv4__extension__header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPv4__extension__header_template::IPv4__extension__header_template(const IPv4__extension__header& other_value)
{
copy_value(other_value);
}

IPv4__extension__header_template::IPv4__extension__header_template(const OPTIONAL<IPv4__extension__header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv4__extension__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @IP_Types.IPv4_extension_header from an unbound optional field.");
}
}

IPv4__extension__header_template::IPv4__extension__header_template(const IPv4__extension__header_template& other_value)
: Base_Template(){
copy_template(other_value);
}

IPv4__extension__header_template::~IPv4__extension__header_template()
{
clean_up();
}

void IPv4__extension__header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case IPv4__extension__header::ALT_mine__hdr:
delete single_value.field_mine__hdr;
break;
case IPv4__extension__header::ALT_ah__hdr:
delete single_value.field_ah__hdr;
break;
case IPv4__extension__header::ALT_esp__hdr:
delete single_value.field_esp__hdr;
break;
case IPv4__extension__header::ALT_gre2__hdr:
delete single_value.field_gre2__hdr;
break;
case IPv4__extension__header::ALT_raw__hdr:
delete single_value.field_raw__hdr;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IPv4__extension__header_template& IPv4__extension__header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPv4__extension__header_template& IPv4__extension__header_template::operator=(const IPv4__extension__header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IPv4__extension__header_template& IPv4__extension__header_template::operator=(const OPTIONAL<IPv4__extension__header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv4__extension__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @IP_Types.IPv4_extension_header.");
}
return *this;
}

IPv4__extension__header_template& IPv4__extension__header_template::operator=(const IPv4__extension__header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPv4__extension__header_template::match(const IPv4__extension__header& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
IPv4__extension__header::union_selection_type value_selection = other_value.get_selection();
if (value_selection == IPv4__extension__header::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case IPv4__extension__header::ALT_mine__hdr:
return single_value.field_mine__hdr->match(other_value.mine__hdr());
case IPv4__extension__header::ALT_ah__hdr:
return single_value.field_ah__hdr->match(other_value.ah__hdr());
case IPv4__extension__header::ALT_esp__hdr:
return single_value.field_esp__hdr->match(other_value.esp__hdr());
case IPv4__extension__header::ALT_gre2__hdr:
return single_value.field_gre2__hdr->match(other_value.gre2__hdr());
case IPv4__extension__header::ALT_raw__hdr:
return single_value.field_raw__hdr->match(other_value.raw__hdr());
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @IP_Types.IPv4_extension_header.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @IP_Types.IPv4_extension_header.");
}
return FALSE;
}

boolean IPv4__extension__header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case IPv4__extension__header::ALT_mine__hdr:
return single_value.field_mine__hdr->is_value();
case IPv4__extension__header::ALT_ah__hdr:
return single_value.field_ah__hdr->is_value();
case IPv4__extension__header::ALT_esp__hdr:
return single_value.field_esp__hdr->is_value();
case IPv4__extension__header::ALT_gre2__hdr:
return single_value.field_gre2__hdr->is_value();
case IPv4__extension__header::ALT_raw__hdr:
return single_value.field_raw__hdr->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @IP_Types.IPv4_extension_header.");
}
}

IPv4__extension__header IPv4__extension__header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @IP_Types.IPv4_extension_header.");
IPv4__extension__header ret_val;
switch (single_value.union_selection) {
case IPv4__extension__header::ALT_mine__hdr:
ret_val.mine__hdr() = single_value.field_mine__hdr->valueof();
break;
case IPv4__extension__header::ALT_ah__hdr:
ret_val.ah__hdr() = single_value.field_ah__hdr->valueof();
break;
case IPv4__extension__header::ALT_esp__hdr:
ret_val.esp__hdr() = single_value.field_esp__hdr->valueof();
break;
case IPv4__extension__header::ALT_gre2__hdr:
ret_val.gre2__hdr() = single_value.field_gre2__hdr->valueof();
break;
case IPv4__extension__header::ALT_raw__hdr:
ret_val.raw__hdr() = single_value.field_raw__hdr->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @IP_Types.IPv4_extension_header.");
}
return ret_val;
}

IPv4__extension__header_template& IPv4__extension__header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @IP_Types.IPv4_extension_header.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @IP_Types.IPv4_extension_header.");
return value_list.list_value[list_index];
}
void IPv4__extension__header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @IP_Types.IPv4_extension_header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPv4__extension__header_template[list_length];
}

IP__MINE__header_template& IPv4__extension__header_template::mine__hdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPv4__extension__header::ALT_mine__hdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_mine__hdr = new IP__MINE__header_template(ANY_VALUE);
else single_value.field_mine__hdr = new IP__MINE__header_template;
single_value.union_selection = IPv4__extension__header::ALT_mine__hdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_mine__hdr;
}

const IP__MINE__header_template& IPv4__extension__header_template::mine__hdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field mine_hdr in a non-specific template of union type @IP_Types.IPv4_extension_header.");
if (single_value.union_selection != IPv4__extension__header::ALT_mine__hdr) TTCN_error("Accessing non-selected field mine_hdr in a template of union type @IP_Types.IPv4_extension_header.");
return *single_value.field_mine__hdr;
}

IP__AH__header_template& IPv4__extension__header_template::ah__hdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPv4__extension__header::ALT_ah__hdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_ah__hdr = new IP__AH__header_template(ANY_VALUE);
else single_value.field_ah__hdr = new IP__AH__header_template;
single_value.union_selection = IPv4__extension__header::ALT_ah__hdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_ah__hdr;
}

const IP__AH__header_template& IPv4__extension__header_template::ah__hdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field ah_hdr in a non-specific template of union type @IP_Types.IPv4_extension_header.");
if (single_value.union_selection != IPv4__extension__header::ALT_ah__hdr) TTCN_error("Accessing non-selected field ah_hdr in a template of union type @IP_Types.IPv4_extension_header.");
return *single_value.field_ah__hdr;
}

IP__ESP__header_template& IPv4__extension__header_template::esp__hdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPv4__extension__header::ALT_esp__hdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_esp__hdr = new IP__ESP__header_template(ANY_VALUE);
else single_value.field_esp__hdr = new IP__ESP__header_template;
single_value.union_selection = IPv4__extension__header::ALT_esp__hdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_esp__hdr;
}

const IP__ESP__header_template& IPv4__extension__header_template::esp__hdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field esp_hdr in a non-specific template of union type @IP_Types.IPv4_extension_header.");
if (single_value.union_selection != IPv4__extension__header::ALT_esp__hdr) TTCN_error("Accessing non-selected field esp_hdr in a template of union type @IP_Types.IPv4_extension_header.");
return *single_value.field_esp__hdr;
}

IP__GRE2__header_template& IPv4__extension__header_template::gre2__hdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPv4__extension__header::ALT_gre2__hdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_gre2__hdr = new IP__GRE2__header_template(ANY_VALUE);
else single_value.field_gre2__hdr = new IP__GRE2__header_template;
single_value.union_selection = IPv4__extension__header::ALT_gre2__hdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_gre2__hdr;
}

const IP__GRE2__header_template& IPv4__extension__header_template::gre2__hdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field gre2_hdr in a non-specific template of union type @IP_Types.IPv4_extension_header.");
if (single_value.union_selection != IPv4__extension__header::ALT_gre2__hdr) TTCN_error("Accessing non-selected field gre2_hdr in a template of union type @IP_Types.IPv4_extension_header.");
return *single_value.field_gre2__hdr;
}

OCTETSTRING_template& IPv4__extension__header_template::raw__hdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPv4__extension__header::ALT_raw__hdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_raw__hdr = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_raw__hdr = new OCTETSTRING_template;
single_value.union_selection = IPv4__extension__header::ALT_raw__hdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_raw__hdr;
}

const OCTETSTRING_template& IPv4__extension__header_template::raw__hdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field raw_hdr in a non-specific template of union type @IP_Types.IPv4_extension_header.");
if (single_value.union_selection != IPv4__extension__header::ALT_raw__hdr) TTCN_error("Accessing non-selected field raw_hdr in a template of union type @IP_Types.IPv4_extension_header.");
return *single_value.field_raw__hdr;
}

boolean IPv4__extension__header_template::ischosen(IPv4__extension__header::union_selection_type checked_selection) const
{
if (checked_selection == IPv4__extension__header::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @IP_Types.IPv4_extension_header.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == IPv4__extension__header::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @IP_Types.IPv4_extension_header.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @IP_Types.IPv4_extension_header containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @IP_Types.IPv4_extension_header, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @IP_Types.IPv4_extension_header");
}
return FALSE;
}

void IPv4__extension__header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case IPv4__extension__header::ALT_mine__hdr:
TTCN_Logger::log_event_str("{ mine_hdr := ");
single_value.field_mine__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case IPv4__extension__header::ALT_ah__hdr:
TTCN_Logger::log_event_str("{ ah_hdr := ");
single_value.field_ah__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case IPv4__extension__header::ALT_esp__hdr:
TTCN_Logger::log_event_str("{ esp_hdr := ");
single_value.field_esp__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case IPv4__extension__header::ALT_gre2__hdr:
TTCN_Logger::log_event_str("{ gre2_hdr := ");
single_value.field_gre2__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case IPv4__extension__header::ALT_raw__hdr:
TTCN_Logger::log_event_str("{ raw_hdr := ");
single_value.field_raw__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPv4__extension__header_template::log_match(const IPv4__extension__header& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case IPv4__extension__header::ALT_mine__hdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".mine_hdr");
single_value.field_mine__hdr->log_match(match_value.mine__hdr());
} else {
TTCN_Logger::log_event_str("{ mine_hdr := ");
single_value.field_mine__hdr->log_match(match_value.mine__hdr());
TTCN_Logger::log_event_str(" }");
}
break;
case IPv4__extension__header::ALT_ah__hdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".ah_hdr");
single_value.field_ah__hdr->log_match(match_value.ah__hdr());
} else {
TTCN_Logger::log_event_str("{ ah_hdr := ");
single_value.field_ah__hdr->log_match(match_value.ah__hdr());
TTCN_Logger::log_event_str(" }");
}
break;
case IPv4__extension__header::ALT_esp__hdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".esp_hdr");
single_value.field_esp__hdr->log_match(match_value.esp__hdr());
} else {
TTCN_Logger::log_event_str("{ esp_hdr := ");
single_value.field_esp__hdr->log_match(match_value.esp__hdr());
TTCN_Logger::log_event_str(" }");
}
break;
case IPv4__extension__header::ALT_gre2__hdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".gre2_hdr");
single_value.field_gre2__hdr->log_match(match_value.gre2__hdr());
} else {
TTCN_Logger::log_event_str("{ gre2_hdr := ");
single_value.field_gre2__hdr->log_match(match_value.gre2__hdr());
TTCN_Logger::log_event_str(" }");
}
break;
case IPv4__extension__header::ALT_raw__hdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".raw_hdr");
single_value.field_raw__hdr->log_match(match_value.raw__hdr());
} else {
TTCN_Logger::log_event_str("{ raw_hdr := ");
single_value.field_raw__hdr->log_match(match_value.raw__hdr());
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IPv4__extension__header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case IPv4__extension__header::ALT_mine__hdr:
single_value.field_mine__hdr->encode_text(text_buf);
break;
case IPv4__extension__header::ALT_ah__hdr:
single_value.field_ah__hdr->encode_text(text_buf);
break;
case IPv4__extension__header::ALT_esp__hdr:
single_value.field_esp__hdr->encode_text(text_buf);
break;
case IPv4__extension__header::ALT_gre2__hdr:
single_value.field_gre2__hdr->encode_text(text_buf);
break;
case IPv4__extension__header::ALT_raw__hdr:
single_value.field_raw__hdr->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @IP_Types.IPv4_extension_header.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @IP_Types.IPv4_extension_header.");
}
}

void IPv4__extension__header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = IPv4__extension__header::UNBOUND_VALUE;
IPv4__extension__header::union_selection_type new_selection = (IPv4__extension__header::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case IPv4__extension__header::ALT_mine__hdr:
single_value.field_mine__hdr = new IP__MINE__header_template;
single_value.field_mine__hdr->decode_text(text_buf);
break;
case IPv4__extension__header::ALT_ah__hdr:
single_value.field_ah__hdr = new IP__AH__header_template;
single_value.field_ah__hdr->decode_text(text_buf);
break;
case IPv4__extension__header::ALT_esp__hdr:
single_value.field_esp__hdr = new IP__ESP__header_template;
single_value.field_esp__hdr->decode_text(text_buf);
break;
case IPv4__extension__header::ALT_gre2__hdr:
single_value.field_gre2__hdr = new IP__GRE2__header_template;
single_value.field_gre2__hdr->decode_text(text_buf);
break;
case IPv4__extension__header::ALT_raw__hdr:
single_value.field_raw__hdr = new OCTETSTRING_template;
single_value.field_raw__hdr->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @IP_Types.IPv4_extension_header.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPv4__extension__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @IP_Types.IPv4_extension_header.");
}
}

boolean IPv4__extension__header_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IPv4__extension__header_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void IPv4__extension__header_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@IP_Types.IPv4_extension_header'");
    }
    if (strcmp("mine_hdr", param_field) == 0) {
      mine__hdr().set_param(param);
      return;
    } else if (strcmp("ah_hdr", param_field) == 0) {
      ah__hdr().set_param(param);
      return;
    } else if (strcmp("esp_hdr", param_field) == 0) {
      esp__hdr().set_param(param);
      return;
    } else if (strcmp("gre2_hdr", param_field) == 0) {
      gre2__hdr().set_param(param);
      return;
    } else if (strcmp("raw_hdr", param_field) == 0) {
      raw__hdr().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@IP_Types.IPv4_extension_header'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (param.get_size()==0) break;
    param.type_error("union template", "@IP_Types.IPv4_extension_header");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = param.get_elem(param.get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "mine_hdr")) {
      mine__hdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "ah_hdr")) {
      ah__hdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "esp_hdr")) {
      esp__hdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "gre2_hdr")) {
      gre2__hdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "raw_hdr")) {
      raw__hdr().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @IP_Types.IPv4_extension_header.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@IP_Types.IPv4_extension_header");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPv4__extension__header_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case IPv4__extension__header::ALT_mine__hdr:
single_value.field_mine__hdr->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_extension_header");
return;
case IPv4__extension__header::ALT_ah__hdr:
single_value.field_ah__hdr->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_extension_header");
return;
case IPv4__extension__header::ALT_esp__hdr:
single_value.field_esp__hdr->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_extension_header");
return;
case IPv4__extension__header::ALT_gre2__hdr:
single_value.field_gre2__hdr->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_extension_header");
return;
case IPv4__extension__header::ALT_raw__hdr:
single_value.field_raw__hdr->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_extension_header");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @IP_Types.IPv4_extension_header.");
}
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IPv4_extension_header");
}

IPv4__header::IPv4__header()
{
  bound_flag = FALSE;
}

IPv4__header::IPv4__header(const INTEGER& par_ver,
    const INTEGER& par_hlen,
    const INTEGER& par_tos,
    const INTEGER& par_tlen,
    const INTEGER& par_id,
    const BITSTRING& par_res,
    const BITSTRING& par_dfrag,
    const BITSTRING& par_mfrag,
    const INTEGER& par_foffset,
    const INTEGER& par_ttl,
    const INTEGER& par_proto,
    const INTEGER& par_cksum,
    const OCTETSTRING& par_srcaddr,
    const OCTETSTRING& par_dstaddr)
  :   field_ver(par_ver),
  field_hlen(par_hlen),
  field_tos(par_tos),
  field_tlen(par_tlen),
  field_id(par_id),
  field_res(par_res),
  field_dfrag(par_dfrag),
  field_mfrag(par_mfrag),
  field_foffset(par_foffset),
  field_ttl(par_ttl),
  field_proto(par_proto),
  field_cksum(par_cksum),
  field_srcaddr(par_srcaddr),
  field_dstaddr(par_dstaddr)
{
  bound_flag = TRUE;
}

IPv4__header::IPv4__header(const IPv4__header& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IPv4_header.");
bound_flag = TRUE;
if (other_value.ver().is_bound()) field_ver = other_value.ver();
else field_ver.clean_up();
if (other_value.hlen().is_bound()) field_hlen = other_value.hlen();
else field_hlen.clean_up();
if (other_value.tos().is_bound()) field_tos = other_value.tos();
else field_tos.clean_up();
if (other_value.tlen().is_bound()) field_tlen = other_value.tlen();
else field_tlen.clean_up();
if (other_value.id().is_bound()) field_id = other_value.id();
else field_id.clean_up();
if (other_value.res().is_bound()) field_res = other_value.res();
else field_res.clean_up();
if (other_value.dfrag().is_bound()) field_dfrag = other_value.dfrag();
else field_dfrag.clean_up();
if (other_value.mfrag().is_bound()) field_mfrag = other_value.mfrag();
else field_mfrag.clean_up();
if (other_value.foffset().is_bound()) field_foffset = other_value.foffset();
else field_foffset.clean_up();
if (other_value.ttl().is_bound()) field_ttl = other_value.ttl();
else field_ttl.clean_up();
if (other_value.proto().is_bound()) field_proto = other_value.proto();
else field_proto.clean_up();
if (other_value.cksum().is_bound()) field_cksum = other_value.cksum();
else field_cksum.clean_up();
if (other_value.srcaddr().is_bound()) field_srcaddr = other_value.srcaddr();
else field_srcaddr.clean_up();
if (other_value.dstaddr().is_bound()) field_dstaddr = other_value.dstaddr();
else field_dstaddr.clean_up();
}

void IPv4__header::clean_up()
{
field_ver.clean_up();
field_hlen.clean_up();
field_tos.clean_up();
field_tlen.clean_up();
field_id.clean_up();
field_res.clean_up();
field_dfrag.clean_up();
field_mfrag.clean_up();
field_foffset.clean_up();
field_ttl.clean_up();
field_proto.clean_up();
field_cksum.clean_up();
field_srcaddr.clean_up();
field_dstaddr.clean_up();
bound_flag = FALSE;
}

IPv4__header& IPv4__header::operator=(const IPv4__header& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.IPv4_header.");
  bound_flag = TRUE;
  if (other_value.ver().is_bound()) field_ver = other_value.ver();
  else field_ver.clean_up();
  if (other_value.hlen().is_bound()) field_hlen = other_value.hlen();
  else field_hlen.clean_up();
  if (other_value.tos().is_bound()) field_tos = other_value.tos();
  else field_tos.clean_up();
  if (other_value.tlen().is_bound()) field_tlen = other_value.tlen();
  else field_tlen.clean_up();
  if (other_value.id().is_bound()) field_id = other_value.id();
  else field_id.clean_up();
  if (other_value.res().is_bound()) field_res = other_value.res();
  else field_res.clean_up();
  if (other_value.dfrag().is_bound()) field_dfrag = other_value.dfrag();
  else field_dfrag.clean_up();
  if (other_value.mfrag().is_bound()) field_mfrag = other_value.mfrag();
  else field_mfrag.clean_up();
  if (other_value.foffset().is_bound()) field_foffset = other_value.foffset();
  else field_foffset.clean_up();
  if (other_value.ttl().is_bound()) field_ttl = other_value.ttl();
  else field_ttl.clean_up();
  if (other_value.proto().is_bound()) field_proto = other_value.proto();
  else field_proto.clean_up();
  if (other_value.cksum().is_bound()) field_cksum = other_value.cksum();
  else field_cksum.clean_up();
  if (other_value.srcaddr().is_bound()) field_srcaddr = other_value.srcaddr();
  else field_srcaddr.clean_up();
  if (other_value.dstaddr().is_bound()) field_dstaddr = other_value.dstaddr();
  else field_dstaddr.clean_up();
}
return *this;
}

boolean IPv4__header::operator==(const IPv4__header& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_ver==other_value.field_ver
  && field_hlen==other_value.field_hlen
  && field_tos==other_value.field_tos
  && field_tlen==other_value.field_tlen
  && field_id==other_value.field_id
  && field_res==other_value.field_res
  && field_dfrag==other_value.field_dfrag
  && field_mfrag==other_value.field_mfrag
  && field_foffset==other_value.field_foffset
  && field_ttl==other_value.field_ttl
  && field_proto==other_value.field_proto
  && field_cksum==other_value.field_cksum
  && field_srcaddr==other_value.field_srcaddr
  && field_dstaddr==other_value.field_dstaddr;
}

boolean IPv4__header::is_bound() const
{
if (bound_flag) return TRUE;
if(field_ver.is_bound()) return TRUE;
if(field_hlen.is_bound()) return TRUE;
if(field_tos.is_bound()) return TRUE;
if(field_tlen.is_bound()) return TRUE;
if(field_id.is_bound()) return TRUE;
if(field_res.is_bound()) return TRUE;
if(field_dfrag.is_bound()) return TRUE;
if(field_mfrag.is_bound()) return TRUE;
if(field_foffset.is_bound()) return TRUE;
if(field_ttl.is_bound()) return TRUE;
if(field_proto.is_bound()) return TRUE;
if(field_cksum.is_bound()) return TRUE;
if(field_srcaddr.is_bound()) return TRUE;
if(field_dstaddr.is_bound()) return TRUE;
return FALSE;
}
boolean IPv4__header::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_ver.is_value()) return FALSE;
if(!field_hlen.is_value()) return FALSE;
if(!field_tos.is_value()) return FALSE;
if(!field_tlen.is_value()) return FALSE;
if(!field_id.is_value()) return FALSE;
if(!field_res.is_value()) return FALSE;
if(!field_dfrag.is_value()) return FALSE;
if(!field_mfrag.is_value()) return FALSE;
if(!field_foffset.is_value()) return FALSE;
if(!field_ttl.is_value()) return FALSE;
if(!field_proto.is_value()) return FALSE;
if(!field_cksum.is_value()) return FALSE;
if(!field_srcaddr.is_value()) return FALSE;
if(!field_dstaddr.is_value()) return FALSE;
return TRUE;
}
int IPv4__header::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.IPv4_header");
  return 14;
}

void IPv4__header::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ ver := ");
field_ver.log();
TTCN_Logger::log_event_str(", hlen := ");
field_hlen.log();
TTCN_Logger::log_event_str(", tos := ");
field_tos.log();
TTCN_Logger::log_event_str(", tlen := ");
field_tlen.log();
TTCN_Logger::log_event_str(", id := ");
field_id.log();
TTCN_Logger::log_event_str(", res := ");
field_res.log();
TTCN_Logger::log_event_str(", dfrag := ");
field_dfrag.log();
TTCN_Logger::log_event_str(", mfrag := ");
field_mfrag.log();
TTCN_Logger::log_event_str(", foffset := ");
field_foffset.log();
TTCN_Logger::log_event_str(", ttl := ");
field_ttl.log();
TTCN_Logger::log_event_str(", proto := ");
field_proto.log();
TTCN_Logger::log_event_str(", cksum := ");
field_cksum.log();
TTCN_Logger::log_event_str(", srcaddr := ");
field_srcaddr.log();
TTCN_Logger::log_event_str(", dstaddr := ");
field_dstaddr.log();
TTCN_Logger::log_event_str(" }");
}

void IPv4__header::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.IPv4_header'");
    }
    if (strcmp("ver", param_field) == 0) {
      ver().set_param(param);
      return;
    } else if (strcmp("hlen", param_field) == 0) {
      hlen().set_param(param);
      return;
    } else if (strcmp("tos", param_field) == 0) {
      tos().set_param(param);
      return;
    } else if (strcmp("tlen", param_field) == 0) {
      tlen().set_param(param);
      return;
    } else if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else if (strcmp("res", param_field) == 0) {
      res().set_param(param);
      return;
    } else if (strcmp("dfrag", param_field) == 0) {
      dfrag().set_param(param);
      return;
    } else if (strcmp("mfrag", param_field) == 0) {
      mfrag().set_param(param);
      return;
    } else if (strcmp("foffset", param_field) == 0) {
      foffset().set_param(param);
      return;
    } else if (strcmp("ttl", param_field) == 0) {
      ttl().set_param(param);
      return;
    } else if (strcmp("proto", param_field) == 0) {
      proto().set_param(param);
      return;
    } else if (strcmp("cksum", param_field) == 0) {
      cksum().set_param(param);
      return;
    } else if (strcmp("srcaddr", param_field) == 0) {
      srcaddr().set_param(param);
      return;
    } else if (strcmp("dstaddr", param_field) == 0) {
      dstaddr().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.IPv4_header'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (14<param.get_size()) {
      param.error("record value of type @IP_Types.IPv4_header has 14 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ver().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) hlen().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) tos().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) tlen().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) res().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) dfrag().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) mfrag().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) foffset().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) ttl().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(10));
    if (param.get_size()>11 && param.get_elem(11)->get_type()!=Module_Param::MP_NotUsed) cksum().set_param(*param.get_elem(11));
    if (param.get_size()>12 && param.get_elem(12)->get_type()!=Module_Param::MP_NotUsed) srcaddr().set_param(*param.get_elem(12));
    if (param.get_size()>13 && param.get_elem(13)->get_type()!=Module_Param::MP_NotUsed) dstaddr().set_param(*param.get_elem(13));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ver")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ver().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hlen")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hlen().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tos")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tos().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tlen")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tlen().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "res")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          res().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dfrag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dfrag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mfrag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mfrag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "foffset")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          foffset().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ttl")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ttl().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cksum")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cksum().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcaddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcaddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dstaddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dstaddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IPv4_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.IPv4_header");
  }
}

void IPv4__header::set_implicit_omit()
{
if (ver().is_bound()) ver().set_implicit_omit();
if (hlen().is_bound()) hlen().set_implicit_omit();
if (tos().is_bound()) tos().set_implicit_omit();
if (tlen().is_bound()) tlen().set_implicit_omit();
if (id().is_bound()) id().set_implicit_omit();
if (res().is_bound()) res().set_implicit_omit();
if (dfrag().is_bound()) dfrag().set_implicit_omit();
if (mfrag().is_bound()) mfrag().set_implicit_omit();
if (foffset().is_bound()) foffset().set_implicit_omit();
if (ttl().is_bound()) ttl().set_implicit_omit();
if (proto().is_bound()) proto().set_implicit_omit();
if (cksum().is_bound()) cksum().set_implicit_omit();
if (srcaddr().is_bound()) srcaddr().set_implicit_omit();
if (dstaddr().is_bound()) dstaddr().set_implicit_omit();
}

void IPv4__header::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.IPv4_header.");
field_ver.encode_text(text_buf);
field_hlen.encode_text(text_buf);
field_tos.encode_text(text_buf);
field_tlen.encode_text(text_buf);
field_id.encode_text(text_buf);
field_res.encode_text(text_buf);
field_dfrag.encode_text(text_buf);
field_mfrag.encode_text(text_buf);
field_foffset.encode_text(text_buf);
field_ttl.encode_text(text_buf);
field_proto.encode_text(text_buf);
field_cksum.encode_text(text_buf);
field_srcaddr.encode_text(text_buf);
field_dstaddr.encode_text(text_buf);
}

void IPv4__header::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_ver.decode_text(text_buf);
field_hlen.decode_text(text_buf);
field_tos.decode_text(text_buf);
field_tlen.decode_text(text_buf);
field_id.decode_text(text_buf);
field_res.decode_text(text_buf);
field_dfrag.decode_text(text_buf);
field_mfrag.decode_text(text_buf);
field_foffset.decode_text(text_buf);
field_ttl.decode_text(text_buf);
field_proto.decode_text(text_buf);
field_cksum.decode_text(text_buf);
field_srcaddr.decode_text(text_buf);
field_dstaddr.decode_text(text_buf);
}

void IPv4__header::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IPv4__header::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IPv4__header::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_ver.RAW_decode(IPv4__header_ver_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_hlen.RAW_decode(IPv4__header_hlen_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_tos.RAW_decode(IPv4__header_tos_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_tlen.RAW_decode(IPv4__header_tlen_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_id.RAW_decode(IPv4__header_id_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_res.RAW_decode(IPv4__header_res_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_dfrag.RAW_decode(IPv4__header_dfrag_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_mfrag.RAW_decode(IPv4__header_mfrag_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_foffset.RAW_decode(IPv4__header_foffset_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_ttl.RAW_decode(IPv4__header_ttl_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_proto.RAW_decode(IPv4__header_proto_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_cksum.RAW_decode(IPv4__header_cksum_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_srcaddr.RAW_decode(IPv4__header_srcaddr_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_dstaddr.RAW_decode(IPv4__header_dstaddr_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IPv4__header::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 14;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(14);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, IPv4__header_ver_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, IPv4__header_hlen_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, IPv4__header_tos_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, IPv4__header_tlen_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, IPv4__header_id_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, IPv4__header_res_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, IPv4__header_dfrag_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, IPv4__header_mfrag_descr_.raw);
  myleaf.body.node.nodes[8] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 8, IPv4__header_foffset_descr_.raw);
  myleaf.body.node.nodes[9] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 9, IPv4__header_ttl_descr_.raw);
  myleaf.body.node.nodes[10] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 10, IPv4__header_proto_descr_.raw);
  myleaf.body.node.nodes[11] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 11, IPv4__header_cksum_descr_.raw);
  myleaf.body.node.nodes[12] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 12, IPv4__header_srcaddr_descr_.raw);
  myleaf.body.node.nodes[13] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 13, IPv4__header_dstaddr_descr_.raw);
  encoded_length += field_ver.RAW_encode(IPv4__header_ver_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_hlen.RAW_encode(IPv4__header_hlen_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_tos.RAW_encode(IPv4__header_tos_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_tlen.RAW_encode(IPv4__header_tlen_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_id.RAW_encode(IPv4__header_id_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_res.RAW_encode(IPv4__header_res_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_dfrag.RAW_encode(IPv4__header_dfrag_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_mfrag.RAW_encode(IPv4__header_mfrag_descr_, *myleaf.body.node.nodes[7]);
  encoded_length += field_foffset.RAW_encode(IPv4__header_foffset_descr_, *myleaf.body.node.nodes[8]);
  encoded_length += field_ttl.RAW_encode(IPv4__header_ttl_descr_, *myleaf.body.node.nodes[9]);
  encoded_length += field_proto.RAW_encode(IPv4__header_proto_descr_, *myleaf.body.node.nodes[10]);
  encoded_length += field_cksum.RAW_encode(IPv4__header_cksum_descr_, *myleaf.body.node.nodes[11]);
  encoded_length += field_srcaddr.RAW_encode(IPv4__header_srcaddr_descr_, *myleaf.body.node.nodes[12]);
  encoded_length += field_dstaddr.RAW_encode(IPv4__header_dstaddr_descr_, *myleaf.body.node.nodes[13]);
  return myleaf.length = encoded_length;
}

int IPv4__header::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IPv4_header.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ver");
    enc_len += field_ver.JSON_encode(IPv4__header_ver_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "hlen");
    enc_len += field_hlen.JSON_encode(IPv4__header_hlen_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "tos");
    enc_len += field_tos.JSON_encode(IPv4__header_tos_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "tlen");
    enc_len += field_tlen.JSON_encode(IPv4__header_tlen_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "id");
    enc_len += field_id.JSON_encode(IPv4__header_id_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "res");
    enc_len += field_res.JSON_encode(IPv4__header_res_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dfrag");
    enc_len += field_dfrag.JSON_encode(IPv4__header_dfrag_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "mfrag");
    enc_len += field_mfrag.JSON_encode(IPv4__header_mfrag_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "foffset");
    enc_len += field_foffset.JSON_encode(IPv4__header_foffset_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ttl");
    enc_len += field_ttl.JSON_encode(IPv4__header_ttl_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "proto");
    enc_len += field_proto.JSON_encode(IPv4__header_proto_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "cksum");
    enc_len += field_cksum.JSON_encode(IPv4__header_cksum_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "srcaddr");
    enc_len += field_srcaddr.JSON_encode(IPv4__header_srcaddr_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dstaddr");
    enc_len += field_dstaddr.JSON_encode(IPv4__header_dstaddr_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IPv4__header::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (3 == name_len && 0 == strncmp(fld_name, "ver", name_len)) {
        int ret_val = field_ver.JSON_decode(IPv4__header_ver_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ver");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (4 == name_len && 0 == strncmp(fld_name, "hlen", name_len)) {
        int ret_val = field_hlen.JSON_decode(IPv4__header_hlen_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "hlen");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (3 == name_len && 0 == strncmp(fld_name, "tos", name_len)) {
        int ret_val = field_tos.JSON_decode(IPv4__header_tos_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "tos");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (4 == name_len && 0 == strncmp(fld_name, "tlen", name_len)) {
        int ret_val = field_tlen.JSON_decode(IPv4__header_tlen_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "tlen");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (2 == name_len && 0 == strncmp(fld_name, "id", name_len)) {
        int ret_val = field_id.JSON_decode(IPv4__header_id_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "id");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (3 == name_len && 0 == strncmp(fld_name, "res", name_len)) {
        int ret_val = field_res.JSON_decode(IPv4__header_res_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "res");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (5 == name_len && 0 == strncmp(fld_name, "dfrag", name_len)) {
        int ret_val = field_dfrag.JSON_decode(IPv4__header_dfrag_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dfrag");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (5 == name_len && 0 == strncmp(fld_name, "mfrag", name_len)) {
        int ret_val = field_mfrag.JSON_decode(IPv4__header_mfrag_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "mfrag");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (7 == name_len && 0 == strncmp(fld_name, "foffset", name_len)) {
        int ret_val = field_foffset.JSON_decode(IPv4__header_foffset_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "foffset");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (3 == name_len && 0 == strncmp(fld_name, "ttl", name_len)) {
        int ret_val = field_ttl.JSON_decode(IPv4__header_ttl_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ttl");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (5 == name_len && 0 == strncmp(fld_name, "proto", name_len)) {
        int ret_val = field_proto.JSON_decode(IPv4__header_proto_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "proto");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (5 == name_len && 0 == strncmp(fld_name, "cksum", name_len)) {
        int ret_val = field_cksum.JSON_decode(IPv4__header_cksum_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "cksum");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (7 == name_len && 0 == strncmp(fld_name, "srcaddr", name_len)) {
        int ret_val = field_srcaddr.JSON_decode(IPv4__header_srcaddr_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "srcaddr");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (7 == name_len && 0 == strncmp(fld_name, "dstaddr", name_len)) {
        int ret_val = field_dstaddr.JSON_decode(IPv4__header_dstaddr_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dstaddr");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_ver.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "ver");
    return JSON_ERROR_FATAL;
  }
  if (!field_hlen.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "hlen");
    return JSON_ERROR_FATAL;
  }
  if (!field_tos.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "tos");
    return JSON_ERROR_FATAL;
  }
  if (!field_tlen.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "tlen");
    return JSON_ERROR_FATAL;
  }
  if (!field_id.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "id");
    return JSON_ERROR_FATAL;
  }
  if (!field_res.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "res");
    return JSON_ERROR_FATAL;
  }
  if (!field_dfrag.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "dfrag");
    return JSON_ERROR_FATAL;
  }
  if (!field_mfrag.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "mfrag");
    return JSON_ERROR_FATAL;
  }
  if (!field_foffset.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "foffset");
    return JSON_ERROR_FATAL;
  }
  if (!field_ttl.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "ttl");
    return JSON_ERROR_FATAL;
  }
  if (!field_proto.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "proto");
    return JSON_ERROR_FATAL;
  }
  if (!field_cksum.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "cksum");
    return JSON_ERROR_FATAL;
  }
  if (!field_srcaddr.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "srcaddr");
    return JSON_ERROR_FATAL;
  }
  if (!field_dstaddr.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "dstaddr");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct IPv4__header_template::single_value_struct {
INTEGER_template field_ver;
INTEGER_template field_hlen;
INTEGER_template field_tos;
INTEGER_template field_tlen;
INTEGER_template field_id;
BITSTRING_template field_res;
BITSTRING_template field_dfrag;
BITSTRING_template field_mfrag;
INTEGER_template field_foffset;
INTEGER_template field_ttl;
INTEGER_template field_proto;
INTEGER_template field_cksum;
OCTETSTRING_template field_srcaddr;
OCTETSTRING_template field_dstaddr;
};

void IPv4__header_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_ver = ANY_VALUE;
single_value->field_hlen = ANY_VALUE;
single_value->field_tos = ANY_VALUE;
single_value->field_tlen = ANY_VALUE;
single_value->field_id = ANY_VALUE;
single_value->field_res = ANY_VALUE;
single_value->field_dfrag = ANY_VALUE;
single_value->field_mfrag = ANY_VALUE;
single_value->field_foffset = ANY_VALUE;
single_value->field_ttl = ANY_VALUE;
single_value->field_proto = ANY_VALUE;
single_value->field_cksum = ANY_VALUE;
single_value->field_srcaddr = ANY_VALUE;
single_value->field_dstaddr = ANY_VALUE;
}
}
}

void IPv4__header_template::copy_value(const IPv4__header& other_value)
{
single_value = new single_value_struct;
if (other_value.ver().is_bound()) {
  single_value->field_ver = other_value.ver();
} else {
  single_value->field_ver.clean_up();
}
if (other_value.hlen().is_bound()) {
  single_value->field_hlen = other_value.hlen();
} else {
  single_value->field_hlen.clean_up();
}
if (other_value.tos().is_bound()) {
  single_value->field_tos = other_value.tos();
} else {
  single_value->field_tos.clean_up();
}
if (other_value.tlen().is_bound()) {
  single_value->field_tlen = other_value.tlen();
} else {
  single_value->field_tlen.clean_up();
}
if (other_value.id().is_bound()) {
  single_value->field_id = other_value.id();
} else {
  single_value->field_id.clean_up();
}
if (other_value.res().is_bound()) {
  single_value->field_res = other_value.res();
} else {
  single_value->field_res.clean_up();
}
if (other_value.dfrag().is_bound()) {
  single_value->field_dfrag = other_value.dfrag();
} else {
  single_value->field_dfrag.clean_up();
}
if (other_value.mfrag().is_bound()) {
  single_value->field_mfrag = other_value.mfrag();
} else {
  single_value->field_mfrag.clean_up();
}
if (other_value.foffset().is_bound()) {
  single_value->field_foffset = other_value.foffset();
} else {
  single_value->field_foffset.clean_up();
}
if (other_value.ttl().is_bound()) {
  single_value->field_ttl = other_value.ttl();
} else {
  single_value->field_ttl.clean_up();
}
if (other_value.proto().is_bound()) {
  single_value->field_proto = other_value.proto();
} else {
  single_value->field_proto.clean_up();
}
if (other_value.cksum().is_bound()) {
  single_value->field_cksum = other_value.cksum();
} else {
  single_value->field_cksum.clean_up();
}
if (other_value.srcaddr().is_bound()) {
  single_value->field_srcaddr = other_value.srcaddr();
} else {
  single_value->field_srcaddr.clean_up();
}
if (other_value.dstaddr().is_bound()) {
  single_value->field_dstaddr = other_value.dstaddr();
} else {
  single_value->field_dstaddr.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IPv4__header_template::copy_template(const IPv4__header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.ver().get_selection()) {
single_value->field_ver = other_value.ver();
} else {
single_value->field_ver.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.hlen().get_selection()) {
single_value->field_hlen = other_value.hlen();
} else {
single_value->field_hlen.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.tos().get_selection()) {
single_value->field_tos = other_value.tos();
} else {
single_value->field_tos.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.tlen().get_selection()) {
single_value->field_tlen = other_value.tlen();
} else {
single_value->field_tlen.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.id().get_selection()) {
single_value->field_id = other_value.id();
} else {
single_value->field_id.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.res().get_selection()) {
single_value->field_res = other_value.res();
} else {
single_value->field_res.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dfrag().get_selection()) {
single_value->field_dfrag = other_value.dfrag();
} else {
single_value->field_dfrag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mfrag().get_selection()) {
single_value->field_mfrag = other_value.mfrag();
} else {
single_value->field_mfrag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.foffset().get_selection()) {
single_value->field_foffset = other_value.foffset();
} else {
single_value->field_foffset.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ttl().get_selection()) {
single_value->field_ttl = other_value.ttl();
} else {
single_value->field_ttl.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.proto().get_selection()) {
single_value->field_proto = other_value.proto();
} else {
single_value->field_proto.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cksum().get_selection()) {
single_value->field_cksum = other_value.cksum();
} else {
single_value->field_cksum.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.srcaddr().get_selection()) {
single_value->field_srcaddr = other_value.srcaddr();
} else {
single_value->field_srcaddr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dstaddr().get_selection()) {
single_value->field_dstaddr = other_value.dstaddr();
} else {
single_value->field_dstaddr.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPv4__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IPv4_header.");
break;
}
set_selection(other_value);
}

IPv4__header_template::IPv4__header_template()
{
}

IPv4__header_template::IPv4__header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPv4__header_template::IPv4__header_template(const IPv4__header& other_value)
{
copy_value(other_value);
}

IPv4__header_template::IPv4__header_template(const OPTIONAL<IPv4__header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv4__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IPv4_header from an unbound optional field.");
}
}

IPv4__header_template::IPv4__header_template(const IPv4__header_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IPv4__header_template::~IPv4__header_template()
{
clean_up();
}

IPv4__header_template& IPv4__header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPv4__header_template& IPv4__header_template::operator=(const IPv4__header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IPv4__header_template& IPv4__header_template::operator=(const OPTIONAL<IPv4__header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv4__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IPv4_header.");
}
return *this;
}

IPv4__header_template& IPv4__header_template::operator=(const IPv4__header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPv4__header_template::match(const IPv4__header& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.ver().is_bound()) return FALSE;
if(!single_value->field_ver.match(other_value.ver()))return FALSE;
if(!other_value.hlen().is_bound()) return FALSE;
if(!single_value->field_hlen.match(other_value.hlen()))return FALSE;
if(!other_value.tos().is_bound()) return FALSE;
if(!single_value->field_tos.match(other_value.tos()))return FALSE;
if(!other_value.tlen().is_bound()) return FALSE;
if(!single_value->field_tlen.match(other_value.tlen()))return FALSE;
if(!other_value.id().is_bound()) return FALSE;
if(!single_value->field_id.match(other_value.id()))return FALSE;
if(!other_value.res().is_bound()) return FALSE;
if(!single_value->field_res.match(other_value.res()))return FALSE;
if(!other_value.dfrag().is_bound()) return FALSE;
if(!single_value->field_dfrag.match(other_value.dfrag()))return FALSE;
if(!other_value.mfrag().is_bound()) return FALSE;
if(!single_value->field_mfrag.match(other_value.mfrag()))return FALSE;
if(!other_value.foffset().is_bound()) return FALSE;
if(!single_value->field_foffset.match(other_value.foffset()))return FALSE;
if(!other_value.ttl().is_bound()) return FALSE;
if(!single_value->field_ttl.match(other_value.ttl()))return FALSE;
if(!other_value.proto().is_bound()) return FALSE;
if(!single_value->field_proto.match(other_value.proto()))return FALSE;
if(!other_value.cksum().is_bound()) return FALSE;
if(!single_value->field_cksum.match(other_value.cksum()))return FALSE;
if(!other_value.srcaddr().is_bound()) return FALSE;
if(!single_value->field_srcaddr.match(other_value.srcaddr()))return FALSE;
if(!other_value.dstaddr().is_bound()) return FALSE;
if(!single_value->field_dstaddr.match(other_value.dstaddr()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.IPv4_header.");
}
return FALSE;
}

boolean IPv4__header_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_ver.is_bound()) return TRUE;
if (single_value->field_hlen.is_bound()) return TRUE;
if (single_value->field_tos.is_bound()) return TRUE;
if (single_value->field_tlen.is_bound()) return TRUE;
if (single_value->field_id.is_bound()) return TRUE;
if (single_value->field_res.is_bound()) return TRUE;
if (single_value->field_dfrag.is_bound()) return TRUE;
if (single_value->field_mfrag.is_bound()) return TRUE;
if (single_value->field_foffset.is_bound()) return TRUE;
if (single_value->field_ttl.is_bound()) return TRUE;
if (single_value->field_proto.is_bound()) return TRUE;
if (single_value->field_cksum.is_bound()) return TRUE;
if (single_value->field_srcaddr.is_bound()) return TRUE;
if (single_value->field_dstaddr.is_bound()) return TRUE;
return FALSE;
}

boolean IPv4__header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_ver.is_value()) return FALSE;
if (!single_value->field_hlen.is_value()) return FALSE;
if (!single_value->field_tos.is_value()) return FALSE;
if (!single_value->field_tlen.is_value()) return FALSE;
if (!single_value->field_id.is_value()) return FALSE;
if (!single_value->field_res.is_value()) return FALSE;
if (!single_value->field_dfrag.is_value()) return FALSE;
if (!single_value->field_mfrag.is_value()) return FALSE;
if (!single_value->field_foffset.is_value()) return FALSE;
if (!single_value->field_ttl.is_value()) return FALSE;
if (!single_value->field_proto.is_value()) return FALSE;
if (!single_value->field_cksum.is_value()) return FALSE;
if (!single_value->field_srcaddr.is_value()) return FALSE;
if (!single_value->field_dstaddr.is_value()) return FALSE;
return TRUE;
}

void IPv4__header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IPv4__header IPv4__header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.IPv4_header.");
IPv4__header ret_val;
if (single_value->field_ver.is_bound()) {
ret_val.ver() = single_value->field_ver.valueof();
}
if (single_value->field_hlen.is_bound()) {
ret_val.hlen() = single_value->field_hlen.valueof();
}
if (single_value->field_tos.is_bound()) {
ret_val.tos() = single_value->field_tos.valueof();
}
if (single_value->field_tlen.is_bound()) {
ret_val.tlen() = single_value->field_tlen.valueof();
}
if (single_value->field_id.is_bound()) {
ret_val.id() = single_value->field_id.valueof();
}
if (single_value->field_res.is_bound()) {
ret_val.res() = single_value->field_res.valueof();
}
if (single_value->field_dfrag.is_bound()) {
ret_val.dfrag() = single_value->field_dfrag.valueof();
}
if (single_value->field_mfrag.is_bound()) {
ret_val.mfrag() = single_value->field_mfrag.valueof();
}
if (single_value->field_foffset.is_bound()) {
ret_val.foffset() = single_value->field_foffset.valueof();
}
if (single_value->field_ttl.is_bound()) {
ret_val.ttl() = single_value->field_ttl.valueof();
}
if (single_value->field_proto.is_bound()) {
ret_val.proto() = single_value->field_proto.valueof();
}
if (single_value->field_cksum.is_bound()) {
ret_val.cksum() = single_value->field_cksum.valueof();
}
if (single_value->field_srcaddr.is_bound()) {
ret_val.srcaddr() = single_value->field_srcaddr.valueof();
}
if (single_value->field_dstaddr.is_bound()) {
ret_val.dstaddr() = single_value->field_dstaddr.valueof();
}
return ret_val;
}

void IPv4__header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.IPv4_header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPv4__header_template[list_length];
}

IPv4__header_template& IPv4__header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.IPv4_header.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.IPv4_header.");
return value_list.list_value[list_index];
}

INTEGER_template& IPv4__header_template::ver()
{
set_specific();
return single_value->field_ver;
}

const INTEGER_template& IPv4__header_template::ver() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ver of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_ver;
}

INTEGER_template& IPv4__header_template::hlen()
{
set_specific();
return single_value->field_hlen;
}

const INTEGER_template& IPv4__header_template::hlen() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field hlen of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_hlen;
}

INTEGER_template& IPv4__header_template::tos()
{
set_specific();
return single_value->field_tos;
}

const INTEGER_template& IPv4__header_template::tos() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field tos of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_tos;
}

INTEGER_template& IPv4__header_template::tlen()
{
set_specific();
return single_value->field_tlen;
}

const INTEGER_template& IPv4__header_template::tlen() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field tlen of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_tlen;
}

INTEGER_template& IPv4__header_template::id()
{
set_specific();
return single_value->field_id;
}

const INTEGER_template& IPv4__header_template::id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field id of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_id;
}

BITSTRING_template& IPv4__header_template::res()
{
set_specific();
return single_value->field_res;
}

const BITSTRING_template& IPv4__header_template::res() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field res of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_res;
}

BITSTRING_template& IPv4__header_template::dfrag()
{
set_specific();
return single_value->field_dfrag;
}

const BITSTRING_template& IPv4__header_template::dfrag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dfrag of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_dfrag;
}

BITSTRING_template& IPv4__header_template::mfrag()
{
set_specific();
return single_value->field_mfrag;
}

const BITSTRING_template& IPv4__header_template::mfrag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mfrag of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_mfrag;
}

INTEGER_template& IPv4__header_template::foffset()
{
set_specific();
return single_value->field_foffset;
}

const INTEGER_template& IPv4__header_template::foffset() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field foffset of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_foffset;
}

INTEGER_template& IPv4__header_template::ttl()
{
set_specific();
return single_value->field_ttl;
}

const INTEGER_template& IPv4__header_template::ttl() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ttl of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_ttl;
}

INTEGER_template& IPv4__header_template::proto()
{
set_specific();
return single_value->field_proto;
}

const INTEGER_template& IPv4__header_template::proto() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field proto of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_proto;
}

INTEGER_template& IPv4__header_template::cksum()
{
set_specific();
return single_value->field_cksum;
}

const INTEGER_template& IPv4__header_template::cksum() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cksum of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_cksum;
}

OCTETSTRING_template& IPv4__header_template::srcaddr()
{
set_specific();
return single_value->field_srcaddr;
}

const OCTETSTRING_template& IPv4__header_template::srcaddr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field srcaddr of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_srcaddr;
}

OCTETSTRING_template& IPv4__header_template::dstaddr()
{
set_specific();
return single_value->field_dstaddr;
}

const OCTETSTRING_template& IPv4__header_template::dstaddr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dstaddr of a non-specific template of type @IP_Types.IPv4_header.");
return single_value->field_dstaddr;
}

int IPv4__header_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv4_header which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 14;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.IPv4_header containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv4_header containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv4_header containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv4_header containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv4_header containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.IPv4_header.");
  }
  return 0;
}

void IPv4__header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ ver := ");
single_value->field_ver.log();
TTCN_Logger::log_event_str(", hlen := ");
single_value->field_hlen.log();
TTCN_Logger::log_event_str(", tos := ");
single_value->field_tos.log();
TTCN_Logger::log_event_str(", tlen := ");
single_value->field_tlen.log();
TTCN_Logger::log_event_str(", id := ");
single_value->field_id.log();
TTCN_Logger::log_event_str(", res := ");
single_value->field_res.log();
TTCN_Logger::log_event_str(", dfrag := ");
single_value->field_dfrag.log();
TTCN_Logger::log_event_str(", mfrag := ");
single_value->field_mfrag.log();
TTCN_Logger::log_event_str(", foffset := ");
single_value->field_foffset.log();
TTCN_Logger::log_event_str(", ttl := ");
single_value->field_ttl.log();
TTCN_Logger::log_event_str(", proto := ");
single_value->field_proto.log();
TTCN_Logger::log_event_str(", cksum := ");
single_value->field_cksum.log();
TTCN_Logger::log_event_str(", srcaddr := ");
single_value->field_srcaddr.log();
TTCN_Logger::log_event_str(", dstaddr := ");
single_value->field_dstaddr.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPv4__header_template::log_match(const IPv4__header& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_ver.match(match_value.ver())){
TTCN_Logger::log_logmatch_info(".ver");
single_value->field_ver.log_match(match_value.ver());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_hlen.match(match_value.hlen())){
TTCN_Logger::log_logmatch_info(".hlen");
single_value->field_hlen.log_match(match_value.hlen());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_tos.match(match_value.tos())){
TTCN_Logger::log_logmatch_info(".tos");
single_value->field_tos.log_match(match_value.tos());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_tlen.match(match_value.tlen())){
TTCN_Logger::log_logmatch_info(".tlen");
single_value->field_tlen.log_match(match_value.tlen());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_id.match(match_value.id())){
TTCN_Logger::log_logmatch_info(".id");
single_value->field_id.log_match(match_value.id());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_res.match(match_value.res())){
TTCN_Logger::log_logmatch_info(".res");
single_value->field_res.log_match(match_value.res());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_dfrag.match(match_value.dfrag())){
TTCN_Logger::log_logmatch_info(".dfrag");
single_value->field_dfrag.log_match(match_value.dfrag());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mfrag.match(match_value.mfrag())){
TTCN_Logger::log_logmatch_info(".mfrag");
single_value->field_mfrag.log_match(match_value.mfrag());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_foffset.match(match_value.foffset())){
TTCN_Logger::log_logmatch_info(".foffset");
single_value->field_foffset.log_match(match_value.foffset());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ttl.match(match_value.ttl())){
TTCN_Logger::log_logmatch_info(".ttl");
single_value->field_ttl.log_match(match_value.ttl());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_proto.match(match_value.proto())){
TTCN_Logger::log_logmatch_info(".proto");
single_value->field_proto.log_match(match_value.proto());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_cksum.match(match_value.cksum())){
TTCN_Logger::log_logmatch_info(".cksum");
single_value->field_cksum.log_match(match_value.cksum());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_srcaddr.match(match_value.srcaddr())){
TTCN_Logger::log_logmatch_info(".srcaddr");
single_value->field_srcaddr.log_match(match_value.srcaddr());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_dstaddr.match(match_value.dstaddr())){
TTCN_Logger::log_logmatch_info(".dstaddr");
single_value->field_dstaddr.log_match(match_value.dstaddr());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ ver := ");
single_value->field_ver.log_match(match_value.ver());
TTCN_Logger::log_event_str(", hlen := ");
single_value->field_hlen.log_match(match_value.hlen());
TTCN_Logger::log_event_str(", tos := ");
single_value->field_tos.log_match(match_value.tos());
TTCN_Logger::log_event_str(", tlen := ");
single_value->field_tlen.log_match(match_value.tlen());
TTCN_Logger::log_event_str(", id := ");
single_value->field_id.log_match(match_value.id());
TTCN_Logger::log_event_str(", res := ");
single_value->field_res.log_match(match_value.res());
TTCN_Logger::log_event_str(", dfrag := ");
single_value->field_dfrag.log_match(match_value.dfrag());
TTCN_Logger::log_event_str(", mfrag := ");
single_value->field_mfrag.log_match(match_value.mfrag());
TTCN_Logger::log_event_str(", foffset := ");
single_value->field_foffset.log_match(match_value.foffset());
TTCN_Logger::log_event_str(", ttl := ");
single_value->field_ttl.log_match(match_value.ttl());
TTCN_Logger::log_event_str(", proto := ");
single_value->field_proto.log_match(match_value.proto());
TTCN_Logger::log_event_str(", cksum := ");
single_value->field_cksum.log_match(match_value.cksum());
TTCN_Logger::log_event_str(", srcaddr := ");
single_value->field_srcaddr.log_match(match_value.srcaddr());
TTCN_Logger::log_event_str(", dstaddr := ");
single_value->field_dstaddr.log_match(match_value.dstaddr());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IPv4__header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_ver.encode_text(text_buf);
single_value->field_hlen.encode_text(text_buf);
single_value->field_tos.encode_text(text_buf);
single_value->field_tlen.encode_text(text_buf);
single_value->field_id.encode_text(text_buf);
single_value->field_res.encode_text(text_buf);
single_value->field_dfrag.encode_text(text_buf);
single_value->field_mfrag.encode_text(text_buf);
single_value->field_foffset.encode_text(text_buf);
single_value->field_ttl.encode_text(text_buf);
single_value->field_proto.encode_text(text_buf);
single_value->field_cksum.encode_text(text_buf);
single_value->field_srcaddr.encode_text(text_buf);
single_value->field_dstaddr.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IPv4_header.");
}
}

void IPv4__header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_ver.decode_text(text_buf);
single_value->field_hlen.decode_text(text_buf);
single_value->field_tos.decode_text(text_buf);
single_value->field_tlen.decode_text(text_buf);
single_value->field_id.decode_text(text_buf);
single_value->field_res.decode_text(text_buf);
single_value->field_dfrag.decode_text(text_buf);
single_value->field_mfrag.decode_text(text_buf);
single_value->field_foffset.decode_text(text_buf);
single_value->field_ttl.decode_text(text_buf);
single_value->field_proto.decode_text(text_buf);
single_value->field_cksum.decode_text(text_buf);
single_value->field_srcaddr.decode_text(text_buf);
single_value->field_dstaddr.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPv4__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.IPv4_header.");
}
}

void IPv4__header_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.IPv4_header'");
    }
    if (strcmp("ver", param_field) == 0) {
      ver().set_param(param);
      return;
    } else if (strcmp("hlen", param_field) == 0) {
      hlen().set_param(param);
      return;
    } else if (strcmp("tos", param_field) == 0) {
      tos().set_param(param);
      return;
    } else if (strcmp("tlen", param_field) == 0) {
      tlen().set_param(param);
      return;
    } else if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else if (strcmp("res", param_field) == 0) {
      res().set_param(param);
      return;
    } else if (strcmp("dfrag", param_field) == 0) {
      dfrag().set_param(param);
      return;
    } else if (strcmp("mfrag", param_field) == 0) {
      mfrag().set_param(param);
      return;
    } else if (strcmp("foffset", param_field) == 0) {
      foffset().set_param(param);
      return;
    } else if (strcmp("ttl", param_field) == 0) {
      ttl().set_param(param);
      return;
    } else if (strcmp("proto", param_field) == 0) {
      proto().set_param(param);
      return;
    } else if (strcmp("cksum", param_field) == 0) {
      cksum().set_param(param);
      return;
    } else if (strcmp("srcaddr", param_field) == 0) {
      srcaddr().set_param(param);
      return;
    } else if (strcmp("dstaddr", param_field) == 0) {
      dstaddr().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.IPv4_header'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (14<param.get_size()) {
      param.error("record template of type @IP_Types.IPv4_header has 14 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ver().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) hlen().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) tos().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) tlen().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) res().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) dfrag().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) mfrag().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) foffset().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) ttl().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(10));
    if (param.get_size()>11 && param.get_elem(11)->get_type()!=Module_Param::MP_NotUsed) cksum().set_param(*param.get_elem(11));
    if (param.get_size()>12 && param.get_elem(12)->get_type()!=Module_Param::MP_NotUsed) srcaddr().set_param(*param.get_elem(12));
    if (param.get_size()>13 && param.get_elem(13)->get_type()!=Module_Param::MP_NotUsed) dstaddr().set_param(*param.get_elem(13));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ver")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ver().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hlen")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hlen().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tos")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tos().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tlen")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tlen().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "res")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          res().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dfrag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dfrag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mfrag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mfrag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "foffset")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          foffset().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ttl")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ttl().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cksum")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cksum().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcaddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcaddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dstaddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dstaddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IPv4_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.IPv4_header");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPv4__header_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_ver.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_hlen.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_tos.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_tlen.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_id.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_res.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_dfrag.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_mfrag.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_foffset.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_ttl.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_proto.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_cksum.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_srcaddr.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
single_value->field_dstaddr.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_header");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IPv4_header");
}

boolean IPv4__header_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IPv4__header_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

IPv4__packet::IPv4__packet()
{
  bound_flag = FALSE;
}

IPv4__packet::IPv4__packet(const IPv4__header& par_header,
    const OPTIONAL<IPv4__extension__headers>& par_ext__headers,
    const OPTIONAL<OCTETSTRING>& par_payload)
  :   field_header(par_header),
  field_ext__headers(par_ext__headers),
  field_payload(par_payload)
{
  bound_flag = TRUE;
}

IPv4__packet::IPv4__packet(const IPv4__packet& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IPv4_packet.");
bound_flag = TRUE;
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.ext__headers().is_bound()) field_ext__headers = other_value.ext__headers();
else field_ext__headers.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void IPv4__packet::clean_up()
{
field_header.clean_up();
field_ext__headers.clean_up();
field_payload.clean_up();
bound_flag = FALSE;
}

IPv4__packet& IPv4__packet::operator=(const IPv4__packet& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.IPv4_packet.");
  bound_flag = TRUE;
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.ext__headers().is_bound()) field_ext__headers = other_value.ext__headers();
  else field_ext__headers.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean IPv4__packet::operator==(const IPv4__packet& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_header==other_value.field_header
  && field_ext__headers==other_value.field_ext__headers
  && field_payload==other_value.field_payload;
}

boolean IPv4__packet::is_bound() const
{
if (bound_flag) return TRUE;
if(field_header.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_ext__headers.get_selection() || field_ext__headers.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_payload.get_selection() || field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean IPv4__packet::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_header.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_ext__headers.get_selection() && !field_ext__headers.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_payload.get_selection() && !field_payload.is_value()) return FALSE;
return TRUE;
}
int IPv4__packet::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.IPv4_packet");
  int ret_val = 1;
  if (field_ext__headers.ispresent()) ret_val++;
  if (field_payload.ispresent()) ret_val++;
  return ret_val;
}

void IPv4__packet::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", ext_headers := ");
field_ext__headers.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void IPv4__packet::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.IPv4_packet'");
    }
    if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("ext_headers", param_field) == 0) {
      ext__headers().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.IPv4_packet'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @IP_Types.IPv4_packet has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ext__headers().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ext_headers")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ext__headers().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IPv4_packet: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.IPv4_packet");
  }
}

void IPv4__packet::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (!ext__headers().is_bound()) ext__headers() = OMIT_VALUE;
else ext__headers().set_implicit_omit();
if (!payload().is_bound()) payload() = OMIT_VALUE;
else payload().set_implicit_omit();
}

void IPv4__packet::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.IPv4_packet.");
field_header.encode_text(text_buf);
field_ext__headers.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void IPv4__packet::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_header.decode_text(text_buf);
field_ext__headers.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

void IPv4__packet::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IPv4__packet::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IPv4__packet::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_header.RAW_decode(IPv4__packet_header_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_ext__headers().RAW_decode(IPv4__packet_ext__headers_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_ext__headers = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_ext__headers=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_payload().RAW_decode(IPv4__packet_payload_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_payload = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_payload=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IPv4__packet::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, IPv4__packet_header_descr_.raw);
  if (field_ext__headers.ispresent()) {
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, IPv4__packet_ext__headers_descr_.raw);
  }
  else myleaf.body.node.nodes[1] = NULL;
  if (field_payload.ispresent()) {
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, IPv4__packet_payload_descr_.raw);
  }
  else myleaf.body.node.nodes[2] = NULL;
  encoded_length += field_header.RAW_encode(IPv4__packet_header_descr_, *myleaf.body.node.nodes[0]);
  if (field_ext__headers.ispresent()) {
  encoded_length += field_ext__headers().RAW_encode(IPv4__packet_ext__headers_descr_, *myleaf.body.node.nodes[1]);
  }
  if (field_payload.ispresent()) {
  encoded_length += field_payload().RAW_encode(IPv4__packet_payload_descr_, *myleaf.body.node.nodes[2]);
  }
  return myleaf.length = encoded_length;
}

int IPv4__packet::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IPv4_packet.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "header");
    enc_len += field_header.JSON_encode(IPv4__packet_header_descr_, p_tok);
  }

  if (field_ext__headers.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ext_headers");
    enc_len += field_ext__headers.JSON_encode(IPv4__packet_ext__headers_descr_, p_tok);
  }

  if (field_payload.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
    enc_len += field_payload.JSON_encode(IPv4__packet_payload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IPv4__packet::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "header", name_len)) {
        int ret_val = field_header.JSON_decode(IPv4__packet_header_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "header");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (11 == name_len && 0 == strncmp(fld_name, "ext_headers", name_len)) {
        int ret_val = field_ext__headers.JSON_decode(IPv4__packet_ext__headers_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ext_headers");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (7 == name_len && 0 == strncmp(fld_name, "payload", name_len)) {
        int ret_val = field_payload.JSON_decode(IPv4__packet_payload_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_header.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "header");
    return JSON_ERROR_FATAL;
  }
  if (!field_ext__headers.is_bound()) {
    field_ext__headers = OMIT_VALUE;
  }
  if (!field_payload.is_bound()) {
    field_payload = OMIT_VALUE;
  }

  return dec_len;
}

struct IPv4__packet_template::single_value_struct {
IPv4__header_template field_header;
IPv4__extension__headers_template field_ext__headers;
OCTETSTRING_template field_payload;
};

void IPv4__packet_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_ext__headers = ANY_OR_OMIT;
single_value->field_payload = ANY_OR_OMIT;
}
}
}

void IPv4__packet_template::copy_value(const IPv4__packet& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.ext__headers().is_bound()) {
  if (other_value.ext__headers().ispresent()) single_value->field_ext__headers = other_value.ext__headers()();
  else single_value->field_ext__headers = OMIT_VALUE;
} else {
  single_value->field_ext__headers.clean_up();
}
if (other_value.payload().is_bound()) {
  if (other_value.payload().ispresent()) single_value->field_payload = other_value.payload()();
  else single_value->field_payload = OMIT_VALUE;
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IPv4__packet_template::copy_template(const IPv4__packet_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ext__headers().get_selection()) {
single_value->field_ext__headers = other_value.ext__headers();
} else {
single_value->field_ext__headers.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPv4__packet_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IPv4_packet.");
break;
}
set_selection(other_value);
}

IPv4__packet_template::IPv4__packet_template()
{
}

IPv4__packet_template::IPv4__packet_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPv4__packet_template::IPv4__packet_template(const IPv4__packet& other_value)
{
copy_value(other_value);
}

IPv4__packet_template::IPv4__packet_template(const OPTIONAL<IPv4__packet>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv4__packet&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IPv4_packet from an unbound optional field.");
}
}

IPv4__packet_template::IPv4__packet_template(const IPv4__packet_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IPv4__packet_template::~IPv4__packet_template()
{
clean_up();
}

IPv4__packet_template& IPv4__packet_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPv4__packet_template& IPv4__packet_template::operator=(const IPv4__packet& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IPv4__packet_template& IPv4__packet_template::operator=(const OPTIONAL<IPv4__packet>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv4__packet&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IPv4_packet.");
}
return *this;
}

IPv4__packet_template& IPv4__packet_template::operator=(const IPv4__packet_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPv4__packet_template::match(const IPv4__packet& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header()))return FALSE;
if(!other_value.ext__headers().is_bound()) return FALSE;
if((other_value.ext__headers().ispresent() ? !single_value->field_ext__headers.match((const IPv4__extension__headers&)other_value.ext__headers()) : !single_value->field_ext__headers.match_omit()))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if((other_value.payload().ispresent() ? !single_value->field_payload.match((const OCTETSTRING&)other_value.payload()) : !single_value->field_payload.match_omit()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.IPv4_packet.");
}
return FALSE;
}

boolean IPv4__packet_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_ext__headers.is_omit() || single_value->field_ext__headers.is_bound()) return TRUE;
if (single_value->field_payload.is_omit() || single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean IPv4__packet_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_ext__headers.is_omit() && !single_value->field_ext__headers.is_value()) return FALSE;
if (!single_value->field_payload.is_omit() && !single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void IPv4__packet_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IPv4__packet IPv4__packet_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.IPv4_packet.");
IPv4__packet ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_ext__headers.is_omit()) ret_val.ext__headers() = OMIT_VALUE;
else if (single_value->field_ext__headers.is_bound()) {
ret_val.ext__headers() = single_value->field_ext__headers.valueof();
}
if (single_value->field_payload.is_omit()) ret_val.payload() = OMIT_VALUE;
else if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void IPv4__packet_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.IPv4_packet.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPv4__packet_template[list_length];
}

IPv4__packet_template& IPv4__packet_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.IPv4_packet.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.IPv4_packet.");
return value_list.list_value[list_index];
}

IPv4__header_template& IPv4__packet_template::header()
{
set_specific();
return single_value->field_header;
}

const IPv4__header_template& IPv4__packet_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @IP_Types.IPv4_packet.");
return single_value->field_header;
}

IPv4__extension__headers_template& IPv4__packet_template::ext__headers()
{
set_specific();
return single_value->field_ext__headers;
}

const IPv4__extension__headers_template& IPv4__packet_template::ext__headers() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ext_headers of a non-specific template of type @IP_Types.IPv4_packet.");
return single_value->field_ext__headers;
}

OCTETSTRING_template& IPv4__packet_template::payload()
{
set_specific();
return single_value->field_payload;
}

const OCTETSTRING_template& IPv4__packet_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @IP_Types.IPv4_packet.");
return single_value->field_payload;
}

int IPv4__packet_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv4_packet which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_ext__headers.is_present()) ret_val++;
      if (single_value->field_payload.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.IPv4_packet containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv4_packet containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv4_packet containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv4_packet containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv4_packet containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.IPv4_packet.");
  }
  return 0;
}

void IPv4__packet_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", ext_headers := ");
single_value->field_ext__headers.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPv4__packet_template::log_match(const IPv4__packet& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header())){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.ext__headers().ispresent()){
if(!single_value->field_ext__headers.match(match_value.ext__headers())){
TTCN_Logger::log_logmatch_info(".ext_headers");
single_value->field_ext__headers.log_match(match_value.ext__headers());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_ext__headers.match_omit()){
 TTCN_Logger::log_logmatch_info(".ext_headers := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_ext__headers.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.payload().ispresent()){
if(!single_value->field_payload.match(match_value.payload())){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_payload.match_omit()){
 TTCN_Logger::log_logmatch_info(".payload := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_payload.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header());
TTCN_Logger::log_event_str(", ext_headers := ");
if (match_value.ext__headers().ispresent()) single_value->field_ext__headers.log_match(match_value.ext__headers());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_ext__headers.log();
if (single_value->field_ext__headers.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", payload := ");
if (match_value.payload().ispresent()) single_value->field_payload.log_match(match_value.payload());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_payload.log();
if (single_value->field_payload.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IPv4__packet_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_ext__headers.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IPv4_packet.");
}
}

void IPv4__packet_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_ext__headers.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPv4__packet_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.IPv4_packet.");
}
}

void IPv4__packet_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.IPv4_packet'");
    }
    if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("ext_headers", param_field) == 0) {
      ext__headers().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.IPv4_packet'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @IP_Types.IPv4_packet has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ext__headers().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ext_headers")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ext__headers().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IPv4_packet: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.IPv4_packet");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPv4__packet_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_packet");
single_value->field_ext__headers.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_packet");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv4_packet");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IPv4_packet");
}

boolean IPv4__packet_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IPv4__packet_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void IPv4msg__SP__PT::remove_msg_queue_head()
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
switch (my_head->item_selection) {
case MESSAGE_0:
delete (my_head)->message_0;
break;
default:
TTCN_error("Internal error: Invalid message selector in the queue of port %s.", port_name);
}
msg_queue_item_base *next_item = msg_queue_head->next_item;
delete (msg_queue_item*)msg_queue_head;
msg_queue_head = next_item;
if (next_item == NULL) msg_queue_tail = NULL;
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::extract__msg, port_name, 0, ++msg_head_count, CHARSTRING(0,NULL), CHARSTRING(0,NULL));}

void IPv4msg__SP__PT::clear_queue()
{
while (msg_queue_head != NULL) remove_msg_queue_head();
}

IPv4msg__SP__PT::IPv4msg__SP__PT(const char *par_port_name)
 : PORT(par_port_name)
{
msg_queue_head = NULL;
msg_queue_tail = NULL;
}

IPv4msg__SP__PT::~IPv4msg__SP__PT()
{
clear_queue();
}

void IPv4msg__SP__PT::send(const IPv4__packet& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @IP_Types.IPv4_packet : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) TTCN_error("Message cannot be sent to system on internal port %s.", port_name);
else {
Text_Buf text_buf;
prepare_message(text_buf, "@IP_Types.IPv4_packet");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void IPv4msg__SP__PT::send(const IPv4__packet& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void IPv4msg__SP__PT::send(const IPv4__packet_template& send_par, const COMPONENT& destination_component)
{
const IPv4__packet& send_par_value = IPv4__packet(send_par.valueof());
send(send_par_value, destination_component);
}

void IPv4msg__SP__PT::send(const IPv4__packet_template& send_par)
{
const IPv4__packet& send_par_value = IPv4__packet(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

alt_status IPv4msg__SP__PT::receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.IPv4_packet: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status IPv4msg__SP__PT::check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.IPv4_packet: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
return ALT_YES;
}
}

alt_status IPv4msg__SP__PT::trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.IPv4_packet: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status IPv4msg__SP__PT::receive(const IPv4__packet_template& value_template, IPv4__packet *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @IP_Types.IPv4_packet.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.IPv4_packet : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status IPv4msg__SP__PT::check_receive(const IPv4__packet_template& value_template, IPv4__packet *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @IP_Types.IPv4_packet.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.IPv4_packet : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status IPv4msg__SP__PT::trigger(const IPv4__packet_template& value_template, IPv4__packet *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @IP_Types.IPv4_packet.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.IPv4_packet : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

void IPv4msg__SP__PT::incoming_message(const IPv4__packet& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @IP_Types.IPv4_packet : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_0;
new_item->message_0 = new IPv4__packet(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

boolean IPv4msg__SP__PT::process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING&)
{
if (!strcmp(message_type, "@IP_Types.IPv4_packet")) {
IPv4__packet incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else return FALSE;
}

ASP__IPv4::ASP__IPv4()
{
  bound_flag = FALSE;
}

ASP__IPv4::ASP__IPv4(const IPv4__packet& par_ipv4__packet,
    const BOOLEAN& par_cksum__calc)
  :   field_ipv4__packet(par_ipv4__packet),
  field_cksum__calc(par_cksum__calc)
{
  bound_flag = TRUE;
}

ASP__IPv4::ASP__IPv4(const ASP__IPv4& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.ASP_IPv4.");
bound_flag = TRUE;
if (other_value.ipv4__packet().is_bound()) field_ipv4__packet = other_value.ipv4__packet();
else field_ipv4__packet.clean_up();
if (other_value.cksum__calc().is_bound()) field_cksum__calc = other_value.cksum__calc();
else field_cksum__calc.clean_up();
}

void ASP__IPv4::clean_up()
{
field_ipv4__packet.clean_up();
field_cksum__calc.clean_up();
bound_flag = FALSE;
}

ASP__IPv4& ASP__IPv4::operator=(const ASP__IPv4& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.ASP_IPv4.");
  bound_flag = TRUE;
  if (other_value.ipv4__packet().is_bound()) field_ipv4__packet = other_value.ipv4__packet();
  else field_ipv4__packet.clean_up();
  if (other_value.cksum__calc().is_bound()) field_cksum__calc = other_value.cksum__calc();
  else field_cksum__calc.clean_up();
}
return *this;
}

boolean ASP__IPv4::operator==(const ASP__IPv4& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_ipv4__packet==other_value.field_ipv4__packet
  && field_cksum__calc==other_value.field_cksum__calc;
}

boolean ASP__IPv4::is_bound() const
{
if (bound_flag) return TRUE;
if(field_ipv4__packet.is_bound()) return TRUE;
if(field_cksum__calc.is_bound()) return TRUE;
return FALSE;
}
boolean ASP__IPv4::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_ipv4__packet.is_value()) return FALSE;
if(!field_cksum__calc.is_value()) return FALSE;
return TRUE;
}
int ASP__IPv4::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.ASP_IPv4");
  return 2;
}

void ASP__IPv4::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ ipv4_packet := ");
field_ipv4__packet.log();
TTCN_Logger::log_event_str(", cksum_calc := ");
field_cksum__calc.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__IPv4::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.ASP_IPv4'");
    }
    if (strcmp("ipv4_packet", param_field) == 0) {
      ipv4__packet().set_param(param);
      return;
    } else if (strcmp("cksum_calc", param_field) == 0) {
      cksum__calc().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.ASP_IPv4'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @IP_Types.ASP_IPv4 has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ipv4__packet().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) cksum__calc().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ipv4_packet")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ipv4__packet().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cksum_calc")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cksum__calc().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.ASP_IPv4: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.ASP_IPv4");
  }
}

void ASP__IPv4::set_implicit_omit()
{
if (ipv4__packet().is_bound()) ipv4__packet().set_implicit_omit();
if (cksum__calc().is_bound()) cksum__calc().set_implicit_omit();
}

void ASP__IPv4::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.ASP_IPv4.");
field_ipv4__packet.encode_text(text_buf);
field_cksum__calc.encode_text(text_buf);
}

void ASP__IPv4::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_ipv4__packet.decode_text(text_buf);
field_cksum__calc.decode_text(text_buf);
}

struct ASP__IPv4_template::single_value_struct {
IPv4__packet_template field_ipv4__packet;
BOOLEAN_template field_cksum__calc;
};

void ASP__IPv4_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_ipv4__packet = ANY_VALUE;
single_value->field_cksum__calc = ANY_VALUE;
}
}
}

void ASP__IPv4_template::copy_value(const ASP__IPv4& other_value)
{
single_value = new single_value_struct;
if (other_value.ipv4__packet().is_bound()) {
  single_value->field_ipv4__packet = other_value.ipv4__packet();
} else {
  single_value->field_ipv4__packet.clean_up();
}
if (other_value.cksum__calc().is_bound()) {
  single_value->field_cksum__calc = other_value.cksum__calc();
} else {
  single_value->field_cksum__calc.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__IPv4_template::copy_template(const ASP__IPv4_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.ipv4__packet().get_selection()) {
single_value->field_ipv4__packet = other_value.ipv4__packet();
} else {
single_value->field_ipv4__packet.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cksum__calc().get_selection()) {
single_value->field_cksum__calc = other_value.cksum__calc();
} else {
single_value->field_cksum__calc.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__IPv4_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.ASP_IPv4.");
break;
}
set_selection(other_value);
}

ASP__IPv4_template::ASP__IPv4_template()
{
}

ASP__IPv4_template::ASP__IPv4_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__IPv4_template::ASP__IPv4_template(const ASP__IPv4& other_value)
{
copy_value(other_value);
}

ASP__IPv4_template::ASP__IPv4_template(const OPTIONAL<ASP__IPv4>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__IPv4&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.ASP_IPv4 from an unbound optional field.");
}
}

ASP__IPv4_template::ASP__IPv4_template(const ASP__IPv4_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__IPv4_template::~ASP__IPv4_template()
{
clean_up();
}

ASP__IPv4_template& ASP__IPv4_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__IPv4_template& ASP__IPv4_template::operator=(const ASP__IPv4& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__IPv4_template& ASP__IPv4_template::operator=(const OPTIONAL<ASP__IPv4>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__IPv4&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.ASP_IPv4.");
}
return *this;
}

ASP__IPv4_template& ASP__IPv4_template::operator=(const ASP__IPv4_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__IPv4_template::match(const ASP__IPv4& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.ipv4__packet().is_bound()) return FALSE;
if(!single_value->field_ipv4__packet.match(other_value.ipv4__packet()))return FALSE;
if(!other_value.cksum__calc().is_bound()) return FALSE;
if(!single_value->field_cksum__calc.match(other_value.cksum__calc()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.ASP_IPv4.");
}
return FALSE;
}

boolean ASP__IPv4_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_ipv4__packet.is_bound()) return TRUE;
if (single_value->field_cksum__calc.is_bound()) return TRUE;
return FALSE;
}

boolean ASP__IPv4_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_ipv4__packet.is_value()) return FALSE;
if (!single_value->field_cksum__calc.is_value()) return FALSE;
return TRUE;
}

void ASP__IPv4_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__IPv4 ASP__IPv4_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.ASP_IPv4.");
ASP__IPv4 ret_val;
if (single_value->field_ipv4__packet.is_bound()) {
ret_val.ipv4__packet() = single_value->field_ipv4__packet.valueof();
}
if (single_value->field_cksum__calc.is_bound()) {
ret_val.cksum__calc() = single_value->field_cksum__calc.valueof();
}
return ret_val;
}

void ASP__IPv4_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.ASP_IPv4.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__IPv4_template[list_length];
}

ASP__IPv4_template& ASP__IPv4_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.ASP_IPv4.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.ASP_IPv4.");
return value_list.list_value[list_index];
}

IPv4__packet_template& ASP__IPv4_template::ipv4__packet()
{
set_specific();
return single_value->field_ipv4__packet;
}

const IPv4__packet_template& ASP__IPv4_template::ipv4__packet() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ipv4_packet of a non-specific template of type @IP_Types.ASP_IPv4.");
return single_value->field_ipv4__packet;
}

BOOLEAN_template& ASP__IPv4_template::cksum__calc()
{
set_specific();
return single_value->field_cksum__calc;
}

const BOOLEAN_template& ASP__IPv4_template::cksum__calc() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cksum_calc of a non-specific template of type @IP_Types.ASP_IPv4.");
return single_value->field_cksum__calc;
}

int ASP__IPv4_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.ASP_IPv4 which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.ASP_IPv4 containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.ASP_IPv4 containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.ASP_IPv4 containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.ASP_IPv4 containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.ASP_IPv4 containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.ASP_IPv4.");
  }
  return 0;
}

void ASP__IPv4_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ ipv4_packet := ");
single_value->field_ipv4__packet.log();
TTCN_Logger::log_event_str(", cksum_calc := ");
single_value->field_cksum__calc.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__IPv4_template::log_match(const ASP__IPv4& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_ipv4__packet.match(match_value.ipv4__packet())){
TTCN_Logger::log_logmatch_info(".ipv4_packet");
single_value->field_ipv4__packet.log_match(match_value.ipv4__packet());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_cksum__calc.match(match_value.cksum__calc())){
TTCN_Logger::log_logmatch_info(".cksum_calc");
single_value->field_cksum__calc.log_match(match_value.cksum__calc());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ ipv4_packet := ");
single_value->field_ipv4__packet.log_match(match_value.ipv4__packet());
TTCN_Logger::log_event_str(", cksum_calc := ");
single_value->field_cksum__calc.log_match(match_value.cksum__calc());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__IPv4_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_ipv4__packet.encode_text(text_buf);
single_value->field_cksum__calc.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.ASP_IPv4.");
}
}

void ASP__IPv4_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_ipv4__packet.decode_text(text_buf);
single_value->field_cksum__calc.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__IPv4_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.ASP_IPv4.");
}
}

void ASP__IPv4_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.ASP_IPv4'");
    }
    if (strcmp("ipv4_packet", param_field) == 0) {
      ipv4__packet().set_param(param);
      return;
    } else if (strcmp("cksum_calc", param_field) == 0) {
      cksum__calc().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.ASP_IPv4'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @IP_Types.ASP_IPv4 has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ipv4__packet().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) cksum__calc().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ipv4_packet")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ipv4__packet().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cksum_calc")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cksum__calc().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.ASP_IPv4: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.ASP_IPv4");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__IPv4_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_ipv4__packet.check_restriction(t_res, t_name ? t_name : "@IP_Types.ASP_IPv4");
single_value->field_cksum__calc.check_restriction(t_res, t_name ? t_name : "@IP_Types.ASP_IPv4");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.ASP_IPv4");
}

boolean ASP__IPv4_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean ASP__IPv4_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void IPv4__ASP__SP__PT::remove_msg_queue_head()
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
switch (my_head->item_selection) {
case MESSAGE_0:
delete (my_head)->message_0;
break;
default:
TTCN_error("Internal error: Invalid message selector in the queue of port %s.", port_name);
}
msg_queue_item_base *next_item = msg_queue_head->next_item;
delete (msg_queue_item*)msg_queue_head;
msg_queue_head = next_item;
if (next_item == NULL) msg_queue_tail = NULL;
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::extract__msg, port_name, 0, ++msg_head_count, CHARSTRING(0,NULL), CHARSTRING(0,NULL));}

void IPv4__ASP__SP__PT::clear_queue()
{
while (msg_queue_head != NULL) remove_msg_queue_head();
}

IPv4__ASP__SP__PT::IPv4__ASP__SP__PT(const char *par_port_name)
 : PORT(par_port_name)
{
msg_queue_head = NULL;
msg_queue_tail = NULL;
}

IPv4__ASP__SP__PT::~IPv4__ASP__SP__PT()
{
clear_queue();
}

void IPv4__ASP__SP__PT::send(const ASP__IPv4& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @IP_Types.ASP_IPv4 : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) TTCN_error("Message cannot be sent to system on internal port %s.", port_name);
else {
Text_Buf text_buf;
prepare_message(text_buf, "@IP_Types.ASP_IPv4");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void IPv4__ASP__SP__PT::send(const ASP__IPv4& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void IPv4__ASP__SP__PT::send(const ASP__IPv4_template& send_par, const COMPONENT& destination_component)
{
const ASP__IPv4& send_par_value = ASP__IPv4(send_par.valueof());
send(send_par_value, destination_component);
}

void IPv4__ASP__SP__PT::send(const ASP__IPv4_template& send_par)
{
const ASP__IPv4& send_par_value = ASP__IPv4(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

alt_status IPv4__ASP__SP__PT::receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.ASP_IPv4: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status IPv4__ASP__SP__PT::check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.ASP_IPv4: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
return ALT_YES;
}
}

alt_status IPv4__ASP__SP__PT::trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.ASP_IPv4: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status IPv4__ASP__SP__PT::receive(const ASP__IPv4_template& value_template, ASP__IPv4 *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @IP_Types.ASP_IPv4.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.ASP_IPv4 : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status IPv4__ASP__SP__PT::check_receive(const ASP__IPv4_template& value_template, ASP__IPv4 *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @IP_Types.ASP_IPv4.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.ASP_IPv4 : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status IPv4__ASP__SP__PT::trigger(const ASP__IPv4_template& value_template, ASP__IPv4 *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @IP_Types.ASP_IPv4.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.ASP_IPv4 : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

void IPv4__ASP__SP__PT::incoming_message(const ASP__IPv4& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @IP_Types.ASP_IPv4 : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_0;
new_item->message_0 = new ASP__IPv4(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

boolean IPv4__ASP__SP__PT::process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING&)
{
if (!strcmp(message_type, "@IP_Types.ASP_IPv4")) {
ASP__IPv4 incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else return FALSE;
}

IPv6__Fragment__header::IPv6__Fragment__header()
{
  bound_flag = FALSE;
}

IPv6__Fragment__header::IPv6__Fragment__header(const INTEGER& par_next__hdr,
    const OCTETSTRING& par_reserved,
    const INTEGER& par_fragmentOffset,
    const BITSTRING& par_reserved2,
    const BITSTRING& par_mFlag,
    const OCTETSTRING& par_identification)
  :   field_next__hdr(par_next__hdr),
  field_reserved(par_reserved),
  field_fragmentOffset(par_fragmentOffset),
  field_reserved2(par_reserved2),
  field_mFlag(par_mFlag),
  field_identification(par_identification)
{
  bound_flag = TRUE;
}

IPv6__Fragment__header::IPv6__Fragment__header(const IPv6__Fragment__header& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IPv6_Fragment_header.");
bound_flag = TRUE;
if (other_value.next__hdr().is_bound()) field_next__hdr = other_value.next__hdr();
else field_next__hdr.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.fragmentOffset().is_bound()) field_fragmentOffset = other_value.fragmentOffset();
else field_fragmentOffset.clean_up();
if (other_value.reserved2().is_bound()) field_reserved2 = other_value.reserved2();
else field_reserved2.clean_up();
if (other_value.mFlag().is_bound()) field_mFlag = other_value.mFlag();
else field_mFlag.clean_up();
if (other_value.identification().is_bound()) field_identification = other_value.identification();
else field_identification.clean_up();
}

void IPv6__Fragment__header::clean_up()
{
field_next__hdr.clean_up();
field_reserved.clean_up();
field_fragmentOffset.clean_up();
field_reserved2.clean_up();
field_mFlag.clean_up();
field_identification.clean_up();
bound_flag = FALSE;
}

IPv6__Fragment__header& IPv6__Fragment__header::operator=(const IPv6__Fragment__header& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.IPv6_Fragment_header.");
  bound_flag = TRUE;
  if (other_value.next__hdr().is_bound()) field_next__hdr = other_value.next__hdr();
  else field_next__hdr.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.fragmentOffset().is_bound()) field_fragmentOffset = other_value.fragmentOffset();
  else field_fragmentOffset.clean_up();
  if (other_value.reserved2().is_bound()) field_reserved2 = other_value.reserved2();
  else field_reserved2.clean_up();
  if (other_value.mFlag().is_bound()) field_mFlag = other_value.mFlag();
  else field_mFlag.clean_up();
  if (other_value.identification().is_bound()) field_identification = other_value.identification();
  else field_identification.clean_up();
}
return *this;
}

boolean IPv6__Fragment__header::operator==(const IPv6__Fragment__header& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_next__hdr==other_value.field_next__hdr
  && field_reserved==other_value.field_reserved
  && field_fragmentOffset==other_value.field_fragmentOffset
  && field_reserved2==other_value.field_reserved2
  && field_mFlag==other_value.field_mFlag
  && field_identification==other_value.field_identification;
}

boolean IPv6__Fragment__header::is_bound() const
{
if (bound_flag) return TRUE;
if(field_next__hdr.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_fragmentOffset.is_bound()) return TRUE;
if(field_reserved2.is_bound()) return TRUE;
if(field_mFlag.is_bound()) return TRUE;
if(field_identification.is_bound()) return TRUE;
return FALSE;
}
boolean IPv6__Fragment__header::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_next__hdr.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_fragmentOffset.is_value()) return FALSE;
if(!field_reserved2.is_value()) return FALSE;
if(!field_mFlag.is_value()) return FALSE;
if(!field_identification.is_value()) return FALSE;
return TRUE;
}
int IPv6__Fragment__header::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.IPv6_Fragment_header");
  return 6;
}

void IPv6__Fragment__header::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ next_hdr := ");
field_next__hdr.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", fragmentOffset := ");
field_fragmentOffset.log();
TTCN_Logger::log_event_str(", reserved2 := ");
field_reserved2.log();
TTCN_Logger::log_event_str(", mFlag := ");
field_mFlag.log();
TTCN_Logger::log_event_str(", identification := ");
field_identification.log();
TTCN_Logger::log_event_str(" }");
}

void IPv6__Fragment__header::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.IPv6_Fragment_header'");
    }
    if (strcmp("next_hdr", param_field) == 0) {
      next__hdr().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("fragmentOffset", param_field) == 0) {
      fragmentOffset().set_param(param);
      return;
    } else if (strcmp("reserved2", param_field) == 0) {
      reserved2().set_param(param);
      return;
    } else if (strcmp("mFlag", param_field) == 0) {
      mFlag().set_param(param);
      return;
    } else if (strcmp("identification", param_field) == 0) {
      identification().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.IPv6_Fragment_header'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (6<param.get_size()) {
      param.error("record value of type @IP_Types.IPv6_Fragment_header has 6 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) next__hdr().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) fragmentOffset().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) reserved2().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) mFlag().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) identification().set_param(*param.get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "next_hdr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          next__hdr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fragmentOffset")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fragmentOffset().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved2().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "identification")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          identification().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IPv6_Fragment_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.IPv6_Fragment_header");
  }
}

void IPv6__Fragment__header::set_implicit_omit()
{
if (next__hdr().is_bound()) next__hdr().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (fragmentOffset().is_bound()) fragmentOffset().set_implicit_omit();
if (reserved2().is_bound()) reserved2().set_implicit_omit();
if (mFlag().is_bound()) mFlag().set_implicit_omit();
if (identification().is_bound()) identification().set_implicit_omit();
}

void IPv6__Fragment__header::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.IPv6_Fragment_header.");
field_next__hdr.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_fragmentOffset.encode_text(text_buf);
field_reserved2.encode_text(text_buf);
field_mFlag.encode_text(text_buf);
field_identification.encode_text(text_buf);
}

void IPv6__Fragment__header::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_next__hdr.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_fragmentOffset.decode_text(text_buf);
field_reserved2.decode_text(text_buf);
field_mFlag.decode_text(text_buf);
field_identification.decode_text(text_buf);
}

void IPv6__Fragment__header::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IPv6__Fragment__header::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IPv6__Fragment__header::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_next__hdr.RAW_decode(General__Types::LIN1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(General__Types::OCT1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_fragmentOffset.RAW_decode(IPv6__Fragment__header_fragmentOffset_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved2.RAW_decode(IPv6__Fragment__header_reserved2_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_mFlag.RAW_decode(IPv6__Fragment__header_mFlag_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_identification.RAW_decode(General__Types::OCT4_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IPv6__Fragment__header::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 6;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(6);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, General__Types::LIN1_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, General__Types::OCT1_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, IPv6__Fragment__header_fragmentOffset_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, IPv6__Fragment__header_reserved2_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, IPv6__Fragment__header_mFlag_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, General__Types::OCT4_descr_.raw);
  encoded_length += field_next__hdr.RAW_encode(General__Types::LIN1_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_reserved.RAW_encode(General__Types::OCT1_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_fragmentOffset.RAW_encode(IPv6__Fragment__header_fragmentOffset_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_reserved2.RAW_encode(IPv6__Fragment__header_reserved2_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_mFlag.RAW_encode(IPv6__Fragment__header_mFlag_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_identification.RAW_encode(General__Types::OCT4_descr_, *myleaf.body.node.nodes[5]);
  return myleaf.length = encoded_length;
}

int IPv6__Fragment__header::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IPv6_Fragment_header.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "next_hdr");
    enc_len += field_next__hdr.JSON_encode(General__Types::LIN1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(General__Types::OCT1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "fragmentOffset");
    enc_len += field_fragmentOffset.JSON_encode(IPv6__Fragment__header_fragmentOffset_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved2");
    enc_len += field_reserved2.JSON_encode(IPv6__Fragment__header_reserved2_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "mFlag");
    enc_len += field_mFlag.JSON_encode(IPv6__Fragment__header_mFlag_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "identification");
    enc_len += field_identification.JSON_encode(General__Types::OCT4_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IPv6__Fragment__header::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (8 == name_len && 0 == strncmp(fld_name, "next_hdr", name_len)) {
        int ret_val = field_next__hdr.JSON_decode(General__Types::LIN1_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "next_hdr");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
        int ret_val = field_reserved.JSON_decode(General__Types::OCT1_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (14 == name_len && 0 == strncmp(fld_name, "fragmentOffset", name_len)) {
        int ret_val = field_fragmentOffset.JSON_decode(IPv6__Fragment__header_fragmentOffset_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "fragmentOffset");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (9 == name_len && 0 == strncmp(fld_name, "reserved2", name_len)) {
        int ret_val = field_reserved2.JSON_decode(IPv6__Fragment__header_reserved2_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved2");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (5 == name_len && 0 == strncmp(fld_name, "mFlag", name_len)) {
        int ret_val = field_mFlag.JSON_decode(IPv6__Fragment__header_mFlag_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "mFlag");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (14 == name_len && 0 == strncmp(fld_name, "identification", name_len)) {
        int ret_val = field_identification.JSON_decode(General__Types::OCT4_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "identification");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_next__hdr.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "next_hdr");
    return JSON_ERROR_FATAL;
  }
  if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
  if (!field_fragmentOffset.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "fragmentOffset");
    return JSON_ERROR_FATAL;
  }
  if (!field_reserved2.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved2");
    return JSON_ERROR_FATAL;
  }
  if (!field_mFlag.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "mFlag");
    return JSON_ERROR_FATAL;
  }
  if (!field_identification.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "identification");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct IPv6__Fragment__header_template::single_value_struct {
INTEGER_template field_next__hdr;
OCTETSTRING_template field_reserved;
INTEGER_template field_fragmentOffset;
BITSTRING_template field_reserved2;
BITSTRING_template field_mFlag;
OCTETSTRING_template field_identification;
};

void IPv6__Fragment__header_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_next__hdr = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_fragmentOffset = ANY_VALUE;
single_value->field_reserved2 = ANY_VALUE;
single_value->field_mFlag = ANY_VALUE;
single_value->field_identification = ANY_VALUE;
}
}
}

void IPv6__Fragment__header_template::copy_value(const IPv6__Fragment__header& other_value)
{
single_value = new single_value_struct;
if (other_value.next__hdr().is_bound()) {
  single_value->field_next__hdr = other_value.next__hdr();
} else {
  single_value->field_next__hdr.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.fragmentOffset().is_bound()) {
  single_value->field_fragmentOffset = other_value.fragmentOffset();
} else {
  single_value->field_fragmentOffset.clean_up();
}
if (other_value.reserved2().is_bound()) {
  single_value->field_reserved2 = other_value.reserved2();
} else {
  single_value->field_reserved2.clean_up();
}
if (other_value.mFlag().is_bound()) {
  single_value->field_mFlag = other_value.mFlag();
} else {
  single_value->field_mFlag.clean_up();
}
if (other_value.identification().is_bound()) {
  single_value->field_identification = other_value.identification();
} else {
  single_value->field_identification.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IPv6__Fragment__header_template::copy_template(const IPv6__Fragment__header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.next__hdr().get_selection()) {
single_value->field_next__hdr = other_value.next__hdr();
} else {
single_value->field_next__hdr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.fragmentOffset().get_selection()) {
single_value->field_fragmentOffset = other_value.fragmentOffset();
} else {
single_value->field_fragmentOffset.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved2().get_selection()) {
single_value->field_reserved2 = other_value.reserved2();
} else {
single_value->field_reserved2.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mFlag().get_selection()) {
single_value->field_mFlag = other_value.mFlag();
} else {
single_value->field_mFlag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.identification().get_selection()) {
single_value->field_identification = other_value.identification();
} else {
single_value->field_identification.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPv6__Fragment__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IPv6_Fragment_header.");
break;
}
set_selection(other_value);
}

IPv6__Fragment__header_template::IPv6__Fragment__header_template()
{
}

IPv6__Fragment__header_template::IPv6__Fragment__header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPv6__Fragment__header_template::IPv6__Fragment__header_template(const IPv6__Fragment__header& other_value)
{
copy_value(other_value);
}

IPv6__Fragment__header_template::IPv6__Fragment__header_template(const OPTIONAL<IPv6__Fragment__header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv6__Fragment__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IPv6_Fragment_header from an unbound optional field.");
}
}

IPv6__Fragment__header_template::IPv6__Fragment__header_template(const IPv6__Fragment__header_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IPv6__Fragment__header_template::~IPv6__Fragment__header_template()
{
clean_up();
}

IPv6__Fragment__header_template& IPv6__Fragment__header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPv6__Fragment__header_template& IPv6__Fragment__header_template::operator=(const IPv6__Fragment__header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IPv6__Fragment__header_template& IPv6__Fragment__header_template::operator=(const OPTIONAL<IPv6__Fragment__header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv6__Fragment__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IPv6_Fragment_header.");
}
return *this;
}

IPv6__Fragment__header_template& IPv6__Fragment__header_template::operator=(const IPv6__Fragment__header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPv6__Fragment__header_template::match(const IPv6__Fragment__header& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.next__hdr().is_bound()) return FALSE;
if(!single_value->field_next__hdr.match(other_value.next__hdr()))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved()))return FALSE;
if(!other_value.fragmentOffset().is_bound()) return FALSE;
if(!single_value->field_fragmentOffset.match(other_value.fragmentOffset()))return FALSE;
if(!other_value.reserved2().is_bound()) return FALSE;
if(!single_value->field_reserved2.match(other_value.reserved2()))return FALSE;
if(!other_value.mFlag().is_bound()) return FALSE;
if(!single_value->field_mFlag.match(other_value.mFlag()))return FALSE;
if(!other_value.identification().is_bound()) return FALSE;
if(!single_value->field_identification.match(other_value.identification()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.IPv6_Fragment_header.");
}
return FALSE;
}

boolean IPv6__Fragment__header_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_next__hdr.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_fragmentOffset.is_bound()) return TRUE;
if (single_value->field_reserved2.is_bound()) return TRUE;
if (single_value->field_mFlag.is_bound()) return TRUE;
if (single_value->field_identification.is_bound()) return TRUE;
return FALSE;
}

boolean IPv6__Fragment__header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_next__hdr.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_fragmentOffset.is_value()) return FALSE;
if (!single_value->field_reserved2.is_value()) return FALSE;
if (!single_value->field_mFlag.is_value()) return FALSE;
if (!single_value->field_identification.is_value()) return FALSE;
return TRUE;
}

void IPv6__Fragment__header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IPv6__Fragment__header IPv6__Fragment__header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.IPv6_Fragment_header.");
IPv6__Fragment__header ret_val;
if (single_value->field_next__hdr.is_bound()) {
ret_val.next__hdr() = single_value->field_next__hdr.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_fragmentOffset.is_bound()) {
ret_val.fragmentOffset() = single_value->field_fragmentOffset.valueof();
}
if (single_value->field_reserved2.is_bound()) {
ret_val.reserved2() = single_value->field_reserved2.valueof();
}
if (single_value->field_mFlag.is_bound()) {
ret_val.mFlag() = single_value->field_mFlag.valueof();
}
if (single_value->field_identification.is_bound()) {
ret_val.identification() = single_value->field_identification.valueof();
}
return ret_val;
}

void IPv6__Fragment__header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.IPv6_Fragment_header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPv6__Fragment__header_template[list_length];
}

IPv6__Fragment__header_template& IPv6__Fragment__header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.IPv6_Fragment_header.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.IPv6_Fragment_header.");
return value_list.list_value[list_index];
}

INTEGER_template& IPv6__Fragment__header_template::next__hdr()
{
set_specific();
return single_value->field_next__hdr;
}

const INTEGER_template& IPv6__Fragment__header_template::next__hdr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field next_hdr of a non-specific template of type @IP_Types.IPv6_Fragment_header.");
return single_value->field_next__hdr;
}

OCTETSTRING_template& IPv6__Fragment__header_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const OCTETSTRING_template& IPv6__Fragment__header_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @IP_Types.IPv6_Fragment_header.");
return single_value->field_reserved;
}

INTEGER_template& IPv6__Fragment__header_template::fragmentOffset()
{
set_specific();
return single_value->field_fragmentOffset;
}

const INTEGER_template& IPv6__Fragment__header_template::fragmentOffset() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field fragmentOffset of a non-specific template of type @IP_Types.IPv6_Fragment_header.");
return single_value->field_fragmentOffset;
}

BITSTRING_template& IPv6__Fragment__header_template::reserved2()
{
set_specific();
return single_value->field_reserved2;
}

const BITSTRING_template& IPv6__Fragment__header_template::reserved2() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved2 of a non-specific template of type @IP_Types.IPv6_Fragment_header.");
return single_value->field_reserved2;
}

BITSTRING_template& IPv6__Fragment__header_template::mFlag()
{
set_specific();
return single_value->field_mFlag;
}

const BITSTRING_template& IPv6__Fragment__header_template::mFlag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mFlag of a non-specific template of type @IP_Types.IPv6_Fragment_header.");
return single_value->field_mFlag;
}

OCTETSTRING_template& IPv6__Fragment__header_template::identification()
{
set_specific();
return single_value->field_identification;
}

const OCTETSTRING_template& IPv6__Fragment__header_template::identification() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field identification of a non-specific template of type @IP_Types.IPv6_Fragment_header.");
return single_value->field_identification;
}

int IPv6__Fragment__header_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_Fragment_header which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 6;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.IPv6_Fragment_header containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_Fragment_header containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_Fragment_header containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_Fragment_header containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_Fragment_header containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.IPv6_Fragment_header.");
  }
  return 0;
}

void IPv6__Fragment__header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ next_hdr := ");
single_value->field_next__hdr.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", fragmentOffset := ");
single_value->field_fragmentOffset.log();
TTCN_Logger::log_event_str(", reserved2 := ");
single_value->field_reserved2.log();
TTCN_Logger::log_event_str(", mFlag := ");
single_value->field_mFlag.log();
TTCN_Logger::log_event_str(", identification := ");
single_value->field_identification.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPv6__Fragment__header_template::log_match(const IPv6__Fragment__header& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_next__hdr.match(match_value.next__hdr())){
TTCN_Logger::log_logmatch_info(".next_hdr");
single_value->field_next__hdr.log_match(match_value.next__hdr());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved())){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_fragmentOffset.match(match_value.fragmentOffset())){
TTCN_Logger::log_logmatch_info(".fragmentOffset");
single_value->field_fragmentOffset.log_match(match_value.fragmentOffset());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved2.match(match_value.reserved2())){
TTCN_Logger::log_logmatch_info(".reserved2");
single_value->field_reserved2.log_match(match_value.reserved2());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mFlag.match(match_value.mFlag())){
TTCN_Logger::log_logmatch_info(".mFlag");
single_value->field_mFlag.log_match(match_value.mFlag());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_identification.match(match_value.identification())){
TTCN_Logger::log_logmatch_info(".identification");
single_value->field_identification.log_match(match_value.identification());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ next_hdr := ");
single_value->field_next__hdr.log_match(match_value.next__hdr());
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved());
TTCN_Logger::log_event_str(", fragmentOffset := ");
single_value->field_fragmentOffset.log_match(match_value.fragmentOffset());
TTCN_Logger::log_event_str(", reserved2 := ");
single_value->field_reserved2.log_match(match_value.reserved2());
TTCN_Logger::log_event_str(", mFlag := ");
single_value->field_mFlag.log_match(match_value.mFlag());
TTCN_Logger::log_event_str(", identification := ");
single_value->field_identification.log_match(match_value.identification());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IPv6__Fragment__header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_next__hdr.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_fragmentOffset.encode_text(text_buf);
single_value->field_reserved2.encode_text(text_buf);
single_value->field_mFlag.encode_text(text_buf);
single_value->field_identification.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IPv6_Fragment_header.");
}
}

void IPv6__Fragment__header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_next__hdr.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_fragmentOffset.decode_text(text_buf);
single_value->field_reserved2.decode_text(text_buf);
single_value->field_mFlag.decode_text(text_buf);
single_value->field_identification.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPv6__Fragment__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.IPv6_Fragment_header.");
}
}

void IPv6__Fragment__header_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.IPv6_Fragment_header'");
    }
    if (strcmp("next_hdr", param_field) == 0) {
      next__hdr().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("fragmentOffset", param_field) == 0) {
      fragmentOffset().set_param(param);
      return;
    } else if (strcmp("reserved2", param_field) == 0) {
      reserved2().set_param(param);
      return;
    } else if (strcmp("mFlag", param_field) == 0) {
      mFlag().set_param(param);
      return;
    } else if (strcmp("identification", param_field) == 0) {
      identification().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.IPv6_Fragment_header'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (6<param.get_size()) {
      param.error("record template of type @IP_Types.IPv6_Fragment_header has 6 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) next__hdr().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) fragmentOffset().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) reserved2().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) mFlag().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) identification().set_param(*param.get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "next_hdr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          next__hdr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fragmentOffset")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fragmentOffset().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved2().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "identification")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          identification().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IPv6_Fragment_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.IPv6_Fragment_header");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPv6__Fragment__header_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_next__hdr.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_Fragment_header");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_Fragment_header");
single_value->field_fragmentOffset.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_Fragment_header");
single_value->field_reserved2.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_Fragment_header");
single_value->field_mFlag.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_Fragment_header");
single_value->field_identification.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_Fragment_header");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IPv6_Fragment_header");
}

boolean IPv6__Fragment__header_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IPv6__Fragment__header_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}


const IPv6__extension__header IPv6__extension__headers::UNBOUND_ELEM;
IPv6__extension__headers::IPv6__extension__headers()
{
val_ptr = NULL;
}

IPv6__extension__headers::IPv6__extension__headers(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

IPv6__extension__headers::IPv6__extension__headers(const IPv6__extension__headers& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IPv6_extension_headers.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

IPv6__extension__headers::~IPv6__extension__headers()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void IPv6__extension__headers::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

IPv6__extension__headers& IPv6__extension__headers::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

IPv6__extension__headers& IPv6__extension__headers::operator=(const IPv6__extension__headers& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @IP_Types.IPv6_extension_headers.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean IPv6__extension__headers::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @IP_Types.IPv6_extension_headers.");
return val_ptr->n_elements == 0 ;
}

boolean IPv6__extension__headers::operator==(const IPv6__extension__headers& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @IP_Types.IPv6_extension_headers.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @IP_Types.IPv6_extension_headers.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

IPv6__extension__header& IPv6__extension__headers::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @IP_Types.IPv6_extension_headers using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (IPv6__extension__header**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new IPv6__extension__header(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new IPv6__extension__header;
}
return *val_ptr->value_elements[index_value];
}

IPv6__extension__header& IPv6__extension__headers::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @IP_Types.IPv6_extension_headers.");
return (*this)[(int)index_value];
}

const IPv6__extension__header& IPv6__extension__headers::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @IP_Types.IPv6_extension_headers.");
if (index_value < 0) TTCN_error("Accessing an element of type @IP_Types.IPv6_extension_headers using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @IP_Types.IPv6_extension_headers: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const IPv6__extension__header& IPv6__extension__headers::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @IP_Types.IPv6_extension_headers.");
return (*this)[(int)index_value];
}

IPv6__extension__headers IPv6__extension__headers::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

IPv6__extension__headers IPv6__extension__headers::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

IPv6__extension__headers IPv6__extension__headers::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

IPv6__extension__headers IPv6__extension__headers::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @IP_Types.IPv6_extension_headers.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
IPv6__extension__headers ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new IPv6__extension__header(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

IPv6__extension__headers IPv6__extension__headers::operator+(const IPv6__extension__headers& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @IP_Types.IPv6_extension_headers concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
IPv6__extension__headers ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new IPv6__extension__header(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new IPv6__extension__header(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

IPv6__extension__headers IPv6__extension__headers::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @IP_Types.IPv6_extension_headers.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@IP_Types.IPv6_extension_headers","element");
IPv6__extension__headers ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new IPv6__extension__header(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

IPv6__extension__headers IPv6__extension__headers::replace(int index, int len, const IPv6__extension__headers& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @IP_Types.IPv6_extension_headers.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @IP_Types.IPv6_extension_headers.");
check_replace_arguments(val_ptr->n_elements, index, len, "@IP_Types.IPv6_extension_headers","element");
IPv6__extension__headers ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new IPv6__extension__header(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new IPv6__extension__header(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new IPv6__extension__header(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

IPv6__extension__headers IPv6__extension__headers::replace(int index, int len, const IPv6__extension__headers_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void IPv6__extension__headers::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @IP_Types.IPv6_extension_headers.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (IPv6__extension__header**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new IPv6__extension__header(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (IPv6__extension__header**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @IP_Types.IPv6_extension_headers: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (IPv6__extension__header**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean IPv6__extension__headers::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int IPv6__extension__headers::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @IP_Types.IPv6_extension_headers.");
return val_ptr->n_elements;
}

int IPv6__extension__headers::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @IP_Types.IPv6_extension_headers.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void IPv6__extension__headers::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void IPv6__extension__headers::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@IP_Types.IPv6_extension_headers'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (param.get_type()) {
    case Module_Param::MP_Value_List:
      set_size(param.get_size());
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@IP_Types.IPv6_extension_headers");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (param.get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@IP_Types.IPv6_extension_headers");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}
void IPv6__extension__headers::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void IPv6__extension__headers::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @IP_Types.IPv6_extension_headers.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void IPv6__extension__headers::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @IP_Types.IPv6_extension_headers.");
val_ptr->value_elements = (IPv6__extension__header**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new IPv6__extension__header;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void IPv6__extension__headers::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IPv6__extension__headers::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IPv6__extension__headers::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int IPv6__extension__headers::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int IPv6__extension__headers::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IPv6_extension_headers.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int IPv6__extension__headers::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    IPv6__extension__header* val = new IPv6__extension__header;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (IPv6__extension__header**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void IPv6__extension__headers_template::copy_value(const IPv6__extension__headers& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @IP_Types.IPv6_extension_headers with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (IPv6__extension__header_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new IPv6__extension__header_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new IPv6__extension__header_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void IPv6__extension__headers_template::copy_template(const IPv6__extension__headers_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (IPv6__extension__header_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new IPv6__extension__header_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new IPv6__extension__header_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPv6__extension__headers_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IPv6_extension_headers.");
break;
}
set_selection(other_value);
}

boolean IPv6__extension__headers_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index)
{
if (value_index >= 0) return ((const IPv6__extension__headers_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const IPv6__extension__headers*)value_ptr)[value_index]);
else return ((const IPv6__extension__headers_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

IPv6__extension__headers_template::IPv6__extension__headers_template()
{
}

IPv6__extension__headers_template::IPv6__extension__headers_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

IPv6__extension__headers_template::IPv6__extension__headers_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

IPv6__extension__headers_template::IPv6__extension__headers_template(const IPv6__extension__headers& other_value)
{
copy_value(other_value);
}

IPv6__extension__headers_template::IPv6__extension__headers_template(const OPTIONAL<IPv6__extension__headers>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv6__extension__headers&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IPv6_extension_headers from an unbound optional field.");
}
}

IPv6__extension__headers_template::IPv6__extension__headers_template(const IPv6__extension__headers_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

IPv6__extension__headers_template::~IPv6__extension__headers_template()
{
clean_up();
}

void IPv6__extension__headers_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IPv6__extension__headers_template& IPv6__extension__headers_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPv6__extension__headers_template& IPv6__extension__headers_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

IPv6__extension__headers_template& IPv6__extension__headers_template::operator=(const IPv6__extension__headers& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IPv6__extension__headers_template& IPv6__extension__headers_template::operator=(const OPTIONAL<IPv6__extension__headers>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv6__extension__headers&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IPv6_extension_headers.");
}
return *this;
}

IPv6__extension__headers_template& IPv6__extension__headers_template::operator=(const IPv6__extension__headers_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

IPv6__extension__header_template& IPv6__extension__headers_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @IP_Types.IPv6_extension_headers using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @IP_Types.IPv6_extension_headers.");
    break;
}
return *single_value.value_elements[index_value];
}

IPv6__extension__header_template& IPv6__extension__headers_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @IP_Types.IPv6_extension_headers.");
return (*this)[(int)index_value];
}

const IPv6__extension__header_template& IPv6__extension__headers_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @IP_Types.IPv6_extension_headers using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @IP_Types.IPv6_extension_headers.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @IP_Types.IPv6_extension_headers: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const IPv6__extension__header_template& IPv6__extension__headers_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @IP_Types.IPv6_extension_headers.");
return (*this)[(int)index_value];
}

void IPv6__extension__headers_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @IP_Types.IPv6_extension_headers.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (IPv6__extension__header_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new IPv6__extension__header_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new IPv6__extension__header_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (IPv6__extension__header_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int IPv6__extension__headers_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int IPv6__extension__headers_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @IP_Types.IPv6_extension_headers which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @IP_Types.IPv6_extension_headers containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @IP_Types.IPv6_extension_headers containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @IP_Types.IPv6_extension_headers containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @IP_Types.IPv6_extension_headers containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @IP_Types.IPv6_extension_headers containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @IP_Types.IPv6_extension_headers.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @IP_Types.IPv6_extension_headers");
}

boolean IPv6__extension__headers_template::match(const IPv6__extension__headers& other_value) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @IP_Types.IPv6_extension_headers.");
}
return FALSE;
}

boolean IPv6__extension__headers_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

IPv6__extension__headers IPv6__extension__headers_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @IP_Types.IPv6_extension_headers.");
IPv6__extension__headers ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

IPv6__extension__headers IPv6__extension__headers_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

IPv6__extension__headers IPv6__extension__headers_template::replace(int index, int len, const IPv6__extension__headers_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

IPv6__extension__headers IPv6__extension__headers_template::replace(int index, int len, const IPv6__extension__headers& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void IPv6__extension__headers_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new IPv6__extension__headers_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @IP_Types.IPv6_extension_headers.");
}
set_selection(template_type);
}

IPv6__extension__headers_template& IPv6__extension__headers_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @IP_Types.IPv6_extension_headers.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @IP_Types.IPv6_extension_headers.");
return value_list.list_value[list_index];
}

void IPv6__extension__headers_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void IPv6__extension__headers_template::log_match(const IPv6__extension__headers& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count])){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count]);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count]);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IPv6__extension__headers_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IPv6_extension_headers.");
}
}

void IPv6__extension__headers_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @IP_Types.IPv6_extension_headers.");
single_value.value_elements = (IPv6__extension__header_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new IPv6__extension__header_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPv6__extension__headers_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @IP_Types.IPv6_extension_headers.");
}
}

boolean IPv6__extension__headers_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IPv6__extension__headers_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void IPv6__extension__headers_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@IP_Types.IPv6_extension_headers'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      (*this)[(int)(param.get_elem(p_i)->get_id()->get_index())].set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(param.get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      switch (param.get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<param.get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(param.get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*param.get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@IP_Types.IPv6_extension_headers");
  }
  is_ifpresent = param.get_ifpresent();
  set_length_range(param);
}

void IPv6__extension__headers_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_extension_headers");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IPv6_extension_headers");
}

void IPv6__extension__header::copy_value(const IPv6__extension__header& other_value)
{
switch (other_value.union_selection) {
case ALT_ah__hdr:
field_ah__hdr = new IP__AH__header(*other_value.field_ah__hdr);
break;
case ALT_esp__hdr:
field_esp__hdr = new IP__ESP__header(*other_value.field_esp__hdr);
break;
case ALT_gre2__hdr:
field_gre2__hdr = new IP__GRE2__header(*other_value.field_gre2__hdr);
break;
case ALT_general__exthdr:
field_general__exthdr = new IPv6__general__IPv6__extension__header(*other_value.field_general__exthdr);
break;
case ALT_iPv6__Fragment__header:
field_iPv6__Fragment__header = new IPv6__Fragment__header(*other_value.field_iPv6__Fragment__header);
break;
case ALT_raw__hdr:
field_raw__hdr = new OCTETSTRING(*other_value.field_raw__hdr);
break;
default:
TTCN_error("Assignment of an unbound union value of type @IP_Types.IPv6_extension_header.");
}
union_selection = other_value.union_selection;
}

IPv6__extension__header::IPv6__extension__header()
{
union_selection = UNBOUND_VALUE;
}

IPv6__extension__header::IPv6__extension__header(const IPv6__extension__header& other_value)
: Base_Type(){
copy_value(other_value);
}

IPv6__extension__header::~IPv6__extension__header()
{
clean_up();
}

IPv6__extension__header& IPv6__extension__header::operator=(const IPv6__extension__header& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean IPv6__extension__header::operator==(const IPv6__extension__header& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @IP_Types.IPv6_extension_header.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @IP_Types.IPv6_extension_header.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_ah__hdr:
return *field_ah__hdr == *other_value.field_ah__hdr;
case ALT_esp__hdr:
return *field_esp__hdr == *other_value.field_esp__hdr;
case ALT_gre2__hdr:
return *field_gre2__hdr == *other_value.field_gre2__hdr;
case ALT_general__exthdr:
return *field_general__exthdr == *other_value.field_general__exthdr;
case ALT_iPv6__Fragment__header:
return *field_iPv6__Fragment__header == *other_value.field_iPv6__Fragment__header;
case ALT_raw__hdr:
return *field_raw__hdr == *other_value.field_raw__hdr;
default:
return FALSE;
}
}

IP__AH__header& IPv6__extension__header::ah__hdr()
{
if (union_selection != ALT_ah__hdr) {
clean_up();
field_ah__hdr = new IP__AH__header;
union_selection = ALT_ah__hdr;
}
return *field_ah__hdr;
}

const IP__AH__header& IPv6__extension__header::ah__hdr() const
{
if (union_selection != ALT_ah__hdr) TTCN_error("Using non-selected field ah_hdr in a value of union type @IP_Types.IPv6_extension_header.");
return *field_ah__hdr;
}

IP__ESP__header& IPv6__extension__header::esp__hdr()
{
if (union_selection != ALT_esp__hdr) {
clean_up();
field_esp__hdr = new IP__ESP__header;
union_selection = ALT_esp__hdr;
}
return *field_esp__hdr;
}

const IP__ESP__header& IPv6__extension__header::esp__hdr() const
{
if (union_selection != ALT_esp__hdr) TTCN_error("Using non-selected field esp_hdr in a value of union type @IP_Types.IPv6_extension_header.");
return *field_esp__hdr;
}

IP__GRE2__header& IPv6__extension__header::gre2__hdr()
{
if (union_selection != ALT_gre2__hdr) {
clean_up();
field_gre2__hdr = new IP__GRE2__header;
union_selection = ALT_gre2__hdr;
}
return *field_gre2__hdr;
}

const IP__GRE2__header& IPv6__extension__header::gre2__hdr() const
{
if (union_selection != ALT_gre2__hdr) TTCN_error("Using non-selected field gre2_hdr in a value of union type @IP_Types.IPv6_extension_header.");
return *field_gre2__hdr;
}

IPv6__general__IPv6__extension__header& IPv6__extension__header::general__exthdr()
{
if (union_selection != ALT_general__exthdr) {
clean_up();
field_general__exthdr = new IPv6__general__IPv6__extension__header;
union_selection = ALT_general__exthdr;
}
return *field_general__exthdr;
}

const IPv6__general__IPv6__extension__header& IPv6__extension__header::general__exthdr() const
{
if (union_selection != ALT_general__exthdr) TTCN_error("Using non-selected field general_exthdr in a value of union type @IP_Types.IPv6_extension_header.");
return *field_general__exthdr;
}

IPv6__Fragment__header& IPv6__extension__header::iPv6__Fragment__header()
{
if (union_selection != ALT_iPv6__Fragment__header) {
clean_up();
field_iPv6__Fragment__header = new IPv6__Fragment__header;
union_selection = ALT_iPv6__Fragment__header;
}
return *field_iPv6__Fragment__header;
}

const IPv6__Fragment__header& IPv6__extension__header::iPv6__Fragment__header() const
{
if (union_selection != ALT_iPv6__Fragment__header) TTCN_error("Using non-selected field iPv6_Fragment_header in a value of union type @IP_Types.IPv6_extension_header.");
return *field_iPv6__Fragment__header;
}

OCTETSTRING& IPv6__extension__header::raw__hdr()
{
if (union_selection != ALT_raw__hdr) {
clean_up();
field_raw__hdr = new OCTETSTRING;
union_selection = ALT_raw__hdr;
}
return *field_raw__hdr;
}

const OCTETSTRING& IPv6__extension__header::raw__hdr() const
{
if (union_selection != ALT_raw__hdr) TTCN_error("Using non-selected field raw_hdr in a value of union type @IP_Types.IPv6_extension_header.");
return *field_raw__hdr;
}

boolean IPv6__extension__header::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @IP_Types.IPv6_extension_header.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @IP_Types.IPv6_extension_header.");
return union_selection == checked_selection;
}

boolean IPv6__extension__header::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean IPv6__extension__header::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_ah__hdr: return field_ah__hdr->is_value();
case ALT_esp__hdr: return field_esp__hdr->is_value();
case ALT_gre2__hdr: return field_gre2__hdr->is_value();
case ALT_general__exthdr: return field_general__exthdr->is_value();
case ALT_iPv6__Fragment__header: return field_iPv6__Fragment__header->is_value();
case ALT_raw__hdr: return field_raw__hdr->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void IPv6__extension__header::clean_up()
{
switch (union_selection) {
case ALT_ah__hdr:
  delete field_ah__hdr;
  break;
case ALT_esp__hdr:
  delete field_esp__hdr;
  break;
case ALT_gre2__hdr:
  delete field_gre2__hdr;
  break;
case ALT_general__exthdr:
  delete field_general__exthdr;
  break;
case ALT_iPv6__Fragment__header:
  delete field_iPv6__Fragment__header;
  break;
case ALT_raw__hdr:
  delete field_raw__hdr;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void IPv6__extension__header::log() const
{
switch (union_selection) {
case ALT_ah__hdr:
TTCN_Logger::log_event_str("{ ah_hdr := ");
field_ah__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_esp__hdr:
TTCN_Logger::log_event_str("{ esp_hdr := ");
field_esp__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_gre2__hdr:
TTCN_Logger::log_event_str("{ gre2_hdr := ");
field_gre2__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_general__exthdr:
TTCN_Logger::log_event_str("{ general_exthdr := ");
field_general__exthdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_iPv6__Fragment__header:
TTCN_Logger::log_event_str("{ iPv6_Fragment_header := ");
field_iPv6__Fragment__header->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_raw__hdr:
TTCN_Logger::log_event_str("{ raw_hdr := ");
field_raw__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void IPv6__extension__header::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@IP_Types.IPv6_extension_header'");
    }
    if (strcmp("ah_hdr", param_field) == 0) {
      ah__hdr().set_param(param);
      return;
    } else if (strcmp("esp_hdr", param_field) == 0) {
      esp__hdr().set_param(param);
      return;
    } else if (strcmp("gre2_hdr", param_field) == 0) {
      gre2__hdr().set_param(param);
      return;
    } else if (strcmp("general_exthdr", param_field) == 0) {
      general__exthdr().set_param(param);
      return;
    } else if (strcmp("iPv6_Fragment_header", param_field) == 0) {
      iPv6__Fragment__header().set_param(param);
      return;
    } else if (strcmp("raw_hdr", param_field) == 0) {
      raw__hdr().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@IP_Types.IPv6_extension_header'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) return;
  if (param.get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = param.get_elem(param.get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "ah_hdr")) {
    ah__hdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "esp_hdr")) {
    esp__hdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "gre2_hdr")) {
    gre2__hdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "general_exthdr")) {
    general__exthdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "iPv6_Fragment_header")) {
    iPv6__Fragment__header().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "raw_hdr")) {
    raw__hdr().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @IP_Types.IPv6_extension_header.", mp_last->get_id()->get_name());
}

void IPv6__extension__header::set_implicit_omit()
{
switch (union_selection) {
case ALT_ah__hdr:
field_ah__hdr->set_implicit_omit(); break;
case ALT_esp__hdr:
field_esp__hdr->set_implicit_omit(); break;
case ALT_gre2__hdr:
field_gre2__hdr->set_implicit_omit(); break;
case ALT_general__exthdr:
field_general__exthdr->set_implicit_omit(); break;
case ALT_iPv6__Fragment__header:
field_iPv6__Fragment__header->set_implicit_omit(); break;
case ALT_raw__hdr:
field_raw__hdr->set_implicit_omit(); break;
default: break;
}
}

void IPv6__extension__header::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_ah__hdr:
field_ah__hdr->encode_text(text_buf);
break;
case ALT_esp__hdr:
field_esp__hdr->encode_text(text_buf);
break;
case ALT_gre2__hdr:
field_gre2__hdr->encode_text(text_buf);
break;
case ALT_general__exthdr:
field_general__exthdr->encode_text(text_buf);
break;
case ALT_iPv6__Fragment__header:
field_iPv6__Fragment__header->encode_text(text_buf);
break;
case ALT_raw__hdr:
field_raw__hdr->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @IP_Types.IPv6_extension_header.");
}
}

void IPv6__extension__header::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_ah__hdr:
ah__hdr().decode_text(text_buf);
break;
case ALT_esp__hdr:
esp__hdr().decode_text(text_buf);
break;
case ALT_gre2__hdr:
gre2__hdr().decode_text(text_buf);
break;
case ALT_general__exthdr:
general__exthdr().decode_text(text_buf);
break;
case ALT_iPv6__Fragment__header:
iPv6__Fragment__header().decode_text(text_buf);
break;
case ALT_raw__hdr:
raw__hdr().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @IP_Types.IPv6_extension_header.");
}
}

void IPv6__extension__header::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IPv6__extension__header::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IPv6__extension__header::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = ah__hdr().RAW_decode(IP__AH__header_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = esp__hdr().RAW_decode(IP__ESP__header_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = gre2__hdr().RAW_decode(IP__GRE2__header_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = general__exthdr().RAW_decode(IPv6__general__IPv6__extension__header_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = iPv6__Fragment__header().RAW_decode(IPv6__Fragment__header_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 5:
      decoded_length = raw__hdr().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = ah__hdr().RAW_decode(IP__AH__header_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = esp__hdr().RAW_decode(IP__ESP__header_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = gre2__hdr().RAW_decode(IP__GRE2__header_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = general__exthdr().RAW_decode(IPv6__general__IPv6__extension__header_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = iPv6__Fragment__header().RAW_decode(IPv6__Fragment__header_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = raw__hdr().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int IPv6__extension__header::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 6;  myleaf.body.node.nodes = init_nodes_of_enc_tree(6);
  memset(myleaf.body.node.nodes, 0, 6 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_ah__hdr:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, IP__AH__header_descr_.raw);
    encoded_length = field_ah__hdr->RAW_encode(IP__AH__header_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &IP__AH__header_descr_;
    break;
  case ALT_esp__hdr:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, IP__ESP__header_descr_.raw);
    encoded_length = field_esp__hdr->RAW_encode(IP__ESP__header_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &IP__ESP__header_descr_;
    break;
  case ALT_gre2__hdr:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, IP__GRE2__header_descr_.raw);
    encoded_length = field_gre2__hdr->RAW_encode(IP__GRE2__header_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &IP__GRE2__header_descr_;
    break;
  case ALT_general__exthdr:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, IPv6__general__IPv6__extension__header_descr_.raw);
    encoded_length = field_general__exthdr->RAW_encode(IPv6__general__IPv6__extension__header_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &IPv6__general__IPv6__extension__header_descr_;
    break;
  case ALT_iPv6__Fragment__header:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, IPv6__Fragment__header_descr_.raw);
    encoded_length = field_iPv6__Fragment__header->RAW_encode(IPv6__Fragment__header_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &IPv6__Fragment__header_descr_;
    break;
  case ALT_raw__hdr:
    myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 5, OCTETSTRING_descr_.raw);
    encoded_length = field_raw__hdr->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[5]);
    myleaf.body.node.nodes[5]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int IPv6__extension__header::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_ah__hdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ah_hdr");
    enc_len += field_ah__hdr->JSON_encode(IP__AH__header_descr_, p_tok);
    break;
  case ALT_esp__hdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "esp_hdr");
    enc_len += field_esp__hdr->JSON_encode(IP__ESP__header_descr_, p_tok);
    break;
  case ALT_gre2__hdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gre2_hdr");
    enc_len += field_gre2__hdr->JSON_encode(IP__GRE2__header_descr_, p_tok);
    break;
  case ALT_general__exthdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "general_exthdr");
    enc_len += field_general__exthdr->JSON_encode(IPv6__general__IPv6__extension__header_descr_, p_tok);
    break;
  case ALT_iPv6__Fragment__header:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "iPv6_Fragment_header");
    enc_len += field_iPv6__Fragment__header->JSON_encode(IPv6__Fragment__header_descr_, p_tok);
    break;
  case ALT_raw__hdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "raw_hdr");
    enc_len += field_raw__hdr->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @IP_Types.IPv6_extension_header.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IPv6__extension__header::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "ah_hdr", name_len)) {
      int ret_val = ah__hdr().JSON_decode(IP__AH__header_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ah_hdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "esp_hdr", name_len)) {
      int ret_val = esp__hdr().JSON_decode(IP__ESP__header_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "esp_hdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "gre2_hdr", name_len)) {
      int ret_val = gre2__hdr().JSON_decode(IP__GRE2__header_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gre2_hdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "general_exthdr", name_len)) {
      int ret_val = general__exthdr().JSON_decode(IPv6__general__IPv6__extension__header_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "general_exthdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "iPv6_Fragment_header", name_len)) {
      int ret_val = iPv6__Fragment__header().JSON_decode(IPv6__Fragment__header_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "iPv6_Fragment_header");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "raw_hdr", name_len)) {
      int ret_val = raw__hdr().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "raw_hdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void IPv6__extension__header_template::copy_value(const IPv6__extension__header& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case IPv6__extension__header::ALT_ah__hdr:
single_value.field_ah__hdr = new IP__AH__header_template(other_value.ah__hdr());
break;
case IPv6__extension__header::ALT_esp__hdr:
single_value.field_esp__hdr = new IP__ESP__header_template(other_value.esp__hdr());
break;
case IPv6__extension__header::ALT_gre2__hdr:
single_value.field_gre2__hdr = new IP__GRE2__header_template(other_value.gre2__hdr());
break;
case IPv6__extension__header::ALT_general__exthdr:
single_value.field_general__exthdr = new IPv6__general__IPv6__extension__header_template(other_value.general__exthdr());
break;
case IPv6__extension__header::ALT_iPv6__Fragment__header:
single_value.field_iPv6__Fragment__header = new IPv6__Fragment__header_template(other_value.iPv6__Fragment__header());
break;
case IPv6__extension__header::ALT_raw__hdr:
single_value.field_raw__hdr = new OCTETSTRING_template(other_value.raw__hdr());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @IP_Types.IPv6_extension_header.");
}
set_selection(SPECIFIC_VALUE);
}

void IPv6__extension__header_template::copy_template(const IPv6__extension__header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case IPv6__extension__header::ALT_ah__hdr:
single_value.field_ah__hdr = new IP__AH__header_template(*other_value.single_value.field_ah__hdr);
break;
case IPv6__extension__header::ALT_esp__hdr:
single_value.field_esp__hdr = new IP__ESP__header_template(*other_value.single_value.field_esp__hdr);
break;
case IPv6__extension__header::ALT_gre2__hdr:
single_value.field_gre2__hdr = new IP__GRE2__header_template(*other_value.single_value.field_gre2__hdr);
break;
case IPv6__extension__header::ALT_general__exthdr:
single_value.field_general__exthdr = new IPv6__general__IPv6__extension__header_template(*other_value.single_value.field_general__exthdr);
break;
case IPv6__extension__header::ALT_iPv6__Fragment__header:
single_value.field_iPv6__Fragment__header = new IPv6__Fragment__header_template(*other_value.single_value.field_iPv6__Fragment__header);
break;
case IPv6__extension__header::ALT_raw__hdr:
single_value.field_raw__hdr = new OCTETSTRING_template(*other_value.single_value.field_raw__hdr);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @IP_Types.IPv6_extension_header.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPv6__extension__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @IP_Types.IPv6_extension_header.");
}
set_selection(other_value);
}

IPv6__extension__header_template::IPv6__extension__header_template()
{
}

IPv6__extension__header_template::IPv6__extension__header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPv6__extension__header_template::IPv6__extension__header_template(const IPv6__extension__header& other_value)
{
copy_value(other_value);
}

IPv6__extension__header_template::IPv6__extension__header_template(const OPTIONAL<IPv6__extension__header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv6__extension__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @IP_Types.IPv6_extension_header from an unbound optional field.");
}
}

IPv6__extension__header_template::IPv6__extension__header_template(const IPv6__extension__header_template& other_value)
: Base_Template(){
copy_template(other_value);
}

IPv6__extension__header_template::~IPv6__extension__header_template()
{
clean_up();
}

void IPv6__extension__header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case IPv6__extension__header::ALT_ah__hdr:
delete single_value.field_ah__hdr;
break;
case IPv6__extension__header::ALT_esp__hdr:
delete single_value.field_esp__hdr;
break;
case IPv6__extension__header::ALT_gre2__hdr:
delete single_value.field_gre2__hdr;
break;
case IPv6__extension__header::ALT_general__exthdr:
delete single_value.field_general__exthdr;
break;
case IPv6__extension__header::ALT_iPv6__Fragment__header:
delete single_value.field_iPv6__Fragment__header;
break;
case IPv6__extension__header::ALT_raw__hdr:
delete single_value.field_raw__hdr;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IPv6__extension__header_template& IPv6__extension__header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPv6__extension__header_template& IPv6__extension__header_template::operator=(const IPv6__extension__header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IPv6__extension__header_template& IPv6__extension__header_template::operator=(const OPTIONAL<IPv6__extension__header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv6__extension__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @IP_Types.IPv6_extension_header.");
}
return *this;
}

IPv6__extension__header_template& IPv6__extension__header_template::operator=(const IPv6__extension__header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPv6__extension__header_template::match(const IPv6__extension__header& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
IPv6__extension__header::union_selection_type value_selection = other_value.get_selection();
if (value_selection == IPv6__extension__header::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case IPv6__extension__header::ALT_ah__hdr:
return single_value.field_ah__hdr->match(other_value.ah__hdr());
case IPv6__extension__header::ALT_esp__hdr:
return single_value.field_esp__hdr->match(other_value.esp__hdr());
case IPv6__extension__header::ALT_gre2__hdr:
return single_value.field_gre2__hdr->match(other_value.gre2__hdr());
case IPv6__extension__header::ALT_general__exthdr:
return single_value.field_general__exthdr->match(other_value.general__exthdr());
case IPv6__extension__header::ALT_iPv6__Fragment__header:
return single_value.field_iPv6__Fragment__header->match(other_value.iPv6__Fragment__header());
case IPv6__extension__header::ALT_raw__hdr:
return single_value.field_raw__hdr->match(other_value.raw__hdr());
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @IP_Types.IPv6_extension_header.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @IP_Types.IPv6_extension_header.");
}
return FALSE;
}

boolean IPv6__extension__header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case IPv6__extension__header::ALT_ah__hdr:
return single_value.field_ah__hdr->is_value();
case IPv6__extension__header::ALT_esp__hdr:
return single_value.field_esp__hdr->is_value();
case IPv6__extension__header::ALT_gre2__hdr:
return single_value.field_gre2__hdr->is_value();
case IPv6__extension__header::ALT_general__exthdr:
return single_value.field_general__exthdr->is_value();
case IPv6__extension__header::ALT_iPv6__Fragment__header:
return single_value.field_iPv6__Fragment__header->is_value();
case IPv6__extension__header::ALT_raw__hdr:
return single_value.field_raw__hdr->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @IP_Types.IPv6_extension_header.");
}
}

IPv6__extension__header IPv6__extension__header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @IP_Types.IPv6_extension_header.");
IPv6__extension__header ret_val;
switch (single_value.union_selection) {
case IPv6__extension__header::ALT_ah__hdr:
ret_val.ah__hdr() = single_value.field_ah__hdr->valueof();
break;
case IPv6__extension__header::ALT_esp__hdr:
ret_val.esp__hdr() = single_value.field_esp__hdr->valueof();
break;
case IPv6__extension__header::ALT_gre2__hdr:
ret_val.gre2__hdr() = single_value.field_gre2__hdr->valueof();
break;
case IPv6__extension__header::ALT_general__exthdr:
ret_val.general__exthdr() = single_value.field_general__exthdr->valueof();
break;
case IPv6__extension__header::ALT_iPv6__Fragment__header:
ret_val.iPv6__Fragment__header() = single_value.field_iPv6__Fragment__header->valueof();
break;
case IPv6__extension__header::ALT_raw__hdr:
ret_val.raw__hdr() = single_value.field_raw__hdr->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @IP_Types.IPv6_extension_header.");
}
return ret_val;
}

IPv6__extension__header_template& IPv6__extension__header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @IP_Types.IPv6_extension_header.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @IP_Types.IPv6_extension_header.");
return value_list.list_value[list_index];
}
void IPv6__extension__header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @IP_Types.IPv6_extension_header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPv6__extension__header_template[list_length];
}

IP__AH__header_template& IPv6__extension__header_template::ah__hdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPv6__extension__header::ALT_ah__hdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_ah__hdr = new IP__AH__header_template(ANY_VALUE);
else single_value.field_ah__hdr = new IP__AH__header_template;
single_value.union_selection = IPv6__extension__header::ALT_ah__hdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_ah__hdr;
}

const IP__AH__header_template& IPv6__extension__header_template::ah__hdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field ah_hdr in a non-specific template of union type @IP_Types.IPv6_extension_header.");
if (single_value.union_selection != IPv6__extension__header::ALT_ah__hdr) TTCN_error("Accessing non-selected field ah_hdr in a template of union type @IP_Types.IPv6_extension_header.");
return *single_value.field_ah__hdr;
}

IP__ESP__header_template& IPv6__extension__header_template::esp__hdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPv6__extension__header::ALT_esp__hdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_esp__hdr = new IP__ESP__header_template(ANY_VALUE);
else single_value.field_esp__hdr = new IP__ESP__header_template;
single_value.union_selection = IPv6__extension__header::ALT_esp__hdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_esp__hdr;
}

const IP__ESP__header_template& IPv6__extension__header_template::esp__hdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field esp_hdr in a non-specific template of union type @IP_Types.IPv6_extension_header.");
if (single_value.union_selection != IPv6__extension__header::ALT_esp__hdr) TTCN_error("Accessing non-selected field esp_hdr in a template of union type @IP_Types.IPv6_extension_header.");
return *single_value.field_esp__hdr;
}

IP__GRE2__header_template& IPv6__extension__header_template::gre2__hdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPv6__extension__header::ALT_gre2__hdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_gre2__hdr = new IP__GRE2__header_template(ANY_VALUE);
else single_value.field_gre2__hdr = new IP__GRE2__header_template;
single_value.union_selection = IPv6__extension__header::ALT_gre2__hdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_gre2__hdr;
}

const IP__GRE2__header_template& IPv6__extension__header_template::gre2__hdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field gre2_hdr in a non-specific template of union type @IP_Types.IPv6_extension_header.");
if (single_value.union_selection != IPv6__extension__header::ALT_gre2__hdr) TTCN_error("Accessing non-selected field gre2_hdr in a template of union type @IP_Types.IPv6_extension_header.");
return *single_value.field_gre2__hdr;
}

IPv6__general__IPv6__extension__header_template& IPv6__extension__header_template::general__exthdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPv6__extension__header::ALT_general__exthdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_general__exthdr = new IPv6__general__IPv6__extension__header_template(ANY_VALUE);
else single_value.field_general__exthdr = new IPv6__general__IPv6__extension__header_template;
single_value.union_selection = IPv6__extension__header::ALT_general__exthdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_general__exthdr;
}

const IPv6__general__IPv6__extension__header_template& IPv6__extension__header_template::general__exthdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field general_exthdr in a non-specific template of union type @IP_Types.IPv6_extension_header.");
if (single_value.union_selection != IPv6__extension__header::ALT_general__exthdr) TTCN_error("Accessing non-selected field general_exthdr in a template of union type @IP_Types.IPv6_extension_header.");
return *single_value.field_general__exthdr;
}

IPv6__Fragment__header_template& IPv6__extension__header_template::iPv6__Fragment__header()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPv6__extension__header::ALT_iPv6__Fragment__header) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_iPv6__Fragment__header = new IPv6__Fragment__header_template(ANY_VALUE);
else single_value.field_iPv6__Fragment__header = new IPv6__Fragment__header_template;
single_value.union_selection = IPv6__extension__header::ALT_iPv6__Fragment__header;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_iPv6__Fragment__header;
}

const IPv6__Fragment__header_template& IPv6__extension__header_template::iPv6__Fragment__header() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field iPv6_Fragment_header in a non-specific template of union type @IP_Types.IPv6_extension_header.");
if (single_value.union_selection != IPv6__extension__header::ALT_iPv6__Fragment__header) TTCN_error("Accessing non-selected field iPv6_Fragment_header in a template of union type @IP_Types.IPv6_extension_header.");
return *single_value.field_iPv6__Fragment__header;
}

OCTETSTRING_template& IPv6__extension__header_template::raw__hdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPv6__extension__header::ALT_raw__hdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_raw__hdr = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_raw__hdr = new OCTETSTRING_template;
single_value.union_selection = IPv6__extension__header::ALT_raw__hdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_raw__hdr;
}

const OCTETSTRING_template& IPv6__extension__header_template::raw__hdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field raw_hdr in a non-specific template of union type @IP_Types.IPv6_extension_header.");
if (single_value.union_selection != IPv6__extension__header::ALT_raw__hdr) TTCN_error("Accessing non-selected field raw_hdr in a template of union type @IP_Types.IPv6_extension_header.");
return *single_value.field_raw__hdr;
}

boolean IPv6__extension__header_template::ischosen(IPv6__extension__header::union_selection_type checked_selection) const
{
if (checked_selection == IPv6__extension__header::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @IP_Types.IPv6_extension_header.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == IPv6__extension__header::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @IP_Types.IPv6_extension_header.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @IP_Types.IPv6_extension_header containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @IP_Types.IPv6_extension_header, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @IP_Types.IPv6_extension_header");
}
return FALSE;
}

void IPv6__extension__header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case IPv6__extension__header::ALT_ah__hdr:
TTCN_Logger::log_event_str("{ ah_hdr := ");
single_value.field_ah__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case IPv6__extension__header::ALT_esp__hdr:
TTCN_Logger::log_event_str("{ esp_hdr := ");
single_value.field_esp__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case IPv6__extension__header::ALT_gre2__hdr:
TTCN_Logger::log_event_str("{ gre2_hdr := ");
single_value.field_gre2__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
case IPv6__extension__header::ALT_general__exthdr:
TTCN_Logger::log_event_str("{ general_exthdr := ");
single_value.field_general__exthdr->log();
TTCN_Logger::log_event_str(" }");
break;
case IPv6__extension__header::ALT_iPv6__Fragment__header:
TTCN_Logger::log_event_str("{ iPv6_Fragment_header := ");
single_value.field_iPv6__Fragment__header->log();
TTCN_Logger::log_event_str(" }");
break;
case IPv6__extension__header::ALT_raw__hdr:
TTCN_Logger::log_event_str("{ raw_hdr := ");
single_value.field_raw__hdr->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPv6__extension__header_template::log_match(const IPv6__extension__header& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case IPv6__extension__header::ALT_ah__hdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".ah_hdr");
single_value.field_ah__hdr->log_match(match_value.ah__hdr());
} else {
TTCN_Logger::log_event_str("{ ah_hdr := ");
single_value.field_ah__hdr->log_match(match_value.ah__hdr());
TTCN_Logger::log_event_str(" }");
}
break;
case IPv6__extension__header::ALT_esp__hdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".esp_hdr");
single_value.field_esp__hdr->log_match(match_value.esp__hdr());
} else {
TTCN_Logger::log_event_str("{ esp_hdr := ");
single_value.field_esp__hdr->log_match(match_value.esp__hdr());
TTCN_Logger::log_event_str(" }");
}
break;
case IPv6__extension__header::ALT_gre2__hdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".gre2_hdr");
single_value.field_gre2__hdr->log_match(match_value.gre2__hdr());
} else {
TTCN_Logger::log_event_str("{ gre2_hdr := ");
single_value.field_gre2__hdr->log_match(match_value.gre2__hdr());
TTCN_Logger::log_event_str(" }");
}
break;
case IPv6__extension__header::ALT_general__exthdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".general_exthdr");
single_value.field_general__exthdr->log_match(match_value.general__exthdr());
} else {
TTCN_Logger::log_event_str("{ general_exthdr := ");
single_value.field_general__exthdr->log_match(match_value.general__exthdr());
TTCN_Logger::log_event_str(" }");
}
break;
case IPv6__extension__header::ALT_iPv6__Fragment__header:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".iPv6_Fragment_header");
single_value.field_iPv6__Fragment__header->log_match(match_value.iPv6__Fragment__header());
} else {
TTCN_Logger::log_event_str("{ iPv6_Fragment_header := ");
single_value.field_iPv6__Fragment__header->log_match(match_value.iPv6__Fragment__header());
TTCN_Logger::log_event_str(" }");
}
break;
case IPv6__extension__header::ALT_raw__hdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".raw_hdr");
single_value.field_raw__hdr->log_match(match_value.raw__hdr());
} else {
TTCN_Logger::log_event_str("{ raw_hdr := ");
single_value.field_raw__hdr->log_match(match_value.raw__hdr());
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IPv6__extension__header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case IPv6__extension__header::ALT_ah__hdr:
single_value.field_ah__hdr->encode_text(text_buf);
break;
case IPv6__extension__header::ALT_esp__hdr:
single_value.field_esp__hdr->encode_text(text_buf);
break;
case IPv6__extension__header::ALT_gre2__hdr:
single_value.field_gre2__hdr->encode_text(text_buf);
break;
case IPv6__extension__header::ALT_general__exthdr:
single_value.field_general__exthdr->encode_text(text_buf);
break;
case IPv6__extension__header::ALT_iPv6__Fragment__header:
single_value.field_iPv6__Fragment__header->encode_text(text_buf);
break;
case IPv6__extension__header::ALT_raw__hdr:
single_value.field_raw__hdr->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @IP_Types.IPv6_extension_header.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @IP_Types.IPv6_extension_header.");
}
}

void IPv6__extension__header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = IPv6__extension__header::UNBOUND_VALUE;
IPv6__extension__header::union_selection_type new_selection = (IPv6__extension__header::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case IPv6__extension__header::ALT_ah__hdr:
single_value.field_ah__hdr = new IP__AH__header_template;
single_value.field_ah__hdr->decode_text(text_buf);
break;
case IPv6__extension__header::ALT_esp__hdr:
single_value.field_esp__hdr = new IP__ESP__header_template;
single_value.field_esp__hdr->decode_text(text_buf);
break;
case IPv6__extension__header::ALT_gre2__hdr:
single_value.field_gre2__hdr = new IP__GRE2__header_template;
single_value.field_gre2__hdr->decode_text(text_buf);
break;
case IPv6__extension__header::ALT_general__exthdr:
single_value.field_general__exthdr = new IPv6__general__IPv6__extension__header_template;
single_value.field_general__exthdr->decode_text(text_buf);
break;
case IPv6__extension__header::ALT_iPv6__Fragment__header:
single_value.field_iPv6__Fragment__header = new IPv6__Fragment__header_template;
single_value.field_iPv6__Fragment__header->decode_text(text_buf);
break;
case IPv6__extension__header::ALT_raw__hdr:
single_value.field_raw__hdr = new OCTETSTRING_template;
single_value.field_raw__hdr->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @IP_Types.IPv6_extension_header.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPv6__extension__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @IP_Types.IPv6_extension_header.");
}
}

boolean IPv6__extension__header_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IPv6__extension__header_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void IPv6__extension__header_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@IP_Types.IPv6_extension_header'");
    }
    if (strcmp("ah_hdr", param_field) == 0) {
      ah__hdr().set_param(param);
      return;
    } else if (strcmp("esp_hdr", param_field) == 0) {
      esp__hdr().set_param(param);
      return;
    } else if (strcmp("gre2_hdr", param_field) == 0) {
      gre2__hdr().set_param(param);
      return;
    } else if (strcmp("general_exthdr", param_field) == 0) {
      general__exthdr().set_param(param);
      return;
    } else if (strcmp("iPv6_Fragment_header", param_field) == 0) {
      iPv6__Fragment__header().set_param(param);
      return;
    } else if (strcmp("raw_hdr", param_field) == 0) {
      raw__hdr().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@IP_Types.IPv6_extension_header'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (param.get_size()==0) break;
    param.type_error("union template", "@IP_Types.IPv6_extension_header");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = param.get_elem(param.get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "ah_hdr")) {
      ah__hdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "esp_hdr")) {
      esp__hdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "gre2_hdr")) {
      gre2__hdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "general_exthdr")) {
      general__exthdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "iPv6_Fragment_header")) {
      iPv6__Fragment__header().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "raw_hdr")) {
      raw__hdr().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @IP_Types.IPv6_extension_header.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@IP_Types.IPv6_extension_header");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPv6__extension__header_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case IPv6__extension__header::ALT_ah__hdr:
single_value.field_ah__hdr->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_extension_header");
return;
case IPv6__extension__header::ALT_esp__hdr:
single_value.field_esp__hdr->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_extension_header");
return;
case IPv6__extension__header::ALT_gre2__hdr:
single_value.field_gre2__hdr->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_extension_header");
return;
case IPv6__extension__header::ALT_general__exthdr:
single_value.field_general__exthdr->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_extension_header");
return;
case IPv6__extension__header::ALT_iPv6__Fragment__header:
single_value.field_iPv6__Fragment__header->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_extension_header");
return;
case IPv6__extension__header::ALT_raw__hdr:
single_value.field_raw__hdr->check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_extension_header");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @IP_Types.IPv6_extension_header.");
}
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IPv6_extension_header");
}

IPv6__general__IPv6__extension__header::IPv6__general__IPv6__extension__header()
{
  bound_flag = FALSE;
}

IPv6__general__IPv6__extension__header::IPv6__general__IPv6__extension__header(const INTEGER& par_next__header,
    const INTEGER& par_exthdr__length,
    const OCTETSTRING& par_data)
  :   field_next__header(par_next__header),
  field_exthdr__length(par_exthdr__length),
  field_data(par_data)
{
  bound_flag = TRUE;
}

IPv6__general__IPv6__extension__header::IPv6__general__IPv6__extension__header(const IPv6__general__IPv6__extension__header& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IPv6_general_IPv6_extension_header.");
bound_flag = TRUE;
if (other_value.next__header().is_bound()) field_next__header = other_value.next__header();
else field_next__header.clean_up();
if (other_value.exthdr__length().is_bound()) field_exthdr__length = other_value.exthdr__length();
else field_exthdr__length.clean_up();
if (other_value.data().is_bound()) field_data = other_value.data();
else field_data.clean_up();
}

void IPv6__general__IPv6__extension__header::clean_up()
{
field_next__header.clean_up();
field_exthdr__length.clean_up();
field_data.clean_up();
bound_flag = FALSE;
}

IPv6__general__IPv6__extension__header& IPv6__general__IPv6__extension__header::operator=(const IPv6__general__IPv6__extension__header& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.IPv6_general_IPv6_extension_header.");
  bound_flag = TRUE;
  if (other_value.next__header().is_bound()) field_next__header = other_value.next__header();
  else field_next__header.clean_up();
  if (other_value.exthdr__length().is_bound()) field_exthdr__length = other_value.exthdr__length();
  else field_exthdr__length.clean_up();
  if (other_value.data().is_bound()) field_data = other_value.data();
  else field_data.clean_up();
}
return *this;
}

boolean IPv6__general__IPv6__extension__header::operator==(const IPv6__general__IPv6__extension__header& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_next__header==other_value.field_next__header
  && field_exthdr__length==other_value.field_exthdr__length
  && field_data==other_value.field_data;
}

boolean IPv6__general__IPv6__extension__header::is_bound() const
{
if (bound_flag) return TRUE;
if(field_next__header.is_bound()) return TRUE;
if(field_exthdr__length.is_bound()) return TRUE;
if(field_data.is_bound()) return TRUE;
return FALSE;
}
boolean IPv6__general__IPv6__extension__header::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_next__header.is_value()) return FALSE;
if(!field_exthdr__length.is_value()) return FALSE;
if(!field_data.is_value()) return FALSE;
return TRUE;
}
int IPv6__general__IPv6__extension__header::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.IPv6_general_IPv6_extension_header");
  return 3;
}

void IPv6__general__IPv6__extension__header::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ next_header := ");
field_next__header.log();
TTCN_Logger::log_event_str(", exthdr_length := ");
field_exthdr__length.log();
TTCN_Logger::log_event_str(", data := ");
field_data.log();
TTCN_Logger::log_event_str(" }");
}

void IPv6__general__IPv6__extension__header::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.IPv6_general_IPv6_extension_header'");
    }
    if (strcmp("next_header", param_field) == 0) {
      next__header().set_param(param);
      return;
    } else if (strcmp("exthdr_length", param_field) == 0) {
      exthdr__length().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.IPv6_general_IPv6_extension_header'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @IP_Types.IPv6_general_IPv6_extension_header has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) next__header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) exthdr__length().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "next_header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          next__header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "exthdr_length")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          exthdr__length().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IPv6_general_IPv6_extension_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.IPv6_general_IPv6_extension_header");
  }
}

void IPv6__general__IPv6__extension__header::set_implicit_omit()
{
if (next__header().is_bound()) next__header().set_implicit_omit();
if (exthdr__length().is_bound()) exthdr__length().set_implicit_omit();
if (data().is_bound()) data().set_implicit_omit();
}

void IPv6__general__IPv6__extension__header::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.IPv6_general_IPv6_extension_header.");
field_next__header.encode_text(text_buf);
field_exthdr__length.encode_text(text_buf);
field_data.encode_text(text_buf);
}

void IPv6__general__IPv6__extension__header::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_next__header.decode_text(text_buf);
field_exthdr__length.decode_text(text_buf);
field_data.decode_text(text_buf);
}

void IPv6__general__IPv6__extension__header::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IPv6__general__IPv6__extension__header::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IPv6__general__IPv6__extension__header::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_next__header.RAW_decode(General__Types::LIN1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_exthdr__length.RAW_decode(IPv6__general__IPv6__extension__header_exthdr__length_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_data.RAW_decode(OCTETSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IPv6__general__IPv6__extension__header::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, General__Types::LIN1_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, IPv6__general__IPv6__extension__header_exthdr__length_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, OCTETSTRING_descr_.raw);
  encoded_length += field_next__header.RAW_encode(General__Types::LIN1_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_exthdr__length.RAW_encode(IPv6__general__IPv6__extension__header_exthdr__length_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_data.RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

int IPv6__general__IPv6__extension__header::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IPv6_general_IPv6_extension_header.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "next_header");
    enc_len += field_next__header.JSON_encode(General__Types::LIN1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "exthdr_length");
    enc_len += field_exthdr__length.JSON_encode(IPv6__general__IPv6__extension__header_exthdr__length_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "data");
    enc_len += field_data.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IPv6__general__IPv6__extension__header::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (11 == name_len && 0 == strncmp(fld_name, "next_header", name_len)) {
        int ret_val = field_next__header.JSON_decode(General__Types::LIN1_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "next_header");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (13 == name_len && 0 == strncmp(fld_name, "exthdr_length", name_len)) {
        int ret_val = field_exthdr__length.JSON_decode(IPv6__general__IPv6__extension__header_exthdr__length_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "exthdr_length");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (4 == name_len && 0 == strncmp(fld_name, "data", name_len)) {
        int ret_val = field_data.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "data");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_next__header.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "next_header");
    return JSON_ERROR_FATAL;
  }
  if (!field_exthdr__length.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "exthdr_length");
    return JSON_ERROR_FATAL;
  }
  if (!field_data.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "data");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct IPv6__general__IPv6__extension__header_template::single_value_struct {
INTEGER_template field_next__header;
INTEGER_template field_exthdr__length;
OCTETSTRING_template field_data;
};

void IPv6__general__IPv6__extension__header_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_next__header = ANY_VALUE;
single_value->field_exthdr__length = ANY_VALUE;
single_value->field_data = ANY_VALUE;
}
}
}

void IPv6__general__IPv6__extension__header_template::copy_value(const IPv6__general__IPv6__extension__header& other_value)
{
single_value = new single_value_struct;
if (other_value.next__header().is_bound()) {
  single_value->field_next__header = other_value.next__header();
} else {
  single_value->field_next__header.clean_up();
}
if (other_value.exthdr__length().is_bound()) {
  single_value->field_exthdr__length = other_value.exthdr__length();
} else {
  single_value->field_exthdr__length.clean_up();
}
if (other_value.data().is_bound()) {
  single_value->field_data = other_value.data();
} else {
  single_value->field_data.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IPv6__general__IPv6__extension__header_template::copy_template(const IPv6__general__IPv6__extension__header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.next__header().get_selection()) {
single_value->field_next__header = other_value.next__header();
} else {
single_value->field_next__header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.exthdr__length().get_selection()) {
single_value->field_exthdr__length = other_value.exthdr__length();
} else {
single_value->field_exthdr__length.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.data().get_selection()) {
single_value->field_data = other_value.data();
} else {
single_value->field_data.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPv6__general__IPv6__extension__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IPv6_general_IPv6_extension_header.");
break;
}
set_selection(other_value);
}

IPv6__general__IPv6__extension__header_template::IPv6__general__IPv6__extension__header_template()
{
}

IPv6__general__IPv6__extension__header_template::IPv6__general__IPv6__extension__header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPv6__general__IPv6__extension__header_template::IPv6__general__IPv6__extension__header_template(const IPv6__general__IPv6__extension__header& other_value)
{
copy_value(other_value);
}

IPv6__general__IPv6__extension__header_template::IPv6__general__IPv6__extension__header_template(const OPTIONAL<IPv6__general__IPv6__extension__header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv6__general__IPv6__extension__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IPv6_general_IPv6_extension_header from an unbound optional field.");
}
}

IPv6__general__IPv6__extension__header_template::IPv6__general__IPv6__extension__header_template(const IPv6__general__IPv6__extension__header_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IPv6__general__IPv6__extension__header_template::~IPv6__general__IPv6__extension__header_template()
{
clean_up();
}

IPv6__general__IPv6__extension__header_template& IPv6__general__IPv6__extension__header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPv6__general__IPv6__extension__header_template& IPv6__general__IPv6__extension__header_template::operator=(const IPv6__general__IPv6__extension__header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IPv6__general__IPv6__extension__header_template& IPv6__general__IPv6__extension__header_template::operator=(const OPTIONAL<IPv6__general__IPv6__extension__header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv6__general__IPv6__extension__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IPv6_general_IPv6_extension_header.");
}
return *this;
}

IPv6__general__IPv6__extension__header_template& IPv6__general__IPv6__extension__header_template::operator=(const IPv6__general__IPv6__extension__header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPv6__general__IPv6__extension__header_template::match(const IPv6__general__IPv6__extension__header& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.next__header().is_bound()) return FALSE;
if(!single_value->field_next__header.match(other_value.next__header()))return FALSE;
if(!other_value.exthdr__length().is_bound()) return FALSE;
if(!single_value->field_exthdr__length.match(other_value.exthdr__length()))return FALSE;
if(!other_value.data().is_bound()) return FALSE;
if(!single_value->field_data.match(other_value.data()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.IPv6_general_IPv6_extension_header.");
}
return FALSE;
}

boolean IPv6__general__IPv6__extension__header_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_next__header.is_bound()) return TRUE;
if (single_value->field_exthdr__length.is_bound()) return TRUE;
if (single_value->field_data.is_bound()) return TRUE;
return FALSE;
}

boolean IPv6__general__IPv6__extension__header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_next__header.is_value()) return FALSE;
if (!single_value->field_exthdr__length.is_value()) return FALSE;
if (!single_value->field_data.is_value()) return FALSE;
return TRUE;
}

void IPv6__general__IPv6__extension__header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IPv6__general__IPv6__extension__header IPv6__general__IPv6__extension__header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.IPv6_general_IPv6_extension_header.");
IPv6__general__IPv6__extension__header ret_val;
if (single_value->field_next__header.is_bound()) {
ret_val.next__header() = single_value->field_next__header.valueof();
}
if (single_value->field_exthdr__length.is_bound()) {
ret_val.exthdr__length() = single_value->field_exthdr__length.valueof();
}
if (single_value->field_data.is_bound()) {
ret_val.data() = single_value->field_data.valueof();
}
return ret_val;
}

void IPv6__general__IPv6__extension__header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.IPv6_general_IPv6_extension_header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPv6__general__IPv6__extension__header_template[list_length];
}

IPv6__general__IPv6__extension__header_template& IPv6__general__IPv6__extension__header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.IPv6_general_IPv6_extension_header.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.IPv6_general_IPv6_extension_header.");
return value_list.list_value[list_index];
}

INTEGER_template& IPv6__general__IPv6__extension__header_template::next__header()
{
set_specific();
return single_value->field_next__header;
}

const INTEGER_template& IPv6__general__IPv6__extension__header_template::next__header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field next_header of a non-specific template of type @IP_Types.IPv6_general_IPv6_extension_header.");
return single_value->field_next__header;
}

INTEGER_template& IPv6__general__IPv6__extension__header_template::exthdr__length()
{
set_specific();
return single_value->field_exthdr__length;
}

const INTEGER_template& IPv6__general__IPv6__extension__header_template::exthdr__length() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field exthdr_length of a non-specific template of type @IP_Types.IPv6_general_IPv6_extension_header.");
return single_value->field_exthdr__length;
}

OCTETSTRING_template& IPv6__general__IPv6__extension__header_template::data()
{
set_specific();
return single_value->field_data;
}

const OCTETSTRING_template& IPv6__general__IPv6__extension__header_template::data() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field data of a non-specific template of type @IP_Types.IPv6_general_IPv6_extension_header.");
return single_value->field_data;
}

int IPv6__general__IPv6__extension__header_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_general_IPv6_extension_header which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.IPv6_general_IPv6_extension_header containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_general_IPv6_extension_header containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_general_IPv6_extension_header containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_general_IPv6_extension_header containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_general_IPv6_extension_header containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.IPv6_general_IPv6_extension_header.");
  }
  return 0;
}

void IPv6__general__IPv6__extension__header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ next_header := ");
single_value->field_next__header.log();
TTCN_Logger::log_event_str(", exthdr_length := ");
single_value->field_exthdr__length.log();
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPv6__general__IPv6__extension__header_template::log_match(const IPv6__general__IPv6__extension__header& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_next__header.match(match_value.next__header())){
TTCN_Logger::log_logmatch_info(".next_header");
single_value->field_next__header.log_match(match_value.next__header());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_exthdr__length.match(match_value.exthdr__length())){
TTCN_Logger::log_logmatch_info(".exthdr_length");
single_value->field_exthdr__length.log_match(match_value.exthdr__length());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_data.match(match_value.data())){
TTCN_Logger::log_logmatch_info(".data");
single_value->field_data.log_match(match_value.data());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ next_header := ");
single_value->field_next__header.log_match(match_value.next__header());
TTCN_Logger::log_event_str(", exthdr_length := ");
single_value->field_exthdr__length.log_match(match_value.exthdr__length());
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log_match(match_value.data());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IPv6__general__IPv6__extension__header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_next__header.encode_text(text_buf);
single_value->field_exthdr__length.encode_text(text_buf);
single_value->field_data.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IPv6_general_IPv6_extension_header.");
}
}

void IPv6__general__IPv6__extension__header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_next__header.decode_text(text_buf);
single_value->field_exthdr__length.decode_text(text_buf);
single_value->field_data.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPv6__general__IPv6__extension__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.IPv6_general_IPv6_extension_header.");
}
}

void IPv6__general__IPv6__extension__header_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.IPv6_general_IPv6_extension_header'");
    }
    if (strcmp("next_header", param_field) == 0) {
      next__header().set_param(param);
      return;
    } else if (strcmp("exthdr_length", param_field) == 0) {
      exthdr__length().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.IPv6_general_IPv6_extension_header'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @IP_Types.IPv6_general_IPv6_extension_header has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) next__header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) exthdr__length().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "next_header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          next__header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "exthdr_length")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          exthdr__length().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IPv6_general_IPv6_extension_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.IPv6_general_IPv6_extension_header");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPv6__general__IPv6__extension__header_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_next__header.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_general_IPv6_extension_header");
single_value->field_exthdr__length.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_general_IPv6_extension_header");
single_value->field_data.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_general_IPv6_extension_header");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IPv6_general_IPv6_extension_header");
}

boolean IPv6__general__IPv6__extension__header_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IPv6__general__IPv6__extension__header_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

IPv6__header::IPv6__header()
{
  bound_flag = FALSE;
}

IPv6__header::IPv6__header(const INTEGER& par_ver,
    const INTEGER& par_trclass,
    const INTEGER& par_flabel,
    const INTEGER& par_plen,
    const INTEGER& par_nexthead,
    const INTEGER& par_hlim,
    const OCTETSTRING& par_srcaddr,
    const OCTETSTRING& par_dstaddr)
  :   field_ver(par_ver),
  field_trclass(par_trclass),
  field_flabel(par_flabel),
  field_plen(par_plen),
  field_nexthead(par_nexthead),
  field_hlim(par_hlim),
  field_srcaddr(par_srcaddr),
  field_dstaddr(par_dstaddr)
{
  bound_flag = TRUE;
}

IPv6__header::IPv6__header(const IPv6__header& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IPv6_header.");
bound_flag = TRUE;
if (other_value.ver().is_bound()) field_ver = other_value.ver();
else field_ver.clean_up();
if (other_value.trclass().is_bound()) field_trclass = other_value.trclass();
else field_trclass.clean_up();
if (other_value.flabel().is_bound()) field_flabel = other_value.flabel();
else field_flabel.clean_up();
if (other_value.plen().is_bound()) field_plen = other_value.plen();
else field_plen.clean_up();
if (other_value.nexthead().is_bound()) field_nexthead = other_value.nexthead();
else field_nexthead.clean_up();
if (other_value.hlim().is_bound()) field_hlim = other_value.hlim();
else field_hlim.clean_up();
if (other_value.srcaddr().is_bound()) field_srcaddr = other_value.srcaddr();
else field_srcaddr.clean_up();
if (other_value.dstaddr().is_bound()) field_dstaddr = other_value.dstaddr();
else field_dstaddr.clean_up();
}

void IPv6__header::clean_up()
{
field_ver.clean_up();
field_trclass.clean_up();
field_flabel.clean_up();
field_plen.clean_up();
field_nexthead.clean_up();
field_hlim.clean_up();
field_srcaddr.clean_up();
field_dstaddr.clean_up();
bound_flag = FALSE;
}

IPv6__header& IPv6__header::operator=(const IPv6__header& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.IPv6_header.");
  bound_flag = TRUE;
  if (other_value.ver().is_bound()) field_ver = other_value.ver();
  else field_ver.clean_up();
  if (other_value.trclass().is_bound()) field_trclass = other_value.trclass();
  else field_trclass.clean_up();
  if (other_value.flabel().is_bound()) field_flabel = other_value.flabel();
  else field_flabel.clean_up();
  if (other_value.plen().is_bound()) field_plen = other_value.plen();
  else field_plen.clean_up();
  if (other_value.nexthead().is_bound()) field_nexthead = other_value.nexthead();
  else field_nexthead.clean_up();
  if (other_value.hlim().is_bound()) field_hlim = other_value.hlim();
  else field_hlim.clean_up();
  if (other_value.srcaddr().is_bound()) field_srcaddr = other_value.srcaddr();
  else field_srcaddr.clean_up();
  if (other_value.dstaddr().is_bound()) field_dstaddr = other_value.dstaddr();
  else field_dstaddr.clean_up();
}
return *this;
}

boolean IPv6__header::operator==(const IPv6__header& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_ver==other_value.field_ver
  && field_trclass==other_value.field_trclass
  && field_flabel==other_value.field_flabel
  && field_plen==other_value.field_plen
  && field_nexthead==other_value.field_nexthead
  && field_hlim==other_value.field_hlim
  && field_srcaddr==other_value.field_srcaddr
  && field_dstaddr==other_value.field_dstaddr;
}

boolean IPv6__header::is_bound() const
{
if (bound_flag) return TRUE;
if(field_ver.is_bound()) return TRUE;
if(field_trclass.is_bound()) return TRUE;
if(field_flabel.is_bound()) return TRUE;
if(field_plen.is_bound()) return TRUE;
if(field_nexthead.is_bound()) return TRUE;
if(field_hlim.is_bound()) return TRUE;
if(field_srcaddr.is_bound()) return TRUE;
if(field_dstaddr.is_bound()) return TRUE;
return FALSE;
}
boolean IPv6__header::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_ver.is_value()) return FALSE;
if(!field_trclass.is_value()) return FALSE;
if(!field_flabel.is_value()) return FALSE;
if(!field_plen.is_value()) return FALSE;
if(!field_nexthead.is_value()) return FALSE;
if(!field_hlim.is_value()) return FALSE;
if(!field_srcaddr.is_value()) return FALSE;
if(!field_dstaddr.is_value()) return FALSE;
return TRUE;
}
int IPv6__header::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.IPv6_header");
  return 8;
}

void IPv6__header::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ ver := ");
field_ver.log();
TTCN_Logger::log_event_str(", trclass := ");
field_trclass.log();
TTCN_Logger::log_event_str(", flabel := ");
field_flabel.log();
TTCN_Logger::log_event_str(", plen := ");
field_plen.log();
TTCN_Logger::log_event_str(", nexthead := ");
field_nexthead.log();
TTCN_Logger::log_event_str(", hlim := ");
field_hlim.log();
TTCN_Logger::log_event_str(", srcaddr := ");
field_srcaddr.log();
TTCN_Logger::log_event_str(", dstaddr := ");
field_dstaddr.log();
TTCN_Logger::log_event_str(" }");
}

void IPv6__header::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.IPv6_header'");
    }
    if (strcmp("ver", param_field) == 0) {
      ver().set_param(param);
      return;
    } else if (strcmp("trclass", param_field) == 0) {
      trclass().set_param(param);
      return;
    } else if (strcmp("flabel", param_field) == 0) {
      flabel().set_param(param);
      return;
    } else if (strcmp("plen", param_field) == 0) {
      plen().set_param(param);
      return;
    } else if (strcmp("nexthead", param_field) == 0) {
      nexthead().set_param(param);
      return;
    } else if (strcmp("hlim", param_field) == 0) {
      hlim().set_param(param);
      return;
    } else if (strcmp("srcaddr", param_field) == 0) {
      srcaddr().set_param(param);
      return;
    } else if (strcmp("dstaddr", param_field) == 0) {
      dstaddr().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.IPv6_header'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (8<param.get_size()) {
      param.error("record value of type @IP_Types.IPv6_header has 8 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ver().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) trclass().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) flabel().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) plen().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) nexthead().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) hlim().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) srcaddr().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) dstaddr().set_param(*param.get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ver")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ver().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trclass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trclass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flabel")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flabel().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "plen")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          plen().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nexthead")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nexthead().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hlim")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hlim().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcaddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcaddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dstaddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dstaddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IPv6_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.IPv6_header");
  }
}

void IPv6__header::set_implicit_omit()
{
if (ver().is_bound()) ver().set_implicit_omit();
if (trclass().is_bound()) trclass().set_implicit_omit();
if (flabel().is_bound()) flabel().set_implicit_omit();
if (plen().is_bound()) plen().set_implicit_omit();
if (nexthead().is_bound()) nexthead().set_implicit_omit();
if (hlim().is_bound()) hlim().set_implicit_omit();
if (srcaddr().is_bound()) srcaddr().set_implicit_omit();
if (dstaddr().is_bound()) dstaddr().set_implicit_omit();
}

void IPv6__header::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.IPv6_header.");
field_ver.encode_text(text_buf);
field_trclass.encode_text(text_buf);
field_flabel.encode_text(text_buf);
field_plen.encode_text(text_buf);
field_nexthead.encode_text(text_buf);
field_hlim.encode_text(text_buf);
field_srcaddr.encode_text(text_buf);
field_dstaddr.encode_text(text_buf);
}

void IPv6__header::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_ver.decode_text(text_buf);
field_trclass.decode_text(text_buf);
field_flabel.decode_text(text_buf);
field_plen.decode_text(text_buf);
field_nexthead.decode_text(text_buf);
field_hlim.decode_text(text_buf);
field_srcaddr.decode_text(text_buf);
field_dstaddr.decode_text(text_buf);
}

void IPv6__header::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IPv6__header::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IPv6__header::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_ver.RAW_decode(IPv6__header_ver_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_trclass.RAW_decode(IPv6__header_trclass_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_flabel.RAW_decode(IPv6__header_flabel_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_plen.RAW_decode(IPv6__header_plen_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_nexthead.RAW_decode(IPv6__header_nexthead_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_hlim.RAW_decode(IPv6__header_hlim_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_srcaddr.RAW_decode(IPv6__header_srcaddr_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_dstaddr.RAW_decode(IPv6__header_dstaddr_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IPv6__header::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 8;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(8);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, IPv6__header_ver_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, IPv6__header_trclass_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, IPv6__header_flabel_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, IPv6__header_plen_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, IPv6__header_nexthead_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, IPv6__header_hlim_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, IPv6__header_srcaddr_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, IPv6__header_dstaddr_descr_.raw);
  encoded_length += field_ver.RAW_encode(IPv6__header_ver_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_trclass.RAW_encode(IPv6__header_trclass_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_flabel.RAW_encode(IPv6__header_flabel_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_plen.RAW_encode(IPv6__header_plen_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_nexthead.RAW_encode(IPv6__header_nexthead_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_hlim.RAW_encode(IPv6__header_hlim_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_srcaddr.RAW_encode(IPv6__header_srcaddr_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_dstaddr.RAW_encode(IPv6__header_dstaddr_descr_, *myleaf.body.node.nodes[7]);
  return myleaf.length = encoded_length;
}

int IPv6__header::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IPv6_header.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ver");
    enc_len += field_ver.JSON_encode(IPv6__header_ver_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trclass");
    enc_len += field_trclass.JSON_encode(IPv6__header_trclass_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "flabel");
    enc_len += field_flabel.JSON_encode(IPv6__header_flabel_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "plen");
    enc_len += field_plen.JSON_encode(IPv6__header_plen_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nexthead");
    enc_len += field_nexthead.JSON_encode(IPv6__header_nexthead_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "hlim");
    enc_len += field_hlim.JSON_encode(IPv6__header_hlim_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "srcaddr");
    enc_len += field_srcaddr.JSON_encode(IPv6__header_srcaddr_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dstaddr");
    enc_len += field_dstaddr.JSON_encode(IPv6__header_dstaddr_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IPv6__header::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (3 == name_len && 0 == strncmp(fld_name, "ver", name_len)) {
        int ret_val = field_ver.JSON_decode(IPv6__header_ver_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ver");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (7 == name_len && 0 == strncmp(fld_name, "trclass", name_len)) {
        int ret_val = field_trclass.JSON_decode(IPv6__header_trclass_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trclass");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (6 == name_len && 0 == strncmp(fld_name, "flabel", name_len)) {
        int ret_val = field_flabel.JSON_decode(IPv6__header_flabel_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "flabel");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (4 == name_len && 0 == strncmp(fld_name, "plen", name_len)) {
        int ret_val = field_plen.JSON_decode(IPv6__header_plen_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "plen");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (8 == name_len && 0 == strncmp(fld_name, "nexthead", name_len)) {
        int ret_val = field_nexthead.JSON_decode(IPv6__header_nexthead_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nexthead");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (4 == name_len && 0 == strncmp(fld_name, "hlim", name_len)) {
        int ret_val = field_hlim.JSON_decode(IPv6__header_hlim_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "hlim");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (7 == name_len && 0 == strncmp(fld_name, "srcaddr", name_len)) {
        int ret_val = field_srcaddr.JSON_decode(IPv6__header_srcaddr_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "srcaddr");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (7 == name_len && 0 == strncmp(fld_name, "dstaddr", name_len)) {
        int ret_val = field_dstaddr.JSON_decode(IPv6__header_dstaddr_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dstaddr");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_ver.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "ver");
    return JSON_ERROR_FATAL;
  }
  if (!field_trclass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trclass");
    return JSON_ERROR_FATAL;
  }
  if (!field_flabel.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "flabel");
    return JSON_ERROR_FATAL;
  }
  if (!field_plen.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "plen");
    return JSON_ERROR_FATAL;
  }
  if (!field_nexthead.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "nexthead");
    return JSON_ERROR_FATAL;
  }
  if (!field_hlim.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "hlim");
    return JSON_ERROR_FATAL;
  }
  if (!field_srcaddr.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "srcaddr");
    return JSON_ERROR_FATAL;
  }
  if (!field_dstaddr.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "dstaddr");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct IPv6__header_template::single_value_struct {
INTEGER_template field_ver;
INTEGER_template field_trclass;
INTEGER_template field_flabel;
INTEGER_template field_plen;
INTEGER_template field_nexthead;
INTEGER_template field_hlim;
OCTETSTRING_template field_srcaddr;
OCTETSTRING_template field_dstaddr;
};

void IPv6__header_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_ver = ANY_VALUE;
single_value->field_trclass = ANY_VALUE;
single_value->field_flabel = ANY_VALUE;
single_value->field_plen = ANY_VALUE;
single_value->field_nexthead = ANY_VALUE;
single_value->field_hlim = ANY_VALUE;
single_value->field_srcaddr = ANY_VALUE;
single_value->field_dstaddr = ANY_VALUE;
}
}
}

void IPv6__header_template::copy_value(const IPv6__header& other_value)
{
single_value = new single_value_struct;
if (other_value.ver().is_bound()) {
  single_value->field_ver = other_value.ver();
} else {
  single_value->field_ver.clean_up();
}
if (other_value.trclass().is_bound()) {
  single_value->field_trclass = other_value.trclass();
} else {
  single_value->field_trclass.clean_up();
}
if (other_value.flabel().is_bound()) {
  single_value->field_flabel = other_value.flabel();
} else {
  single_value->field_flabel.clean_up();
}
if (other_value.plen().is_bound()) {
  single_value->field_plen = other_value.plen();
} else {
  single_value->field_plen.clean_up();
}
if (other_value.nexthead().is_bound()) {
  single_value->field_nexthead = other_value.nexthead();
} else {
  single_value->field_nexthead.clean_up();
}
if (other_value.hlim().is_bound()) {
  single_value->field_hlim = other_value.hlim();
} else {
  single_value->field_hlim.clean_up();
}
if (other_value.srcaddr().is_bound()) {
  single_value->field_srcaddr = other_value.srcaddr();
} else {
  single_value->field_srcaddr.clean_up();
}
if (other_value.dstaddr().is_bound()) {
  single_value->field_dstaddr = other_value.dstaddr();
} else {
  single_value->field_dstaddr.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IPv6__header_template::copy_template(const IPv6__header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.ver().get_selection()) {
single_value->field_ver = other_value.ver();
} else {
single_value->field_ver.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trclass().get_selection()) {
single_value->field_trclass = other_value.trclass();
} else {
single_value->field_trclass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.flabel().get_selection()) {
single_value->field_flabel = other_value.flabel();
} else {
single_value->field_flabel.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.plen().get_selection()) {
single_value->field_plen = other_value.plen();
} else {
single_value->field_plen.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.nexthead().get_selection()) {
single_value->field_nexthead = other_value.nexthead();
} else {
single_value->field_nexthead.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.hlim().get_selection()) {
single_value->field_hlim = other_value.hlim();
} else {
single_value->field_hlim.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.srcaddr().get_selection()) {
single_value->field_srcaddr = other_value.srcaddr();
} else {
single_value->field_srcaddr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dstaddr().get_selection()) {
single_value->field_dstaddr = other_value.dstaddr();
} else {
single_value->field_dstaddr.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPv6__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IPv6_header.");
break;
}
set_selection(other_value);
}

IPv6__header_template::IPv6__header_template()
{
}

IPv6__header_template::IPv6__header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPv6__header_template::IPv6__header_template(const IPv6__header& other_value)
{
copy_value(other_value);
}

IPv6__header_template::IPv6__header_template(const OPTIONAL<IPv6__header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv6__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IPv6_header from an unbound optional field.");
}
}

IPv6__header_template::IPv6__header_template(const IPv6__header_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IPv6__header_template::~IPv6__header_template()
{
clean_up();
}

IPv6__header_template& IPv6__header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPv6__header_template& IPv6__header_template::operator=(const IPv6__header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IPv6__header_template& IPv6__header_template::operator=(const OPTIONAL<IPv6__header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv6__header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IPv6_header.");
}
return *this;
}

IPv6__header_template& IPv6__header_template::operator=(const IPv6__header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPv6__header_template::match(const IPv6__header& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.ver().is_bound()) return FALSE;
if(!single_value->field_ver.match(other_value.ver()))return FALSE;
if(!other_value.trclass().is_bound()) return FALSE;
if(!single_value->field_trclass.match(other_value.trclass()))return FALSE;
if(!other_value.flabel().is_bound()) return FALSE;
if(!single_value->field_flabel.match(other_value.flabel()))return FALSE;
if(!other_value.plen().is_bound()) return FALSE;
if(!single_value->field_plen.match(other_value.plen()))return FALSE;
if(!other_value.nexthead().is_bound()) return FALSE;
if(!single_value->field_nexthead.match(other_value.nexthead()))return FALSE;
if(!other_value.hlim().is_bound()) return FALSE;
if(!single_value->field_hlim.match(other_value.hlim()))return FALSE;
if(!other_value.srcaddr().is_bound()) return FALSE;
if(!single_value->field_srcaddr.match(other_value.srcaddr()))return FALSE;
if(!other_value.dstaddr().is_bound()) return FALSE;
if(!single_value->field_dstaddr.match(other_value.dstaddr()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.IPv6_header.");
}
return FALSE;
}

boolean IPv6__header_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_ver.is_bound()) return TRUE;
if (single_value->field_trclass.is_bound()) return TRUE;
if (single_value->field_flabel.is_bound()) return TRUE;
if (single_value->field_plen.is_bound()) return TRUE;
if (single_value->field_nexthead.is_bound()) return TRUE;
if (single_value->field_hlim.is_bound()) return TRUE;
if (single_value->field_srcaddr.is_bound()) return TRUE;
if (single_value->field_dstaddr.is_bound()) return TRUE;
return FALSE;
}

boolean IPv6__header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_ver.is_value()) return FALSE;
if (!single_value->field_trclass.is_value()) return FALSE;
if (!single_value->field_flabel.is_value()) return FALSE;
if (!single_value->field_plen.is_value()) return FALSE;
if (!single_value->field_nexthead.is_value()) return FALSE;
if (!single_value->field_hlim.is_value()) return FALSE;
if (!single_value->field_srcaddr.is_value()) return FALSE;
if (!single_value->field_dstaddr.is_value()) return FALSE;
return TRUE;
}

void IPv6__header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IPv6__header IPv6__header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.IPv6_header.");
IPv6__header ret_val;
if (single_value->field_ver.is_bound()) {
ret_val.ver() = single_value->field_ver.valueof();
}
if (single_value->field_trclass.is_bound()) {
ret_val.trclass() = single_value->field_trclass.valueof();
}
if (single_value->field_flabel.is_bound()) {
ret_val.flabel() = single_value->field_flabel.valueof();
}
if (single_value->field_plen.is_bound()) {
ret_val.plen() = single_value->field_plen.valueof();
}
if (single_value->field_nexthead.is_bound()) {
ret_val.nexthead() = single_value->field_nexthead.valueof();
}
if (single_value->field_hlim.is_bound()) {
ret_val.hlim() = single_value->field_hlim.valueof();
}
if (single_value->field_srcaddr.is_bound()) {
ret_val.srcaddr() = single_value->field_srcaddr.valueof();
}
if (single_value->field_dstaddr.is_bound()) {
ret_val.dstaddr() = single_value->field_dstaddr.valueof();
}
return ret_val;
}

void IPv6__header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.IPv6_header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPv6__header_template[list_length];
}

IPv6__header_template& IPv6__header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.IPv6_header.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.IPv6_header.");
return value_list.list_value[list_index];
}

INTEGER_template& IPv6__header_template::ver()
{
set_specific();
return single_value->field_ver;
}

const INTEGER_template& IPv6__header_template::ver() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ver of a non-specific template of type @IP_Types.IPv6_header.");
return single_value->field_ver;
}

INTEGER_template& IPv6__header_template::trclass()
{
set_specific();
return single_value->field_trclass;
}

const INTEGER_template& IPv6__header_template::trclass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trclass of a non-specific template of type @IP_Types.IPv6_header.");
return single_value->field_trclass;
}

INTEGER_template& IPv6__header_template::flabel()
{
set_specific();
return single_value->field_flabel;
}

const INTEGER_template& IPv6__header_template::flabel() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field flabel of a non-specific template of type @IP_Types.IPv6_header.");
return single_value->field_flabel;
}

INTEGER_template& IPv6__header_template::plen()
{
set_specific();
return single_value->field_plen;
}

const INTEGER_template& IPv6__header_template::plen() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field plen of a non-specific template of type @IP_Types.IPv6_header.");
return single_value->field_plen;
}

INTEGER_template& IPv6__header_template::nexthead()
{
set_specific();
return single_value->field_nexthead;
}

const INTEGER_template& IPv6__header_template::nexthead() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nexthead of a non-specific template of type @IP_Types.IPv6_header.");
return single_value->field_nexthead;
}

INTEGER_template& IPv6__header_template::hlim()
{
set_specific();
return single_value->field_hlim;
}

const INTEGER_template& IPv6__header_template::hlim() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field hlim of a non-specific template of type @IP_Types.IPv6_header.");
return single_value->field_hlim;
}

OCTETSTRING_template& IPv6__header_template::srcaddr()
{
set_specific();
return single_value->field_srcaddr;
}

const OCTETSTRING_template& IPv6__header_template::srcaddr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field srcaddr of a non-specific template of type @IP_Types.IPv6_header.");
return single_value->field_srcaddr;
}

OCTETSTRING_template& IPv6__header_template::dstaddr()
{
set_specific();
return single_value->field_dstaddr;
}

const OCTETSTRING_template& IPv6__header_template::dstaddr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dstaddr of a non-specific template of type @IP_Types.IPv6_header.");
return single_value->field_dstaddr;
}

int IPv6__header_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_header which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 8;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.IPv6_header containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_header containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_header containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_header containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_header containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.IPv6_header.");
  }
  return 0;
}

void IPv6__header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ ver := ");
single_value->field_ver.log();
TTCN_Logger::log_event_str(", trclass := ");
single_value->field_trclass.log();
TTCN_Logger::log_event_str(", flabel := ");
single_value->field_flabel.log();
TTCN_Logger::log_event_str(", plen := ");
single_value->field_plen.log();
TTCN_Logger::log_event_str(", nexthead := ");
single_value->field_nexthead.log();
TTCN_Logger::log_event_str(", hlim := ");
single_value->field_hlim.log();
TTCN_Logger::log_event_str(", srcaddr := ");
single_value->field_srcaddr.log();
TTCN_Logger::log_event_str(", dstaddr := ");
single_value->field_dstaddr.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPv6__header_template::log_match(const IPv6__header& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_ver.match(match_value.ver())){
TTCN_Logger::log_logmatch_info(".ver");
single_value->field_ver.log_match(match_value.ver());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trclass.match(match_value.trclass())){
TTCN_Logger::log_logmatch_info(".trclass");
single_value->field_trclass.log_match(match_value.trclass());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_flabel.match(match_value.flabel())){
TTCN_Logger::log_logmatch_info(".flabel");
single_value->field_flabel.log_match(match_value.flabel());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_plen.match(match_value.plen())){
TTCN_Logger::log_logmatch_info(".plen");
single_value->field_plen.log_match(match_value.plen());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_nexthead.match(match_value.nexthead())){
TTCN_Logger::log_logmatch_info(".nexthead");
single_value->field_nexthead.log_match(match_value.nexthead());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_hlim.match(match_value.hlim())){
TTCN_Logger::log_logmatch_info(".hlim");
single_value->field_hlim.log_match(match_value.hlim());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_srcaddr.match(match_value.srcaddr())){
TTCN_Logger::log_logmatch_info(".srcaddr");
single_value->field_srcaddr.log_match(match_value.srcaddr());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_dstaddr.match(match_value.dstaddr())){
TTCN_Logger::log_logmatch_info(".dstaddr");
single_value->field_dstaddr.log_match(match_value.dstaddr());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ ver := ");
single_value->field_ver.log_match(match_value.ver());
TTCN_Logger::log_event_str(", trclass := ");
single_value->field_trclass.log_match(match_value.trclass());
TTCN_Logger::log_event_str(", flabel := ");
single_value->field_flabel.log_match(match_value.flabel());
TTCN_Logger::log_event_str(", plen := ");
single_value->field_plen.log_match(match_value.plen());
TTCN_Logger::log_event_str(", nexthead := ");
single_value->field_nexthead.log_match(match_value.nexthead());
TTCN_Logger::log_event_str(", hlim := ");
single_value->field_hlim.log_match(match_value.hlim());
TTCN_Logger::log_event_str(", srcaddr := ");
single_value->field_srcaddr.log_match(match_value.srcaddr());
TTCN_Logger::log_event_str(", dstaddr := ");
single_value->field_dstaddr.log_match(match_value.dstaddr());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IPv6__header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_ver.encode_text(text_buf);
single_value->field_trclass.encode_text(text_buf);
single_value->field_flabel.encode_text(text_buf);
single_value->field_plen.encode_text(text_buf);
single_value->field_nexthead.encode_text(text_buf);
single_value->field_hlim.encode_text(text_buf);
single_value->field_srcaddr.encode_text(text_buf);
single_value->field_dstaddr.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IPv6_header.");
}
}

void IPv6__header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_ver.decode_text(text_buf);
single_value->field_trclass.decode_text(text_buf);
single_value->field_flabel.decode_text(text_buf);
single_value->field_plen.decode_text(text_buf);
single_value->field_nexthead.decode_text(text_buf);
single_value->field_hlim.decode_text(text_buf);
single_value->field_srcaddr.decode_text(text_buf);
single_value->field_dstaddr.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPv6__header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.IPv6_header.");
}
}

void IPv6__header_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.IPv6_header'");
    }
    if (strcmp("ver", param_field) == 0) {
      ver().set_param(param);
      return;
    } else if (strcmp("trclass", param_field) == 0) {
      trclass().set_param(param);
      return;
    } else if (strcmp("flabel", param_field) == 0) {
      flabel().set_param(param);
      return;
    } else if (strcmp("plen", param_field) == 0) {
      plen().set_param(param);
      return;
    } else if (strcmp("nexthead", param_field) == 0) {
      nexthead().set_param(param);
      return;
    } else if (strcmp("hlim", param_field) == 0) {
      hlim().set_param(param);
      return;
    } else if (strcmp("srcaddr", param_field) == 0) {
      srcaddr().set_param(param);
      return;
    } else if (strcmp("dstaddr", param_field) == 0) {
      dstaddr().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.IPv6_header'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (8<param.get_size()) {
      param.error("record template of type @IP_Types.IPv6_header has 8 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ver().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) trclass().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) flabel().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) plen().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) nexthead().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) hlim().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) srcaddr().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) dstaddr().set_param(*param.get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ver")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ver().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trclass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trclass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flabel")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flabel().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "plen")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          plen().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nexthead")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nexthead().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hlim")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hlim().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcaddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcaddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dstaddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dstaddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IPv6_header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.IPv6_header");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPv6__header_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_ver.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_header");
single_value->field_trclass.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_header");
single_value->field_flabel.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_header");
single_value->field_plen.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_header");
single_value->field_nexthead.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_header");
single_value->field_hlim.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_header");
single_value->field_srcaddr.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_header");
single_value->field_dstaddr.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_header");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IPv6_header");
}

boolean IPv6__header_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IPv6__header_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

IPv6__packet::IPv6__packet()
{
  bound_flag = FALSE;
}

IPv6__packet::IPv6__packet(const IPv6__header& par_header,
    const OPTIONAL<IPv6__extension__headers>& par_ext__headers,
    const OPTIONAL<OCTETSTRING>& par_payload)
  :   field_header(par_header),
  field_ext__headers(par_ext__headers),
  field_payload(par_payload)
{
  bound_flag = TRUE;
}

IPv6__packet::IPv6__packet(const IPv6__packet& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IP_Types.IPv6_packet.");
bound_flag = TRUE;
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.ext__headers().is_bound()) field_ext__headers = other_value.ext__headers();
else field_ext__headers.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void IPv6__packet::clean_up()
{
field_header.clean_up();
field_ext__headers.clean_up();
field_payload.clean_up();
bound_flag = FALSE;
}

IPv6__packet& IPv6__packet::operator=(const IPv6__packet& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IP_Types.IPv6_packet.");
  bound_flag = TRUE;
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.ext__headers().is_bound()) field_ext__headers = other_value.ext__headers();
  else field_ext__headers.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean IPv6__packet::operator==(const IPv6__packet& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_header==other_value.field_header
  && field_ext__headers==other_value.field_ext__headers
  && field_payload==other_value.field_payload;
}

boolean IPv6__packet::is_bound() const
{
if (bound_flag) return TRUE;
if(field_header.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_ext__headers.get_selection() || field_ext__headers.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_payload.get_selection() || field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean IPv6__packet::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_header.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_ext__headers.get_selection() && !field_ext__headers.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_payload.get_selection() && !field_payload.is_value()) return FALSE;
return TRUE;
}
int IPv6__packet::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @IP_Types.IPv6_packet");
  int ret_val = 1;
  if (field_ext__headers.ispresent()) ret_val++;
  if (field_payload.ispresent()) ret_val++;
  return ret_val;
}

void IPv6__packet::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", ext_headers := ");
field_ext__headers.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void IPv6__packet::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@IP_Types.IPv6_packet'");
    }
    if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("ext_headers", param_field) == 0) {
      ext__headers().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@IP_Types.IPv6_packet'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @IP_Types.IPv6_packet has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ext__headers().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ext_headers")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ext__headers().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IPv6_packet: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IP_Types.IPv6_packet");
  }
}

void IPv6__packet::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (!ext__headers().is_bound()) ext__headers() = OMIT_VALUE;
else ext__headers().set_implicit_omit();
if (!payload().is_bound()) payload() = OMIT_VALUE;
else payload().set_implicit_omit();
}

void IPv6__packet::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @IP_Types.IPv6_packet.");
field_header.encode_text(text_buf);
field_ext__headers.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void IPv6__packet::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_header.decode_text(text_buf);
field_ext__headers.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

void IPv6__packet::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IPv6__packet::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IPv6__packet::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_header.RAW_decode(IPv6__packet_header_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_ext__headers().RAW_decode(IPv6__packet_ext__headers_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_ext__headers = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_ext__headers=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_payload().RAW_decode(IPv6__packet_payload_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_payload = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_payload=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IPv6__packet::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, IPv6__packet_header_descr_.raw);
  if (field_ext__headers.ispresent()) {
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, IPv6__packet_ext__headers_descr_.raw);
  }
  else myleaf.body.node.nodes[1] = NULL;
  if (field_payload.ispresent()) {
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, IPv6__packet_payload_descr_.raw);
  }
  else myleaf.body.node.nodes[2] = NULL;
  encoded_length += field_header.RAW_encode(IPv6__packet_header_descr_, *myleaf.body.node.nodes[0]);
  if (field_ext__headers.ispresent()) {
  encoded_length += field_ext__headers().RAW_encode(IPv6__packet_ext__headers_descr_, *myleaf.body.node.nodes[1]);
  }
  if (field_payload.ispresent()) {
  encoded_length += field_payload().RAW_encode(IPv6__packet_payload_descr_, *myleaf.body.node.nodes[2]);
  }
  return myleaf.length = encoded_length;
}

int IPv6__packet::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @IP_Types.IPv6_packet.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "header");
    enc_len += field_header.JSON_encode(IPv6__packet_header_descr_, p_tok);
  }

  if (field_ext__headers.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ext_headers");
    enc_len += field_ext__headers.JSON_encode(IPv6__packet_ext__headers_descr_, p_tok);
  }

  if (field_payload.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
    enc_len += field_payload.JSON_encode(IPv6__packet_payload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IPv6__packet::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "header", name_len)) {
        int ret_val = field_header.JSON_decode(IPv6__packet_header_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "header");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (11 == name_len && 0 == strncmp(fld_name, "ext_headers", name_len)) {
        int ret_val = field_ext__headers.JSON_decode(IPv6__packet_ext__headers_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ext_headers");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (7 == name_len && 0 == strncmp(fld_name, "payload", name_len)) {
        int ret_val = field_payload.JSON_decode(IPv6__packet_payload_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_header.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "header");
    return JSON_ERROR_FATAL;
  }
  if (!field_ext__headers.is_bound()) {
    field_ext__headers = OMIT_VALUE;
  }
  if (!field_payload.is_bound()) {
    field_payload = OMIT_VALUE;
  }

  return dec_len;
}

struct IPv6__packet_template::single_value_struct {
IPv6__header_template field_header;
IPv6__extension__headers_template field_ext__headers;
OCTETSTRING_template field_payload;
};

void IPv6__packet_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_ext__headers = ANY_OR_OMIT;
single_value->field_payload = ANY_OR_OMIT;
}
}
}

void IPv6__packet_template::copy_value(const IPv6__packet& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.ext__headers().is_bound()) {
  if (other_value.ext__headers().ispresent()) single_value->field_ext__headers = other_value.ext__headers()();
  else single_value->field_ext__headers = OMIT_VALUE;
} else {
  single_value->field_ext__headers.clean_up();
}
if (other_value.payload().is_bound()) {
  if (other_value.payload().ispresent()) single_value->field_payload = other_value.payload()();
  else single_value->field_payload = OMIT_VALUE;
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IPv6__packet_template::copy_template(const IPv6__packet_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ext__headers().get_selection()) {
single_value->field_ext__headers = other_value.ext__headers();
} else {
single_value->field_ext__headers.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPv6__packet_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IP_Types.IPv6_packet.");
break;
}
set_selection(other_value);
}

IPv6__packet_template::IPv6__packet_template()
{
}

IPv6__packet_template::IPv6__packet_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPv6__packet_template::IPv6__packet_template(const IPv6__packet& other_value)
{
copy_value(other_value);
}

IPv6__packet_template::IPv6__packet_template(const OPTIONAL<IPv6__packet>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv6__packet&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IP_Types.IPv6_packet from an unbound optional field.");
}
}

IPv6__packet_template::IPv6__packet_template(const IPv6__packet_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IPv6__packet_template::~IPv6__packet_template()
{
clean_up();
}

IPv6__packet_template& IPv6__packet_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPv6__packet_template& IPv6__packet_template::operator=(const IPv6__packet& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IPv6__packet_template& IPv6__packet_template::operator=(const OPTIONAL<IPv6__packet>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPv6__packet&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IP_Types.IPv6_packet.");
}
return *this;
}

IPv6__packet_template& IPv6__packet_template::operator=(const IPv6__packet_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPv6__packet_template::match(const IPv6__packet& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header()))return FALSE;
if(!other_value.ext__headers().is_bound()) return FALSE;
if((other_value.ext__headers().ispresent() ? !single_value->field_ext__headers.match((const IPv6__extension__headers&)other_value.ext__headers()) : !single_value->field_ext__headers.match_omit()))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if((other_value.payload().ispresent() ? !single_value->field_payload.match((const OCTETSTRING&)other_value.payload()) : !single_value->field_payload.match_omit()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IP_Types.IPv6_packet.");
}
return FALSE;
}

boolean IPv6__packet_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_ext__headers.is_omit() || single_value->field_ext__headers.is_bound()) return TRUE;
if (single_value->field_payload.is_omit() || single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean IPv6__packet_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_ext__headers.is_omit() && !single_value->field_ext__headers.is_value()) return FALSE;
if (!single_value->field_payload.is_omit() && !single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void IPv6__packet_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IPv6__packet IPv6__packet_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @IP_Types.IPv6_packet.");
IPv6__packet ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_ext__headers.is_omit()) ret_val.ext__headers() = OMIT_VALUE;
else if (single_value->field_ext__headers.is_bound()) {
ret_val.ext__headers() = single_value->field_ext__headers.valueof();
}
if (single_value->field_payload.is_omit()) ret_val.payload() = OMIT_VALUE;
else if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void IPv6__packet_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IP_Types.IPv6_packet.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPv6__packet_template[list_length];
}

IPv6__packet_template& IPv6__packet_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IP_Types.IPv6_packet.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IP_Types.IPv6_packet.");
return value_list.list_value[list_index];
}

IPv6__header_template& IPv6__packet_template::header()
{
set_specific();
return single_value->field_header;
}

const IPv6__header_template& IPv6__packet_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @IP_Types.IPv6_packet.");
return single_value->field_header;
}

IPv6__extension__headers_template& IPv6__packet_template::ext__headers()
{
set_specific();
return single_value->field_ext__headers;
}

const IPv6__extension__headers_template& IPv6__packet_template::ext__headers() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ext_headers of a non-specific template of type @IP_Types.IPv6_packet.");
return single_value->field_ext__headers;
}

OCTETSTRING_template& IPv6__packet_template::payload()
{
set_specific();
return single_value->field_payload;
}

const OCTETSTRING_template& IPv6__packet_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @IP_Types.IPv6_packet.");
return single_value->field_payload;
}

int IPv6__packet_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_packet which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_ext__headers.is_present()) ret_val++;
      if (single_value->field_payload.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IP_Types.IPv6_packet containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_packet containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_packet containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_packet containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IP_Types.IPv6_packet containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IP_Types.IPv6_packet.");
  }
  return 0;
}

void IPv6__packet_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", ext_headers := ");
single_value->field_ext__headers.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPv6__packet_template::log_match(const IPv6__packet& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header())){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.ext__headers().ispresent()){
if(!single_value->field_ext__headers.match(match_value.ext__headers())){
TTCN_Logger::log_logmatch_info(".ext_headers");
single_value->field_ext__headers.log_match(match_value.ext__headers());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_ext__headers.match_omit()){
 TTCN_Logger::log_logmatch_info(".ext_headers := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_ext__headers.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.payload().ispresent()){
if(!single_value->field_payload.match(match_value.payload())){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_payload.match_omit()){
 TTCN_Logger::log_logmatch_info(".payload := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_payload.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header());
TTCN_Logger::log_event_str(", ext_headers := ");
if (match_value.ext__headers().ispresent()) single_value->field_ext__headers.log_match(match_value.ext__headers());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_ext__headers.log();
if (single_value->field_ext__headers.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", payload := ");
if (match_value.payload().ispresent()) single_value->field_payload.log_match(match_value.payload());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_payload.log();
if (single_value->field_payload.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IPv6__packet_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_ext__headers.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IP_Types.IPv6_packet.");
}
}

void IPv6__packet_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_ext__headers.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPv6__packet_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IP_Types.IPv6_packet.");
}
}

void IPv6__packet_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@IP_Types.IPv6_packet'");
    }
    if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("ext_headers", param_field) == 0) {
      ext__headers().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@IP_Types.IPv6_packet'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @IP_Types.IPv6_packet has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ext__headers().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ext_headers")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ext__headers().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IP_Types.IPv6_packet: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IP_Types.IPv6_packet");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPv6__packet_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_packet");
single_value->field_ext__headers.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_packet");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@IP_Types.IPv6_packet");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IP_Types.IPv6_packet");
}

boolean IPv6__packet_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean IPv6__packet_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void IPv6msg__SP__PT::remove_msg_queue_head()
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
switch (my_head->item_selection) {
case MESSAGE_0:
delete (my_head)->message_0;
break;
default:
TTCN_error("Internal error: Invalid message selector in the queue of port %s.", port_name);
}
msg_queue_item_base *next_item = msg_queue_head->next_item;
delete (msg_queue_item*)msg_queue_head;
msg_queue_head = next_item;
if (next_item == NULL) msg_queue_tail = NULL;
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::extract__msg, port_name, 0, ++msg_head_count, CHARSTRING(0,NULL), CHARSTRING(0,NULL));}

void IPv6msg__SP__PT::clear_queue()
{
while (msg_queue_head != NULL) remove_msg_queue_head();
}

IPv6msg__SP__PT::IPv6msg__SP__PT(const char *par_port_name)
 : PORT(par_port_name)
{
msg_queue_head = NULL;
msg_queue_tail = NULL;
}

IPv6msg__SP__PT::~IPv6msg__SP__PT()
{
clear_queue();
}

void IPv6msg__SP__PT::send(const IPv6__packet& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @IP_Types.IPv6_packet : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) TTCN_error("Message cannot be sent to system on internal port %s.", port_name);
else {
Text_Buf text_buf;
prepare_message(text_buf, "@IP_Types.IPv6_packet");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void IPv6msg__SP__PT::send(const IPv6__packet& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void IPv6msg__SP__PT::send(const IPv6__packet_template& send_par, const COMPONENT& destination_component)
{
const IPv6__packet& send_par_value = IPv6__packet(send_par.valueof());
send(send_par_value, destination_component);
}

void IPv6msg__SP__PT::send(const IPv6__packet_template& send_par)
{
const IPv6__packet& send_par_value = IPv6__packet(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

alt_status IPv6msg__SP__PT::receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.IPv6_packet: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status IPv6msg__SP__PT::check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.IPv6_packet: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
return ALT_YES;
}
}

alt_status IPv6msg__SP__PT::trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.IPv6_packet: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status IPv6msg__SP__PT::receive(const IPv6__packet_template& value_template, IPv6__packet *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @IP_Types.IPv6_packet.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.IPv6_packet : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status IPv6msg__SP__PT::check_receive(const IPv6__packet_template& value_template, IPv6__packet *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @IP_Types.IPv6_packet.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.IPv6_packet : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status IPv6msg__SP__PT::trigger(const IPv6__packet_template& value_template, IPv6__packet *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @IP_Types.IPv6_packet.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @IP_Types.IPv6_packet : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

void IPv6msg__SP__PT::incoming_message(const IPv6__packet& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @IP_Types.IPv6_packet : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_0;
new_item->message_0 = new IPv6__packet(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

boolean IPv6msg__SP__PT::process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING&)
{
if (!strcmp(message_type, "@IP_Types.IPv6_packet")) {
IPv6__packet incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else return FALSE;
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const IPv4__extension__headers& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @IP_Types.IPv4_extension_headers.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const IPv6__extension__headers& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @IP_Types.IPv6_extension_headers.");
return other_value.val_ptr->n_elements == 0;
}


/* Bodies of static functions */

static void pre_init_module()
{
General__Types::module_object.pre_init_module();
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 34 */
const_c__ip__proto__ipv4 = 4;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 35 */
const_c__ip__proto__ipv6 = 41;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 36 */
const_c__ip__proto__gre2 = 47;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 37 */
const_c__ip__proto__esp = 50;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 38 */
const_c__ip__proto__ah = 51;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 39 */
const_c__ip__proto__mine = 55;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 41 */
const_c__ip__proto__ipv6__hopopt = 0;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 42 */
const_c__ip__proto__ipv6__route = 43;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 43 */
const_c__ip__proto__ipv6__frag = 44;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 44 */
const_c__ip__proto__ipv6__dest = 60;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 45 */
const_c__ip__proto__ipv6__nonext = 59;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 46 */
const_c__ip__proto__udp = 17;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 47 */
const_c__ip__proto__tcp = 6;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 49 */
const_c__ip__proto__mobility = 135;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 51 */
const_c__ip__gre__proto__ipv4 = 2048;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 52 */
const_c__ip__gre__proto__ipv6 = 34525;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 53 */
const_c__ip__gre__proto__transparentEthernetBridging = 25944;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 55 */
const_c__ip__version__ipv4 = 4;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 56 */
const_c__ip__version__ipv6 = 6;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 58 */
const_c__ip__proto__icmp = 1;
/* /work/TDT4290/src/skeleton/protocols/ip_types/IP_Types.ttcn, line 59 */
const_c__ip__proto__icmpv6 = 58;
module_object.add_function("f_IPv4_enc", (genericfunc_t)&f__IPv4__enc, NULL);
module_object.add_function("f_IPv4_enc_eth", (genericfunc_t)&f__IPv4__enc__eth, NULL);
module_object.add_function("f_IPv4_dec", (genericfunc_t)&f__IPv4__dec, NULL);
module_object.add_function("f_IPv4_checksum", (genericfunc_t)&f__IPv4__checksum, NULL);
module_object.add_function("f_IPv4_addr_enc", (genericfunc_t)&f__IPv4__addr__enc, NULL);
module_object.add_function("f_IPv4_addr_dec", (genericfunc_t)&f__IPv4__addr__dec, NULL);
module_object.add_function("f_IPv6_enc", (genericfunc_t)&f__IPv6__enc, NULL);
module_object.add_function("f_IPv6_dec", (genericfunc_t)&f__IPv6__dec, NULL);
module_object.add_function("f_IPv6_addr_enc", (genericfunc_t)&f__IPv6__addr__enc, NULL);
module_object.add_function("f_IPv6_addr_dec", (genericfunc_t)&f__IPv6__addr__dec, NULL);
}

static void post_init_module()
{
General__Types::module_object.post_init_module();
}


} /* end of namespace */
