// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for titanrt (titanrt@Ubuntu-14-04-64bit) on Fri May 22 16:34:41 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

#ifndef PreGenRecordOf_HH
#define PreGenRecordOf_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 50300
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef PreGenRecordOf_HH
#endif

namespace PreGenRecordOf {

/* Forward declarations of classes */

class PREGEN__RECORD__OF__BOOLEAN;
class PREGEN__RECORD__OF__BOOLEAN_template;
class PREGEN__RECORD__OF__INTEGER;
class PREGEN__RECORD__OF__INTEGER_template;
class PREGEN__RECORD__OF__FLOAT;
class PREGEN__RECORD__OF__FLOAT_template;
class PREGEN__RECORD__OF__BITSTRING;
class PREGEN__RECORD__OF__BITSTRING_template;
class PREGEN__RECORD__OF__HEXSTRING;
class PREGEN__RECORD__OF__HEXSTRING_template;
class PREGEN__RECORD__OF__OCTETSTRING;
class PREGEN__RECORD__OF__OCTETSTRING_template;
class PREGEN__RECORD__OF__CHARSTRING;
class PREGEN__RECORD__OF__CHARSTRING_template;
class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING;
class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template;
class PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED;
class PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template;
class PREGEN__RECORD__OF__INTEGER__OPTIMIZED;
class PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template;
class PREGEN__RECORD__OF__FLOAT__OPTIMIZED;
class PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template;
class PREGEN__RECORD__OF__BITSTRING__OPTIMIZED;
class PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template;
class PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED;
class PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template;
class PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED;
class PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template;
class PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED;
class PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template;
class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED;
class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template;
class PREGEN__SET__OF__BOOLEAN;
class PREGEN__SET__OF__BOOLEAN_template;
class PREGEN__SET__OF__INTEGER;
class PREGEN__SET__OF__INTEGER_template;
class PREGEN__SET__OF__FLOAT;
class PREGEN__SET__OF__FLOAT_template;
class PREGEN__SET__OF__BITSTRING;
class PREGEN__SET__OF__BITSTRING_template;
class PREGEN__SET__OF__HEXSTRING;
class PREGEN__SET__OF__HEXSTRING_template;
class PREGEN__SET__OF__OCTETSTRING;
class PREGEN__SET__OF__OCTETSTRING_template;
class PREGEN__SET__OF__CHARSTRING;
class PREGEN__SET__OF__CHARSTRING_template;
class PREGEN__SET__OF__UNIVERSAL__CHARSTRING;
class PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template;
class PREGEN__SET__OF__BOOLEAN__OPTIMIZED;
class PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template;
class PREGEN__SET__OF__INTEGER__OPTIMIZED;
class PREGEN__SET__OF__INTEGER__OPTIMIZED_template;
class PREGEN__SET__OF__FLOAT__OPTIMIZED;
class PREGEN__SET__OF__FLOAT__OPTIMIZED_template;
class PREGEN__SET__OF__BITSTRING__OPTIMIZED;
class PREGEN__SET__OF__BITSTRING__OPTIMIZED_template;
class PREGEN__SET__OF__HEXSTRING__OPTIMIZED;
class PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template;
class PREGEN__SET__OF__OCTETSTRING__OPTIMIZED;
class PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template;
class PREGEN__SET__OF__CHARSTRING__OPTIMIZED;
class PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template;
class PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED;
class PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template;

} /* end of namespace */

#ifndef PreGenRecordOf_HH
#define PreGenRecordOf_HH

namespace PreGenRecordOf {

/* Class definitions */

class PREGEN__RECORD__OF__BOOLEAN : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
BOOLEAN **value_elements;
} *val_ptr;

static const BOOLEAN UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__BOOLEAN& other_value);

public:
  typedef BOOLEAN of_type;
PREGEN__RECORD__OF__BOOLEAN();
PREGEN__RECORD__OF__BOOLEAN(null_type other_value);
PREGEN__RECORD__OF__BOOLEAN(const PREGEN__RECORD__OF__BOOLEAN& other_value);
~PREGEN__RECORD__OF__BOOLEAN();

void clean_up();
PREGEN__RECORD__OF__BOOLEAN& operator=(null_type other_value);
PREGEN__RECORD__OF__BOOLEAN& operator=(const PREGEN__RECORD__OF__BOOLEAN& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__BOOLEAN& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__BOOLEAN& other_value) const { return !(*this == other_value); }

BOOLEAN& operator[](int index_value);
BOOLEAN& operator[](const INTEGER& index_value);
const BOOLEAN& operator[](int index_value) const;
const BOOLEAN& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__BOOLEAN operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__BOOLEAN operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__BOOLEAN operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__BOOLEAN operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__BOOLEAN operator+(const PREGEN__RECORD__OF__BOOLEAN& other_value) const;

PREGEN__RECORD__OF__BOOLEAN substr(int index, int returncount) const;

PREGEN__RECORD__OF__BOOLEAN replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN& repl) const;

PREGEN__RECORD__OF__BOOLEAN replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__BOOLEAN_template : public Record_Of_Template {
union {
struct {
int n_elements;
BOOLEAN_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__BOOLEAN_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__BOOLEAN& other_value);
void copy_template(const PREGEN__RECORD__OF__BOOLEAN_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__BOOLEAN_template();
PREGEN__RECORD__OF__BOOLEAN_template(template_sel other_value);
PREGEN__RECORD__OF__BOOLEAN_template(null_type other_value);
PREGEN__RECORD__OF__BOOLEAN_template(const PREGEN__RECORD__OF__BOOLEAN& other_value);
PREGEN__RECORD__OF__BOOLEAN_template(const OPTIONAL<PREGEN__RECORD__OF__BOOLEAN>& other_value);
PREGEN__RECORD__OF__BOOLEAN_template(const PREGEN__RECORD__OF__BOOLEAN_template& other_value);
~PREGEN__RECORD__OF__BOOLEAN_template();

void clean_up();
PREGEN__RECORD__OF__BOOLEAN_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__BOOLEAN_template& operator=(null_type other_value);
PREGEN__RECORD__OF__BOOLEAN_template& operator=(const PREGEN__RECORD__OF__BOOLEAN& other_value);
PREGEN__RECORD__OF__BOOLEAN_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__BOOLEAN>& other_value);
PREGEN__RECORD__OF__BOOLEAN_template& operator=(const PREGEN__RECORD__OF__BOOLEAN_template& other_value);

BOOLEAN_template& operator[](int index_value);
BOOLEAN_template& operator[](const INTEGER& index_value);
const BOOLEAN_template& operator[](int index_value) const;
const BOOLEAN_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__BOOLEAN& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__BOOLEAN valueof() const;
PREGEN__RECORD__OF__BOOLEAN substr(int index, int returncount) const;

PREGEN__RECORD__OF__BOOLEAN replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN_template& repl) const;

PREGEN__RECORD__OF__BOOLEAN replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__BOOLEAN_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__BOOLEAN& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__INTEGER : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
INTEGER **value_elements;
} *val_ptr;

static const INTEGER UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__INTEGER& other_value);

public:
  typedef INTEGER of_type;
PREGEN__RECORD__OF__INTEGER();
PREGEN__RECORD__OF__INTEGER(null_type other_value);
PREGEN__RECORD__OF__INTEGER(const PREGEN__RECORD__OF__INTEGER& other_value);
~PREGEN__RECORD__OF__INTEGER();

void clean_up();
PREGEN__RECORD__OF__INTEGER& operator=(null_type other_value);
PREGEN__RECORD__OF__INTEGER& operator=(const PREGEN__RECORD__OF__INTEGER& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__INTEGER& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__INTEGER& other_value) const { return !(*this == other_value); }

INTEGER& operator[](int index_value);
INTEGER& operator[](const INTEGER& index_value);
const INTEGER& operator[](int index_value) const;
const INTEGER& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__INTEGER operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__INTEGER operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__INTEGER operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__INTEGER operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__INTEGER operator+(const PREGEN__RECORD__OF__INTEGER& other_value) const;

PREGEN__RECORD__OF__INTEGER substr(int index, int returncount) const;

PREGEN__RECORD__OF__INTEGER replace(int index, int len, const PREGEN__RECORD__OF__INTEGER& repl) const;

PREGEN__RECORD__OF__INTEGER replace(int index, int len, const PREGEN__RECORD__OF__INTEGER_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__INTEGER_template : public Record_Of_Template {
union {
struct {
int n_elements;
INTEGER_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__INTEGER_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__INTEGER& other_value);
void copy_template(const PREGEN__RECORD__OF__INTEGER_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__INTEGER_template();
PREGEN__RECORD__OF__INTEGER_template(template_sel other_value);
PREGEN__RECORD__OF__INTEGER_template(null_type other_value);
PREGEN__RECORD__OF__INTEGER_template(const PREGEN__RECORD__OF__INTEGER& other_value);
PREGEN__RECORD__OF__INTEGER_template(const OPTIONAL<PREGEN__RECORD__OF__INTEGER>& other_value);
PREGEN__RECORD__OF__INTEGER_template(const PREGEN__RECORD__OF__INTEGER_template& other_value);
~PREGEN__RECORD__OF__INTEGER_template();

void clean_up();
PREGEN__RECORD__OF__INTEGER_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__INTEGER_template& operator=(null_type other_value);
PREGEN__RECORD__OF__INTEGER_template& operator=(const PREGEN__RECORD__OF__INTEGER& other_value);
PREGEN__RECORD__OF__INTEGER_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__INTEGER>& other_value);
PREGEN__RECORD__OF__INTEGER_template& operator=(const PREGEN__RECORD__OF__INTEGER_template& other_value);

INTEGER_template& operator[](int index_value);
INTEGER_template& operator[](const INTEGER& index_value);
const INTEGER_template& operator[](int index_value) const;
const INTEGER_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__INTEGER& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__INTEGER valueof() const;
PREGEN__RECORD__OF__INTEGER substr(int index, int returncount) const;

PREGEN__RECORD__OF__INTEGER replace(int index, int len, const PREGEN__RECORD__OF__INTEGER_template& repl) const;

PREGEN__RECORD__OF__INTEGER replace(int index, int len, const PREGEN__RECORD__OF__INTEGER& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__INTEGER_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__INTEGER& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__FLOAT : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
FLOAT **value_elements;
} *val_ptr;

static const FLOAT UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__FLOAT& other_value);

public:
  typedef FLOAT of_type;
PREGEN__RECORD__OF__FLOAT();
PREGEN__RECORD__OF__FLOAT(null_type other_value);
PREGEN__RECORD__OF__FLOAT(const PREGEN__RECORD__OF__FLOAT& other_value);
~PREGEN__RECORD__OF__FLOAT();

void clean_up();
PREGEN__RECORD__OF__FLOAT& operator=(null_type other_value);
PREGEN__RECORD__OF__FLOAT& operator=(const PREGEN__RECORD__OF__FLOAT& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__FLOAT& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__FLOAT& other_value) const { return !(*this == other_value); }

FLOAT& operator[](int index_value);
FLOAT& operator[](const INTEGER& index_value);
const FLOAT& operator[](int index_value) const;
const FLOAT& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__FLOAT operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__FLOAT operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__FLOAT operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__FLOAT operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__FLOAT operator+(const PREGEN__RECORD__OF__FLOAT& other_value) const;

PREGEN__RECORD__OF__FLOAT substr(int index, int returncount) const;

PREGEN__RECORD__OF__FLOAT replace(int index, int len, const PREGEN__RECORD__OF__FLOAT& repl) const;

PREGEN__RECORD__OF__FLOAT replace(int index, int len, const PREGEN__RECORD__OF__FLOAT_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__FLOAT_template : public Record_Of_Template {
union {
struct {
int n_elements;
FLOAT_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__FLOAT_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__FLOAT& other_value);
void copy_template(const PREGEN__RECORD__OF__FLOAT_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__FLOAT_template();
PREGEN__RECORD__OF__FLOAT_template(template_sel other_value);
PREGEN__RECORD__OF__FLOAT_template(null_type other_value);
PREGEN__RECORD__OF__FLOAT_template(const PREGEN__RECORD__OF__FLOAT& other_value);
PREGEN__RECORD__OF__FLOAT_template(const OPTIONAL<PREGEN__RECORD__OF__FLOAT>& other_value);
PREGEN__RECORD__OF__FLOAT_template(const PREGEN__RECORD__OF__FLOAT_template& other_value);
~PREGEN__RECORD__OF__FLOAT_template();

void clean_up();
PREGEN__RECORD__OF__FLOAT_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__FLOAT_template& operator=(null_type other_value);
PREGEN__RECORD__OF__FLOAT_template& operator=(const PREGEN__RECORD__OF__FLOAT& other_value);
PREGEN__RECORD__OF__FLOAT_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__FLOAT>& other_value);
PREGEN__RECORD__OF__FLOAT_template& operator=(const PREGEN__RECORD__OF__FLOAT_template& other_value);

FLOAT_template& operator[](int index_value);
FLOAT_template& operator[](const INTEGER& index_value);
const FLOAT_template& operator[](int index_value) const;
const FLOAT_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__FLOAT& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__FLOAT valueof() const;
PREGEN__RECORD__OF__FLOAT substr(int index, int returncount) const;

PREGEN__RECORD__OF__FLOAT replace(int index, int len, const PREGEN__RECORD__OF__FLOAT_template& repl) const;

PREGEN__RECORD__OF__FLOAT replace(int index, int len, const PREGEN__RECORD__OF__FLOAT& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__FLOAT_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__FLOAT& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__BITSTRING : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
BITSTRING **value_elements;
} *val_ptr;

static const BITSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__BITSTRING& other_value);

public:
  typedef BITSTRING of_type;
PREGEN__RECORD__OF__BITSTRING();
PREGEN__RECORD__OF__BITSTRING(null_type other_value);
PREGEN__RECORD__OF__BITSTRING(const PREGEN__RECORD__OF__BITSTRING& other_value);
~PREGEN__RECORD__OF__BITSTRING();

void clean_up();
PREGEN__RECORD__OF__BITSTRING& operator=(null_type other_value);
PREGEN__RECORD__OF__BITSTRING& operator=(const PREGEN__RECORD__OF__BITSTRING& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__BITSTRING& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__BITSTRING& other_value) const { return !(*this == other_value); }

BITSTRING& operator[](int index_value);
BITSTRING& operator[](const INTEGER& index_value);
const BITSTRING& operator[](int index_value) const;
const BITSTRING& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__BITSTRING operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__BITSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__BITSTRING operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__BITSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__BITSTRING operator+(const PREGEN__RECORD__OF__BITSTRING& other_value) const;

PREGEN__RECORD__OF__BITSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__BITSTRING replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING& repl) const;

PREGEN__RECORD__OF__BITSTRING replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__BITSTRING_template : public Record_Of_Template {
union {
struct {
int n_elements;
BITSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__BITSTRING_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__BITSTRING& other_value);
void copy_template(const PREGEN__RECORD__OF__BITSTRING_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__BITSTRING_template();
PREGEN__RECORD__OF__BITSTRING_template(template_sel other_value);
PREGEN__RECORD__OF__BITSTRING_template(null_type other_value);
PREGEN__RECORD__OF__BITSTRING_template(const PREGEN__RECORD__OF__BITSTRING& other_value);
PREGEN__RECORD__OF__BITSTRING_template(const OPTIONAL<PREGEN__RECORD__OF__BITSTRING>& other_value);
PREGEN__RECORD__OF__BITSTRING_template(const PREGEN__RECORD__OF__BITSTRING_template& other_value);
~PREGEN__RECORD__OF__BITSTRING_template();

void clean_up();
PREGEN__RECORD__OF__BITSTRING_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__BITSTRING_template& operator=(null_type other_value);
PREGEN__RECORD__OF__BITSTRING_template& operator=(const PREGEN__RECORD__OF__BITSTRING& other_value);
PREGEN__RECORD__OF__BITSTRING_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__BITSTRING>& other_value);
PREGEN__RECORD__OF__BITSTRING_template& operator=(const PREGEN__RECORD__OF__BITSTRING_template& other_value);

BITSTRING_template& operator[](int index_value);
BITSTRING_template& operator[](const INTEGER& index_value);
const BITSTRING_template& operator[](int index_value) const;
const BITSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__BITSTRING& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__BITSTRING valueof() const;
PREGEN__RECORD__OF__BITSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__BITSTRING replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING_template& repl) const;

PREGEN__RECORD__OF__BITSTRING replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__BITSTRING_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__BITSTRING& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__HEXSTRING : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
HEXSTRING **value_elements;
} *val_ptr;

static const HEXSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__HEXSTRING& other_value);

public:
  typedef HEXSTRING of_type;
PREGEN__RECORD__OF__HEXSTRING();
PREGEN__RECORD__OF__HEXSTRING(null_type other_value);
PREGEN__RECORD__OF__HEXSTRING(const PREGEN__RECORD__OF__HEXSTRING& other_value);
~PREGEN__RECORD__OF__HEXSTRING();

void clean_up();
PREGEN__RECORD__OF__HEXSTRING& operator=(null_type other_value);
PREGEN__RECORD__OF__HEXSTRING& operator=(const PREGEN__RECORD__OF__HEXSTRING& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__HEXSTRING& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__HEXSTRING& other_value) const { return !(*this == other_value); }

HEXSTRING& operator[](int index_value);
HEXSTRING& operator[](const INTEGER& index_value);
const HEXSTRING& operator[](int index_value) const;
const HEXSTRING& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__HEXSTRING operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__HEXSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__HEXSTRING operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__HEXSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__HEXSTRING operator+(const PREGEN__RECORD__OF__HEXSTRING& other_value) const;

PREGEN__RECORD__OF__HEXSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__HEXSTRING replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING& repl) const;

PREGEN__RECORD__OF__HEXSTRING replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__HEXSTRING_template : public Record_Of_Template {
union {
struct {
int n_elements;
HEXSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__HEXSTRING_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__HEXSTRING& other_value);
void copy_template(const PREGEN__RECORD__OF__HEXSTRING_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__HEXSTRING_template();
PREGEN__RECORD__OF__HEXSTRING_template(template_sel other_value);
PREGEN__RECORD__OF__HEXSTRING_template(null_type other_value);
PREGEN__RECORD__OF__HEXSTRING_template(const PREGEN__RECORD__OF__HEXSTRING& other_value);
PREGEN__RECORD__OF__HEXSTRING_template(const OPTIONAL<PREGEN__RECORD__OF__HEXSTRING>& other_value);
PREGEN__RECORD__OF__HEXSTRING_template(const PREGEN__RECORD__OF__HEXSTRING_template& other_value);
~PREGEN__RECORD__OF__HEXSTRING_template();

void clean_up();
PREGEN__RECORD__OF__HEXSTRING_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__HEXSTRING_template& operator=(null_type other_value);
PREGEN__RECORD__OF__HEXSTRING_template& operator=(const PREGEN__RECORD__OF__HEXSTRING& other_value);
PREGEN__RECORD__OF__HEXSTRING_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__HEXSTRING>& other_value);
PREGEN__RECORD__OF__HEXSTRING_template& operator=(const PREGEN__RECORD__OF__HEXSTRING_template& other_value);

HEXSTRING_template& operator[](int index_value);
HEXSTRING_template& operator[](const INTEGER& index_value);
const HEXSTRING_template& operator[](int index_value) const;
const HEXSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__HEXSTRING& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__HEXSTRING valueof() const;
PREGEN__RECORD__OF__HEXSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__HEXSTRING replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING_template& repl) const;

PREGEN__RECORD__OF__HEXSTRING replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__HEXSTRING_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__HEXSTRING& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__OCTETSTRING : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
OCTETSTRING **value_elements;
} *val_ptr;

static const OCTETSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__OCTETSTRING& other_value);

public:
  typedef OCTETSTRING of_type;
PREGEN__RECORD__OF__OCTETSTRING();
PREGEN__RECORD__OF__OCTETSTRING(null_type other_value);
PREGEN__RECORD__OF__OCTETSTRING(const PREGEN__RECORD__OF__OCTETSTRING& other_value);
~PREGEN__RECORD__OF__OCTETSTRING();

void clean_up();
PREGEN__RECORD__OF__OCTETSTRING& operator=(null_type other_value);
PREGEN__RECORD__OF__OCTETSTRING& operator=(const PREGEN__RECORD__OF__OCTETSTRING& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__OCTETSTRING& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__OCTETSTRING& other_value) const { return !(*this == other_value); }

OCTETSTRING& operator[](int index_value);
OCTETSTRING& operator[](const INTEGER& index_value);
const OCTETSTRING& operator[](int index_value) const;
const OCTETSTRING& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__OCTETSTRING operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__OCTETSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__OCTETSTRING operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__OCTETSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__OCTETSTRING operator+(const PREGEN__RECORD__OF__OCTETSTRING& other_value) const;

PREGEN__RECORD__OF__OCTETSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__OCTETSTRING replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING& repl) const;

PREGEN__RECORD__OF__OCTETSTRING replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__OCTETSTRING_template : public Record_Of_Template {
union {
struct {
int n_elements;
OCTETSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__OCTETSTRING_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__OCTETSTRING& other_value);
void copy_template(const PREGEN__RECORD__OF__OCTETSTRING_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__OCTETSTRING_template();
PREGEN__RECORD__OF__OCTETSTRING_template(template_sel other_value);
PREGEN__RECORD__OF__OCTETSTRING_template(null_type other_value);
PREGEN__RECORD__OF__OCTETSTRING_template(const PREGEN__RECORD__OF__OCTETSTRING& other_value);
PREGEN__RECORD__OF__OCTETSTRING_template(const OPTIONAL<PREGEN__RECORD__OF__OCTETSTRING>& other_value);
PREGEN__RECORD__OF__OCTETSTRING_template(const PREGEN__RECORD__OF__OCTETSTRING_template& other_value);
~PREGEN__RECORD__OF__OCTETSTRING_template();

void clean_up();
PREGEN__RECORD__OF__OCTETSTRING_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__OCTETSTRING_template& operator=(null_type other_value);
PREGEN__RECORD__OF__OCTETSTRING_template& operator=(const PREGEN__RECORD__OF__OCTETSTRING& other_value);
PREGEN__RECORD__OF__OCTETSTRING_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__OCTETSTRING>& other_value);
PREGEN__RECORD__OF__OCTETSTRING_template& operator=(const PREGEN__RECORD__OF__OCTETSTRING_template& other_value);

OCTETSTRING_template& operator[](int index_value);
OCTETSTRING_template& operator[](const INTEGER& index_value);
const OCTETSTRING_template& operator[](int index_value) const;
const OCTETSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__OCTETSTRING& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__OCTETSTRING valueof() const;
PREGEN__RECORD__OF__OCTETSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__OCTETSTRING replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING_template& repl) const;

PREGEN__RECORD__OF__OCTETSTRING replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__OCTETSTRING_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__OCTETSTRING& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__CHARSTRING : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
CHARSTRING **value_elements;
} *val_ptr;

static const CHARSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__CHARSTRING& other_value);

public:
  typedef CHARSTRING of_type;
PREGEN__RECORD__OF__CHARSTRING();
PREGEN__RECORD__OF__CHARSTRING(null_type other_value);
PREGEN__RECORD__OF__CHARSTRING(const PREGEN__RECORD__OF__CHARSTRING& other_value);
~PREGEN__RECORD__OF__CHARSTRING();

void clean_up();
PREGEN__RECORD__OF__CHARSTRING& operator=(null_type other_value);
PREGEN__RECORD__OF__CHARSTRING& operator=(const PREGEN__RECORD__OF__CHARSTRING& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__CHARSTRING& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__CHARSTRING& other_value) const { return !(*this == other_value); }

CHARSTRING& operator[](int index_value);
CHARSTRING& operator[](const INTEGER& index_value);
const CHARSTRING& operator[](int index_value) const;
const CHARSTRING& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__CHARSTRING operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__CHARSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__CHARSTRING operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__CHARSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__CHARSTRING operator+(const PREGEN__RECORD__OF__CHARSTRING& other_value) const;

PREGEN__RECORD__OF__CHARSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING& repl) const;

PREGEN__RECORD__OF__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__CHARSTRING_template : public Record_Of_Template {
union {
struct {
int n_elements;
CHARSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__CHARSTRING_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__CHARSTRING& other_value);
void copy_template(const PREGEN__RECORD__OF__CHARSTRING_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__CHARSTRING_template();
PREGEN__RECORD__OF__CHARSTRING_template(template_sel other_value);
PREGEN__RECORD__OF__CHARSTRING_template(null_type other_value);
PREGEN__RECORD__OF__CHARSTRING_template(const PREGEN__RECORD__OF__CHARSTRING& other_value);
PREGEN__RECORD__OF__CHARSTRING_template(const OPTIONAL<PREGEN__RECORD__OF__CHARSTRING>& other_value);
PREGEN__RECORD__OF__CHARSTRING_template(const PREGEN__RECORD__OF__CHARSTRING_template& other_value);
~PREGEN__RECORD__OF__CHARSTRING_template();

void clean_up();
PREGEN__RECORD__OF__CHARSTRING_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__CHARSTRING_template& operator=(null_type other_value);
PREGEN__RECORD__OF__CHARSTRING_template& operator=(const PREGEN__RECORD__OF__CHARSTRING& other_value);
PREGEN__RECORD__OF__CHARSTRING_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__CHARSTRING>& other_value);
PREGEN__RECORD__OF__CHARSTRING_template& operator=(const PREGEN__RECORD__OF__CHARSTRING_template& other_value);

CHARSTRING_template& operator[](int index_value);
CHARSTRING_template& operator[](const INTEGER& index_value);
const CHARSTRING_template& operator[](int index_value) const;
const CHARSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__CHARSTRING& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__CHARSTRING valueof() const;
PREGEN__RECORD__OF__CHARSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING_template& repl) const;

PREGEN__RECORD__OF__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__CHARSTRING_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__CHARSTRING& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
UNIVERSAL_CHARSTRING **value_elements;
} *val_ptr;

static const UNIVERSAL_CHARSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value);

public:
  typedef UNIVERSAL_CHARSTRING of_type;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING();
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(null_type other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value);
~PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING();

void clean_up();
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& operator=(null_type other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& operator=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value) const { return !(*this == other_value); }

UNIVERSAL_CHARSTRING& operator[](int index_value);
UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator+(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& repl) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template : public Record_Of_Template {
union {
struct {
int n_elements;
UNIVERSAL_CHARSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value);
void copy_template(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template();
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template(template_sel other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template(null_type other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template(const OPTIONAL<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING>& other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& other_value);
~PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template();

void clean_up();
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& operator=(null_type other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& operator=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING>& other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& operator=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& other_value);

UNIVERSAL_CHARSTRING_template& operator[](int index_value);
UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING_template& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING valueof() const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& repl) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED : public Base_Type {
int n_elements;
BOOLEAN* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value);
void copy_value(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value);

public:
  typedef BOOLEAN of_type;
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& operator=(null_type other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& operator=(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value) const { return !(*this == other_value); }

BOOLEAN& operator[](int index_value);
BOOLEAN& operator[](const INTEGER& index_value);
const BOOLEAN& operator[](int index_value) const;
const BOOLEAN& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator+(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template : public Record_Of_Template {
union {
struct {
int n_elements;
BOOLEAN_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value);
void copy_template(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template();
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template(template_sel other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& other_value);
~PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template();

void clean_up();
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& other_value);

BOOLEAN_template& operator[](int index_value);
BOOLEAN_template& operator[](const INTEGER& index_value);
const BOOLEAN_template& operator[](int index_value) const;
const BOOLEAN_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__INTEGER__OPTIMIZED : public Base_Type {
int n_elements;
INTEGER* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value);
void copy_value(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value);

public:
  typedef INTEGER of_type;
PREGEN__RECORD__OF__INTEGER__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__RECORD__OF__INTEGER__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__RECORD__OF__INTEGER__OPTIMIZED(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__RECORD__OF__INTEGER__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__RECORD__OF__INTEGER__OPTIMIZED& operator=(null_type other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED& operator=(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value) const { return !(*this == other_value); }

INTEGER& operator[](int index_value);
INTEGER& operator[](const INTEGER& index_value);
const INTEGER& operator[](int index_value) const;
const INTEGER& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator+(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template : public Record_Of_Template {
union {
struct {
int n_elements;
INTEGER_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value);
void copy_template(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template();
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template(template_sel other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__INTEGER__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& other_value);
~PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template();

void clean_up();
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__INTEGER__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& other_value);

INTEGER_template& operator[](int index_value);
INTEGER_template& operator[](const INTEGER& index_value);
const INTEGER_template& operator[](int index_value) const;
const INTEGER_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__INTEGER__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__INTEGER__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__FLOAT__OPTIMIZED : public Base_Type {
int n_elements;
FLOAT* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value);
void copy_value(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value);

public:
  typedef FLOAT of_type;
PREGEN__RECORD__OF__FLOAT__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__RECORD__OF__FLOAT__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__RECORD__OF__FLOAT__OPTIMIZED(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__RECORD__OF__FLOAT__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__RECORD__OF__FLOAT__OPTIMIZED& operator=(null_type other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED& operator=(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value) const { return !(*this == other_value); }

FLOAT& operator[](int index_value);
FLOAT& operator[](const INTEGER& index_value);
const FLOAT& operator[](int index_value) const;
const FLOAT& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator+(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template : public Record_Of_Template {
union {
struct {
int n_elements;
FLOAT_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value);
void copy_template(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template();
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template(template_sel other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__FLOAT__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& other_value);
~PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template();

void clean_up();
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__FLOAT__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& other_value);

FLOAT_template& operator[](int index_value);
FLOAT_template& operator[](const INTEGER& index_value);
const FLOAT_template& operator[](int index_value) const;
const FLOAT_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__FLOAT__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__FLOAT__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__BITSTRING__OPTIMIZED : public Base_Type {
int n_elements;
BITSTRING* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value);
void copy_value(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value);

public:
  typedef BITSTRING of_type;
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__RECORD__OF__BITSTRING__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& operator=(null_type other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& operator=(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value) const { return !(*this == other_value); }

BITSTRING& operator[](int index_value);
BITSTRING& operator[](const INTEGER& index_value);
const BITSTRING& operator[](int index_value) const;
const BITSTRING& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator+(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template : public Record_Of_Template {
union {
struct {
int n_elements;
BITSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value);
void copy_template(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template();
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template(template_sel other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__BITSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& other_value);
~PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template();

void clean_up();
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__BITSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& other_value);

BITSTRING_template& operator[](int index_value);
BITSTRING_template& operator[](const INTEGER& index_value);
const BITSTRING_template& operator[](int index_value) const;
const BITSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED : public Base_Type {
int n_elements;
HEXSTRING* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value);
void copy_value(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value);

public:
  typedef HEXSTRING of_type;
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& operator=(null_type other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& operator=(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value) const { return !(*this == other_value); }

HEXSTRING& operator[](int index_value);
HEXSTRING& operator[](const INTEGER& index_value);
const HEXSTRING& operator[](int index_value) const;
const HEXSTRING& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator+(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template : public Record_Of_Template {
union {
struct {
int n_elements;
HEXSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value);
void copy_template(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template();
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template(template_sel other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& other_value);
~PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template();

void clean_up();
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& other_value);

HEXSTRING_template& operator[](int index_value);
HEXSTRING_template& operator[](const INTEGER& index_value);
const HEXSTRING_template& operator[](int index_value) const;
const HEXSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED : public Base_Type {
int n_elements;
OCTETSTRING* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value);
void copy_value(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value);

public:
  typedef OCTETSTRING of_type;
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& operator=(null_type other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& operator=(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value) const { return !(*this == other_value); }

OCTETSTRING& operator[](int index_value);
OCTETSTRING& operator[](const INTEGER& index_value);
const OCTETSTRING& operator[](int index_value) const;
const OCTETSTRING& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator+(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template : public Record_Of_Template {
union {
struct {
int n_elements;
OCTETSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value);
void copy_template(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template();
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template(template_sel other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& other_value);
~PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template();

void clean_up();
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& other_value);

OCTETSTRING_template& operator[](int index_value);
OCTETSTRING_template& operator[](const INTEGER& index_value);
const OCTETSTRING_template& operator[](int index_value) const;
const OCTETSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED : public Base_Type {
int n_elements;
CHARSTRING* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value);
void copy_value(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value);

public:
  typedef CHARSTRING of_type;
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& operator=(null_type other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& operator=(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value) const { return !(*this == other_value); }

CHARSTRING& operator[](int index_value);
CHARSTRING& operator[](const INTEGER& index_value);
const CHARSTRING& operator[](int index_value) const;
const CHARSTRING& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator+(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template : public Record_Of_Template {
union {
struct {
int n_elements;
CHARSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value);
void copy_template(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template();
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template(template_sel other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& other_value);
~PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template();

void clean_up();
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& other_value);

CHARSTRING_template& operator[](int index_value);
CHARSTRING_template& operator[](const INTEGER& index_value);
const CHARSTRING_template& operator[](int index_value) const;
const CHARSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED : public Base_Type {
int n_elements;
UNIVERSAL_CHARSTRING* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
void copy_value(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);

public:
  typedef UNIVERSAL_CHARSTRING of_type;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& operator=(null_type other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& operator=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const { return !(*this == other_value); }

UNIVERSAL_CHARSTRING& operator[](int index_value);
UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator+(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template : public Record_Of_Template {
union {
struct {
int n_elements;
UNIVERSAL_CHARSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template *list_value;
} value_list;
};
void copy_value(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
void copy_template(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template();
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(template_sel other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& other_value);
~PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template();

void clean_up();
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& other_value);

UNIVERSAL_CHARSTRING_template& operator[](int index_value);
UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING_template& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__BOOLEAN : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
BOOLEAN **value_elements;
} *val_ptr;

static const BOOLEAN UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__BOOLEAN& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef BOOLEAN of_type;
PREGEN__SET__OF__BOOLEAN();
PREGEN__SET__OF__BOOLEAN(null_type other_value);
PREGEN__SET__OF__BOOLEAN(const PREGEN__SET__OF__BOOLEAN& other_value);
~PREGEN__SET__OF__BOOLEAN();

void clean_up();
PREGEN__SET__OF__BOOLEAN& operator=(null_type other_value);
PREGEN__SET__OF__BOOLEAN& operator=(const PREGEN__SET__OF__BOOLEAN& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__BOOLEAN& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__BOOLEAN& other_value) const { return !(*this == other_value); }

BOOLEAN& operator[](int index_value);
BOOLEAN& operator[](const INTEGER& index_value);
const BOOLEAN& operator[](int index_value) const;
const BOOLEAN& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__BOOLEAN operator<<=(int rotate_count) const;
PREGEN__SET__OF__BOOLEAN operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__BOOLEAN operator>>=(int rotate_count) const;
PREGEN__SET__OF__BOOLEAN operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__BOOLEAN operator+(const PREGEN__SET__OF__BOOLEAN& other_value) const;

PREGEN__SET__OF__BOOLEAN substr(int index, int returncount) const;

PREGEN__SET__OF__BOOLEAN replace(int index, int len, const PREGEN__SET__OF__BOOLEAN& repl) const;

PREGEN__SET__OF__BOOLEAN replace(int index, int len, const PREGEN__SET__OF__BOOLEAN_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__BOOLEAN_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
BOOLEAN_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__BOOLEAN_template *list_value;
} value_list;
struct {
unsigned int n_items;
BOOLEAN_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__BOOLEAN& other_value);
void copy_template(const PREGEN__SET__OF__BOOLEAN_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__BOOLEAN_template();
PREGEN__SET__OF__BOOLEAN_template(template_sel other_value);
PREGEN__SET__OF__BOOLEAN_template(null_type other_value);
PREGEN__SET__OF__BOOLEAN_template(const PREGEN__SET__OF__BOOLEAN& other_value);
PREGEN__SET__OF__BOOLEAN_template(const OPTIONAL<PREGEN__SET__OF__BOOLEAN>& other_value);
PREGEN__SET__OF__BOOLEAN_template(const PREGEN__SET__OF__BOOLEAN_template& other_value);
~PREGEN__SET__OF__BOOLEAN_template();

void clean_up();
PREGEN__SET__OF__BOOLEAN_template& operator=(template_sel other_value);
PREGEN__SET__OF__BOOLEAN_template& operator=(null_type other_value);
PREGEN__SET__OF__BOOLEAN_template& operator=(const PREGEN__SET__OF__BOOLEAN& other_value);
PREGEN__SET__OF__BOOLEAN_template& operator=(const OPTIONAL<PREGEN__SET__OF__BOOLEAN>& other_value);
PREGEN__SET__OF__BOOLEAN_template& operator=(const PREGEN__SET__OF__BOOLEAN_template& other_value);

BOOLEAN_template& operator[](int index_value);
BOOLEAN_template& operator[](const INTEGER& index_value);
const BOOLEAN_template& operator[](int index_value) const;
const BOOLEAN_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__BOOLEAN& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__BOOLEAN valueof() const;
PREGEN__SET__OF__BOOLEAN substr(int index, int returncount) const;

PREGEN__SET__OF__BOOLEAN replace(int index, int len, const PREGEN__SET__OF__BOOLEAN_template& repl) const;

PREGEN__SET__OF__BOOLEAN replace(int index, int len, const PREGEN__SET__OF__BOOLEAN& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__BOOLEAN_template& list_item(unsigned int list_index);
BOOLEAN_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__BOOLEAN& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__INTEGER : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
INTEGER **value_elements;
} *val_ptr;

static const INTEGER UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__INTEGER& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef INTEGER of_type;
PREGEN__SET__OF__INTEGER();
PREGEN__SET__OF__INTEGER(null_type other_value);
PREGEN__SET__OF__INTEGER(const PREGEN__SET__OF__INTEGER& other_value);
~PREGEN__SET__OF__INTEGER();

void clean_up();
PREGEN__SET__OF__INTEGER& operator=(null_type other_value);
PREGEN__SET__OF__INTEGER& operator=(const PREGEN__SET__OF__INTEGER& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__INTEGER& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__INTEGER& other_value) const { return !(*this == other_value); }

INTEGER& operator[](int index_value);
INTEGER& operator[](const INTEGER& index_value);
const INTEGER& operator[](int index_value) const;
const INTEGER& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__INTEGER operator<<=(int rotate_count) const;
PREGEN__SET__OF__INTEGER operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__INTEGER operator>>=(int rotate_count) const;
PREGEN__SET__OF__INTEGER operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__INTEGER operator+(const PREGEN__SET__OF__INTEGER& other_value) const;

PREGEN__SET__OF__INTEGER substr(int index, int returncount) const;

PREGEN__SET__OF__INTEGER replace(int index, int len, const PREGEN__SET__OF__INTEGER& repl) const;

PREGEN__SET__OF__INTEGER replace(int index, int len, const PREGEN__SET__OF__INTEGER_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__INTEGER_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
INTEGER_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__INTEGER_template *list_value;
} value_list;
struct {
unsigned int n_items;
INTEGER_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__INTEGER& other_value);
void copy_template(const PREGEN__SET__OF__INTEGER_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__INTEGER_template();
PREGEN__SET__OF__INTEGER_template(template_sel other_value);
PREGEN__SET__OF__INTEGER_template(null_type other_value);
PREGEN__SET__OF__INTEGER_template(const PREGEN__SET__OF__INTEGER& other_value);
PREGEN__SET__OF__INTEGER_template(const OPTIONAL<PREGEN__SET__OF__INTEGER>& other_value);
PREGEN__SET__OF__INTEGER_template(const PREGEN__SET__OF__INTEGER_template& other_value);
~PREGEN__SET__OF__INTEGER_template();

void clean_up();
PREGEN__SET__OF__INTEGER_template& operator=(template_sel other_value);
PREGEN__SET__OF__INTEGER_template& operator=(null_type other_value);
PREGEN__SET__OF__INTEGER_template& operator=(const PREGEN__SET__OF__INTEGER& other_value);
PREGEN__SET__OF__INTEGER_template& operator=(const OPTIONAL<PREGEN__SET__OF__INTEGER>& other_value);
PREGEN__SET__OF__INTEGER_template& operator=(const PREGEN__SET__OF__INTEGER_template& other_value);

INTEGER_template& operator[](int index_value);
INTEGER_template& operator[](const INTEGER& index_value);
const INTEGER_template& operator[](int index_value) const;
const INTEGER_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__INTEGER& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__INTEGER valueof() const;
PREGEN__SET__OF__INTEGER substr(int index, int returncount) const;

PREGEN__SET__OF__INTEGER replace(int index, int len, const PREGEN__SET__OF__INTEGER_template& repl) const;

PREGEN__SET__OF__INTEGER replace(int index, int len, const PREGEN__SET__OF__INTEGER& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__INTEGER_template& list_item(unsigned int list_index);
INTEGER_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__INTEGER& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__FLOAT : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
FLOAT **value_elements;
} *val_ptr;

static const FLOAT UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__FLOAT& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef FLOAT of_type;
PREGEN__SET__OF__FLOAT();
PREGEN__SET__OF__FLOAT(null_type other_value);
PREGEN__SET__OF__FLOAT(const PREGEN__SET__OF__FLOAT& other_value);
~PREGEN__SET__OF__FLOAT();

void clean_up();
PREGEN__SET__OF__FLOAT& operator=(null_type other_value);
PREGEN__SET__OF__FLOAT& operator=(const PREGEN__SET__OF__FLOAT& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__FLOAT& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__FLOAT& other_value) const { return !(*this == other_value); }

FLOAT& operator[](int index_value);
FLOAT& operator[](const INTEGER& index_value);
const FLOAT& operator[](int index_value) const;
const FLOAT& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__FLOAT operator<<=(int rotate_count) const;
PREGEN__SET__OF__FLOAT operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__FLOAT operator>>=(int rotate_count) const;
PREGEN__SET__OF__FLOAT operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__FLOAT operator+(const PREGEN__SET__OF__FLOAT& other_value) const;

PREGEN__SET__OF__FLOAT substr(int index, int returncount) const;

PREGEN__SET__OF__FLOAT replace(int index, int len, const PREGEN__SET__OF__FLOAT& repl) const;

PREGEN__SET__OF__FLOAT replace(int index, int len, const PREGEN__SET__OF__FLOAT_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__FLOAT_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
FLOAT_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__FLOAT_template *list_value;
} value_list;
struct {
unsigned int n_items;
FLOAT_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__FLOAT& other_value);
void copy_template(const PREGEN__SET__OF__FLOAT_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__FLOAT_template();
PREGEN__SET__OF__FLOAT_template(template_sel other_value);
PREGEN__SET__OF__FLOAT_template(null_type other_value);
PREGEN__SET__OF__FLOAT_template(const PREGEN__SET__OF__FLOAT& other_value);
PREGEN__SET__OF__FLOAT_template(const OPTIONAL<PREGEN__SET__OF__FLOAT>& other_value);
PREGEN__SET__OF__FLOAT_template(const PREGEN__SET__OF__FLOAT_template& other_value);
~PREGEN__SET__OF__FLOAT_template();

void clean_up();
PREGEN__SET__OF__FLOAT_template& operator=(template_sel other_value);
PREGEN__SET__OF__FLOAT_template& operator=(null_type other_value);
PREGEN__SET__OF__FLOAT_template& operator=(const PREGEN__SET__OF__FLOAT& other_value);
PREGEN__SET__OF__FLOAT_template& operator=(const OPTIONAL<PREGEN__SET__OF__FLOAT>& other_value);
PREGEN__SET__OF__FLOAT_template& operator=(const PREGEN__SET__OF__FLOAT_template& other_value);

FLOAT_template& operator[](int index_value);
FLOAT_template& operator[](const INTEGER& index_value);
const FLOAT_template& operator[](int index_value) const;
const FLOAT_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__FLOAT& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__FLOAT valueof() const;
PREGEN__SET__OF__FLOAT substr(int index, int returncount) const;

PREGEN__SET__OF__FLOAT replace(int index, int len, const PREGEN__SET__OF__FLOAT_template& repl) const;

PREGEN__SET__OF__FLOAT replace(int index, int len, const PREGEN__SET__OF__FLOAT& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__FLOAT_template& list_item(unsigned int list_index);
FLOAT_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__FLOAT& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__BITSTRING : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
BITSTRING **value_elements;
} *val_ptr;

static const BITSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__BITSTRING& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef BITSTRING of_type;
PREGEN__SET__OF__BITSTRING();
PREGEN__SET__OF__BITSTRING(null_type other_value);
PREGEN__SET__OF__BITSTRING(const PREGEN__SET__OF__BITSTRING& other_value);
~PREGEN__SET__OF__BITSTRING();

void clean_up();
PREGEN__SET__OF__BITSTRING& operator=(null_type other_value);
PREGEN__SET__OF__BITSTRING& operator=(const PREGEN__SET__OF__BITSTRING& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__BITSTRING& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__BITSTRING& other_value) const { return !(*this == other_value); }

BITSTRING& operator[](int index_value);
BITSTRING& operator[](const INTEGER& index_value);
const BITSTRING& operator[](int index_value) const;
const BITSTRING& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__BITSTRING operator<<=(int rotate_count) const;
PREGEN__SET__OF__BITSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__BITSTRING operator>>=(int rotate_count) const;
PREGEN__SET__OF__BITSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__BITSTRING operator+(const PREGEN__SET__OF__BITSTRING& other_value) const;

PREGEN__SET__OF__BITSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__BITSTRING replace(int index, int len, const PREGEN__SET__OF__BITSTRING& repl) const;

PREGEN__SET__OF__BITSTRING replace(int index, int len, const PREGEN__SET__OF__BITSTRING_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__BITSTRING_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
BITSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__BITSTRING_template *list_value;
} value_list;
struct {
unsigned int n_items;
BITSTRING_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__BITSTRING& other_value);
void copy_template(const PREGEN__SET__OF__BITSTRING_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__BITSTRING_template();
PREGEN__SET__OF__BITSTRING_template(template_sel other_value);
PREGEN__SET__OF__BITSTRING_template(null_type other_value);
PREGEN__SET__OF__BITSTRING_template(const PREGEN__SET__OF__BITSTRING& other_value);
PREGEN__SET__OF__BITSTRING_template(const OPTIONAL<PREGEN__SET__OF__BITSTRING>& other_value);
PREGEN__SET__OF__BITSTRING_template(const PREGEN__SET__OF__BITSTRING_template& other_value);
~PREGEN__SET__OF__BITSTRING_template();

void clean_up();
PREGEN__SET__OF__BITSTRING_template& operator=(template_sel other_value);
PREGEN__SET__OF__BITSTRING_template& operator=(null_type other_value);
PREGEN__SET__OF__BITSTRING_template& operator=(const PREGEN__SET__OF__BITSTRING& other_value);
PREGEN__SET__OF__BITSTRING_template& operator=(const OPTIONAL<PREGEN__SET__OF__BITSTRING>& other_value);
PREGEN__SET__OF__BITSTRING_template& operator=(const PREGEN__SET__OF__BITSTRING_template& other_value);

BITSTRING_template& operator[](int index_value);
BITSTRING_template& operator[](const INTEGER& index_value);
const BITSTRING_template& operator[](int index_value) const;
const BITSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__BITSTRING& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__BITSTRING valueof() const;
PREGEN__SET__OF__BITSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__BITSTRING replace(int index, int len, const PREGEN__SET__OF__BITSTRING_template& repl) const;

PREGEN__SET__OF__BITSTRING replace(int index, int len, const PREGEN__SET__OF__BITSTRING& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__BITSTRING_template& list_item(unsigned int list_index);
BITSTRING_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__BITSTRING& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__HEXSTRING : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
HEXSTRING **value_elements;
} *val_ptr;

static const HEXSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__HEXSTRING& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef HEXSTRING of_type;
PREGEN__SET__OF__HEXSTRING();
PREGEN__SET__OF__HEXSTRING(null_type other_value);
PREGEN__SET__OF__HEXSTRING(const PREGEN__SET__OF__HEXSTRING& other_value);
~PREGEN__SET__OF__HEXSTRING();

void clean_up();
PREGEN__SET__OF__HEXSTRING& operator=(null_type other_value);
PREGEN__SET__OF__HEXSTRING& operator=(const PREGEN__SET__OF__HEXSTRING& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__HEXSTRING& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__HEXSTRING& other_value) const { return !(*this == other_value); }

HEXSTRING& operator[](int index_value);
HEXSTRING& operator[](const INTEGER& index_value);
const HEXSTRING& operator[](int index_value) const;
const HEXSTRING& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__HEXSTRING operator<<=(int rotate_count) const;
PREGEN__SET__OF__HEXSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__HEXSTRING operator>>=(int rotate_count) const;
PREGEN__SET__OF__HEXSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__HEXSTRING operator+(const PREGEN__SET__OF__HEXSTRING& other_value) const;

PREGEN__SET__OF__HEXSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__HEXSTRING replace(int index, int len, const PREGEN__SET__OF__HEXSTRING& repl) const;

PREGEN__SET__OF__HEXSTRING replace(int index, int len, const PREGEN__SET__OF__HEXSTRING_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__HEXSTRING_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
HEXSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__HEXSTRING_template *list_value;
} value_list;
struct {
unsigned int n_items;
HEXSTRING_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__HEXSTRING& other_value);
void copy_template(const PREGEN__SET__OF__HEXSTRING_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__HEXSTRING_template();
PREGEN__SET__OF__HEXSTRING_template(template_sel other_value);
PREGEN__SET__OF__HEXSTRING_template(null_type other_value);
PREGEN__SET__OF__HEXSTRING_template(const PREGEN__SET__OF__HEXSTRING& other_value);
PREGEN__SET__OF__HEXSTRING_template(const OPTIONAL<PREGEN__SET__OF__HEXSTRING>& other_value);
PREGEN__SET__OF__HEXSTRING_template(const PREGEN__SET__OF__HEXSTRING_template& other_value);
~PREGEN__SET__OF__HEXSTRING_template();

void clean_up();
PREGEN__SET__OF__HEXSTRING_template& operator=(template_sel other_value);
PREGEN__SET__OF__HEXSTRING_template& operator=(null_type other_value);
PREGEN__SET__OF__HEXSTRING_template& operator=(const PREGEN__SET__OF__HEXSTRING& other_value);
PREGEN__SET__OF__HEXSTRING_template& operator=(const OPTIONAL<PREGEN__SET__OF__HEXSTRING>& other_value);
PREGEN__SET__OF__HEXSTRING_template& operator=(const PREGEN__SET__OF__HEXSTRING_template& other_value);

HEXSTRING_template& operator[](int index_value);
HEXSTRING_template& operator[](const INTEGER& index_value);
const HEXSTRING_template& operator[](int index_value) const;
const HEXSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__HEXSTRING& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__HEXSTRING valueof() const;
PREGEN__SET__OF__HEXSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__HEXSTRING replace(int index, int len, const PREGEN__SET__OF__HEXSTRING_template& repl) const;

PREGEN__SET__OF__HEXSTRING replace(int index, int len, const PREGEN__SET__OF__HEXSTRING& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__HEXSTRING_template& list_item(unsigned int list_index);
HEXSTRING_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__HEXSTRING& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__OCTETSTRING : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
OCTETSTRING **value_elements;
} *val_ptr;

static const OCTETSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__OCTETSTRING& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef OCTETSTRING of_type;
PREGEN__SET__OF__OCTETSTRING();
PREGEN__SET__OF__OCTETSTRING(null_type other_value);
PREGEN__SET__OF__OCTETSTRING(const PREGEN__SET__OF__OCTETSTRING& other_value);
~PREGEN__SET__OF__OCTETSTRING();

void clean_up();
PREGEN__SET__OF__OCTETSTRING& operator=(null_type other_value);
PREGEN__SET__OF__OCTETSTRING& operator=(const PREGEN__SET__OF__OCTETSTRING& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__OCTETSTRING& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__OCTETSTRING& other_value) const { return !(*this == other_value); }

OCTETSTRING& operator[](int index_value);
OCTETSTRING& operator[](const INTEGER& index_value);
const OCTETSTRING& operator[](int index_value) const;
const OCTETSTRING& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__OCTETSTRING operator<<=(int rotate_count) const;
PREGEN__SET__OF__OCTETSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__OCTETSTRING operator>>=(int rotate_count) const;
PREGEN__SET__OF__OCTETSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__OCTETSTRING operator+(const PREGEN__SET__OF__OCTETSTRING& other_value) const;

PREGEN__SET__OF__OCTETSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__OCTETSTRING replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING& repl) const;

PREGEN__SET__OF__OCTETSTRING replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__OCTETSTRING_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
OCTETSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__OCTETSTRING_template *list_value;
} value_list;
struct {
unsigned int n_items;
OCTETSTRING_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__OCTETSTRING& other_value);
void copy_template(const PREGEN__SET__OF__OCTETSTRING_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__OCTETSTRING_template();
PREGEN__SET__OF__OCTETSTRING_template(template_sel other_value);
PREGEN__SET__OF__OCTETSTRING_template(null_type other_value);
PREGEN__SET__OF__OCTETSTRING_template(const PREGEN__SET__OF__OCTETSTRING& other_value);
PREGEN__SET__OF__OCTETSTRING_template(const OPTIONAL<PREGEN__SET__OF__OCTETSTRING>& other_value);
PREGEN__SET__OF__OCTETSTRING_template(const PREGEN__SET__OF__OCTETSTRING_template& other_value);
~PREGEN__SET__OF__OCTETSTRING_template();

void clean_up();
PREGEN__SET__OF__OCTETSTRING_template& operator=(template_sel other_value);
PREGEN__SET__OF__OCTETSTRING_template& operator=(null_type other_value);
PREGEN__SET__OF__OCTETSTRING_template& operator=(const PREGEN__SET__OF__OCTETSTRING& other_value);
PREGEN__SET__OF__OCTETSTRING_template& operator=(const OPTIONAL<PREGEN__SET__OF__OCTETSTRING>& other_value);
PREGEN__SET__OF__OCTETSTRING_template& operator=(const PREGEN__SET__OF__OCTETSTRING_template& other_value);

OCTETSTRING_template& operator[](int index_value);
OCTETSTRING_template& operator[](const INTEGER& index_value);
const OCTETSTRING_template& operator[](int index_value) const;
const OCTETSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__OCTETSTRING& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__OCTETSTRING valueof() const;
PREGEN__SET__OF__OCTETSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__OCTETSTRING replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING_template& repl) const;

PREGEN__SET__OF__OCTETSTRING replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__OCTETSTRING_template& list_item(unsigned int list_index);
OCTETSTRING_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__OCTETSTRING& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__CHARSTRING : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
CHARSTRING **value_elements;
} *val_ptr;

static const CHARSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__CHARSTRING& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef CHARSTRING of_type;
PREGEN__SET__OF__CHARSTRING();
PREGEN__SET__OF__CHARSTRING(null_type other_value);
PREGEN__SET__OF__CHARSTRING(const PREGEN__SET__OF__CHARSTRING& other_value);
~PREGEN__SET__OF__CHARSTRING();

void clean_up();
PREGEN__SET__OF__CHARSTRING& operator=(null_type other_value);
PREGEN__SET__OF__CHARSTRING& operator=(const PREGEN__SET__OF__CHARSTRING& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__CHARSTRING& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__CHARSTRING& other_value) const { return !(*this == other_value); }

CHARSTRING& operator[](int index_value);
CHARSTRING& operator[](const INTEGER& index_value);
const CHARSTRING& operator[](int index_value) const;
const CHARSTRING& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__CHARSTRING operator<<=(int rotate_count) const;
PREGEN__SET__OF__CHARSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__CHARSTRING operator>>=(int rotate_count) const;
PREGEN__SET__OF__CHARSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__CHARSTRING operator+(const PREGEN__SET__OF__CHARSTRING& other_value) const;

PREGEN__SET__OF__CHARSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__CHARSTRING& repl) const;

PREGEN__SET__OF__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__CHARSTRING_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__CHARSTRING_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
CHARSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__CHARSTRING_template *list_value;
} value_list;
struct {
unsigned int n_items;
CHARSTRING_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__CHARSTRING& other_value);
void copy_template(const PREGEN__SET__OF__CHARSTRING_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__CHARSTRING_template();
PREGEN__SET__OF__CHARSTRING_template(template_sel other_value);
PREGEN__SET__OF__CHARSTRING_template(null_type other_value);
PREGEN__SET__OF__CHARSTRING_template(const PREGEN__SET__OF__CHARSTRING& other_value);
PREGEN__SET__OF__CHARSTRING_template(const OPTIONAL<PREGEN__SET__OF__CHARSTRING>& other_value);
PREGEN__SET__OF__CHARSTRING_template(const PREGEN__SET__OF__CHARSTRING_template& other_value);
~PREGEN__SET__OF__CHARSTRING_template();

void clean_up();
PREGEN__SET__OF__CHARSTRING_template& operator=(template_sel other_value);
PREGEN__SET__OF__CHARSTRING_template& operator=(null_type other_value);
PREGEN__SET__OF__CHARSTRING_template& operator=(const PREGEN__SET__OF__CHARSTRING& other_value);
PREGEN__SET__OF__CHARSTRING_template& operator=(const OPTIONAL<PREGEN__SET__OF__CHARSTRING>& other_value);
PREGEN__SET__OF__CHARSTRING_template& operator=(const PREGEN__SET__OF__CHARSTRING_template& other_value);

CHARSTRING_template& operator[](int index_value);
CHARSTRING_template& operator[](const INTEGER& index_value);
const CHARSTRING_template& operator[](int index_value) const;
const CHARSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__CHARSTRING& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__CHARSTRING valueof() const;
PREGEN__SET__OF__CHARSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__CHARSTRING_template& repl) const;

PREGEN__SET__OF__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__CHARSTRING& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__CHARSTRING_template& list_item(unsigned int list_index);
CHARSTRING_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__CHARSTRING& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__UNIVERSAL__CHARSTRING : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
UNIVERSAL_CHARSTRING **value_elements;
} *val_ptr;

static const UNIVERSAL_CHARSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef UNIVERSAL_CHARSTRING of_type;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING();
PREGEN__SET__OF__UNIVERSAL__CHARSTRING(null_type other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value);
~PREGEN__SET__OF__UNIVERSAL__CHARSTRING();

void clean_up();
PREGEN__SET__OF__UNIVERSAL__CHARSTRING& operator=(null_type other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING& operator=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value) const { return !(*this == other_value); }

UNIVERSAL_CHARSTRING& operator[](int index_value);
UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator<<=(int rotate_count) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator>>=(int rotate_count) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator+(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& repl) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
UNIVERSAL_CHARSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template *list_value;
} value_list;
struct {
unsigned int n_items;
UNIVERSAL_CHARSTRING_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value);
void copy_template(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template();
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template(template_sel other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template(null_type other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template(const OPTIONAL<PREGEN__SET__OF__UNIVERSAL__CHARSTRING>& other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& other_value);
~PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template();

void clean_up();
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& operator=(template_sel other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& operator=(null_type other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& operator=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& operator=(const OPTIONAL<PREGEN__SET__OF__UNIVERSAL__CHARSTRING>& other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& operator=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& other_value);

UNIVERSAL_CHARSTRING_template& operator[](int index_value);
UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING_template& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING valueof() const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& repl) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& list_item(unsigned int list_index);
UNIVERSAL_CHARSTRING_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__BOOLEAN__OPTIMIZED : public Base_Type {
int n_elements;
BOOLEAN* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value);
void copy_value(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef BOOLEAN of_type;
PREGEN__SET__OF__BOOLEAN__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__SET__OF__BOOLEAN__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__SET__OF__BOOLEAN__OPTIMIZED(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__SET__OF__BOOLEAN__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__SET__OF__BOOLEAN__OPTIMIZED& operator=(null_type other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED& operator=(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value) const { return !(*this == other_value); }

BOOLEAN& operator[](int index_value);
BOOLEAN& operator[](const INTEGER& index_value);
const BOOLEAN& operator[](int index_value) const;
const BOOLEAN& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator+(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& repl) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
BOOLEAN_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template *list_value;
} value_list;
struct {
unsigned int n_items;
BOOLEAN_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value);
void copy_template(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template();
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template(template_sel other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__BOOLEAN__OPTIMIZED>& other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& other_value);
~PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template();

void clean_up();
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& operator=(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__BOOLEAN__OPTIMIZED>& other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& operator=(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& other_value);

BOOLEAN_template& operator[](int index_value);
BOOLEAN_template& operator[](const INTEGER& index_value);
const BOOLEAN_template& operator[](int index_value) const;
const BOOLEAN_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__BOOLEAN__OPTIMIZED valueof() const;
PREGEN__SET__OF__BOOLEAN__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& list_item(unsigned int list_index);
BOOLEAN_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__INTEGER__OPTIMIZED : public Base_Type {
int n_elements;
INTEGER* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value);
void copy_value(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef INTEGER of_type;
PREGEN__SET__OF__INTEGER__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__SET__OF__INTEGER__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__SET__OF__INTEGER__OPTIMIZED(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__SET__OF__INTEGER__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__SET__OF__INTEGER__OPTIMIZED& operator=(null_type other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED& operator=(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value) const { return !(*this == other_value); }

INTEGER& operator[](int index_value);
INTEGER& operator[](const INTEGER& index_value);
const INTEGER& operator[](int index_value) const;
const INTEGER& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__INTEGER__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__INTEGER__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__INTEGER__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED operator+(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__INTEGER__OPTIMIZED& repl) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__INTEGER__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__INTEGER__OPTIMIZED_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
INTEGER_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__INTEGER__OPTIMIZED_template *list_value;
} value_list;
struct {
unsigned int n_items;
INTEGER_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value);
void copy_template(const PREGEN__SET__OF__INTEGER__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__INTEGER__OPTIMIZED_template();
PREGEN__SET__OF__INTEGER__OPTIMIZED_template(template_sel other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__INTEGER__OPTIMIZED>& other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template(const PREGEN__SET__OF__INTEGER__OPTIMIZED_template& other_value);
~PREGEN__SET__OF__INTEGER__OPTIMIZED_template();

void clean_up();
PREGEN__SET__OF__INTEGER__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template& operator=(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__INTEGER__OPTIMIZED>& other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template& operator=(const PREGEN__SET__OF__INTEGER__OPTIMIZED_template& other_value);

INTEGER_template& operator[](int index_value);
INTEGER_template& operator[](const INTEGER& index_value);
const INTEGER_template& operator[](int index_value) const;
const INTEGER_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__INTEGER__OPTIMIZED valueof() const;
PREGEN__SET__OF__INTEGER__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__INTEGER__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__INTEGER__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template& list_item(unsigned int list_index);
INTEGER_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__INTEGER__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__FLOAT__OPTIMIZED : public Base_Type {
int n_elements;
FLOAT* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value);
void copy_value(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef FLOAT of_type;
PREGEN__SET__OF__FLOAT__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__SET__OF__FLOAT__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__SET__OF__FLOAT__OPTIMIZED(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__SET__OF__FLOAT__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__SET__OF__FLOAT__OPTIMIZED& operator=(null_type other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED& operator=(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value) const { return !(*this == other_value); }

FLOAT& operator[](int index_value);
FLOAT& operator[](const INTEGER& index_value);
const FLOAT& operator[](int index_value) const;
const FLOAT& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__FLOAT__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__FLOAT__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__FLOAT__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED operator+(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__FLOAT__OPTIMIZED& repl) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__FLOAT__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__FLOAT__OPTIMIZED_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
FLOAT_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__FLOAT__OPTIMIZED_template *list_value;
} value_list;
struct {
unsigned int n_items;
FLOAT_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value);
void copy_template(const PREGEN__SET__OF__FLOAT__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__FLOAT__OPTIMIZED_template();
PREGEN__SET__OF__FLOAT__OPTIMIZED_template(template_sel other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__FLOAT__OPTIMIZED>& other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template(const PREGEN__SET__OF__FLOAT__OPTIMIZED_template& other_value);
~PREGEN__SET__OF__FLOAT__OPTIMIZED_template();

void clean_up();
PREGEN__SET__OF__FLOAT__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template& operator=(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__FLOAT__OPTIMIZED>& other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template& operator=(const PREGEN__SET__OF__FLOAT__OPTIMIZED_template& other_value);

FLOAT_template& operator[](int index_value);
FLOAT_template& operator[](const INTEGER& index_value);
const FLOAT_template& operator[](int index_value) const;
const FLOAT_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__FLOAT__OPTIMIZED valueof() const;
PREGEN__SET__OF__FLOAT__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__FLOAT__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__FLOAT__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template& list_item(unsigned int list_index);
FLOAT_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__FLOAT__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__BITSTRING__OPTIMIZED : public Base_Type {
int n_elements;
BITSTRING* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value);
void copy_value(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef BITSTRING of_type;
PREGEN__SET__OF__BITSTRING__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__SET__OF__BITSTRING__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__SET__OF__BITSTRING__OPTIMIZED(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__SET__OF__BITSTRING__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__SET__OF__BITSTRING__OPTIMIZED& operator=(null_type other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED& operator=(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value) const { return !(*this == other_value); }

BITSTRING& operator[](int index_value);
BITSTRING& operator[](const INTEGER& index_value);
const BITSTRING& operator[](int index_value) const;
const BITSTRING& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__BITSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__BITSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__BITSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED operator+(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BITSTRING__OPTIMIZED& repl) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__BITSTRING__OPTIMIZED_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
BITSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template *list_value;
} value_list;
struct {
unsigned int n_items;
BITSTRING_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value);
void copy_template(const PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template();
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template(template_sel other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__BITSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template(const PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& other_value);
~PREGEN__SET__OF__BITSTRING__OPTIMIZED_template();

void clean_up();
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__BITSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& other_value);

BITSTRING_template& operator[](int index_value);
BITSTRING_template& operator[](const INTEGER& index_value);
const BITSTRING_template& operator[](int index_value) const;
const BITSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__BITSTRING__OPTIMIZED valueof() const;
PREGEN__SET__OF__BITSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BITSTRING__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& list_item(unsigned int list_index);
BITSTRING_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__HEXSTRING__OPTIMIZED : public Base_Type {
int n_elements;
HEXSTRING* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value);
void copy_value(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef HEXSTRING of_type;
PREGEN__SET__OF__HEXSTRING__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__SET__OF__HEXSTRING__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__SET__OF__HEXSTRING__OPTIMIZED(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__SET__OF__HEXSTRING__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__SET__OF__HEXSTRING__OPTIMIZED& operator=(null_type other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED& operator=(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value) const { return !(*this == other_value); }

HEXSTRING& operator[](int index_value);
HEXSTRING& operator[](const INTEGER& index_value);
const HEXSTRING& operator[](int index_value) const;
const HEXSTRING& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator+(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& repl) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
HEXSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template *list_value;
} value_list;
struct {
unsigned int n_items;
HEXSTRING_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value);
void copy_template(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template();
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template(template_sel other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__HEXSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& other_value);
~PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template();

void clean_up();
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__HEXSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& other_value);

HEXSTRING_template& operator[](int index_value);
HEXSTRING_template& operator[](const INTEGER& index_value);
const HEXSTRING_template& operator[](int index_value) const;
const HEXSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__HEXSTRING__OPTIMIZED valueof() const;
PREGEN__SET__OF__HEXSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& list_item(unsigned int list_index);
HEXSTRING_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__OCTETSTRING__OPTIMIZED : public Base_Type {
int n_elements;
OCTETSTRING* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value);
void copy_value(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef OCTETSTRING of_type;
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__SET__OF__OCTETSTRING__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& operator=(null_type other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& operator=(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value) const { return !(*this == other_value); }

OCTETSTRING& operator[](int index_value);
OCTETSTRING& operator[](const INTEGER& index_value);
const OCTETSTRING& operator[](int index_value) const;
const OCTETSTRING& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator+(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& repl) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
OCTETSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template *list_value;
} value_list;
struct {
unsigned int n_items;
OCTETSTRING_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value);
void copy_template(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template();
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template(template_sel other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__OCTETSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& other_value);
~PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template();

void clean_up();
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__OCTETSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& other_value);

OCTETSTRING_template& operator[](int index_value);
OCTETSTRING_template& operator[](const INTEGER& index_value);
const OCTETSTRING_template& operator[](int index_value) const;
const OCTETSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED valueof() const;
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& list_item(unsigned int list_index);
OCTETSTRING_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__CHARSTRING__OPTIMIZED : public Base_Type {
int n_elements;
CHARSTRING* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value);
void copy_value(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef CHARSTRING of_type;
PREGEN__SET__OF__CHARSTRING__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__SET__OF__CHARSTRING__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__SET__OF__CHARSTRING__OPTIMIZED(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__SET__OF__CHARSTRING__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__SET__OF__CHARSTRING__OPTIMIZED& operator=(null_type other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED& operator=(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value) const { return !(*this == other_value); }

CHARSTRING& operator[](int index_value);
CHARSTRING& operator[](const INTEGER& index_value);
const CHARSTRING& operator[](int index_value) const;
const CHARSTRING& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator+(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& repl) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
CHARSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template *list_value;
} value_list;
struct {
unsigned int n_items;
CHARSTRING_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value);
void copy_template(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template();
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template(template_sel other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__CHARSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& other_value);
~PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template();

void clean_up();
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__CHARSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& other_value);

CHARSTRING_template& operator[](int index_value);
CHARSTRING_template& operator[](const INTEGER& index_value);
const CHARSTRING_template& operator[](int index_value) const;
const CHARSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__CHARSTRING__OPTIMIZED valueof() const;
PREGEN__SET__OF__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& list_item(unsigned int list_index);
CHARSTRING_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED : public Base_Type {
int n_elements;
UNIVERSAL_CHARSTRING* value_elements;
private:
friend boolean operator==(null_type null_value, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
void copy_value(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef UNIVERSAL_CHARSTRING of_type;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(): n_elements(-1), value_elements(NULL) {}
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(null_type): n_elements(0), value_elements(NULL) {}
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) { copy_value(other_value); }
~PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED() { clean_up(); }

void clean_up();
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& operator=(null_type other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& operator=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const { return !(*this == other_value); }

UNIVERSAL_CHARSTRING& operator[](int index_value);
UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator+(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& repl) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return n_elements!=-1; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int TEXT_encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&) const;
int TEXT_decode(const TTCN_Typedescriptor_t&,TTCN_Buffer&, Limit_Token_List&, boolean no_err=FALSE,boolean first_call=TRUE);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
UNIVERSAL_CHARSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template *list_value;
} value_list;
struct {
unsigned int n_items;
UNIVERSAL_CHARSTRING_template *set_items;
} value_set;
};
void copy_value(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
void copy_template(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template);

public:
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template();
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(template_sel other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& other_value);
~PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template();

void clean_up();
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& other_value);

UNIVERSAL_CHARSTRING_template& operator[](int index_value);
UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING_template& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED valueof() const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& list_item(unsigned int list_index);
UNIVERSAL_CHARSTRING_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__BOOLEAN& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__BOOLEAN& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__INTEGER& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__INTEGER& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__FLOAT& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__FLOAT& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__BITSTRING& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__BITSTRING& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__HEXSTRING& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__HEXSTRING& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__OCTETSTRING& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__OCTETSTRING& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__CHARSTRING& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__CHARSTRING& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__BOOLEAN& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__BOOLEAN& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__INTEGER& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__INTEGER& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__FLOAT& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__FLOAT& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__BITSTRING& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__BITSTRING& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__HEXSTRING& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__HEXSTRING& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__OCTETSTRING& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__OCTETSTRING& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__CHARSTRING& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__CHARSTRING& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
inline boolean operator!=(null_type null_value, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BOOLEAN_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__BOOLEAN_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BOOLEAN_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__INTEGER_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__INTEGER_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__INTEGER_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__FLOAT_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__FLOAT_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__FLOAT_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BITSTRING_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__BITSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BITSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__HEXSTRING_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__HEXSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__HEXSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__OCTETSTRING_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__OCTETSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__OCTETSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__CHARSTRING_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__CHARSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__CHARSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__INTEGER__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__INTEGER__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__INTEGER__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__FLOAT__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__FLOAT__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__FLOAT__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BOOLEAN_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__BOOLEAN_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BOOLEAN_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__INTEGER_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__INTEGER_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__INTEGER_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__FLOAT_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__FLOAT_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__FLOAT_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BITSTRING_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__BITSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BITSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__HEXSTRING_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__HEXSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__HEXSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__OCTETSTRING_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__OCTETSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__OCTETSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__CHARSTRING_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__CHARSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__CHARSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__UNIVERSAL__CHARSTRING_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__UNIVERSAL__CHARSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__UNIVERSAL__CHARSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BOOLEAN__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__BOOLEAN__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BOOLEAN__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__INTEGER__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__INTEGER__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__INTEGER__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__FLOAT__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__FLOAT__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__FLOAT__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BITSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__BITSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BITSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__HEXSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__HEXSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__HEXSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__CHARSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__CHARSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__CHARSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_0_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
