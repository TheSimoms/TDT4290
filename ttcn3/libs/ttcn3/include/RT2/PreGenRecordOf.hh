// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for titanrt (titanrt@Ubuntu-14-04-64bit) on Fri May 22 16:37:26 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

#ifndef PreGenRecordOf_HH
#define PreGenRecordOf_HH

#ifndef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated with -R option but -DTITAN_RUNTIME_2 was not used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 50300
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef PreGenRecordOf_HH
#endif

namespace PreGenRecordOf {

/* Forward declarations of classes */

class PREGEN__RECORD__OF__BOOLEAN;
class PREGEN__RECORD__OF__BOOLEAN_template;
class PREGEN__RECORD__OF__INTEGER;
class PREGEN__RECORD__OF__INTEGER_template;
class PREGEN__RECORD__OF__FLOAT;
class PREGEN__RECORD__OF__FLOAT_template;
class PREGEN__RECORD__OF__BITSTRING;
class PREGEN__RECORD__OF__BITSTRING_template;
class PREGEN__RECORD__OF__HEXSTRING;
class PREGEN__RECORD__OF__HEXSTRING_template;
class PREGEN__RECORD__OF__OCTETSTRING;
class PREGEN__RECORD__OF__OCTETSTRING_template;
class PREGEN__RECORD__OF__CHARSTRING;
class PREGEN__RECORD__OF__CHARSTRING_template;
class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING;
class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template;
class PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED;
class PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template;
class PREGEN__RECORD__OF__INTEGER__OPTIMIZED;
class PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template;
class PREGEN__RECORD__OF__FLOAT__OPTIMIZED;
class PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template;
class PREGEN__RECORD__OF__BITSTRING__OPTIMIZED;
class PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template;
class PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED;
class PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template;
class PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED;
class PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template;
class PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED;
class PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template;
class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED;
class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template;
class PREGEN__SET__OF__BOOLEAN;
class PREGEN__SET__OF__BOOLEAN_template;
class PREGEN__SET__OF__INTEGER;
class PREGEN__SET__OF__INTEGER_template;
class PREGEN__SET__OF__FLOAT;
class PREGEN__SET__OF__FLOAT_template;
class PREGEN__SET__OF__BITSTRING;
class PREGEN__SET__OF__BITSTRING_template;
class PREGEN__SET__OF__HEXSTRING;
class PREGEN__SET__OF__HEXSTRING_template;
class PREGEN__SET__OF__OCTETSTRING;
class PREGEN__SET__OF__OCTETSTRING_template;
class PREGEN__SET__OF__CHARSTRING;
class PREGEN__SET__OF__CHARSTRING_template;
class PREGEN__SET__OF__UNIVERSAL__CHARSTRING;
class PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template;
class PREGEN__SET__OF__BOOLEAN__OPTIMIZED;
class PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template;
class PREGEN__SET__OF__INTEGER__OPTIMIZED;
class PREGEN__SET__OF__INTEGER__OPTIMIZED_template;
class PREGEN__SET__OF__FLOAT__OPTIMIZED;
class PREGEN__SET__OF__FLOAT__OPTIMIZED_template;
class PREGEN__SET__OF__BITSTRING__OPTIMIZED;
class PREGEN__SET__OF__BITSTRING__OPTIMIZED_template;
class PREGEN__SET__OF__HEXSTRING__OPTIMIZED;
class PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template;
class PREGEN__SET__OF__OCTETSTRING__OPTIMIZED;
class PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template;
class PREGEN__SET__OF__CHARSTRING__OPTIMIZED;
class PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template;
class PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED;
class PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template;

} /* end of namespace */

#ifndef PreGenRecordOf_HH
#define PreGenRecordOf_HH

namespace PreGenRecordOf {

/* Class definitions */

class PREGEN__RECORD__OF__BOOLEAN : public Record_Of_Type {

static const BOOLEAN UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__BOOLEAN(): Record_Of_Type() {}
PREGEN__RECORD__OF__BOOLEAN(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__BOOLEAN(const PREGEN__RECORD__OF__BOOLEAN& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__BOOLEAN() { clean_up(); }

inline PREGEN__RECORD__OF__BOOLEAN& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__BOOLEAN& operator=(const PREGEN__RECORD__OF__BOOLEAN& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__BOOLEAN& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__BOOLEAN& other_value) const { return !is_equal(&other_value); }
BOOLEAN& operator[](int index_value);
BOOLEAN& operator[](const INTEGER& index_value);
const BOOLEAN& operator[](int index_value) const;
const BOOLEAN& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__BOOLEAN operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__BOOLEAN operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__BOOLEAN operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__BOOLEAN operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__BOOLEAN operator+(const PREGEN__RECORD__OF__BOOLEAN& other_value) const;

PREGEN__RECORD__OF__BOOLEAN substr(int index, int returncount) const;

PREGEN__RECORD__OF__BOOLEAN replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN& repl) const;

PREGEN__RECORD__OF__BOOLEAN replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__BOOLEAN(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return TRUE; }

};

class PREGEN__RECORD__OF__BOOLEAN_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__BOOLEAN_template() {}
PREGEN__RECORD__OF__BOOLEAN_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__BOOLEAN_template(null_type other_value);
PREGEN__RECORD__OF__BOOLEAN_template(const PREGEN__RECORD__OF__BOOLEAN& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__BOOLEAN_template(const OPTIONAL<PREGEN__RECORD__OF__BOOLEAN>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__BOOLEAN_template(const PREGEN__RECORD__OF__BOOLEAN_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__BOOLEAN_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__BOOLEAN_template& operator=(null_type other_value);
PREGEN__RECORD__OF__BOOLEAN_template& operator=(const PREGEN__RECORD__OF__BOOLEAN& other_value);
PREGEN__RECORD__OF__BOOLEAN_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__BOOLEAN>& other_value);
PREGEN__RECORD__OF__BOOLEAN_template& operator=(const PREGEN__RECORD__OF__BOOLEAN_template& other_value);

BOOLEAN_template& operator[](int index_value);
BOOLEAN_template& operator[](const INTEGER& index_value);
const BOOLEAN_template& operator[](int index_value) const;
const BOOLEAN_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__BOOLEAN& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__BOOLEAN valueof() const;
PREGEN__RECORD__OF__BOOLEAN substr(int index, int returncount) const;

PREGEN__RECORD__OF__BOOLEAN replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN_template& repl) const;

PREGEN__RECORD__OF__BOOLEAN replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN& repl) const;

inline PREGEN__RECORD__OF__BOOLEAN_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__BOOLEAN_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__BOOLEAN& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__BOOLEAN_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__INTEGER : public Record_Of_Type {

static const INTEGER UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__INTEGER(): Record_Of_Type() {}
PREGEN__RECORD__OF__INTEGER(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__INTEGER(const PREGEN__RECORD__OF__INTEGER& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__INTEGER() { clean_up(); }

inline PREGEN__RECORD__OF__INTEGER& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__INTEGER& operator=(const PREGEN__RECORD__OF__INTEGER& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__INTEGER& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__INTEGER& other_value) const { return !is_equal(&other_value); }
INTEGER& operator[](int index_value);
INTEGER& operator[](const INTEGER& index_value);
const INTEGER& operator[](int index_value) const;
const INTEGER& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__INTEGER operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__INTEGER operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__INTEGER operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__INTEGER operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__INTEGER operator+(const PREGEN__RECORD__OF__INTEGER& other_value) const;

PREGEN__RECORD__OF__INTEGER substr(int index, int returncount) const;

PREGEN__RECORD__OF__INTEGER replace(int index, int len, const PREGEN__RECORD__OF__INTEGER& repl) const;

PREGEN__RECORD__OF__INTEGER replace(int index, int len, const PREGEN__RECORD__OF__INTEGER_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__INTEGER(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__INTEGER_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__INTEGER_template() {}
PREGEN__RECORD__OF__INTEGER_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__INTEGER_template(null_type other_value);
PREGEN__RECORD__OF__INTEGER_template(const PREGEN__RECORD__OF__INTEGER& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__INTEGER_template(const OPTIONAL<PREGEN__RECORD__OF__INTEGER>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__INTEGER_template(const PREGEN__RECORD__OF__INTEGER_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__INTEGER_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__INTEGER_template& operator=(null_type other_value);
PREGEN__RECORD__OF__INTEGER_template& operator=(const PREGEN__RECORD__OF__INTEGER& other_value);
PREGEN__RECORD__OF__INTEGER_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__INTEGER>& other_value);
PREGEN__RECORD__OF__INTEGER_template& operator=(const PREGEN__RECORD__OF__INTEGER_template& other_value);

INTEGER_template& operator[](int index_value);
INTEGER_template& operator[](const INTEGER& index_value);
const INTEGER_template& operator[](int index_value) const;
const INTEGER_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__INTEGER& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__INTEGER valueof() const;
PREGEN__RECORD__OF__INTEGER substr(int index, int returncount) const;

PREGEN__RECORD__OF__INTEGER replace(int index, int len, const PREGEN__RECORD__OF__INTEGER_template& repl) const;

PREGEN__RECORD__OF__INTEGER replace(int index, int len, const PREGEN__RECORD__OF__INTEGER& repl) const;

inline PREGEN__RECORD__OF__INTEGER_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__INTEGER_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__INTEGER& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__INTEGER_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__FLOAT : public Record_Of_Type {

static const FLOAT UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__FLOAT(): Record_Of_Type() {}
PREGEN__RECORD__OF__FLOAT(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__FLOAT(const PREGEN__RECORD__OF__FLOAT& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__FLOAT() { clean_up(); }

inline PREGEN__RECORD__OF__FLOAT& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__FLOAT& operator=(const PREGEN__RECORD__OF__FLOAT& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__FLOAT& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__FLOAT& other_value) const { return !is_equal(&other_value); }
FLOAT& operator[](int index_value);
FLOAT& operator[](const INTEGER& index_value);
const FLOAT& operator[](int index_value) const;
const FLOAT& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__FLOAT operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__FLOAT operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__FLOAT operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__FLOAT operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__FLOAT operator+(const PREGEN__RECORD__OF__FLOAT& other_value) const;

PREGEN__RECORD__OF__FLOAT substr(int index, int returncount) const;

PREGEN__RECORD__OF__FLOAT replace(int index, int len, const PREGEN__RECORD__OF__FLOAT& repl) const;

PREGEN__RECORD__OF__FLOAT replace(int index, int len, const PREGEN__RECORD__OF__FLOAT_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__FLOAT(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__FLOAT_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__FLOAT_template() {}
PREGEN__RECORD__OF__FLOAT_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__FLOAT_template(null_type other_value);
PREGEN__RECORD__OF__FLOAT_template(const PREGEN__RECORD__OF__FLOAT& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__FLOAT_template(const OPTIONAL<PREGEN__RECORD__OF__FLOAT>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__FLOAT_template(const PREGEN__RECORD__OF__FLOAT_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__FLOAT_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__FLOAT_template& operator=(null_type other_value);
PREGEN__RECORD__OF__FLOAT_template& operator=(const PREGEN__RECORD__OF__FLOAT& other_value);
PREGEN__RECORD__OF__FLOAT_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__FLOAT>& other_value);
PREGEN__RECORD__OF__FLOAT_template& operator=(const PREGEN__RECORD__OF__FLOAT_template& other_value);

FLOAT_template& operator[](int index_value);
FLOAT_template& operator[](const INTEGER& index_value);
const FLOAT_template& operator[](int index_value) const;
const FLOAT_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__FLOAT& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__FLOAT valueof() const;
PREGEN__RECORD__OF__FLOAT substr(int index, int returncount) const;

PREGEN__RECORD__OF__FLOAT replace(int index, int len, const PREGEN__RECORD__OF__FLOAT_template& repl) const;

PREGEN__RECORD__OF__FLOAT replace(int index, int len, const PREGEN__RECORD__OF__FLOAT& repl) const;

inline PREGEN__RECORD__OF__FLOAT_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__FLOAT_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__FLOAT& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__FLOAT_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__BITSTRING : public Record_Of_Type {

static const BITSTRING UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__BITSTRING(): Record_Of_Type() {}
PREGEN__RECORD__OF__BITSTRING(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__BITSTRING(const PREGEN__RECORD__OF__BITSTRING& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__BITSTRING() { clean_up(); }

inline PREGEN__RECORD__OF__BITSTRING& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__BITSTRING& operator=(const PREGEN__RECORD__OF__BITSTRING& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__BITSTRING& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__BITSTRING& other_value) const { return !is_equal(&other_value); }
BITSTRING& operator[](int index_value);
BITSTRING& operator[](const INTEGER& index_value);
const BITSTRING& operator[](int index_value) const;
const BITSTRING& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__BITSTRING operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__BITSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__BITSTRING operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__BITSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__BITSTRING operator+(const PREGEN__RECORD__OF__BITSTRING& other_value) const;

PREGEN__RECORD__OF__BITSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__BITSTRING replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING& repl) const;

PREGEN__RECORD__OF__BITSTRING replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__BITSTRING(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__BITSTRING_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__BITSTRING_template() {}
PREGEN__RECORD__OF__BITSTRING_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__BITSTRING_template(null_type other_value);
PREGEN__RECORD__OF__BITSTRING_template(const PREGEN__RECORD__OF__BITSTRING& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__BITSTRING_template(const OPTIONAL<PREGEN__RECORD__OF__BITSTRING>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__BITSTRING_template(const PREGEN__RECORD__OF__BITSTRING_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__BITSTRING_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__BITSTRING_template& operator=(null_type other_value);
PREGEN__RECORD__OF__BITSTRING_template& operator=(const PREGEN__RECORD__OF__BITSTRING& other_value);
PREGEN__RECORD__OF__BITSTRING_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__BITSTRING>& other_value);
PREGEN__RECORD__OF__BITSTRING_template& operator=(const PREGEN__RECORD__OF__BITSTRING_template& other_value);

BITSTRING_template& operator[](int index_value);
BITSTRING_template& operator[](const INTEGER& index_value);
const BITSTRING_template& operator[](int index_value) const;
const BITSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__BITSTRING& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__BITSTRING valueof() const;
PREGEN__RECORD__OF__BITSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__BITSTRING replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING_template& repl) const;

PREGEN__RECORD__OF__BITSTRING replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING& repl) const;

inline PREGEN__RECORD__OF__BITSTRING_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__BITSTRING_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__BITSTRING& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__BITSTRING_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__HEXSTRING : public Record_Of_Type {

static const HEXSTRING UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__HEXSTRING(): Record_Of_Type() {}
PREGEN__RECORD__OF__HEXSTRING(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__HEXSTRING(const PREGEN__RECORD__OF__HEXSTRING& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__HEXSTRING() { clean_up(); }

inline PREGEN__RECORD__OF__HEXSTRING& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__HEXSTRING& operator=(const PREGEN__RECORD__OF__HEXSTRING& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__HEXSTRING& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__HEXSTRING& other_value) const { return !is_equal(&other_value); }
HEXSTRING& operator[](int index_value);
HEXSTRING& operator[](const INTEGER& index_value);
const HEXSTRING& operator[](int index_value) const;
const HEXSTRING& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__HEXSTRING operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__HEXSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__HEXSTRING operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__HEXSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__HEXSTRING operator+(const PREGEN__RECORD__OF__HEXSTRING& other_value) const;

PREGEN__RECORD__OF__HEXSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__HEXSTRING replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING& repl) const;

PREGEN__RECORD__OF__HEXSTRING replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__HEXSTRING(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__HEXSTRING_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__HEXSTRING_template() {}
PREGEN__RECORD__OF__HEXSTRING_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__HEXSTRING_template(null_type other_value);
PREGEN__RECORD__OF__HEXSTRING_template(const PREGEN__RECORD__OF__HEXSTRING& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__HEXSTRING_template(const OPTIONAL<PREGEN__RECORD__OF__HEXSTRING>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__HEXSTRING_template(const PREGEN__RECORD__OF__HEXSTRING_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__HEXSTRING_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__HEXSTRING_template& operator=(null_type other_value);
PREGEN__RECORD__OF__HEXSTRING_template& operator=(const PREGEN__RECORD__OF__HEXSTRING& other_value);
PREGEN__RECORD__OF__HEXSTRING_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__HEXSTRING>& other_value);
PREGEN__RECORD__OF__HEXSTRING_template& operator=(const PREGEN__RECORD__OF__HEXSTRING_template& other_value);

HEXSTRING_template& operator[](int index_value);
HEXSTRING_template& operator[](const INTEGER& index_value);
const HEXSTRING_template& operator[](int index_value) const;
const HEXSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__HEXSTRING& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__HEXSTRING valueof() const;
PREGEN__RECORD__OF__HEXSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__HEXSTRING replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING_template& repl) const;

PREGEN__RECORD__OF__HEXSTRING replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING& repl) const;

inline PREGEN__RECORD__OF__HEXSTRING_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__HEXSTRING_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__HEXSTRING& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__HEXSTRING_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__OCTETSTRING : public Record_Of_Type {

static const OCTETSTRING UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__OCTETSTRING(): Record_Of_Type() {}
PREGEN__RECORD__OF__OCTETSTRING(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__OCTETSTRING(const PREGEN__RECORD__OF__OCTETSTRING& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__OCTETSTRING() { clean_up(); }

inline PREGEN__RECORD__OF__OCTETSTRING& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__OCTETSTRING& operator=(const PREGEN__RECORD__OF__OCTETSTRING& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__OCTETSTRING& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__OCTETSTRING& other_value) const { return !is_equal(&other_value); }
OCTETSTRING& operator[](int index_value);
OCTETSTRING& operator[](const INTEGER& index_value);
const OCTETSTRING& operator[](int index_value) const;
const OCTETSTRING& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__OCTETSTRING operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__OCTETSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__OCTETSTRING operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__OCTETSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__OCTETSTRING operator+(const PREGEN__RECORD__OF__OCTETSTRING& other_value) const;

PREGEN__RECORD__OF__OCTETSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__OCTETSTRING replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING& repl) const;

PREGEN__RECORD__OF__OCTETSTRING replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__OCTETSTRING(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__OCTETSTRING_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__OCTETSTRING_template() {}
PREGEN__RECORD__OF__OCTETSTRING_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__OCTETSTRING_template(null_type other_value);
PREGEN__RECORD__OF__OCTETSTRING_template(const PREGEN__RECORD__OF__OCTETSTRING& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__OCTETSTRING_template(const OPTIONAL<PREGEN__RECORD__OF__OCTETSTRING>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__OCTETSTRING_template(const PREGEN__RECORD__OF__OCTETSTRING_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__OCTETSTRING_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__OCTETSTRING_template& operator=(null_type other_value);
PREGEN__RECORD__OF__OCTETSTRING_template& operator=(const PREGEN__RECORD__OF__OCTETSTRING& other_value);
PREGEN__RECORD__OF__OCTETSTRING_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__OCTETSTRING>& other_value);
PREGEN__RECORD__OF__OCTETSTRING_template& operator=(const PREGEN__RECORD__OF__OCTETSTRING_template& other_value);

OCTETSTRING_template& operator[](int index_value);
OCTETSTRING_template& operator[](const INTEGER& index_value);
const OCTETSTRING_template& operator[](int index_value) const;
const OCTETSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__OCTETSTRING& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__OCTETSTRING valueof() const;
PREGEN__RECORD__OF__OCTETSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__OCTETSTRING replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING_template& repl) const;

PREGEN__RECORD__OF__OCTETSTRING replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING& repl) const;

inline PREGEN__RECORD__OF__OCTETSTRING_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__OCTETSTRING_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__OCTETSTRING& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__OCTETSTRING_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__CHARSTRING : public Record_Of_Type {

static const CHARSTRING UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__CHARSTRING(): Record_Of_Type() {}
PREGEN__RECORD__OF__CHARSTRING(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__CHARSTRING(const PREGEN__RECORD__OF__CHARSTRING& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__CHARSTRING() { clean_up(); }

inline PREGEN__RECORD__OF__CHARSTRING& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__CHARSTRING& operator=(const PREGEN__RECORD__OF__CHARSTRING& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__CHARSTRING& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__CHARSTRING& other_value) const { return !is_equal(&other_value); }
CHARSTRING& operator[](int index_value);
CHARSTRING& operator[](const INTEGER& index_value);
const CHARSTRING& operator[](int index_value) const;
const CHARSTRING& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__CHARSTRING operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__CHARSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__CHARSTRING operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__CHARSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__CHARSTRING operator+(const PREGEN__RECORD__OF__CHARSTRING& other_value) const;

PREGEN__RECORD__OF__CHARSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING& repl) const;

PREGEN__RECORD__OF__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__CHARSTRING(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__CHARSTRING_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__CHARSTRING_template() {}
PREGEN__RECORD__OF__CHARSTRING_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__CHARSTRING_template(null_type other_value);
PREGEN__RECORD__OF__CHARSTRING_template(const PREGEN__RECORD__OF__CHARSTRING& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__CHARSTRING_template(const OPTIONAL<PREGEN__RECORD__OF__CHARSTRING>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__CHARSTRING_template(const PREGEN__RECORD__OF__CHARSTRING_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__CHARSTRING_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__CHARSTRING_template& operator=(null_type other_value);
PREGEN__RECORD__OF__CHARSTRING_template& operator=(const PREGEN__RECORD__OF__CHARSTRING& other_value);
PREGEN__RECORD__OF__CHARSTRING_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__CHARSTRING>& other_value);
PREGEN__RECORD__OF__CHARSTRING_template& operator=(const PREGEN__RECORD__OF__CHARSTRING_template& other_value);

CHARSTRING_template& operator[](int index_value);
CHARSTRING_template& operator[](const INTEGER& index_value);
const CHARSTRING_template& operator[](int index_value) const;
const CHARSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__CHARSTRING& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__CHARSTRING valueof() const;
PREGEN__RECORD__OF__CHARSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING_template& repl) const;

PREGEN__RECORD__OF__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING& repl) const;

inline PREGEN__RECORD__OF__CHARSTRING_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__CHARSTRING_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__CHARSTRING& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__CHARSTRING_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING : public Record_Of_Type {

static const UNIVERSAL_CHARSTRING UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(): Record_Of_Type() {}
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING() { clean_up(); }

inline PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& operator=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value) const { return !is_equal(&other_value); }
UNIVERSAL_CHARSTRING& operator[](int index_value);
UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator+(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& repl) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template() {}
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template(null_type other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template(const OPTIONAL<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& operator=(null_type other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& operator=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING>& other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& operator=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& other_value);

UNIVERSAL_CHARSTRING_template& operator[](int index_value);
UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING_template& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING valueof() const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING substr(int index, int returncount) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& repl) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& repl) const;

inline PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED : public Record_Of_Type {

static const BOOLEAN UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(): Record_Of_Type() {}
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED() { clean_up(); }

inline PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& operator=(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
BOOLEAN& operator[](int index_value);
BOOLEAN& operator[](const INTEGER& index_value);
const BOOLEAN& operator[](int index_value) const;
const BOOLEAN& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator+(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return TRUE; }

};

class PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template() {}
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& other_value);

BOOLEAN_template& operator[](int index_value);
BOOLEAN_template& operator[](const INTEGER& index_value);
const BOOLEAN_template& operator[](int index_value) const;
const BOOLEAN_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& repl) const;

inline PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__INTEGER__OPTIMIZED : public Record_Of_Type {

static const INTEGER UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__INTEGER__OPTIMIZED(): Record_Of_Type() {}
PREGEN__RECORD__OF__INTEGER__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__INTEGER__OPTIMIZED(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__INTEGER__OPTIMIZED() { clean_up(); }

inline PREGEN__RECORD__OF__INTEGER__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__INTEGER__OPTIMIZED& operator=(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
INTEGER& operator[](int index_value);
INTEGER& operator[](const INTEGER& index_value);
const INTEGER& operator[](int index_value) const;
const INTEGER& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator+(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__INTEGER__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template() {}
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__INTEGER__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__INTEGER__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& other_value);

INTEGER_template& operator[](int index_value);
INTEGER_template& operator[](const INTEGER& index_value);
const INTEGER_template& operator[](int index_value) const;
const INTEGER_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__INTEGER__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__INTEGER__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& repl) const;

inline PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__INTEGER__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__FLOAT__OPTIMIZED : public Record_Of_Type {

static const FLOAT UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__FLOAT__OPTIMIZED(): Record_Of_Type() {}
PREGEN__RECORD__OF__FLOAT__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__FLOAT__OPTIMIZED(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__FLOAT__OPTIMIZED() { clean_up(); }

inline PREGEN__RECORD__OF__FLOAT__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__FLOAT__OPTIMIZED& operator=(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
FLOAT& operator[](int index_value);
FLOAT& operator[](const INTEGER& index_value);
const FLOAT& operator[](int index_value) const;
const FLOAT& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator+(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__FLOAT__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template() {}
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__FLOAT__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__FLOAT__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& other_value);

FLOAT_template& operator[](int index_value);
FLOAT_template& operator[](const INTEGER& index_value);
const FLOAT_template& operator[](int index_value) const;
const FLOAT_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__FLOAT__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__FLOAT__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& repl) const;

inline PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__FLOAT__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__BITSTRING__OPTIMIZED : public Record_Of_Type {

static const BITSTRING UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(): Record_Of_Type() {}
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__BITSTRING__OPTIMIZED() { clean_up(); }

inline PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& operator=(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
BITSTRING& operator[](int index_value);
BITSTRING& operator[](const INTEGER& index_value);
const BITSTRING& operator[](int index_value) const;
const BITSTRING& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator+(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template() {}
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__BITSTRING__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__BITSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& other_value);

BITSTRING_template& operator[](int index_value);
BITSTRING_template& operator[](const INTEGER& index_value);
const BITSTRING_template& operator[](int index_value) const;
const BITSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__BITSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& repl) const;

inline PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__BITSTRING__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED : public Record_Of_Type {

static const HEXSTRING UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(): Record_Of_Type() {}
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED() { clean_up(); }

inline PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& operator=(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
HEXSTRING& operator[](int index_value);
HEXSTRING& operator[](const INTEGER& index_value);
const HEXSTRING& operator[](int index_value) const;
const HEXSTRING& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator+(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template() {}
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& other_value);

HEXSTRING_template& operator[](int index_value);
HEXSTRING_template& operator[](const INTEGER& index_value);
const HEXSTRING_template& operator[](int index_value) const;
const HEXSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& repl) const;

inline PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED : public Record_Of_Type {

static const OCTETSTRING UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(): Record_Of_Type() {}
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED() { clean_up(); }

inline PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& operator=(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
OCTETSTRING& operator[](int index_value);
OCTETSTRING& operator[](const INTEGER& index_value);
const OCTETSTRING& operator[](int index_value) const;
const OCTETSTRING& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator+(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template() {}
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& other_value);

OCTETSTRING_template& operator[](int index_value);
OCTETSTRING_template& operator[](const INTEGER& index_value);
const OCTETSTRING_template& operator[](int index_value) const;
const OCTETSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& repl) const;

inline PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED : public Record_Of_Type {

static const CHARSTRING UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(): Record_Of_Type() {}
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED() { clean_up(); }

inline PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& operator=(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
CHARSTRING& operator[](int index_value);
CHARSTRING& operator[](const INTEGER& index_value);
const CHARSTRING& operator[](int index_value) const;
const CHARSTRING& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator+(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template() {}
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& other_value);

CHARSTRING_template& operator[](int index_value);
CHARSTRING_template& operator[](const INTEGER& index_value);
const CHARSTRING_template& operator[](int index_value) const;
const CHARSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& repl) const;

inline PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED : public Record_Of_Type {

static const UNIVERSAL_CHARSTRING UNBOUND_ELEM;

public:
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(): Record_Of_Type() {}
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED() { clean_up(); }

inline PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& operator=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
UNIVERSAL_CHARSTRING& operator[](int index_value);
UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator+(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& repl) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template : public Record_Of_Template {

public:
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template() {}
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& other_value): Record_Of_Template() { copy_template(other_value); }
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED>& other_value);
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& other_value);

UNIVERSAL_CHARSTRING_template& operator[](int index_value);
UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING_template& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED valueof() const;
PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& repl) const;

PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& repl) const;

inline PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template*>(get_list_item(list_index))); }
inline void log_match(const PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__BOOLEAN : public Record_Of_Type {

static const BOOLEAN UNBOUND_ELEM;

public:
PREGEN__SET__OF__BOOLEAN(): Record_Of_Type() {}
PREGEN__SET__OF__BOOLEAN(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__BOOLEAN(const PREGEN__SET__OF__BOOLEAN& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__BOOLEAN() { clean_up(); }

inline PREGEN__SET__OF__BOOLEAN& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__BOOLEAN& operator=(const PREGEN__SET__OF__BOOLEAN& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__BOOLEAN& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__BOOLEAN& other_value) const { return !is_equal(&other_value); }
BOOLEAN& operator[](int index_value);
BOOLEAN& operator[](const INTEGER& index_value);
const BOOLEAN& operator[](int index_value) const;
const BOOLEAN& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__BOOLEAN operator<<=(int rotate_count) const;
PREGEN__SET__OF__BOOLEAN operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__BOOLEAN operator>>=(int rotate_count) const;
PREGEN__SET__OF__BOOLEAN operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__BOOLEAN operator+(const PREGEN__SET__OF__BOOLEAN& other_value) const;

PREGEN__SET__OF__BOOLEAN substr(int index, int returncount) const;

PREGEN__SET__OF__BOOLEAN replace(int index, int len, const PREGEN__SET__OF__BOOLEAN& repl) const;

PREGEN__SET__OF__BOOLEAN replace(int index, int len, const PREGEN__SET__OF__BOOLEAN_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__BOOLEAN(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return TRUE; }

};

class PREGEN__SET__OF__BOOLEAN_template : public Set_Of_Template {

public:
PREGEN__SET__OF__BOOLEAN_template() {}
PREGEN__SET__OF__BOOLEAN_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__BOOLEAN_template(null_type other_value);
PREGEN__SET__OF__BOOLEAN_template(const PREGEN__SET__OF__BOOLEAN& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__BOOLEAN_template(const OPTIONAL<PREGEN__SET__OF__BOOLEAN>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__BOOLEAN_template(const PREGEN__SET__OF__BOOLEAN_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__BOOLEAN_template& operator=(template_sel other_value);
PREGEN__SET__OF__BOOLEAN_template& operator=(null_type other_value);
PREGEN__SET__OF__BOOLEAN_template& operator=(const PREGEN__SET__OF__BOOLEAN& other_value);
PREGEN__SET__OF__BOOLEAN_template& operator=(const OPTIONAL<PREGEN__SET__OF__BOOLEAN>& other_value);
PREGEN__SET__OF__BOOLEAN_template& operator=(const PREGEN__SET__OF__BOOLEAN_template& other_value);

BOOLEAN_template& operator[](int index_value);
BOOLEAN_template& operator[](const INTEGER& index_value);
const BOOLEAN_template& operator[](int index_value) const;
const BOOLEAN_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__BOOLEAN& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__BOOLEAN valueof() const;
PREGEN__SET__OF__BOOLEAN substr(int index, int returncount) const;

PREGEN__SET__OF__BOOLEAN replace(int index, int len, const PREGEN__SET__OF__BOOLEAN_template& repl) const;

PREGEN__SET__OF__BOOLEAN replace(int index, int len, const PREGEN__SET__OF__BOOLEAN& repl) const;

inline PREGEN__SET__OF__BOOLEAN_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__BOOLEAN_template*>(get_list_item(list_index))); }
BOOLEAN_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__BOOLEAN& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__BOOLEAN_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__INTEGER : public Record_Of_Type {

static const INTEGER UNBOUND_ELEM;

public:
PREGEN__SET__OF__INTEGER(): Record_Of_Type() {}
PREGEN__SET__OF__INTEGER(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__INTEGER(const PREGEN__SET__OF__INTEGER& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__INTEGER() { clean_up(); }

inline PREGEN__SET__OF__INTEGER& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__INTEGER& operator=(const PREGEN__SET__OF__INTEGER& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__INTEGER& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__INTEGER& other_value) const { return !is_equal(&other_value); }
INTEGER& operator[](int index_value);
INTEGER& operator[](const INTEGER& index_value);
const INTEGER& operator[](int index_value) const;
const INTEGER& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__INTEGER operator<<=(int rotate_count) const;
PREGEN__SET__OF__INTEGER operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__INTEGER operator>>=(int rotate_count) const;
PREGEN__SET__OF__INTEGER operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__INTEGER operator+(const PREGEN__SET__OF__INTEGER& other_value) const;

PREGEN__SET__OF__INTEGER substr(int index, int returncount) const;

PREGEN__SET__OF__INTEGER replace(int index, int len, const PREGEN__SET__OF__INTEGER& repl) const;

PREGEN__SET__OF__INTEGER replace(int index, int len, const PREGEN__SET__OF__INTEGER_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__INTEGER(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__INTEGER_template : public Set_Of_Template {

public:
PREGEN__SET__OF__INTEGER_template() {}
PREGEN__SET__OF__INTEGER_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__INTEGER_template(null_type other_value);
PREGEN__SET__OF__INTEGER_template(const PREGEN__SET__OF__INTEGER& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__INTEGER_template(const OPTIONAL<PREGEN__SET__OF__INTEGER>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__INTEGER_template(const PREGEN__SET__OF__INTEGER_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__INTEGER_template& operator=(template_sel other_value);
PREGEN__SET__OF__INTEGER_template& operator=(null_type other_value);
PREGEN__SET__OF__INTEGER_template& operator=(const PREGEN__SET__OF__INTEGER& other_value);
PREGEN__SET__OF__INTEGER_template& operator=(const OPTIONAL<PREGEN__SET__OF__INTEGER>& other_value);
PREGEN__SET__OF__INTEGER_template& operator=(const PREGEN__SET__OF__INTEGER_template& other_value);

INTEGER_template& operator[](int index_value);
INTEGER_template& operator[](const INTEGER& index_value);
const INTEGER_template& operator[](int index_value) const;
const INTEGER_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__INTEGER& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__INTEGER valueof() const;
PREGEN__SET__OF__INTEGER substr(int index, int returncount) const;

PREGEN__SET__OF__INTEGER replace(int index, int len, const PREGEN__SET__OF__INTEGER_template& repl) const;

PREGEN__SET__OF__INTEGER replace(int index, int len, const PREGEN__SET__OF__INTEGER& repl) const;

inline PREGEN__SET__OF__INTEGER_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__INTEGER_template*>(get_list_item(list_index))); }
INTEGER_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__INTEGER& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__INTEGER_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__FLOAT : public Record_Of_Type {

static const FLOAT UNBOUND_ELEM;

public:
PREGEN__SET__OF__FLOAT(): Record_Of_Type() {}
PREGEN__SET__OF__FLOAT(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__FLOAT(const PREGEN__SET__OF__FLOAT& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__FLOAT() { clean_up(); }

inline PREGEN__SET__OF__FLOAT& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__FLOAT& operator=(const PREGEN__SET__OF__FLOAT& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__FLOAT& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__FLOAT& other_value) const { return !is_equal(&other_value); }
FLOAT& operator[](int index_value);
FLOAT& operator[](const INTEGER& index_value);
const FLOAT& operator[](int index_value) const;
const FLOAT& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__FLOAT operator<<=(int rotate_count) const;
PREGEN__SET__OF__FLOAT operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__FLOAT operator>>=(int rotate_count) const;
PREGEN__SET__OF__FLOAT operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__FLOAT operator+(const PREGEN__SET__OF__FLOAT& other_value) const;

PREGEN__SET__OF__FLOAT substr(int index, int returncount) const;

PREGEN__SET__OF__FLOAT replace(int index, int len, const PREGEN__SET__OF__FLOAT& repl) const;

PREGEN__SET__OF__FLOAT replace(int index, int len, const PREGEN__SET__OF__FLOAT_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__FLOAT(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__FLOAT_template : public Set_Of_Template {

public:
PREGEN__SET__OF__FLOAT_template() {}
PREGEN__SET__OF__FLOAT_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__FLOAT_template(null_type other_value);
PREGEN__SET__OF__FLOAT_template(const PREGEN__SET__OF__FLOAT& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__FLOAT_template(const OPTIONAL<PREGEN__SET__OF__FLOAT>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__FLOAT_template(const PREGEN__SET__OF__FLOAT_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__FLOAT_template& operator=(template_sel other_value);
PREGEN__SET__OF__FLOAT_template& operator=(null_type other_value);
PREGEN__SET__OF__FLOAT_template& operator=(const PREGEN__SET__OF__FLOAT& other_value);
PREGEN__SET__OF__FLOAT_template& operator=(const OPTIONAL<PREGEN__SET__OF__FLOAT>& other_value);
PREGEN__SET__OF__FLOAT_template& operator=(const PREGEN__SET__OF__FLOAT_template& other_value);

FLOAT_template& operator[](int index_value);
FLOAT_template& operator[](const INTEGER& index_value);
const FLOAT_template& operator[](int index_value) const;
const FLOAT_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__FLOAT& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__FLOAT valueof() const;
PREGEN__SET__OF__FLOAT substr(int index, int returncount) const;

PREGEN__SET__OF__FLOAT replace(int index, int len, const PREGEN__SET__OF__FLOAT_template& repl) const;

PREGEN__SET__OF__FLOAT replace(int index, int len, const PREGEN__SET__OF__FLOAT& repl) const;

inline PREGEN__SET__OF__FLOAT_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__FLOAT_template*>(get_list_item(list_index))); }
FLOAT_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__FLOAT& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__FLOAT_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__BITSTRING : public Record_Of_Type {

static const BITSTRING UNBOUND_ELEM;

public:
PREGEN__SET__OF__BITSTRING(): Record_Of_Type() {}
PREGEN__SET__OF__BITSTRING(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__BITSTRING(const PREGEN__SET__OF__BITSTRING& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__BITSTRING() { clean_up(); }

inline PREGEN__SET__OF__BITSTRING& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__BITSTRING& operator=(const PREGEN__SET__OF__BITSTRING& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__BITSTRING& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__BITSTRING& other_value) const { return !is_equal(&other_value); }
BITSTRING& operator[](int index_value);
BITSTRING& operator[](const INTEGER& index_value);
const BITSTRING& operator[](int index_value) const;
const BITSTRING& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__BITSTRING operator<<=(int rotate_count) const;
PREGEN__SET__OF__BITSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__BITSTRING operator>>=(int rotate_count) const;
PREGEN__SET__OF__BITSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__BITSTRING operator+(const PREGEN__SET__OF__BITSTRING& other_value) const;

PREGEN__SET__OF__BITSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__BITSTRING replace(int index, int len, const PREGEN__SET__OF__BITSTRING& repl) const;

PREGEN__SET__OF__BITSTRING replace(int index, int len, const PREGEN__SET__OF__BITSTRING_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__BITSTRING(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__BITSTRING_template : public Set_Of_Template {

public:
PREGEN__SET__OF__BITSTRING_template() {}
PREGEN__SET__OF__BITSTRING_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__BITSTRING_template(null_type other_value);
PREGEN__SET__OF__BITSTRING_template(const PREGEN__SET__OF__BITSTRING& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__BITSTRING_template(const OPTIONAL<PREGEN__SET__OF__BITSTRING>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__BITSTRING_template(const PREGEN__SET__OF__BITSTRING_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__BITSTRING_template& operator=(template_sel other_value);
PREGEN__SET__OF__BITSTRING_template& operator=(null_type other_value);
PREGEN__SET__OF__BITSTRING_template& operator=(const PREGEN__SET__OF__BITSTRING& other_value);
PREGEN__SET__OF__BITSTRING_template& operator=(const OPTIONAL<PREGEN__SET__OF__BITSTRING>& other_value);
PREGEN__SET__OF__BITSTRING_template& operator=(const PREGEN__SET__OF__BITSTRING_template& other_value);

BITSTRING_template& operator[](int index_value);
BITSTRING_template& operator[](const INTEGER& index_value);
const BITSTRING_template& operator[](int index_value) const;
const BITSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__BITSTRING& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__BITSTRING valueof() const;
PREGEN__SET__OF__BITSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__BITSTRING replace(int index, int len, const PREGEN__SET__OF__BITSTRING_template& repl) const;

PREGEN__SET__OF__BITSTRING replace(int index, int len, const PREGEN__SET__OF__BITSTRING& repl) const;

inline PREGEN__SET__OF__BITSTRING_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__BITSTRING_template*>(get_list_item(list_index))); }
BITSTRING_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__BITSTRING& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__BITSTRING_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__HEXSTRING : public Record_Of_Type {

static const HEXSTRING UNBOUND_ELEM;

public:
PREGEN__SET__OF__HEXSTRING(): Record_Of_Type() {}
PREGEN__SET__OF__HEXSTRING(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__HEXSTRING(const PREGEN__SET__OF__HEXSTRING& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__HEXSTRING() { clean_up(); }

inline PREGEN__SET__OF__HEXSTRING& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__HEXSTRING& operator=(const PREGEN__SET__OF__HEXSTRING& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__HEXSTRING& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__HEXSTRING& other_value) const { return !is_equal(&other_value); }
HEXSTRING& operator[](int index_value);
HEXSTRING& operator[](const INTEGER& index_value);
const HEXSTRING& operator[](int index_value) const;
const HEXSTRING& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__HEXSTRING operator<<=(int rotate_count) const;
PREGEN__SET__OF__HEXSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__HEXSTRING operator>>=(int rotate_count) const;
PREGEN__SET__OF__HEXSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__HEXSTRING operator+(const PREGEN__SET__OF__HEXSTRING& other_value) const;

PREGEN__SET__OF__HEXSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__HEXSTRING replace(int index, int len, const PREGEN__SET__OF__HEXSTRING& repl) const;

PREGEN__SET__OF__HEXSTRING replace(int index, int len, const PREGEN__SET__OF__HEXSTRING_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__HEXSTRING(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__HEXSTRING_template : public Set_Of_Template {

public:
PREGEN__SET__OF__HEXSTRING_template() {}
PREGEN__SET__OF__HEXSTRING_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__HEXSTRING_template(null_type other_value);
PREGEN__SET__OF__HEXSTRING_template(const PREGEN__SET__OF__HEXSTRING& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__HEXSTRING_template(const OPTIONAL<PREGEN__SET__OF__HEXSTRING>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__HEXSTRING_template(const PREGEN__SET__OF__HEXSTRING_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__HEXSTRING_template& operator=(template_sel other_value);
PREGEN__SET__OF__HEXSTRING_template& operator=(null_type other_value);
PREGEN__SET__OF__HEXSTRING_template& operator=(const PREGEN__SET__OF__HEXSTRING& other_value);
PREGEN__SET__OF__HEXSTRING_template& operator=(const OPTIONAL<PREGEN__SET__OF__HEXSTRING>& other_value);
PREGEN__SET__OF__HEXSTRING_template& operator=(const PREGEN__SET__OF__HEXSTRING_template& other_value);

HEXSTRING_template& operator[](int index_value);
HEXSTRING_template& operator[](const INTEGER& index_value);
const HEXSTRING_template& operator[](int index_value) const;
const HEXSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__HEXSTRING& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__HEXSTRING valueof() const;
PREGEN__SET__OF__HEXSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__HEXSTRING replace(int index, int len, const PREGEN__SET__OF__HEXSTRING_template& repl) const;

PREGEN__SET__OF__HEXSTRING replace(int index, int len, const PREGEN__SET__OF__HEXSTRING& repl) const;

inline PREGEN__SET__OF__HEXSTRING_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__HEXSTRING_template*>(get_list_item(list_index))); }
HEXSTRING_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__HEXSTRING& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__HEXSTRING_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__OCTETSTRING : public Record_Of_Type {

static const OCTETSTRING UNBOUND_ELEM;

public:
PREGEN__SET__OF__OCTETSTRING(): Record_Of_Type() {}
PREGEN__SET__OF__OCTETSTRING(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__OCTETSTRING(const PREGEN__SET__OF__OCTETSTRING& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__OCTETSTRING() { clean_up(); }

inline PREGEN__SET__OF__OCTETSTRING& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__OCTETSTRING& operator=(const PREGEN__SET__OF__OCTETSTRING& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__OCTETSTRING& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__OCTETSTRING& other_value) const { return !is_equal(&other_value); }
OCTETSTRING& operator[](int index_value);
OCTETSTRING& operator[](const INTEGER& index_value);
const OCTETSTRING& operator[](int index_value) const;
const OCTETSTRING& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__OCTETSTRING operator<<=(int rotate_count) const;
PREGEN__SET__OF__OCTETSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__OCTETSTRING operator>>=(int rotate_count) const;
PREGEN__SET__OF__OCTETSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__OCTETSTRING operator+(const PREGEN__SET__OF__OCTETSTRING& other_value) const;

PREGEN__SET__OF__OCTETSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__OCTETSTRING replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING& repl) const;

PREGEN__SET__OF__OCTETSTRING replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__OCTETSTRING(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__OCTETSTRING_template : public Set_Of_Template {

public:
PREGEN__SET__OF__OCTETSTRING_template() {}
PREGEN__SET__OF__OCTETSTRING_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__OCTETSTRING_template(null_type other_value);
PREGEN__SET__OF__OCTETSTRING_template(const PREGEN__SET__OF__OCTETSTRING& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__OCTETSTRING_template(const OPTIONAL<PREGEN__SET__OF__OCTETSTRING>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__OCTETSTRING_template(const PREGEN__SET__OF__OCTETSTRING_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__OCTETSTRING_template& operator=(template_sel other_value);
PREGEN__SET__OF__OCTETSTRING_template& operator=(null_type other_value);
PREGEN__SET__OF__OCTETSTRING_template& operator=(const PREGEN__SET__OF__OCTETSTRING& other_value);
PREGEN__SET__OF__OCTETSTRING_template& operator=(const OPTIONAL<PREGEN__SET__OF__OCTETSTRING>& other_value);
PREGEN__SET__OF__OCTETSTRING_template& operator=(const PREGEN__SET__OF__OCTETSTRING_template& other_value);

OCTETSTRING_template& operator[](int index_value);
OCTETSTRING_template& operator[](const INTEGER& index_value);
const OCTETSTRING_template& operator[](int index_value) const;
const OCTETSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__OCTETSTRING& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__OCTETSTRING valueof() const;
PREGEN__SET__OF__OCTETSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__OCTETSTRING replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING_template& repl) const;

PREGEN__SET__OF__OCTETSTRING replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING& repl) const;

inline PREGEN__SET__OF__OCTETSTRING_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__OCTETSTRING_template*>(get_list_item(list_index))); }
OCTETSTRING_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__OCTETSTRING& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__OCTETSTRING_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__CHARSTRING : public Record_Of_Type {

static const CHARSTRING UNBOUND_ELEM;

public:
PREGEN__SET__OF__CHARSTRING(): Record_Of_Type() {}
PREGEN__SET__OF__CHARSTRING(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__CHARSTRING(const PREGEN__SET__OF__CHARSTRING& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__CHARSTRING() { clean_up(); }

inline PREGEN__SET__OF__CHARSTRING& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__CHARSTRING& operator=(const PREGEN__SET__OF__CHARSTRING& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__CHARSTRING& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__CHARSTRING& other_value) const { return !is_equal(&other_value); }
CHARSTRING& operator[](int index_value);
CHARSTRING& operator[](const INTEGER& index_value);
const CHARSTRING& operator[](int index_value) const;
const CHARSTRING& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__CHARSTRING operator<<=(int rotate_count) const;
PREGEN__SET__OF__CHARSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__CHARSTRING operator>>=(int rotate_count) const;
PREGEN__SET__OF__CHARSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__CHARSTRING operator+(const PREGEN__SET__OF__CHARSTRING& other_value) const;

PREGEN__SET__OF__CHARSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__CHARSTRING& repl) const;

PREGEN__SET__OF__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__CHARSTRING_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__CHARSTRING(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__CHARSTRING_template : public Set_Of_Template {

public:
PREGEN__SET__OF__CHARSTRING_template() {}
PREGEN__SET__OF__CHARSTRING_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__CHARSTRING_template(null_type other_value);
PREGEN__SET__OF__CHARSTRING_template(const PREGEN__SET__OF__CHARSTRING& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__CHARSTRING_template(const OPTIONAL<PREGEN__SET__OF__CHARSTRING>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__CHARSTRING_template(const PREGEN__SET__OF__CHARSTRING_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__CHARSTRING_template& operator=(template_sel other_value);
PREGEN__SET__OF__CHARSTRING_template& operator=(null_type other_value);
PREGEN__SET__OF__CHARSTRING_template& operator=(const PREGEN__SET__OF__CHARSTRING& other_value);
PREGEN__SET__OF__CHARSTRING_template& operator=(const OPTIONAL<PREGEN__SET__OF__CHARSTRING>& other_value);
PREGEN__SET__OF__CHARSTRING_template& operator=(const PREGEN__SET__OF__CHARSTRING_template& other_value);

CHARSTRING_template& operator[](int index_value);
CHARSTRING_template& operator[](const INTEGER& index_value);
const CHARSTRING_template& operator[](int index_value) const;
const CHARSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__CHARSTRING& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__CHARSTRING valueof() const;
PREGEN__SET__OF__CHARSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__CHARSTRING_template& repl) const;

PREGEN__SET__OF__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__CHARSTRING& repl) const;

inline PREGEN__SET__OF__CHARSTRING_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__CHARSTRING_template*>(get_list_item(list_index))); }
CHARSTRING_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__CHARSTRING& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__CHARSTRING_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__UNIVERSAL__CHARSTRING : public Record_Of_Type {

static const UNIVERSAL_CHARSTRING UNBOUND_ELEM;

public:
PREGEN__SET__OF__UNIVERSAL__CHARSTRING(): Record_Of_Type() {}
PREGEN__SET__OF__UNIVERSAL__CHARSTRING(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__UNIVERSAL__CHARSTRING(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__UNIVERSAL__CHARSTRING() { clean_up(); }

inline PREGEN__SET__OF__UNIVERSAL__CHARSTRING& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__UNIVERSAL__CHARSTRING& operator=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value) const { return !is_equal(&other_value); }
UNIVERSAL_CHARSTRING& operator[](int index_value);
UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator<<=(int rotate_count) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator>>=(int rotate_count) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator+(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& repl) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__UNIVERSAL__CHARSTRING(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template : public Set_Of_Template {

public:
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template() {}
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template(null_type other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template(const OPTIONAL<PREGEN__SET__OF__UNIVERSAL__CHARSTRING>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& operator=(template_sel other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& operator=(null_type other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& operator=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& operator=(const OPTIONAL<PREGEN__SET__OF__UNIVERSAL__CHARSTRING>& other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& operator=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& other_value);

UNIVERSAL_CHARSTRING_template& operator[](int index_value);
UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING_template& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__UNIVERSAL__CHARSTRING valueof() const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING substr(int index, int returncount) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& repl) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& repl) const;

inline PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template*>(get_list_item(list_index))); }
UNIVERSAL_CHARSTRING_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__BOOLEAN__OPTIMIZED : public Record_Of_Type {

static const BOOLEAN UNBOUND_ELEM;

public:
PREGEN__SET__OF__BOOLEAN__OPTIMIZED(): Record_Of_Type() {}
PREGEN__SET__OF__BOOLEAN__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__BOOLEAN__OPTIMIZED(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__BOOLEAN__OPTIMIZED() { clean_up(); }

inline PREGEN__SET__OF__BOOLEAN__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__BOOLEAN__OPTIMIZED& operator=(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
BOOLEAN& operator[](int index_value);
BOOLEAN& operator[](const INTEGER& index_value);
const BOOLEAN& operator[](int index_value) const;
const BOOLEAN& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator+(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& repl) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__BOOLEAN__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return TRUE; }

};

class PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template : public Set_Of_Template {

public:
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template() {}
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__BOOLEAN__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& operator=(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__BOOLEAN__OPTIMIZED>& other_value);
PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& operator=(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& other_value);

BOOLEAN_template& operator[](int index_value);
BOOLEAN_template& operator[](const INTEGER& index_value);
const BOOLEAN_template& operator[](int index_value) const;
const BOOLEAN_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__BOOLEAN__OPTIMIZED valueof() const;
PREGEN__SET__OF__BOOLEAN__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& repl) const;

inline PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template*>(get_list_item(list_index))); }
BOOLEAN_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__BOOLEAN__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__INTEGER__OPTIMIZED : public Record_Of_Type {

static const INTEGER UNBOUND_ELEM;

public:
PREGEN__SET__OF__INTEGER__OPTIMIZED(): Record_Of_Type() {}
PREGEN__SET__OF__INTEGER__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__INTEGER__OPTIMIZED(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__INTEGER__OPTIMIZED() { clean_up(); }

inline PREGEN__SET__OF__INTEGER__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__INTEGER__OPTIMIZED& operator=(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
INTEGER& operator[](int index_value);
INTEGER& operator[](const INTEGER& index_value);
const INTEGER& operator[](int index_value) const;
const INTEGER& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__INTEGER__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__INTEGER__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__INTEGER__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__INTEGER__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED operator+(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__INTEGER__OPTIMIZED& repl) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__INTEGER__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__INTEGER__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__INTEGER__OPTIMIZED_template : public Set_Of_Template {

public:
PREGEN__SET__OF__INTEGER__OPTIMIZED_template() {}
PREGEN__SET__OF__INTEGER__OPTIMIZED_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__INTEGER__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__INTEGER__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__INTEGER__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__INTEGER__OPTIMIZED_template(const PREGEN__SET__OF__INTEGER__OPTIMIZED_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__INTEGER__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template& operator=(const PREGEN__SET__OF__INTEGER__OPTIMIZED& other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__INTEGER__OPTIMIZED>& other_value);
PREGEN__SET__OF__INTEGER__OPTIMIZED_template& operator=(const PREGEN__SET__OF__INTEGER__OPTIMIZED_template& other_value);

INTEGER_template& operator[](int index_value);
INTEGER_template& operator[](const INTEGER& index_value);
const INTEGER_template& operator[](int index_value) const;
const INTEGER_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__INTEGER__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__INTEGER__OPTIMIZED valueof() const;
PREGEN__SET__OF__INTEGER__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__INTEGER__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__INTEGER__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__INTEGER__OPTIMIZED& repl) const;

inline PREGEN__SET__OF__INTEGER__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__INTEGER__OPTIMIZED_template*>(get_list_item(list_index))); }
INTEGER_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__INTEGER__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__INTEGER__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__FLOAT__OPTIMIZED : public Record_Of_Type {

static const FLOAT UNBOUND_ELEM;

public:
PREGEN__SET__OF__FLOAT__OPTIMIZED(): Record_Of_Type() {}
PREGEN__SET__OF__FLOAT__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__FLOAT__OPTIMIZED(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__FLOAT__OPTIMIZED() { clean_up(); }

inline PREGEN__SET__OF__FLOAT__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__FLOAT__OPTIMIZED& operator=(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
FLOAT& operator[](int index_value);
FLOAT& operator[](const INTEGER& index_value);
const FLOAT& operator[](int index_value) const;
const FLOAT& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__FLOAT__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__FLOAT__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__FLOAT__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__FLOAT__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED operator+(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__FLOAT__OPTIMIZED& repl) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__FLOAT__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__FLOAT__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__FLOAT__OPTIMIZED_template : public Set_Of_Template {

public:
PREGEN__SET__OF__FLOAT__OPTIMIZED_template() {}
PREGEN__SET__OF__FLOAT__OPTIMIZED_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__FLOAT__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__FLOAT__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__FLOAT__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__FLOAT__OPTIMIZED_template(const PREGEN__SET__OF__FLOAT__OPTIMIZED_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__FLOAT__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template& operator=(const PREGEN__SET__OF__FLOAT__OPTIMIZED& other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__FLOAT__OPTIMIZED>& other_value);
PREGEN__SET__OF__FLOAT__OPTIMIZED_template& operator=(const PREGEN__SET__OF__FLOAT__OPTIMIZED_template& other_value);

FLOAT_template& operator[](int index_value);
FLOAT_template& operator[](const INTEGER& index_value);
const FLOAT_template& operator[](int index_value) const;
const FLOAT_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__FLOAT__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__FLOAT__OPTIMIZED valueof() const;
PREGEN__SET__OF__FLOAT__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__FLOAT__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__FLOAT__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__FLOAT__OPTIMIZED& repl) const;

inline PREGEN__SET__OF__FLOAT__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__FLOAT__OPTIMIZED_template*>(get_list_item(list_index))); }
FLOAT_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__FLOAT__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__FLOAT__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__BITSTRING__OPTIMIZED : public Record_Of_Type {

static const BITSTRING UNBOUND_ELEM;

public:
PREGEN__SET__OF__BITSTRING__OPTIMIZED(): Record_Of_Type() {}
PREGEN__SET__OF__BITSTRING__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__BITSTRING__OPTIMIZED(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__BITSTRING__OPTIMIZED() { clean_up(); }

inline PREGEN__SET__OF__BITSTRING__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__BITSTRING__OPTIMIZED& operator=(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
BITSTRING& operator[](int index_value);
BITSTRING& operator[](const INTEGER& index_value);
const BITSTRING& operator[](int index_value) const;
const BITSTRING& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__BITSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__BITSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__BITSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__BITSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED operator+(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BITSTRING__OPTIMIZED& repl) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__BITSTRING__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__BITSTRING__OPTIMIZED_template : public Set_Of_Template {

public:
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template() {}
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__BITSTRING__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template(const PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__BITSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& other_value);

BITSTRING_template& operator[](int index_value);
BITSTRING_template& operator[](const INTEGER& index_value);
const BITSTRING_template& operator[](int index_value) const;
const BITSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__BITSTRING__OPTIMIZED valueof() const;
PREGEN__SET__OF__BITSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__BITSTRING__OPTIMIZED& repl) const;

inline PREGEN__SET__OF__BITSTRING__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__BITSTRING__OPTIMIZED_template*>(get_list_item(list_index))); }
BITSTRING_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__BITSTRING__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__BITSTRING__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__HEXSTRING__OPTIMIZED : public Record_Of_Type {

static const HEXSTRING UNBOUND_ELEM;

public:
PREGEN__SET__OF__HEXSTRING__OPTIMIZED(): Record_Of_Type() {}
PREGEN__SET__OF__HEXSTRING__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__HEXSTRING__OPTIMIZED(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__HEXSTRING__OPTIMIZED() { clean_up(); }

inline PREGEN__SET__OF__HEXSTRING__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__HEXSTRING__OPTIMIZED& operator=(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
HEXSTRING& operator[](int index_value);
HEXSTRING& operator[](const INTEGER& index_value);
const HEXSTRING& operator[](int index_value) const;
const HEXSTRING& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator+(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& repl) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__HEXSTRING__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template : public Set_Of_Template {

public:
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template() {}
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__HEXSTRING__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__HEXSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& other_value);

HEXSTRING_template& operator[](int index_value);
HEXSTRING_template& operator[](const INTEGER& index_value);
const HEXSTRING_template& operator[](int index_value) const;
const HEXSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__HEXSTRING__OPTIMIZED valueof() const;
PREGEN__SET__OF__HEXSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& repl) const;

inline PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template*>(get_list_item(list_index))); }
HEXSTRING_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__HEXSTRING__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__OCTETSTRING__OPTIMIZED : public Record_Of_Type {

static const OCTETSTRING UNBOUND_ELEM;

public:
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(): Record_Of_Type() {}
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__OCTETSTRING__OPTIMIZED() { clean_up(); }

inline PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& operator=(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
OCTETSTRING& operator[](int index_value);
OCTETSTRING& operator[](const INTEGER& index_value);
const OCTETSTRING& operator[](int index_value) const;
const OCTETSTRING& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator+(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& repl) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template : public Set_Of_Template {

public:
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template() {}
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__OCTETSTRING__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__OCTETSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& other_value);

OCTETSTRING_template& operator[](int index_value);
OCTETSTRING_template& operator[](const INTEGER& index_value);
const OCTETSTRING_template& operator[](int index_value) const;
const OCTETSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED valueof() const;
PREGEN__SET__OF__OCTETSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& repl) const;

inline PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template*>(get_list_item(list_index))); }
OCTETSTRING_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__OCTETSTRING__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__CHARSTRING__OPTIMIZED : public Record_Of_Type {

static const CHARSTRING UNBOUND_ELEM;

public:
PREGEN__SET__OF__CHARSTRING__OPTIMIZED(): Record_Of_Type() {}
PREGEN__SET__OF__CHARSTRING__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__CHARSTRING__OPTIMIZED(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__CHARSTRING__OPTIMIZED() { clean_up(); }

inline PREGEN__SET__OF__CHARSTRING__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__CHARSTRING__OPTIMIZED& operator=(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
CHARSTRING& operator[](int index_value);
CHARSTRING& operator[](const INTEGER& index_value);
const CHARSTRING& operator[](int index_value) const;
const CHARSTRING& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator+(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& repl) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__CHARSTRING__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template : public Set_Of_Template {

public:
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template() {}
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__CHARSTRING__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__CHARSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& other_value);

CHARSTRING_template& operator[](int index_value);
CHARSTRING_template& operator[](const INTEGER& index_value);
const CHARSTRING_template& operator[](int index_value) const;
const CHARSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__CHARSTRING__OPTIMIZED valueof() const;
PREGEN__SET__OF__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& repl) const;

inline PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template*>(get_list_item(list_index))); }
CHARSTRING_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__CHARSTRING__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED : public Record_Of_Type {

static const UNIVERSAL_CHARSTRING UNBOUND_ELEM;

public:
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(): Record_Of_Type() {}
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(null_type other_value): Record_Of_Type(other_value) {}
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value): Record_Of_Type(other_value) {}
~PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED() { clean_up(); }

inline PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& operator=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const { return !is_equal(&other_value); }
UNIVERSAL_CHARSTRING& operator[](int index_value);
UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator<<=(int rotate_count) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator<<=(const INTEGER& rotate_count) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator>>=(int rotate_count) const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator>>=(const INTEGER& rotate_count) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator+(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& repl) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& repl) const;

Base_Type* clone() const { return new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return TRUE; }
int rawdec_ebv() const { return 0; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template : public Set_Of_Template {

public:
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template() {}
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(template_sel other_value): Set_Of_Template(other_value) { check_single_selection(other_value); }
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(null_type other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value) { copy_value(&other_value); }
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(const OPTIONAL<PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED>& other_value) { copy_optional(&other_value); }
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& other_value): Set_Of_Template() { copy_template(other_value); }
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(template_sel other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(null_type other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(const OPTIONAL<PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED>& other_value);
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& operator=(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& other_value);

UNIVERSAL_CHARSTRING_template& operator[](int index_value);
UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING_template& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& match_value) const { return matchv(&match_value); }
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED valueof() const;
PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED substr(int index, int returncount) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& repl) const;

PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(int index, int len, const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& repl) const;

inline PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template& list_item(int list_index) { return *(static_cast<PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template*>(get_list_item(list_index))); }
UNIVERSAL_CHARSTRING_template& set_item(int set_index);
inline void log_match(const PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED& match_value) const { log_matchv(&match_value); }
Set_Of_Template* create() const { return new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};


/* Global variable declarations */

extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BOOLEAN_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__BOOLEAN_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BOOLEAN_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__INTEGER_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__INTEGER_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__INTEGER_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__FLOAT_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__FLOAT_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__FLOAT_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BITSTRING_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__BITSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BITSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__HEXSTRING_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__HEXSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__HEXSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__OCTETSTRING_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__OCTETSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__OCTETSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__CHARSTRING_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__CHARSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__CHARSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__INTEGER__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__INTEGER__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__INTEGER__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__FLOAT__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__FLOAT__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__FLOAT__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BOOLEAN_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__BOOLEAN_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BOOLEAN_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__INTEGER_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__INTEGER_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__INTEGER_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__FLOAT_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__FLOAT_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__FLOAT_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BITSTRING_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__BITSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BITSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__HEXSTRING_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__HEXSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__HEXSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__OCTETSTRING_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__OCTETSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__OCTETSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__CHARSTRING_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__CHARSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__CHARSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__UNIVERSAL__CHARSTRING_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__UNIVERSAL__CHARSTRING_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__UNIVERSAL__CHARSTRING_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BOOLEAN__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__BOOLEAN__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BOOLEAN__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__INTEGER__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__INTEGER__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__INTEGER__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__FLOAT__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__FLOAT__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__FLOAT__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BITSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__BITSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__BITSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__HEXSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__HEXSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__HEXSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__CHARSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__CHARSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__CHARSTRING__OPTIMIZED_0_descr_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_descr_;
extern const XERdescriptor_t PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_0_xer_;
extern const TTCN_Typedescriptor_t PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_0_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
