// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for titanrt (titanrt@Ubuntu-14-04-64bit) on Fri May 22 16:37:27 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

#ifndef TitanLoggerApi_HH
#define TitanLoggerApi_HH

#ifndef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated with -R option but -DTITAN_RUNTIME_2 was not used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 50300
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef TitanLoggerApi_HH
#endif

namespace TitanLoggerApi {

/* Forward declarations of classes */

class TitanLog_sequence__list;
class TitanLog_sequence__list_template;
class ComponentIDType;
class ComponentIDType_template;
class TitanLog_sequence__list_0_event__list;
class TitanLog_sequence__list_0_event__list_template;
class TimestampType;
class TimestampType_template;
class TitanLogEvent_sourceInfo__list;
class TitanLogEvent_sourceInfo__list_template;
class LocationInfo_ent__type;
class LocationInfo_ent__type_template;
class LocationInfo;
class LocationInfo_template;
class LogEventType_choice;
class LogEventType_choice_template;
class Strings;
class Strings_template;
class DefaultEvent_choice;
class DefaultEvent_choice_template;
class DefaultEnd;
class DefaultEnd_template;
class DefaultOp;
class DefaultOp_template;
class DefaultEvent;
class DefaultEvent_template;
class Categorized;
class Categorized_template;
class ExecutorEvent_choice;
class ExecutorEvent_choice_template;
class ExecutorRuntime_reason;
class ExecutorRuntime_reason_template;
class ExecutorRuntime;
class ExecutorRuntime_template;
class ExecutorConfigdata_reason;
class ExecutorConfigdata_reason_template;
class ExecutorConfigdata;
class ExecutorConfigdata_template;
class ExecutorComponent_reason;
class ExecutorComponent_reason_template;
class ExecutorComponent;
class ExecutorComponent_template;
class ExecutorUnqualified_reason;
class ExecutorUnqualified_reason_template;
class ExecutorUnqualified;
class ExecutorUnqualified_template;
class ExecutorEvent;
class ExecutorEvent_template;
class FunctionEvent_choice;
class FunctionEvent_choice_template;
class RandomAction;
class RandomAction_template;
class FunctionEvent_choice_random;
class FunctionEvent_choice_random_template;
class FunctionEvent;
class FunctionEvent_template;
class ParallelEvent_choice;
class ParallelEvent_choice_template;
class ParallelPTC_reason;
class ParallelPTC_reason_template;
class ParallelPTC;
class ParallelPTC_template;
class PTC__exit;
class PTC__exit_template;
class ParPort_operation;
class ParPort_operation_template;
class ParPort;
class ParPort_template;
class ParallelEvent;
class ParallelEvent_template;
class TestcaseEvent_choice;
class TestcaseEvent_choice_template;
class QualifiedName;
class QualifiedName_template;
class Verdict;
class Verdict_template;
class TestcaseType;
class TestcaseType_template;
class TestcaseEvent;
class TestcaseEvent_template;
class PortEvent_choice;
class PortEvent_choice_template;
class Port__Queue_operation;
class Port__Queue_operation_template;
class Port__Queue;
class Port__Queue_template;
class Port__State_operation;
class Port__State_operation_template;
class Port__State;
class Port__State_template;
class Port__oper;
class Port__oper_template;
class Proc__port__out;
class Proc__port__out_template;
class Proc__port__in;
class Proc__port__in_template;
class Msg__port__send;
class Msg__port__send_template;
class Msg__port__recv_operation;
class Msg__port__recv_operation_template;
class Msg__port__recv;
class Msg__port__recv_template;
class Dualface__mapped;
class Dualface__mapped_template;
class Dualface__discard;
class Dualface__discard_template;
class Port__Misc_reason;
class Port__Misc_reason_template;
class Port__Misc;
class Port__Misc_template;
class PortEvent;
class PortEvent_template;
class StatisticsType_choice;
class StatisticsType_choice_template;
class StatisticsType_choice_verdictStatistics;
class StatisticsType_choice_verdictStatistics_template;
class StatisticsType;
class StatisticsType_template;
class TimerEvent_choice;
class TimerEvent_choice_template;
class TimerType;
class TimerType_template;
class TimerGuardType;
class TimerGuardType_template;
class TimerAnyTimeoutType;
class TimerAnyTimeoutType_template;
class TimerEvent;
class TimerEvent_template;
class VerdictOp_choice;
class VerdictOp_choice_template;
class SetVerdictType;
class SetVerdictType_template;
class FinalVerdictType_choice;
class FinalVerdictType_choice_template;
class FinalVerdictInfo;
class FinalVerdictInfo_template;
class FinalVerdictType_choice_notification;
class FinalVerdictType_choice_notification_template;
class FinalVerdictType;
class FinalVerdictType_template;
class VerdictOp;
class VerdictOp_template;
class MatchingEvent_choice;
class MatchingEvent_choice_template;
class MatchingDoneType_reason;
class MatchingDoneType_reason_template;
class MatchingDoneType;
class MatchingDoneType_template;
class PortType;
class PortType_template;
class MatchingSuccessType;
class MatchingSuccessType_template;
class MatchingFailureType_choice;
class MatchingFailureType_choice_template;
class MatchingFailureType_reason;
class MatchingFailureType_reason_template;
class MatchingFailureType;
class MatchingFailureType_template;
class MatchingProblemType_reason;
class MatchingProblemType_reason_template;
class MatchingProblemType_operation;
class MatchingProblemType_operation_template;
class MatchingProblemType;
class MatchingProblemType_template;
class MatchingTimeout;
class MatchingTimeout_template;
class MatchingEvent;
class MatchingEvent_template;
class ExecutionSummaryType;
class ExecutionSummaryType_template;
class LogEventType;
class LogEventType_template;
class TitanLogEvent;
class TitanLogEvent_template;
class TitanLog_sequence__list_0;
class TitanLog_sequence__list_0_template;
class TitanLog;
class TitanLog_template;
class TitanSingleLogEvent;
class TitanSingleLogEvent_template;
class ErrorEvent;
class ErrorEvent_template;
class WarningEvent;
class WarningEvent_template;
class VerdictType;
class VerdictType_template;
class Parallel_reason;
class Parallel_reason_template;
class Parallel;
class Parallel_template;
class StartFunction;
class StartFunction_template;

} /* end of namespace */

#ifndef TitanLoggerApi_HH
#define TitanLoggerApi_HH

namespace TitanLoggerApi {

/* Type definitions */

typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING Strings_str__list;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING_template Strings_str__list_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING StartFunction_parameter__list;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING_template StartFunction_parameter__list_template;

/* Class definitions */

class TitanLog_sequence__list : public Record_Of_Type {

static const TitanLog_sequence__list_0 UNBOUND_ELEM;

public:
TitanLog_sequence__list(): Record_Of_Type() {}
TitanLog_sequence__list(null_type other_value): Record_Of_Type(other_value) {}
TitanLog_sequence__list(const TitanLog_sequence__list& other_value): Record_Of_Type(other_value) {}
~TitanLog_sequence__list() { clean_up(); }

inline TitanLog_sequence__list& operator=(null_type other_value) { set_val(other_value); return *this; }
inline TitanLog_sequence__list& operator=(const TitanLog_sequence__list& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TitanLog_sequence__list& other_value) const { return is_equal(&other_value); }
boolean operator!=(const TitanLog_sequence__list& other_value) const { return !is_equal(&other_value); }
TitanLog_sequence__list_0& operator[](int index_value);
TitanLog_sequence__list_0& operator[](const INTEGER& index_value);
const TitanLog_sequence__list_0& operator[](int index_value) const;
const TitanLog_sequence__list_0& operator[](const INTEGER& index_value) const;
TitanLog_sequence__list operator<<=(int rotate_count) const;
TitanLog_sequence__list operator<<=(const INTEGER& rotate_count) const;
TitanLog_sequence__list operator>>=(int rotate_count) const;
TitanLog_sequence__list operator>>=(const INTEGER& rotate_count) const;

TitanLog_sequence__list operator+(const TitanLog_sequence__list& other_value) const;

TitanLog_sequence__list substr(int index, int returncount) const;

TitanLog_sequence__list replace(int index, int len, const TitanLog_sequence__list& repl) const;

TitanLog_sequence__list replace(int index, int len, const TitanLog_sequence__list_template& repl) const;

Base_Type* clone() const { return new TitanLog_sequence__list(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class TitanLog_sequence__list_template : public Record_Of_Template {

public:
TitanLog_sequence__list_template() {}
TitanLog_sequence__list_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
TitanLog_sequence__list_template(null_type other_value);
TitanLog_sequence__list_template(const TitanLog_sequence__list& other_value) { copy_value(&other_value); }
TitanLog_sequence__list_template(const OPTIONAL<TitanLog_sequence__list>& other_value) { copy_optional(&other_value); }
TitanLog_sequence__list_template(const TitanLog_sequence__list_template& other_value): Record_Of_Template() { copy_template(other_value); }
TitanLog_sequence__list_template& operator=(template_sel other_value);
TitanLog_sequence__list_template& operator=(null_type other_value);
TitanLog_sequence__list_template& operator=(const TitanLog_sequence__list& other_value);
TitanLog_sequence__list_template& operator=(const OPTIONAL<TitanLog_sequence__list>& other_value);
TitanLog_sequence__list_template& operator=(const TitanLog_sequence__list_template& other_value);

TitanLog_sequence__list_0_template& operator[](int index_value);
TitanLog_sequence__list_0_template& operator[](const INTEGER& index_value);
const TitanLog_sequence__list_0_template& operator[](int index_value) const;
const TitanLog_sequence__list_0_template& operator[](const INTEGER& index_value) const;
inline boolean match(const TitanLog_sequence__list& match_value) const { return matchv(&match_value); }
TitanLog_sequence__list valueof() const;
TitanLog_sequence__list substr(int index, int returncount) const;

TitanLog_sequence__list replace(int index, int len, const TitanLog_sequence__list_template& repl) const;

TitanLog_sequence__list replace(int index, int len, const TitanLog_sequence__list& repl) const;

inline TitanLog_sequence__list_template& list_item(int list_index) { return *(static_cast<TitanLog_sequence__list_template*>(get_list_item(list_index))); }
inline void log_match(const TitanLog_sequence__list& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new TitanLog_sequence__list_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class ComponentIDType : public Record_Type {
  INTEGER field_id;
  CHARSTRING field_name;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  ComponentIDType();
  ComponentIDType(const ComponentIDType& other_value);
  ComponentIDType(const INTEGER& par_id,
    const CHARSTRING& par_name);
inline ComponentIDType& operator=(const ComponentIDType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ComponentIDType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const ComponentIDType& other_value) const
    { return !is_equal(&other_value); }

  inline INTEGER& id()
    {return field_id;}
  inline const INTEGER& id() const
    {return field_id;}
  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
Base_Type* clone() const { return new ComponentIDType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class ComponentIDType_template : public Record_Template {
void set_specific();
public:
ComponentIDType_template(): Record_Template() {}
ComponentIDType_template(template_sel other_value): Record_Template(other_value) {}
ComponentIDType_template(const ComponentIDType& other_value): Record_Template() { copy_value(&other_value); }
ComponentIDType_template(const OPTIONAL<ComponentIDType>& other_value): Record_Template() { copy_optional(&other_value); }
ComponentIDType_template(const ComponentIDType_template& other_value): Record_Template() { copy_template(other_value); }
ComponentIDType_template& operator=(template_sel other_value);
ComponentIDType_template& operator=(const ComponentIDType& other_value);
ComponentIDType_template& operator=(const OPTIONAL<ComponentIDType>& other_value);
ComponentIDType_template& operator=(const ComponentIDType_template& other_value);
inline boolean match(const ComponentIDType& other_value) const { return matchv(&other_value); }
inline void log_match(const ComponentIDType& match_value) const { log_matchv(&match_value); }
ComponentIDType valueof() const;
inline ComponentIDType_template& list_item(unsigned int list_index) const { return *(static_cast<ComponentIDType_template*>(get_list_item(list_index))); }
INTEGER_template& id();
const INTEGER_template& id() const;
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
Record_Template* create() const { return new ComponentIDType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class TitanLog_sequence__list_0_event__list : public Record_Of_Type {

static const TitanLogEvent UNBOUND_ELEM;

public:
TitanLog_sequence__list_0_event__list(): Record_Of_Type() {}
TitanLog_sequence__list_0_event__list(null_type other_value): Record_Of_Type(other_value) {}
TitanLog_sequence__list_0_event__list(const TitanLog_sequence__list_0_event__list& other_value): Record_Of_Type(other_value) {}
~TitanLog_sequence__list_0_event__list() { clean_up(); }

inline TitanLog_sequence__list_0_event__list& operator=(null_type other_value) { set_val(other_value); return *this; }
inline TitanLog_sequence__list_0_event__list& operator=(const TitanLog_sequence__list_0_event__list& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TitanLog_sequence__list_0_event__list& other_value) const { return is_equal(&other_value); }
boolean operator!=(const TitanLog_sequence__list_0_event__list& other_value) const { return !is_equal(&other_value); }
TitanLogEvent& operator[](int index_value);
TitanLogEvent& operator[](const INTEGER& index_value);
const TitanLogEvent& operator[](int index_value) const;
const TitanLogEvent& operator[](const INTEGER& index_value) const;
TitanLog_sequence__list_0_event__list operator<<=(int rotate_count) const;
TitanLog_sequence__list_0_event__list operator<<=(const INTEGER& rotate_count) const;
TitanLog_sequence__list_0_event__list operator>>=(int rotate_count) const;
TitanLog_sequence__list_0_event__list operator>>=(const INTEGER& rotate_count) const;

TitanLog_sequence__list_0_event__list operator+(const TitanLog_sequence__list_0_event__list& other_value) const;

TitanLog_sequence__list_0_event__list substr(int index, int returncount) const;

TitanLog_sequence__list_0_event__list replace(int index, int len, const TitanLog_sequence__list_0_event__list& repl) const;

TitanLog_sequence__list_0_event__list replace(int index, int len, const TitanLog_sequence__list_0_event__list_template& repl) const;

Base_Type* clone() const { return new TitanLog_sequence__list_0_event__list(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class TitanLog_sequence__list_0_event__list_template : public Record_Of_Template {

public:
TitanLog_sequence__list_0_event__list_template() {}
TitanLog_sequence__list_0_event__list_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
TitanLog_sequence__list_0_event__list_template(null_type other_value);
TitanLog_sequence__list_0_event__list_template(const TitanLog_sequence__list_0_event__list& other_value) { copy_value(&other_value); }
TitanLog_sequence__list_0_event__list_template(const OPTIONAL<TitanLog_sequence__list_0_event__list>& other_value) { copy_optional(&other_value); }
TitanLog_sequence__list_0_event__list_template(const TitanLog_sequence__list_0_event__list_template& other_value): Record_Of_Template() { copy_template(other_value); }
TitanLog_sequence__list_0_event__list_template& operator=(template_sel other_value);
TitanLog_sequence__list_0_event__list_template& operator=(null_type other_value);
TitanLog_sequence__list_0_event__list_template& operator=(const TitanLog_sequence__list_0_event__list& other_value);
TitanLog_sequence__list_0_event__list_template& operator=(const OPTIONAL<TitanLog_sequence__list_0_event__list>& other_value);
TitanLog_sequence__list_0_event__list_template& operator=(const TitanLog_sequence__list_0_event__list_template& other_value);

TitanLogEvent_template& operator[](int index_value);
TitanLogEvent_template& operator[](const INTEGER& index_value);
const TitanLogEvent_template& operator[](int index_value) const;
const TitanLogEvent_template& operator[](const INTEGER& index_value) const;
inline boolean match(const TitanLog_sequence__list_0_event__list& match_value) const { return matchv(&match_value); }
TitanLog_sequence__list_0_event__list valueof() const;
TitanLog_sequence__list_0_event__list substr(int index, int returncount) const;

TitanLog_sequence__list_0_event__list replace(int index, int len, const TitanLog_sequence__list_0_event__list_template& repl) const;

TitanLog_sequence__list_0_event__list replace(int index, int len, const TitanLog_sequence__list_0_event__list& repl) const;

inline TitanLog_sequence__list_0_event__list_template& list_item(int list_index) { return *(static_cast<TitanLog_sequence__list_0_event__list_template*>(get_list_item(list_index))); }
inline void log_match(const TitanLog_sequence__list_0_event__list& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new TitanLog_sequence__list_0_event__list_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class TimestampType : public Record_Type {
  INTEGER field_seconds;
  INTEGER field_microSeconds;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  TimestampType();
  TimestampType(const TimestampType& other_value);
  TimestampType(const INTEGER& par_seconds,
    const INTEGER& par_microSeconds);
inline TimestampType& operator=(const TimestampType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TimestampType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const TimestampType& other_value) const
    { return !is_equal(&other_value); }

  inline INTEGER& seconds()
    {return field_seconds;}
  inline const INTEGER& seconds() const
    {return field_seconds;}
  inline INTEGER& microSeconds()
    {return field_microSeconds;}
  inline const INTEGER& microSeconds() const
    {return field_microSeconds;}
Base_Type* clone() const { return new TimestampType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class TimestampType_template : public Record_Template {
void set_specific();
public:
TimestampType_template(): Record_Template() {}
TimestampType_template(template_sel other_value): Record_Template(other_value) {}
TimestampType_template(const TimestampType& other_value): Record_Template() { copy_value(&other_value); }
TimestampType_template(const OPTIONAL<TimestampType>& other_value): Record_Template() { copy_optional(&other_value); }
TimestampType_template(const TimestampType_template& other_value): Record_Template() { copy_template(other_value); }
TimestampType_template& operator=(template_sel other_value);
TimestampType_template& operator=(const TimestampType& other_value);
TimestampType_template& operator=(const OPTIONAL<TimestampType>& other_value);
TimestampType_template& operator=(const TimestampType_template& other_value);
inline boolean match(const TimestampType& other_value) const { return matchv(&other_value); }
inline void log_match(const TimestampType& match_value) const { log_matchv(&match_value); }
TimestampType valueof() const;
inline TimestampType_template& list_item(unsigned int list_index) const { return *(static_cast<TimestampType_template*>(get_list_item(list_index))); }
INTEGER_template& seconds();
const INTEGER_template& seconds() const;
INTEGER_template& microSeconds();
const INTEGER_template& microSeconds() const;
Record_Template* create() const { return new TimestampType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class TitanLogEvent_sourceInfo__list : public Record_Of_Type {

static const LocationInfo UNBOUND_ELEM;

public:
TitanLogEvent_sourceInfo__list(): Record_Of_Type() {}
TitanLogEvent_sourceInfo__list(null_type other_value): Record_Of_Type(other_value) {}
TitanLogEvent_sourceInfo__list(const TitanLogEvent_sourceInfo__list& other_value): Record_Of_Type(other_value) {}
~TitanLogEvent_sourceInfo__list() { clean_up(); }

inline TitanLogEvent_sourceInfo__list& operator=(null_type other_value) { set_val(other_value); return *this; }
inline TitanLogEvent_sourceInfo__list& operator=(const TitanLogEvent_sourceInfo__list& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TitanLogEvent_sourceInfo__list& other_value) const { return is_equal(&other_value); }
boolean operator!=(const TitanLogEvent_sourceInfo__list& other_value) const { return !is_equal(&other_value); }
LocationInfo& operator[](int index_value);
LocationInfo& operator[](const INTEGER& index_value);
const LocationInfo& operator[](int index_value) const;
const LocationInfo& operator[](const INTEGER& index_value) const;
TitanLogEvent_sourceInfo__list operator<<=(int rotate_count) const;
TitanLogEvent_sourceInfo__list operator<<=(const INTEGER& rotate_count) const;
TitanLogEvent_sourceInfo__list operator>>=(int rotate_count) const;
TitanLogEvent_sourceInfo__list operator>>=(const INTEGER& rotate_count) const;

TitanLogEvent_sourceInfo__list operator+(const TitanLogEvent_sourceInfo__list& other_value) const;

TitanLogEvent_sourceInfo__list substr(int index, int returncount) const;

TitanLogEvent_sourceInfo__list replace(int index, int len, const TitanLogEvent_sourceInfo__list& repl) const;

TitanLogEvent_sourceInfo__list replace(int index, int len, const TitanLogEvent_sourceInfo__list_template& repl) const;

Base_Type* clone() const { return new TitanLogEvent_sourceInfo__list(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
boolean isXerAttribute() const { return FALSE; }
virtual boolean can_start_v(const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
static  boolean can_start  (const char * name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean isXmlValueList() const { return FALSE; }

};

class TitanLogEvent_sourceInfo__list_template : public Record_Of_Template {

public:
TitanLogEvent_sourceInfo__list_template() {}
TitanLogEvent_sourceInfo__list_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
TitanLogEvent_sourceInfo__list_template(null_type other_value);
TitanLogEvent_sourceInfo__list_template(const TitanLogEvent_sourceInfo__list& other_value) { copy_value(&other_value); }
TitanLogEvent_sourceInfo__list_template(const OPTIONAL<TitanLogEvent_sourceInfo__list>& other_value) { copy_optional(&other_value); }
TitanLogEvent_sourceInfo__list_template(const TitanLogEvent_sourceInfo__list_template& other_value): Record_Of_Template() { copy_template(other_value); }
TitanLogEvent_sourceInfo__list_template& operator=(template_sel other_value);
TitanLogEvent_sourceInfo__list_template& operator=(null_type other_value);
TitanLogEvent_sourceInfo__list_template& operator=(const TitanLogEvent_sourceInfo__list& other_value);
TitanLogEvent_sourceInfo__list_template& operator=(const OPTIONAL<TitanLogEvent_sourceInfo__list>& other_value);
TitanLogEvent_sourceInfo__list_template& operator=(const TitanLogEvent_sourceInfo__list_template& other_value);

LocationInfo_template& operator[](int index_value);
LocationInfo_template& operator[](const INTEGER& index_value);
const LocationInfo_template& operator[](int index_value) const;
const LocationInfo_template& operator[](const INTEGER& index_value) const;
inline boolean match(const TitanLogEvent_sourceInfo__list& match_value) const { return matchv(&match_value); }
TitanLogEvent_sourceInfo__list valueof() const;
TitanLogEvent_sourceInfo__list substr(int index, int returncount) const;

TitanLogEvent_sourceInfo__list replace(int index, int len, const TitanLogEvent_sourceInfo__list_template& repl) const;

TitanLogEvent_sourceInfo__list replace(int index, int len, const TitanLogEvent_sourceInfo__list& repl) const;

inline TitanLogEvent_sourceInfo__list_template& list_item(int list_index) { return *(static_cast<TitanLogEvent_sourceInfo__list_template*>(get_list_item(list_index))); }
inline void log_match(const TitanLogEvent_sourceInfo__list& match_value) const { log_matchv(&match_value); }
Record_Of_Template* create() const { return new TitanLogEvent_sourceInfo__list_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class LocationInfo_ent__type : public Enum_Type { // enum
friend class LocationInfo_ent__type_template;
public:
enum enum_type { unknown = 0, controlpart = 1, testcase__ = 2, altstep__ = 3, function__ = 4, external__function = 5, template__ = 6, UNKNOWN_VALUE = 7, UNBOUND_VALUE = 8 };
private:
enum_type enum_value;

public:
LocationInfo_ent__type();
LocationInfo_ent__type(int other_value);
LocationInfo_ent__type(enum_type other_value);
LocationInfo_ent__type(const LocationInfo_ent__type& other_value);

LocationInfo_ent__type& operator=(int other_value);
LocationInfo_ent__type& operator=(enum_type other_value);
LocationInfo_ent__type& operator=(const LocationInfo_ent__type& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const LocationInfo_ent__type& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const LocationInfo_ent__type& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const LocationInfo_ent__type& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const LocationInfo_ent__type& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const LocationInfo_ent__type& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const LocationInfo_ent__type& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const LocationInfo_ent__type& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LocationInfo_ent__type_template : public Base_Template {
union {
LocationInfo_ent__type::enum_type single_value;
struct {
unsigned int n_values;
LocationInfo_ent__type_template *list_value;
} value_list;
};

void copy_template(const LocationInfo_ent__type_template& other_value);

public:
LocationInfo_ent__type_template();
LocationInfo_ent__type_template(template_sel other_value);
LocationInfo_ent__type_template(int other_value);
LocationInfo_ent__type_template(LocationInfo_ent__type::enum_type other_value);
LocationInfo_ent__type_template(const LocationInfo_ent__type& other_value);
LocationInfo_ent__type_template(const OPTIONAL<LocationInfo_ent__type>& other_value);
LocationInfo_ent__type_template(const LocationInfo_ent__type_template& other_value);
~LocationInfo_ent__type_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
LocationInfo_ent__type_template& operator=(template_sel other_value);
LocationInfo_ent__type_template& operator=(int other_value);
LocationInfo_ent__type_template& operator=(LocationInfo_ent__type::enum_type other_value);
LocationInfo_ent__type_template& operator=(const LocationInfo_ent__type& other_value);
LocationInfo_ent__type_template& operator=(const OPTIONAL<LocationInfo_ent__type>& other_value);
LocationInfo_ent__type_template& operator=(const LocationInfo_ent__type_template& other_value);

boolean match(LocationInfo_ent__type::enum_type other_value) const;
boolean match(const LocationInfo_ent__type& other_value) const;
LocationInfo_ent__type::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LocationInfo_ent__type_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const LocationInfo_ent__type& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class LocationInfo : public Record_Type {
  CHARSTRING field_filename;
  INTEGER field_line;
  CHARSTRING field_ent__name;
  LocationInfo_ent__type field_ent__type;
  Base_Type* fld_vec[4];
  void init_vec();
public:
  LocationInfo();
  LocationInfo(const LocationInfo& other_value);
  LocationInfo(const CHARSTRING& par_filename,
    const INTEGER& par_line,
    const CHARSTRING& par_ent__name,
    const LocationInfo_ent__type& par_ent__type);
inline LocationInfo& operator=(const LocationInfo& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const LocationInfo& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const LocationInfo& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& filename()
    {return field_filename;}
  inline const CHARSTRING& filename() const
    {return field_filename;}
  inline INTEGER& line()
    {return field_line;}
  inline const INTEGER& line() const
    {return field_line;}
  inline CHARSTRING& ent__name()
    {return field_ent__name;}
  inline const CHARSTRING& ent__name() const
    {return field_ent__name;}
  inline LocationInfo_ent__type& ent__type()
    {return field_ent__type;}
  inline const LocationInfo_ent__type& ent__type() const
    {return field_ent__type;}
Base_Type* clone() const { return new LocationInfo(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 4; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class LocationInfo_template : public Record_Template {
void set_specific();
public:
LocationInfo_template(): Record_Template() {}
LocationInfo_template(template_sel other_value): Record_Template(other_value) {}
LocationInfo_template(const LocationInfo& other_value): Record_Template() { copy_value(&other_value); }
LocationInfo_template(const OPTIONAL<LocationInfo>& other_value): Record_Template() { copy_optional(&other_value); }
LocationInfo_template(const LocationInfo_template& other_value): Record_Template() { copy_template(other_value); }
LocationInfo_template& operator=(template_sel other_value);
LocationInfo_template& operator=(const LocationInfo& other_value);
LocationInfo_template& operator=(const OPTIONAL<LocationInfo>& other_value);
LocationInfo_template& operator=(const LocationInfo_template& other_value);
inline boolean match(const LocationInfo& other_value) const { return matchv(&other_value); }
inline void log_match(const LocationInfo& match_value) const { log_matchv(&match_value); }
LocationInfo valueof() const;
inline LocationInfo_template& list_item(unsigned int list_index) const { return *(static_cast<LocationInfo_template*>(get_list_item(list_index))); }
CHARSTRING_template& filename();
const CHARSTRING_template& filename() const;
INTEGER_template& line();
const INTEGER_template& line() const;
CHARSTRING_template& ent__name();
const CHARSTRING_template& ent__name() const;
LocationInfo_ent__type_template& ent__type();
const LocationInfo_ent__type_template& ent__type() const;
Record_Template* create() const { return new LocationInfo_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class LogEventType_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_actionEvent = 1, ALT_defaultEvent = 2, ALT_errorLog = 3, ALT_executorEvent = 4, ALT_functionEvent = 5, ALT_parallelEvent = 6, ALT_testcaseOp = 7, ALT_portEvent = 8, ALT_statistics = 9, ALT_timerEvent = 10, ALT_userLog = 11, ALT_verdictOp = 12, ALT_warningLog = 13, ALT_matchingEvent = 14, ALT_debugLog = 15, ALT_executionSummary = 16, ALT_unhandledEvent = 17 };
private:
union_selection_type union_selection;
union {
Strings *field_actionEvent;
DefaultEvent *field_defaultEvent;
Categorized *field_errorLog;
ExecutorEvent *field_executorEvent;
FunctionEvent *field_functionEvent;
ParallelEvent *field_parallelEvent;
TestcaseEvent *field_testcaseOp;
PortEvent *field_portEvent;
StatisticsType *field_statistics;
TimerEvent *field_timerEvent;
Strings *field_userLog;
VerdictOp *field_verdictOp;
Categorized *field_warningLog;
MatchingEvent *field_matchingEvent;
Categorized *field_debugLog;
ExecutionSummaryType *field_executionSummary;
CHARSTRING *field_unhandledEvent;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const LogEventType_choice& other_value);

public:
LogEventType_choice();
LogEventType_choice(const LogEventType_choice& other_value);
~LogEventType_choice();
LogEventType_choice& operator=(const LogEventType_choice& other_value);
boolean operator==(const LogEventType_choice& other_value) const;
inline boolean operator!=(const LogEventType_choice& other_value) const { return !(*this == other_value); }
Strings& actionEvent();
const Strings& actionEvent() const;
DefaultEvent& defaultEvent();
const DefaultEvent& defaultEvent() const;
Categorized& errorLog();
const Categorized& errorLog() const;
ExecutorEvent& executorEvent();
const ExecutorEvent& executorEvent() const;
FunctionEvent& functionEvent();
const FunctionEvent& functionEvent() const;
ParallelEvent& parallelEvent();
const ParallelEvent& parallelEvent() const;
TestcaseEvent& testcaseOp();
const TestcaseEvent& testcaseOp() const;
PortEvent& portEvent();
const PortEvent& portEvent() const;
StatisticsType& statistics();
const StatisticsType& statistics() const;
TimerEvent& timerEvent();
const TimerEvent& timerEvent() const;
Strings& userLog();
const Strings& userLog() const;
VerdictOp& verdictOp();
const VerdictOp& verdictOp() const;
Categorized& warningLog();
const Categorized& warningLog() const;
MatchingEvent& matchingEvent();
const MatchingEvent& matchingEvent() const;
Categorized& debugLog();
const Categorized& debugLog() const;
ExecutionSummaryType& executionSummary();
const ExecutionSummaryType& executionSummary() const;
CHARSTRING& unhandledEvent();
const CHARSTRING& unhandledEvent() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class LogEventType_choice_template : public Base_Template {
union {
struct {
LogEventType_choice::union_selection_type union_selection;
union {
Strings_template *field_actionEvent;
DefaultEvent_template *field_defaultEvent;
Categorized_template *field_errorLog;
ExecutorEvent_template *field_executorEvent;
FunctionEvent_template *field_functionEvent;
ParallelEvent_template *field_parallelEvent;
TestcaseEvent_template *field_testcaseOp;
PortEvent_template *field_portEvent;
StatisticsType_template *field_statistics;
TimerEvent_template *field_timerEvent;
Strings_template *field_userLog;
VerdictOp_template *field_verdictOp;
Categorized_template *field_warningLog;
MatchingEvent_template *field_matchingEvent;
Categorized_template *field_debugLog;
ExecutionSummaryType_template *field_executionSummary;
CHARSTRING_template *field_unhandledEvent;
};
} single_value;
struct {
unsigned int n_values;
LogEventType_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const LogEventType_choice& other_value);

void copy_template(const LogEventType_choice_template& other_value);

public:
LogEventType_choice_template();
LogEventType_choice_template(template_sel other_value);
LogEventType_choice_template(const LogEventType_choice& other_value);
LogEventType_choice_template(const OPTIONAL<LogEventType_choice>& other_value);
LogEventType_choice_template(const LogEventType_choice_template& other_value);
~LogEventType_choice_template();
void clean_up();
LogEventType_choice_template& operator=(template_sel other_value);
LogEventType_choice_template& operator=(const LogEventType_choice& other_value);
LogEventType_choice_template& operator=(const OPTIONAL<LogEventType_choice>& other_value);
LogEventType_choice_template& operator=(const LogEventType_choice_template& other_value);
boolean match(const LogEventType_choice& other_value) const;
boolean is_value() const;LogEventType_choice valueof() const;
LogEventType_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
Strings_template& actionEvent();
const Strings_template& actionEvent() const;
DefaultEvent_template& defaultEvent();
const DefaultEvent_template& defaultEvent() const;
Categorized_template& errorLog();
const Categorized_template& errorLog() const;
ExecutorEvent_template& executorEvent();
const ExecutorEvent_template& executorEvent() const;
FunctionEvent_template& functionEvent();
const FunctionEvent_template& functionEvent() const;
ParallelEvent_template& parallelEvent();
const ParallelEvent_template& parallelEvent() const;
TestcaseEvent_template& testcaseOp();
const TestcaseEvent_template& testcaseOp() const;
PortEvent_template& portEvent();
const PortEvent_template& portEvent() const;
StatisticsType_template& statistics();
const StatisticsType_template& statistics() const;
TimerEvent_template& timerEvent();
const TimerEvent_template& timerEvent() const;
Strings_template& userLog();
const Strings_template& userLog() const;
VerdictOp_template& verdictOp();
const VerdictOp_template& verdictOp() const;
Categorized_template& warningLog();
const Categorized_template& warningLog() const;
MatchingEvent_template& matchingEvent();
const MatchingEvent_template& matchingEvent() const;
Categorized_template& debugLog();
const Categorized_template& debugLog() const;
ExecutionSummaryType_template& executionSummary();
const ExecutionSummaryType_template& executionSummary() const;
CHARSTRING_template& unhandledEvent();
const CHARSTRING_template& unhandledEvent() const;
boolean ischosen(LogEventType_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const LogEventType_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Strings : public Record_Type {
  Strings_str__list field_str__list;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  Strings();
  Strings(const Strings& other_value);
  Strings(const Strings_str__list& par_str__list);
inline Strings& operator=(const Strings& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const Strings& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const Strings& other_value) const
    { return !is_equal(&other_value); }

  inline Strings_str__list& str__list()
    {return field_str__list;}
  inline const Strings_str__list& str__list() const
    {return field_str__list;}
Base_Type* clone() const { return new Strings(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class Strings_template : public Record_Template {
void set_specific();
public:
Strings_template(): Record_Template() {}
Strings_template(template_sel other_value): Record_Template(other_value) {}
Strings_template(const Strings& other_value): Record_Template() { copy_value(&other_value); }
Strings_template(const OPTIONAL<Strings>& other_value): Record_Template() { copy_optional(&other_value); }
Strings_template(const Strings_template& other_value): Record_Template() { copy_template(other_value); }
Strings_template& operator=(template_sel other_value);
Strings_template& operator=(const Strings& other_value);
Strings_template& operator=(const OPTIONAL<Strings>& other_value);
Strings_template& operator=(const Strings_template& other_value);
inline boolean match(const Strings& other_value) const { return matchv(&other_value); }
inline void log_match(const Strings& match_value) const { log_matchv(&match_value); }
Strings valueof() const;
inline Strings_template& list_item(unsigned int list_index) const { return *(static_cast<Strings_template*>(get_list_item(list_index))); }
Strings_str__list_template& str__list();
const Strings_str__list_template& str__list() const;
Record_Template* create() const { return new Strings_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class DefaultEvent_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_defaultopActivate = 1, ALT_defaultopDeactivate = 2, ALT_defaultopExit = 3 };
private:
union_selection_type union_selection;
union {
DefaultOp *field_defaultopActivate;
DefaultOp *field_defaultopDeactivate;
DefaultOp *field_defaultopExit;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const DefaultEvent_choice& other_value);

public:
DefaultEvent_choice();
DefaultEvent_choice(const DefaultEvent_choice& other_value);
~DefaultEvent_choice();
DefaultEvent_choice& operator=(const DefaultEvent_choice& other_value);
boolean operator==(const DefaultEvent_choice& other_value) const;
inline boolean operator!=(const DefaultEvent_choice& other_value) const { return !(*this == other_value); }
DefaultOp& defaultopActivate();
const DefaultOp& defaultopActivate() const;
DefaultOp& defaultopDeactivate();
const DefaultOp& defaultopDeactivate() const;
DefaultOp& defaultopExit();
const DefaultOp& defaultopExit() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class DefaultEvent_choice_template : public Base_Template {
union {
struct {
DefaultEvent_choice::union_selection_type union_selection;
union {
DefaultOp_template *field_defaultopActivate;
DefaultOp_template *field_defaultopDeactivate;
DefaultOp_template *field_defaultopExit;
};
} single_value;
struct {
unsigned int n_values;
DefaultEvent_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const DefaultEvent_choice& other_value);

void copy_template(const DefaultEvent_choice_template& other_value);

public:
DefaultEvent_choice_template();
DefaultEvent_choice_template(template_sel other_value);
DefaultEvent_choice_template(const DefaultEvent_choice& other_value);
DefaultEvent_choice_template(const OPTIONAL<DefaultEvent_choice>& other_value);
DefaultEvent_choice_template(const DefaultEvent_choice_template& other_value);
~DefaultEvent_choice_template();
void clean_up();
DefaultEvent_choice_template& operator=(template_sel other_value);
DefaultEvent_choice_template& operator=(const DefaultEvent_choice& other_value);
DefaultEvent_choice_template& operator=(const OPTIONAL<DefaultEvent_choice>& other_value);
DefaultEvent_choice_template& operator=(const DefaultEvent_choice_template& other_value);
boolean match(const DefaultEvent_choice& other_value) const;
boolean is_value() const;DefaultEvent_choice valueof() const;
DefaultEvent_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
DefaultOp_template& defaultopActivate();
const DefaultOp_template& defaultopActivate() const;
DefaultOp_template& defaultopDeactivate();
const DefaultOp_template& defaultopDeactivate() const;
DefaultOp_template& defaultopExit();
const DefaultOp_template& defaultopExit() const;
boolean ischosen(DefaultEvent_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const DefaultEvent_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class DefaultEnd : public Enum_Type { // enum
friend class DefaultEnd_template;
public:
enum enum_type { break__ = 0, finish = 1, repeat__ = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
DefaultEnd();
DefaultEnd(int other_value);
DefaultEnd(enum_type other_value);
DefaultEnd(const DefaultEnd& other_value);

DefaultEnd& operator=(int other_value);
DefaultEnd& operator=(enum_type other_value);
DefaultEnd& operator=(const DefaultEnd& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const DefaultEnd& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const DefaultEnd& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const DefaultEnd& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const DefaultEnd& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const DefaultEnd& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const DefaultEnd& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const DefaultEnd& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class DefaultEnd_template : public Base_Template {
union {
DefaultEnd::enum_type single_value;
struct {
unsigned int n_values;
DefaultEnd_template *list_value;
} value_list;
};

void copy_template(const DefaultEnd_template& other_value);

public:
DefaultEnd_template();
DefaultEnd_template(template_sel other_value);
DefaultEnd_template(int other_value);
DefaultEnd_template(DefaultEnd::enum_type other_value);
DefaultEnd_template(const DefaultEnd& other_value);
DefaultEnd_template(const OPTIONAL<DefaultEnd>& other_value);
DefaultEnd_template(const DefaultEnd_template& other_value);
~DefaultEnd_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
DefaultEnd_template& operator=(template_sel other_value);
DefaultEnd_template& operator=(int other_value);
DefaultEnd_template& operator=(DefaultEnd::enum_type other_value);
DefaultEnd_template& operator=(const DefaultEnd& other_value);
DefaultEnd_template& operator=(const OPTIONAL<DefaultEnd>& other_value);
DefaultEnd_template& operator=(const DefaultEnd_template& other_value);

boolean match(DefaultEnd::enum_type other_value) const;
boolean match(const DefaultEnd& other_value) const;
DefaultEnd::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DefaultEnd_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const DefaultEnd& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class DefaultOp : public Record_Type {
  CHARSTRING field_name;
  INTEGER field_id;
  DefaultEnd field_end;
  Base_Type* fld_vec[3];
  void init_vec();
public:
  DefaultOp();
  DefaultOp(const DefaultOp& other_value);
  DefaultOp(const CHARSTRING& par_name,
    const INTEGER& par_id,
    const DefaultEnd& par_end);
inline DefaultOp& operator=(const DefaultOp& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const DefaultOp& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const DefaultOp& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline INTEGER& id()
    {return field_id;}
  inline const INTEGER& id() const
    {return field_id;}
  inline DefaultEnd& end()
    {return field_end;}
  inline const DefaultEnd& end() const
    {return field_end;}
Base_Type* clone() const { return new DefaultOp(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 3; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class DefaultOp_template : public Record_Template {
void set_specific();
public:
DefaultOp_template(): Record_Template() {}
DefaultOp_template(template_sel other_value): Record_Template(other_value) {}
DefaultOp_template(const DefaultOp& other_value): Record_Template() { copy_value(&other_value); }
DefaultOp_template(const OPTIONAL<DefaultOp>& other_value): Record_Template() { copy_optional(&other_value); }
DefaultOp_template(const DefaultOp_template& other_value): Record_Template() { copy_template(other_value); }
DefaultOp_template& operator=(template_sel other_value);
DefaultOp_template& operator=(const DefaultOp& other_value);
DefaultOp_template& operator=(const OPTIONAL<DefaultOp>& other_value);
DefaultOp_template& operator=(const DefaultOp_template& other_value);
inline boolean match(const DefaultOp& other_value) const { return matchv(&other_value); }
inline void log_match(const DefaultOp& match_value) const { log_matchv(&match_value); }
DefaultOp valueof() const;
inline DefaultOp_template& list_item(unsigned int list_index) const { return *(static_cast<DefaultOp_template*>(get_list_item(list_index))); }
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
INTEGER_template& id();
const INTEGER_template& id() const;
DefaultEnd_template& end();
const DefaultEnd_template& end() const;
Record_Template* create() const { return new DefaultOp_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class DefaultEvent : public Record_Type {
  DefaultEvent_choice field_choice;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  DefaultEvent();
  DefaultEvent(const DefaultEvent& other_value);
  DefaultEvent(const DefaultEvent_choice& par_choice);
inline DefaultEvent& operator=(const DefaultEvent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const DefaultEvent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const DefaultEvent& other_value) const
    { return !is_equal(&other_value); }

  inline DefaultEvent_choice& choice()
    {return field_choice;}
  inline const DefaultEvent_choice& choice() const
    {return field_choice;}
Base_Type* clone() const { return new DefaultEvent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class DefaultEvent_template : public Record_Template {
void set_specific();
public:
DefaultEvent_template(): Record_Template() {}
DefaultEvent_template(template_sel other_value): Record_Template(other_value) {}
DefaultEvent_template(const DefaultEvent& other_value): Record_Template() { copy_value(&other_value); }
DefaultEvent_template(const OPTIONAL<DefaultEvent>& other_value): Record_Template() { copy_optional(&other_value); }
DefaultEvent_template(const DefaultEvent_template& other_value): Record_Template() { copy_template(other_value); }
DefaultEvent_template& operator=(template_sel other_value);
DefaultEvent_template& operator=(const DefaultEvent& other_value);
DefaultEvent_template& operator=(const OPTIONAL<DefaultEvent>& other_value);
DefaultEvent_template& operator=(const DefaultEvent_template& other_value);
inline boolean match(const DefaultEvent& other_value) const { return matchv(&other_value); }
inline void log_match(const DefaultEvent& match_value) const { log_matchv(&match_value); }
DefaultEvent valueof() const;
inline DefaultEvent_template& list_item(unsigned int list_index) const { return *(static_cast<DefaultEvent_template*>(get_list_item(list_index))); }
DefaultEvent_choice_template& choice();
const DefaultEvent_choice_template& choice() const;
Record_Template* create() const { return new DefaultEvent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class Categorized : public Record_Type {
  INTEGER field_category;
  CHARSTRING field_text;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  Categorized();
  Categorized(const Categorized& other_value);
  Categorized(const INTEGER& par_category,
    const CHARSTRING& par_text);
inline Categorized& operator=(const Categorized& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const Categorized& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const Categorized& other_value) const
    { return !is_equal(&other_value); }

  inline INTEGER& category()
    {return field_category;}
  inline const INTEGER& category() const
    {return field_category;}
  inline CHARSTRING& text()
    {return field_text;}
  inline const CHARSTRING& text() const
    {return field_text;}
Base_Type* clone() const { return new Categorized(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class Categorized_template : public Record_Template {
void set_specific();
public:
Categorized_template(): Record_Template() {}
Categorized_template(template_sel other_value): Record_Template(other_value) {}
Categorized_template(const Categorized& other_value): Record_Template() { copy_value(&other_value); }
Categorized_template(const OPTIONAL<Categorized>& other_value): Record_Template() { copy_optional(&other_value); }
Categorized_template(const Categorized_template& other_value): Record_Template() { copy_template(other_value); }
Categorized_template& operator=(template_sel other_value);
Categorized_template& operator=(const Categorized& other_value);
Categorized_template& operator=(const OPTIONAL<Categorized>& other_value);
Categorized_template& operator=(const Categorized_template& other_value);
inline boolean match(const Categorized& other_value) const { return matchv(&other_value); }
inline void log_match(const Categorized& match_value) const { log_matchv(&match_value); }
Categorized valueof() const;
inline Categorized_template& list_item(unsigned int list_index) const { return *(static_cast<Categorized_template*>(get_list_item(list_index))); }
INTEGER_template& category();
const INTEGER_template& category() const;
CHARSTRING_template& text();
const CHARSTRING_template& text() const;
Record_Template* create() const { return new Categorized_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class ExecutorEvent_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_executorRuntime = 1, ALT_executorConfigdata = 2, ALT_extcommandStart = 3, ALT_extcommandSuccess = 4, ALT_executorComponent = 5, ALT_logOptions = 6, ALT_executorMisc = 7 };
private:
union_selection_type union_selection;
union {
ExecutorRuntime *field_executorRuntime;
ExecutorConfigdata *field_executorConfigdata;
CHARSTRING *field_extcommandStart;
CHARSTRING *field_extcommandSuccess;
ExecutorComponent *field_executorComponent;
CHARSTRING *field_logOptions;
ExecutorUnqualified *field_executorMisc;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const ExecutorEvent_choice& other_value);

public:
ExecutorEvent_choice();
ExecutorEvent_choice(const ExecutorEvent_choice& other_value);
~ExecutorEvent_choice();
ExecutorEvent_choice& operator=(const ExecutorEvent_choice& other_value);
boolean operator==(const ExecutorEvent_choice& other_value) const;
inline boolean operator!=(const ExecutorEvent_choice& other_value) const { return !(*this == other_value); }
ExecutorRuntime& executorRuntime();
const ExecutorRuntime& executorRuntime() const;
ExecutorConfigdata& executorConfigdata();
const ExecutorConfigdata& executorConfigdata() const;
CHARSTRING& extcommandStart();
const CHARSTRING& extcommandStart() const;
CHARSTRING& extcommandSuccess();
const CHARSTRING& extcommandSuccess() const;
ExecutorComponent& executorComponent();
const ExecutorComponent& executorComponent() const;
CHARSTRING& logOptions();
const CHARSTRING& logOptions() const;
ExecutorUnqualified& executorMisc();
const ExecutorUnqualified& executorMisc() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class ExecutorEvent_choice_template : public Base_Template {
union {
struct {
ExecutorEvent_choice::union_selection_type union_selection;
union {
ExecutorRuntime_template *field_executorRuntime;
ExecutorConfigdata_template *field_executorConfigdata;
CHARSTRING_template *field_extcommandStart;
CHARSTRING_template *field_extcommandSuccess;
ExecutorComponent_template *field_executorComponent;
CHARSTRING_template *field_logOptions;
ExecutorUnqualified_template *field_executorMisc;
};
} single_value;
struct {
unsigned int n_values;
ExecutorEvent_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const ExecutorEvent_choice& other_value);

void copy_template(const ExecutorEvent_choice_template& other_value);

public:
ExecutorEvent_choice_template();
ExecutorEvent_choice_template(template_sel other_value);
ExecutorEvent_choice_template(const ExecutorEvent_choice& other_value);
ExecutorEvent_choice_template(const OPTIONAL<ExecutorEvent_choice>& other_value);
ExecutorEvent_choice_template(const ExecutorEvent_choice_template& other_value);
~ExecutorEvent_choice_template();
void clean_up();
ExecutorEvent_choice_template& operator=(template_sel other_value);
ExecutorEvent_choice_template& operator=(const ExecutorEvent_choice& other_value);
ExecutorEvent_choice_template& operator=(const OPTIONAL<ExecutorEvent_choice>& other_value);
ExecutorEvent_choice_template& operator=(const ExecutorEvent_choice_template& other_value);
boolean match(const ExecutorEvent_choice& other_value) const;
boolean is_value() const;ExecutorEvent_choice valueof() const;
ExecutorEvent_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
ExecutorRuntime_template& executorRuntime();
const ExecutorRuntime_template& executorRuntime() const;
ExecutorConfigdata_template& executorConfigdata();
const ExecutorConfigdata_template& executorConfigdata() const;
CHARSTRING_template& extcommandStart();
const CHARSTRING_template& extcommandStart() const;
CHARSTRING_template& extcommandSuccess();
const CHARSTRING_template& extcommandSuccess() const;
ExecutorComponent_template& executorComponent();
const ExecutorComponent_template& executorComponent() const;
CHARSTRING_template& logOptions();
const CHARSTRING_template& logOptions() const;
ExecutorUnqualified_template& executorMisc();
const ExecutorUnqualified_template& executorMisc() const;
boolean ischosen(ExecutorEvent_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const ExecutorEvent_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class ExecutorRuntime_reason : public Enum_Type { // enum
friend class ExecutorRuntime_reason_template;
public:
enum enum_type { connected__to__mc = 0, disconnected__from__mc = 1, initialization__of__modules__failed = 2, exit__requested__from__mc__hc = 3, exit__requested__from__mc__mtc = 4, stop__was__requested__from__mc__ignored__on__idle__mtc = 5, stop__was__requested__from__mc = 6, stop__was__requested__from__mc__ignored__on__idle__ptc = 7, executing__testcase__in__module = 8, performing__error__recovery = 9, initializing__module = 10, initialization__of__module__finished = 11, stopping__current__testcase = 12, exiting = 13, host__controller__started = 14, host__controller__finished = 15, stopping__control__part__execution = 16, stopping__test__component__execution = 17, waiting__for__ptcs__to__finish = 18, user__paused__waiting__to__resume = 19, resuming__execution = 20, terminating__execution = 21, mtc__created = 22, overload__check = 23, overload__check__fail = 24, overloaded__no__more = 25, executor__start__single__mode = 26, executor__finish__single__mode = 27, fd__limits = 28, UNKNOWN_VALUE = 29, UNBOUND_VALUE = 30 };
private:
enum_type enum_value;

public:
ExecutorRuntime_reason();
ExecutorRuntime_reason(int other_value);
ExecutorRuntime_reason(enum_type other_value);
ExecutorRuntime_reason(const ExecutorRuntime_reason& other_value);

ExecutorRuntime_reason& operator=(int other_value);
ExecutorRuntime_reason& operator=(enum_type other_value);
ExecutorRuntime_reason& operator=(const ExecutorRuntime_reason& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const ExecutorRuntime_reason& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ExecutorRuntime_reason& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const ExecutorRuntime_reason& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const ExecutorRuntime_reason& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const ExecutorRuntime_reason& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const ExecutorRuntime_reason& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const ExecutorRuntime_reason& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExecutorRuntime_reason_template : public Base_Template {
union {
ExecutorRuntime_reason::enum_type single_value;
struct {
unsigned int n_values;
ExecutorRuntime_reason_template *list_value;
} value_list;
};

void copy_template(const ExecutorRuntime_reason_template& other_value);

public:
ExecutorRuntime_reason_template();
ExecutorRuntime_reason_template(template_sel other_value);
ExecutorRuntime_reason_template(int other_value);
ExecutorRuntime_reason_template(ExecutorRuntime_reason::enum_type other_value);
ExecutorRuntime_reason_template(const ExecutorRuntime_reason& other_value);
ExecutorRuntime_reason_template(const OPTIONAL<ExecutorRuntime_reason>& other_value);
ExecutorRuntime_reason_template(const ExecutorRuntime_reason_template& other_value);
~ExecutorRuntime_reason_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExecutorRuntime_reason_template& operator=(template_sel other_value);
ExecutorRuntime_reason_template& operator=(int other_value);
ExecutorRuntime_reason_template& operator=(ExecutorRuntime_reason::enum_type other_value);
ExecutorRuntime_reason_template& operator=(const ExecutorRuntime_reason& other_value);
ExecutorRuntime_reason_template& operator=(const OPTIONAL<ExecutorRuntime_reason>& other_value);
ExecutorRuntime_reason_template& operator=(const ExecutorRuntime_reason_template& other_value);

boolean match(ExecutorRuntime_reason::enum_type other_value) const;
boolean match(const ExecutorRuntime_reason& other_value) const;
ExecutorRuntime_reason::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExecutorRuntime_reason_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const ExecutorRuntime_reason& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class ExecutorRuntime : public Record_Type {
  ExecutorRuntime_reason field_reason;
  OPTIONAL<CHARSTRING> field_module__name;
  OPTIONAL<CHARSTRING> field_testcase__name;
  OPTIONAL<INTEGER> field_pid;
  OPTIONAL<INTEGER> field_fd__setsize;
  Base_Type* fld_vec[5];
  void init_vec();
public:
  ExecutorRuntime();
  ExecutorRuntime(const ExecutorRuntime& other_value);
  ExecutorRuntime(const ExecutorRuntime_reason& par_reason,
    const OPTIONAL<CHARSTRING>& par_module__name,
    const OPTIONAL<CHARSTRING>& par_testcase__name,
    const OPTIONAL<INTEGER>& par_pid,
    const OPTIONAL<INTEGER>& par_fd__setsize);
inline ExecutorRuntime& operator=(const ExecutorRuntime& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ExecutorRuntime& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const ExecutorRuntime& other_value) const
    { return !is_equal(&other_value); }

  inline ExecutorRuntime_reason& reason()
    {return field_reason;}
  inline const ExecutorRuntime_reason& reason() const
    {return field_reason;}
  inline OPTIONAL<CHARSTRING>& module__name()
    {return field_module__name;}
  inline const OPTIONAL<CHARSTRING>& module__name() const
    {return field_module__name;}
  inline OPTIONAL<CHARSTRING>& testcase__name()
    {return field_testcase__name;}
  inline const OPTIONAL<CHARSTRING>& testcase__name() const
    {return field_testcase__name;}
  inline OPTIONAL<INTEGER>& pid()
    {return field_pid;}
  inline const OPTIONAL<INTEGER>& pid() const
    {return field_pid;}
  inline OPTIONAL<INTEGER>& fd__setsize()
    {return field_fd__setsize;}
  inline const OPTIONAL<INTEGER>& fd__setsize() const
    {return field_fd__setsize;}
Base_Type* clone() const { return new ExecutorRuntime(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 5; }
int optional_count() const { return 4; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const int optional_indexes[];
const int* get_optional_indexes() const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class ExecutorRuntime_template : public Record_Template {
void set_specific();
public:
ExecutorRuntime_template(): Record_Template() {}
ExecutorRuntime_template(template_sel other_value): Record_Template(other_value) {}
ExecutorRuntime_template(const ExecutorRuntime& other_value): Record_Template() { copy_value(&other_value); }
ExecutorRuntime_template(const OPTIONAL<ExecutorRuntime>& other_value): Record_Template() { copy_optional(&other_value); }
ExecutorRuntime_template(const ExecutorRuntime_template& other_value): Record_Template() { copy_template(other_value); }
ExecutorRuntime_template& operator=(template_sel other_value);
ExecutorRuntime_template& operator=(const ExecutorRuntime& other_value);
ExecutorRuntime_template& operator=(const OPTIONAL<ExecutorRuntime>& other_value);
ExecutorRuntime_template& operator=(const ExecutorRuntime_template& other_value);
inline boolean match(const ExecutorRuntime& other_value) const { return matchv(&other_value); }
inline void log_match(const ExecutorRuntime& match_value) const { log_matchv(&match_value); }
ExecutorRuntime valueof() const;
inline ExecutorRuntime_template& list_item(unsigned int list_index) const { return *(static_cast<ExecutorRuntime_template*>(get_list_item(list_index))); }
ExecutorRuntime_reason_template& reason();
const ExecutorRuntime_reason_template& reason() const;
CHARSTRING_template& module__name();
const CHARSTRING_template& module__name() const;
CHARSTRING_template& testcase__name();
const CHARSTRING_template& testcase__name() const;
INTEGER_template& pid();
const INTEGER_template& pid() const;
INTEGER_template& fd__setsize();
const INTEGER_template& fd__setsize() const;
Record_Template* create() const { return new ExecutorRuntime_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class ExecutorConfigdata_reason : public Enum_Type { // enum
friend class ExecutorConfigdata_reason_template;
public:
enum enum_type { received__from__mc = 0, processing__failed = 1, processing__succeeded = 2, module__has__parameters = 3, using__config__file = 4, overriding__testcase__list = 5, UNKNOWN_VALUE = 6, UNBOUND_VALUE = 7 };
private:
enum_type enum_value;

public:
ExecutorConfigdata_reason();
ExecutorConfigdata_reason(int other_value);
ExecutorConfigdata_reason(enum_type other_value);
ExecutorConfigdata_reason(const ExecutorConfigdata_reason& other_value);

ExecutorConfigdata_reason& operator=(int other_value);
ExecutorConfigdata_reason& operator=(enum_type other_value);
ExecutorConfigdata_reason& operator=(const ExecutorConfigdata_reason& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const ExecutorConfigdata_reason& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ExecutorConfigdata_reason& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const ExecutorConfigdata_reason& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const ExecutorConfigdata_reason& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const ExecutorConfigdata_reason& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const ExecutorConfigdata_reason& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const ExecutorConfigdata_reason& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExecutorConfigdata_reason_template : public Base_Template {
union {
ExecutorConfigdata_reason::enum_type single_value;
struct {
unsigned int n_values;
ExecutorConfigdata_reason_template *list_value;
} value_list;
};

void copy_template(const ExecutorConfigdata_reason_template& other_value);

public:
ExecutorConfigdata_reason_template();
ExecutorConfigdata_reason_template(template_sel other_value);
ExecutorConfigdata_reason_template(int other_value);
ExecutorConfigdata_reason_template(ExecutorConfigdata_reason::enum_type other_value);
ExecutorConfigdata_reason_template(const ExecutorConfigdata_reason& other_value);
ExecutorConfigdata_reason_template(const OPTIONAL<ExecutorConfigdata_reason>& other_value);
ExecutorConfigdata_reason_template(const ExecutorConfigdata_reason_template& other_value);
~ExecutorConfigdata_reason_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExecutorConfigdata_reason_template& operator=(template_sel other_value);
ExecutorConfigdata_reason_template& operator=(int other_value);
ExecutorConfigdata_reason_template& operator=(ExecutorConfigdata_reason::enum_type other_value);
ExecutorConfigdata_reason_template& operator=(const ExecutorConfigdata_reason& other_value);
ExecutorConfigdata_reason_template& operator=(const OPTIONAL<ExecutorConfigdata_reason>& other_value);
ExecutorConfigdata_reason_template& operator=(const ExecutorConfigdata_reason_template& other_value);

boolean match(ExecutorConfigdata_reason::enum_type other_value) const;
boolean match(const ExecutorConfigdata_reason& other_value) const;
ExecutorConfigdata_reason::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExecutorConfigdata_reason_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const ExecutorConfigdata_reason& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class ExecutorConfigdata : public Record_Type {
  ExecutorConfigdata_reason field_reason;
  OPTIONAL<CHARSTRING> field_param__;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  ExecutorConfigdata();
  ExecutorConfigdata(const ExecutorConfigdata& other_value);
  ExecutorConfigdata(const ExecutorConfigdata_reason& par_reason,
    const OPTIONAL<CHARSTRING>& par_param__);
inline ExecutorConfigdata& operator=(const ExecutorConfigdata& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ExecutorConfigdata& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const ExecutorConfigdata& other_value) const
    { return !is_equal(&other_value); }

  inline ExecutorConfigdata_reason& reason()
    {return field_reason;}
  inline const ExecutorConfigdata_reason& reason() const
    {return field_reason;}
  inline OPTIONAL<CHARSTRING>& param__()
    {return field_param__;}
  inline const OPTIONAL<CHARSTRING>& param__() const
    {return field_param__;}
Base_Type* clone() const { return new ExecutorConfigdata(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
int optional_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const int optional_indexes[];
const int* get_optional_indexes() const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class ExecutorConfigdata_template : public Record_Template {
void set_specific();
public:
ExecutorConfigdata_template(): Record_Template() {}
ExecutorConfigdata_template(template_sel other_value): Record_Template(other_value) {}
ExecutorConfigdata_template(const ExecutorConfigdata& other_value): Record_Template() { copy_value(&other_value); }
ExecutorConfigdata_template(const OPTIONAL<ExecutorConfigdata>& other_value): Record_Template() { copy_optional(&other_value); }
ExecutorConfigdata_template(const ExecutorConfigdata_template& other_value): Record_Template() { copy_template(other_value); }
ExecutorConfigdata_template& operator=(template_sel other_value);
ExecutorConfigdata_template& operator=(const ExecutorConfigdata& other_value);
ExecutorConfigdata_template& operator=(const OPTIONAL<ExecutorConfigdata>& other_value);
ExecutorConfigdata_template& operator=(const ExecutorConfigdata_template& other_value);
inline boolean match(const ExecutorConfigdata& other_value) const { return matchv(&other_value); }
inline void log_match(const ExecutorConfigdata& match_value) const { log_matchv(&match_value); }
ExecutorConfigdata valueof() const;
inline ExecutorConfigdata_template& list_item(unsigned int list_index) const { return *(static_cast<ExecutorConfigdata_template*>(get_list_item(list_index))); }
ExecutorConfigdata_reason_template& reason();
const ExecutorConfigdata_reason_template& reason() const;
CHARSTRING_template& param__();
const CHARSTRING_template& param__() const;
Record_Template* create() const { return new ExecutorConfigdata_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class ExecutorComponent_reason : public Enum_Type { // enum
friend class ExecutorComponent_reason_template;
public:
enum enum_type { mtc__started = 0, mtc__finished = 1, ptc__started = 2, ptc__finished = 3, component__init__fail = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
ExecutorComponent_reason();
ExecutorComponent_reason(int other_value);
ExecutorComponent_reason(enum_type other_value);
ExecutorComponent_reason(const ExecutorComponent_reason& other_value);

ExecutorComponent_reason& operator=(int other_value);
ExecutorComponent_reason& operator=(enum_type other_value);
ExecutorComponent_reason& operator=(const ExecutorComponent_reason& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const ExecutorComponent_reason& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ExecutorComponent_reason& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const ExecutorComponent_reason& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const ExecutorComponent_reason& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const ExecutorComponent_reason& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const ExecutorComponent_reason& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const ExecutorComponent_reason& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExecutorComponent_reason_template : public Base_Template {
union {
ExecutorComponent_reason::enum_type single_value;
struct {
unsigned int n_values;
ExecutorComponent_reason_template *list_value;
} value_list;
};

void copy_template(const ExecutorComponent_reason_template& other_value);

public:
ExecutorComponent_reason_template();
ExecutorComponent_reason_template(template_sel other_value);
ExecutorComponent_reason_template(int other_value);
ExecutorComponent_reason_template(ExecutorComponent_reason::enum_type other_value);
ExecutorComponent_reason_template(const ExecutorComponent_reason& other_value);
ExecutorComponent_reason_template(const OPTIONAL<ExecutorComponent_reason>& other_value);
ExecutorComponent_reason_template(const ExecutorComponent_reason_template& other_value);
~ExecutorComponent_reason_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExecutorComponent_reason_template& operator=(template_sel other_value);
ExecutorComponent_reason_template& operator=(int other_value);
ExecutorComponent_reason_template& operator=(ExecutorComponent_reason::enum_type other_value);
ExecutorComponent_reason_template& operator=(const ExecutorComponent_reason& other_value);
ExecutorComponent_reason_template& operator=(const OPTIONAL<ExecutorComponent_reason>& other_value);
ExecutorComponent_reason_template& operator=(const ExecutorComponent_reason_template& other_value);

boolean match(ExecutorComponent_reason::enum_type other_value) const;
boolean match(const ExecutorComponent_reason& other_value) const;
ExecutorComponent_reason::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExecutorComponent_reason_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const ExecutorComponent_reason& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class ExecutorComponent : public Record_Type {
  ExecutorComponent_reason field_reason;
  OPTIONAL<INTEGER> field_compref;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  ExecutorComponent();
  ExecutorComponent(const ExecutorComponent& other_value);
  ExecutorComponent(const ExecutorComponent_reason& par_reason,
    const OPTIONAL<INTEGER>& par_compref);
inline ExecutorComponent& operator=(const ExecutorComponent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ExecutorComponent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const ExecutorComponent& other_value) const
    { return !is_equal(&other_value); }

  inline ExecutorComponent_reason& reason()
    {return field_reason;}
  inline const ExecutorComponent_reason& reason() const
    {return field_reason;}
  inline OPTIONAL<INTEGER>& compref()
    {return field_compref;}
  inline const OPTIONAL<INTEGER>& compref() const
    {return field_compref;}
Base_Type* clone() const { return new ExecutorComponent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
int optional_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const int optional_indexes[];
const int* get_optional_indexes() const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class ExecutorComponent_template : public Record_Template {
void set_specific();
public:
ExecutorComponent_template(): Record_Template() {}
ExecutorComponent_template(template_sel other_value): Record_Template(other_value) {}
ExecutorComponent_template(const ExecutorComponent& other_value): Record_Template() { copy_value(&other_value); }
ExecutorComponent_template(const OPTIONAL<ExecutorComponent>& other_value): Record_Template() { copy_optional(&other_value); }
ExecutorComponent_template(const ExecutorComponent_template& other_value): Record_Template() { copy_template(other_value); }
ExecutorComponent_template& operator=(template_sel other_value);
ExecutorComponent_template& operator=(const ExecutorComponent& other_value);
ExecutorComponent_template& operator=(const OPTIONAL<ExecutorComponent>& other_value);
ExecutorComponent_template& operator=(const ExecutorComponent_template& other_value);
inline boolean match(const ExecutorComponent& other_value) const { return matchv(&other_value); }
inline void log_match(const ExecutorComponent& match_value) const { log_matchv(&match_value); }
ExecutorComponent valueof() const;
inline ExecutorComponent_template& list_item(unsigned int list_index) const { return *(static_cast<ExecutorComponent_template*>(get_list_item(list_index))); }
ExecutorComponent_reason_template& reason();
const ExecutorComponent_reason_template& reason() const;
INTEGER_template& compref();
const INTEGER_template& compref() const;
Record_Template* create() const { return new ExecutorComponent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class ExecutorUnqualified_reason : public Enum_Type { // enum
friend class ExecutorUnqualified_reason_template;
public:
enum enum_type { local__address__was__set = 0, address__of__mc__was__set = 1, address__of__control__connection = 2, host__support__unix__domain__sockets = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
ExecutorUnqualified_reason();
ExecutorUnqualified_reason(int other_value);
ExecutorUnqualified_reason(enum_type other_value);
ExecutorUnqualified_reason(const ExecutorUnqualified_reason& other_value);

ExecutorUnqualified_reason& operator=(int other_value);
ExecutorUnqualified_reason& operator=(enum_type other_value);
ExecutorUnqualified_reason& operator=(const ExecutorUnqualified_reason& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const ExecutorUnqualified_reason& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ExecutorUnqualified_reason& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const ExecutorUnqualified_reason& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const ExecutorUnqualified_reason& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const ExecutorUnqualified_reason& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const ExecutorUnqualified_reason& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const ExecutorUnqualified_reason& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExecutorUnqualified_reason_template : public Base_Template {
union {
ExecutorUnqualified_reason::enum_type single_value;
struct {
unsigned int n_values;
ExecutorUnqualified_reason_template *list_value;
} value_list;
};

void copy_template(const ExecutorUnqualified_reason_template& other_value);

public:
ExecutorUnqualified_reason_template();
ExecutorUnqualified_reason_template(template_sel other_value);
ExecutorUnqualified_reason_template(int other_value);
ExecutorUnqualified_reason_template(ExecutorUnqualified_reason::enum_type other_value);
ExecutorUnqualified_reason_template(const ExecutorUnqualified_reason& other_value);
ExecutorUnqualified_reason_template(const OPTIONAL<ExecutorUnqualified_reason>& other_value);
ExecutorUnqualified_reason_template(const ExecutorUnqualified_reason_template& other_value);
~ExecutorUnqualified_reason_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExecutorUnqualified_reason_template& operator=(template_sel other_value);
ExecutorUnqualified_reason_template& operator=(int other_value);
ExecutorUnqualified_reason_template& operator=(ExecutorUnqualified_reason::enum_type other_value);
ExecutorUnqualified_reason_template& operator=(const ExecutorUnqualified_reason& other_value);
ExecutorUnqualified_reason_template& operator=(const OPTIONAL<ExecutorUnqualified_reason>& other_value);
ExecutorUnqualified_reason_template& operator=(const ExecutorUnqualified_reason_template& other_value);

boolean match(ExecutorUnqualified_reason::enum_type other_value) const;
boolean match(const ExecutorUnqualified_reason& other_value) const;
ExecutorUnqualified_reason::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExecutorUnqualified_reason_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const ExecutorUnqualified_reason& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class ExecutorUnqualified : public Record_Type {
  ExecutorUnqualified_reason field_reason;
  CHARSTRING field_name;
  CHARSTRING field_addr;
  INTEGER field_port__;
  Base_Type* fld_vec[4];
  void init_vec();
public:
  ExecutorUnqualified();
  ExecutorUnqualified(const ExecutorUnqualified& other_value);
  ExecutorUnqualified(const ExecutorUnqualified_reason& par_reason,
    const CHARSTRING& par_name,
    const CHARSTRING& par_addr,
    const INTEGER& par_port__);
inline ExecutorUnqualified& operator=(const ExecutorUnqualified& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ExecutorUnqualified& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const ExecutorUnqualified& other_value) const
    { return !is_equal(&other_value); }

  inline ExecutorUnqualified_reason& reason()
    {return field_reason;}
  inline const ExecutorUnqualified_reason& reason() const
    {return field_reason;}
  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline CHARSTRING& addr()
    {return field_addr;}
  inline const CHARSTRING& addr() const
    {return field_addr;}
  inline INTEGER& port__()
    {return field_port__;}
  inline const INTEGER& port__() const
    {return field_port__;}
Base_Type* clone() const { return new ExecutorUnqualified(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 4; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class ExecutorUnqualified_template : public Record_Template {
void set_specific();
public:
ExecutorUnqualified_template(): Record_Template() {}
ExecutorUnqualified_template(template_sel other_value): Record_Template(other_value) {}
ExecutorUnqualified_template(const ExecutorUnqualified& other_value): Record_Template() { copy_value(&other_value); }
ExecutorUnqualified_template(const OPTIONAL<ExecutorUnqualified>& other_value): Record_Template() { copy_optional(&other_value); }
ExecutorUnqualified_template(const ExecutorUnqualified_template& other_value): Record_Template() { copy_template(other_value); }
ExecutorUnqualified_template& operator=(template_sel other_value);
ExecutorUnqualified_template& operator=(const ExecutorUnqualified& other_value);
ExecutorUnqualified_template& operator=(const OPTIONAL<ExecutorUnqualified>& other_value);
ExecutorUnqualified_template& operator=(const ExecutorUnqualified_template& other_value);
inline boolean match(const ExecutorUnqualified& other_value) const { return matchv(&other_value); }
inline void log_match(const ExecutorUnqualified& match_value) const { log_matchv(&match_value); }
ExecutorUnqualified valueof() const;
inline ExecutorUnqualified_template& list_item(unsigned int list_index) const { return *(static_cast<ExecutorUnqualified_template*>(get_list_item(list_index))); }
ExecutorUnqualified_reason_template& reason();
const ExecutorUnqualified_reason_template& reason() const;
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
CHARSTRING_template& addr();
const CHARSTRING_template& addr() const;
INTEGER_template& port__();
const INTEGER_template& port__() const;
Record_Template* create() const { return new ExecutorUnqualified_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class ExecutorEvent : public Record_Type {
  ExecutorEvent_choice field_choice;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  ExecutorEvent();
  ExecutorEvent(const ExecutorEvent& other_value);
  ExecutorEvent(const ExecutorEvent_choice& par_choice);
inline ExecutorEvent& operator=(const ExecutorEvent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ExecutorEvent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const ExecutorEvent& other_value) const
    { return !is_equal(&other_value); }

  inline ExecutorEvent_choice& choice()
    {return field_choice;}
  inline const ExecutorEvent_choice& choice() const
    {return field_choice;}
Base_Type* clone() const { return new ExecutorEvent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class ExecutorEvent_template : public Record_Template {
void set_specific();
public:
ExecutorEvent_template(): Record_Template() {}
ExecutorEvent_template(template_sel other_value): Record_Template(other_value) {}
ExecutorEvent_template(const ExecutorEvent& other_value): Record_Template() { copy_value(&other_value); }
ExecutorEvent_template(const OPTIONAL<ExecutorEvent>& other_value): Record_Template() { copy_optional(&other_value); }
ExecutorEvent_template(const ExecutorEvent_template& other_value): Record_Template() { copy_template(other_value); }
ExecutorEvent_template& operator=(template_sel other_value);
ExecutorEvent_template& operator=(const ExecutorEvent& other_value);
ExecutorEvent_template& operator=(const OPTIONAL<ExecutorEvent>& other_value);
ExecutorEvent_template& operator=(const ExecutorEvent_template& other_value);
inline boolean match(const ExecutorEvent& other_value) const { return matchv(&other_value); }
inline void log_match(const ExecutorEvent& match_value) const { log_matchv(&match_value); }
ExecutorEvent valueof() const;
inline ExecutorEvent_template& list_item(unsigned int list_index) const { return *(static_cast<ExecutorEvent_template*>(get_list_item(list_index))); }
ExecutorEvent_choice_template& choice();
const ExecutorEvent_choice_template& choice() const;
Record_Template* create() const { return new ExecutorEvent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class FunctionEvent_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_unqualified = 1, ALT_random = 2 };
private:
union_selection_type union_selection;
union {
CHARSTRING *field_unqualified;
FunctionEvent_choice_random *field_random;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const FunctionEvent_choice& other_value);

public:
FunctionEvent_choice();
FunctionEvent_choice(const FunctionEvent_choice& other_value);
~FunctionEvent_choice();
FunctionEvent_choice& operator=(const FunctionEvent_choice& other_value);
boolean operator==(const FunctionEvent_choice& other_value) const;
inline boolean operator!=(const FunctionEvent_choice& other_value) const { return !(*this == other_value); }
CHARSTRING& unqualified();
const CHARSTRING& unqualified() const;
FunctionEvent_choice_random& random();
const FunctionEvent_choice_random& random() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class FunctionEvent_choice_template : public Base_Template {
union {
struct {
FunctionEvent_choice::union_selection_type union_selection;
union {
CHARSTRING_template *field_unqualified;
FunctionEvent_choice_random_template *field_random;
};
} single_value;
struct {
unsigned int n_values;
FunctionEvent_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const FunctionEvent_choice& other_value);

void copy_template(const FunctionEvent_choice_template& other_value);

public:
FunctionEvent_choice_template();
FunctionEvent_choice_template(template_sel other_value);
FunctionEvent_choice_template(const FunctionEvent_choice& other_value);
FunctionEvent_choice_template(const OPTIONAL<FunctionEvent_choice>& other_value);
FunctionEvent_choice_template(const FunctionEvent_choice_template& other_value);
~FunctionEvent_choice_template();
void clean_up();
FunctionEvent_choice_template& operator=(template_sel other_value);
FunctionEvent_choice_template& operator=(const FunctionEvent_choice& other_value);
FunctionEvent_choice_template& operator=(const OPTIONAL<FunctionEvent_choice>& other_value);
FunctionEvent_choice_template& operator=(const FunctionEvent_choice_template& other_value);
boolean match(const FunctionEvent_choice& other_value) const;
boolean is_value() const;FunctionEvent_choice valueof() const;
FunctionEvent_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
CHARSTRING_template& unqualified();
const CHARSTRING_template& unqualified() const;
FunctionEvent_choice_random_template& random();
const FunctionEvent_choice_random_template& random() const;
boolean ischosen(FunctionEvent_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const FunctionEvent_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class RandomAction : public Enum_Type { // enum
friend class RandomAction_template;
public:
enum enum_type { read__out = 0, seed = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
RandomAction();
RandomAction(int other_value);
RandomAction(enum_type other_value);
RandomAction(const RandomAction& other_value);

RandomAction& operator=(int other_value);
RandomAction& operator=(enum_type other_value);
RandomAction& operator=(const RandomAction& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const RandomAction& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RandomAction& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const RandomAction& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const RandomAction& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const RandomAction& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const RandomAction& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const RandomAction& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RandomAction_template : public Base_Template {
union {
RandomAction::enum_type single_value;
struct {
unsigned int n_values;
RandomAction_template *list_value;
} value_list;
};

void copy_template(const RandomAction_template& other_value);

public:
RandomAction_template();
RandomAction_template(template_sel other_value);
RandomAction_template(int other_value);
RandomAction_template(RandomAction::enum_type other_value);
RandomAction_template(const RandomAction& other_value);
RandomAction_template(const OPTIONAL<RandomAction>& other_value);
RandomAction_template(const RandomAction_template& other_value);
~RandomAction_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
RandomAction_template& operator=(template_sel other_value);
RandomAction_template& operator=(int other_value);
RandomAction_template& operator=(RandomAction::enum_type other_value);
RandomAction_template& operator=(const RandomAction& other_value);
RandomAction_template& operator=(const OPTIONAL<RandomAction>& other_value);
RandomAction_template& operator=(const RandomAction_template& other_value);

boolean match(RandomAction::enum_type other_value) const;
boolean match(const RandomAction& other_value) const;
RandomAction::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RandomAction_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const RandomAction& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class FunctionEvent_choice_random : public Record_Type {
  RandomAction field_operation;
  FLOAT field_retval;
  INTEGER field_intseed;
  Base_Type* fld_vec[3];
  void init_vec();
public:
  FunctionEvent_choice_random();
  FunctionEvent_choice_random(const FunctionEvent_choice_random& other_value);
  FunctionEvent_choice_random(const RandomAction& par_operation,
    const FLOAT& par_retval,
    const INTEGER& par_intseed);
inline FunctionEvent_choice_random& operator=(const FunctionEvent_choice_random& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const FunctionEvent_choice_random& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const FunctionEvent_choice_random& other_value) const
    { return !is_equal(&other_value); }

  inline RandomAction& operation()
    {return field_operation;}
  inline const RandomAction& operation() const
    {return field_operation;}
  inline FLOAT& retval()
    {return field_retval;}
  inline const FLOAT& retval() const
    {return field_retval;}
  inline INTEGER& intseed()
    {return field_intseed;}
  inline const INTEGER& intseed() const
    {return field_intseed;}
Base_Type* clone() const { return new FunctionEvent_choice_random(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 3; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class FunctionEvent_choice_random_template : public Record_Template {
void set_specific();
public:
FunctionEvent_choice_random_template(): Record_Template() {}
FunctionEvent_choice_random_template(template_sel other_value): Record_Template(other_value) {}
FunctionEvent_choice_random_template(const FunctionEvent_choice_random& other_value): Record_Template() { copy_value(&other_value); }
FunctionEvent_choice_random_template(const OPTIONAL<FunctionEvent_choice_random>& other_value): Record_Template() { copy_optional(&other_value); }
FunctionEvent_choice_random_template(const FunctionEvent_choice_random_template& other_value): Record_Template() { copy_template(other_value); }
FunctionEvent_choice_random_template& operator=(template_sel other_value);
FunctionEvent_choice_random_template& operator=(const FunctionEvent_choice_random& other_value);
FunctionEvent_choice_random_template& operator=(const OPTIONAL<FunctionEvent_choice_random>& other_value);
FunctionEvent_choice_random_template& operator=(const FunctionEvent_choice_random_template& other_value);
inline boolean match(const FunctionEvent_choice_random& other_value) const { return matchv(&other_value); }
inline void log_match(const FunctionEvent_choice_random& match_value) const { log_matchv(&match_value); }
FunctionEvent_choice_random valueof() const;
inline FunctionEvent_choice_random_template& list_item(unsigned int list_index) const { return *(static_cast<FunctionEvent_choice_random_template*>(get_list_item(list_index))); }
RandomAction_template& operation();
const RandomAction_template& operation() const;
FLOAT_template& retval();
const FLOAT_template& retval() const;
INTEGER_template& intseed();
const INTEGER_template& intseed() const;
Record_Template* create() const { return new FunctionEvent_choice_random_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class FunctionEvent : public Record_Type {
  FunctionEvent_choice field_choice;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  FunctionEvent();
  FunctionEvent(const FunctionEvent& other_value);
  FunctionEvent(const FunctionEvent_choice& par_choice);
inline FunctionEvent& operator=(const FunctionEvent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const FunctionEvent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const FunctionEvent& other_value) const
    { return !is_equal(&other_value); }

  inline FunctionEvent_choice& choice()
    {return field_choice;}
  inline const FunctionEvent_choice& choice() const
    {return field_choice;}
Base_Type* clone() const { return new FunctionEvent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class FunctionEvent_template : public Record_Template {
void set_specific();
public:
FunctionEvent_template(): Record_Template() {}
FunctionEvent_template(template_sel other_value): Record_Template(other_value) {}
FunctionEvent_template(const FunctionEvent& other_value): Record_Template() { copy_value(&other_value); }
FunctionEvent_template(const OPTIONAL<FunctionEvent>& other_value): Record_Template() { copy_optional(&other_value); }
FunctionEvent_template(const FunctionEvent_template& other_value): Record_Template() { copy_template(other_value); }
FunctionEvent_template& operator=(template_sel other_value);
FunctionEvent_template& operator=(const FunctionEvent& other_value);
FunctionEvent_template& operator=(const OPTIONAL<FunctionEvent>& other_value);
FunctionEvent_template& operator=(const FunctionEvent_template& other_value);
inline boolean match(const FunctionEvent& other_value) const { return matchv(&other_value); }
inline void log_match(const FunctionEvent& match_value) const { log_matchv(&match_value); }
FunctionEvent valueof() const;
inline FunctionEvent_template& list_item(unsigned int list_index) const { return *(static_cast<FunctionEvent_template*>(get_list_item(list_index))); }
FunctionEvent_choice_template& choice();
const FunctionEvent_choice_template& choice() const;
Record_Template* create() const { return new FunctionEvent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class ParallelEvent_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_parallelPTC = 1, ALT_parallelPTC__exit = 2, ALT_parallelPort = 3 };
private:
union_selection_type union_selection;
union {
ParallelPTC *field_parallelPTC;
PTC__exit *field_parallelPTC__exit;
ParPort *field_parallelPort;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const ParallelEvent_choice& other_value);

public:
ParallelEvent_choice();
ParallelEvent_choice(const ParallelEvent_choice& other_value);
~ParallelEvent_choice();
ParallelEvent_choice& operator=(const ParallelEvent_choice& other_value);
boolean operator==(const ParallelEvent_choice& other_value) const;
inline boolean operator!=(const ParallelEvent_choice& other_value) const { return !(*this == other_value); }
ParallelPTC& parallelPTC();
const ParallelPTC& parallelPTC() const;
PTC__exit& parallelPTC__exit();
const PTC__exit& parallelPTC__exit() const;
ParPort& parallelPort();
const ParPort& parallelPort() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class ParallelEvent_choice_template : public Base_Template {
union {
struct {
ParallelEvent_choice::union_selection_type union_selection;
union {
ParallelPTC_template *field_parallelPTC;
PTC__exit_template *field_parallelPTC__exit;
ParPort_template *field_parallelPort;
};
} single_value;
struct {
unsigned int n_values;
ParallelEvent_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const ParallelEvent_choice& other_value);

void copy_template(const ParallelEvent_choice_template& other_value);

public:
ParallelEvent_choice_template();
ParallelEvent_choice_template(template_sel other_value);
ParallelEvent_choice_template(const ParallelEvent_choice& other_value);
ParallelEvent_choice_template(const OPTIONAL<ParallelEvent_choice>& other_value);
ParallelEvent_choice_template(const ParallelEvent_choice_template& other_value);
~ParallelEvent_choice_template();
void clean_up();
ParallelEvent_choice_template& operator=(template_sel other_value);
ParallelEvent_choice_template& operator=(const ParallelEvent_choice& other_value);
ParallelEvent_choice_template& operator=(const OPTIONAL<ParallelEvent_choice>& other_value);
ParallelEvent_choice_template& operator=(const ParallelEvent_choice_template& other_value);
boolean match(const ParallelEvent_choice& other_value) const;
boolean is_value() const;ParallelEvent_choice valueof() const;
ParallelEvent_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
ParallelPTC_template& parallelPTC();
const ParallelPTC_template& parallelPTC() const;
PTC__exit_template& parallelPTC__exit();
const PTC__exit_template& parallelPTC__exit() const;
ParPort_template& parallelPort();
const ParPort_template& parallelPort() const;
boolean ischosen(ParallelEvent_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const ParallelEvent_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class ParallelPTC_reason : public Enum_Type { // enum
friend class ParallelPTC_reason_template;
public:
enum enum_type { init__component__start = 0, init__component__finish = 1, terminating__component = 2, component__shut__down = 3, error__idle__ptc = 4, ptc__created = 5, ptc__created__pid = 6, function__started = 7, function__stopped = 8, function__finished = 9, function__error = 10, ptc__done = 11, ptc__killed = 12, stopping__mtc = 13, ptc__stopped = 14, all__comps__stopped = 15, ptc__was__killed = 16, all__comps__killed = 17, kill__request__frm__mc = 18, mtc__finished = 19, ptc__finished = 20, starting__function = 21, UNKNOWN_VALUE = 22, UNBOUND_VALUE = 23 };
private:
enum_type enum_value;

public:
ParallelPTC_reason();
ParallelPTC_reason(int other_value);
ParallelPTC_reason(enum_type other_value);
ParallelPTC_reason(const ParallelPTC_reason& other_value);

ParallelPTC_reason& operator=(int other_value);
ParallelPTC_reason& operator=(enum_type other_value);
ParallelPTC_reason& operator=(const ParallelPTC_reason& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const ParallelPTC_reason& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ParallelPTC_reason& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const ParallelPTC_reason& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const ParallelPTC_reason& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const ParallelPTC_reason& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const ParallelPTC_reason& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const ParallelPTC_reason& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ParallelPTC_reason_template : public Base_Template {
union {
ParallelPTC_reason::enum_type single_value;
struct {
unsigned int n_values;
ParallelPTC_reason_template *list_value;
} value_list;
};

void copy_template(const ParallelPTC_reason_template& other_value);

public:
ParallelPTC_reason_template();
ParallelPTC_reason_template(template_sel other_value);
ParallelPTC_reason_template(int other_value);
ParallelPTC_reason_template(ParallelPTC_reason::enum_type other_value);
ParallelPTC_reason_template(const ParallelPTC_reason& other_value);
ParallelPTC_reason_template(const OPTIONAL<ParallelPTC_reason>& other_value);
ParallelPTC_reason_template(const ParallelPTC_reason_template& other_value);
~ParallelPTC_reason_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
ParallelPTC_reason_template& operator=(template_sel other_value);
ParallelPTC_reason_template& operator=(int other_value);
ParallelPTC_reason_template& operator=(ParallelPTC_reason::enum_type other_value);
ParallelPTC_reason_template& operator=(const ParallelPTC_reason& other_value);
ParallelPTC_reason_template& operator=(const OPTIONAL<ParallelPTC_reason>& other_value);
ParallelPTC_reason_template& operator=(const ParallelPTC_reason_template& other_value);

boolean match(ParallelPTC_reason::enum_type other_value) const;
boolean match(const ParallelPTC_reason& other_value) const;
ParallelPTC_reason::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ParallelPTC_reason_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const ParallelPTC_reason& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class ParallelPTC : public Record_Type {
  ParallelPTC_reason field_reason;
  CHARSTRING field_module__;
  CHARSTRING field_name;
  INTEGER field_compref;
  CHARSTRING field_compname;
  CHARSTRING field_tc__loc;
  INTEGER field_alive__pid;
  INTEGER field_status;
  Base_Type* fld_vec[8];
  void init_vec();
public:
  ParallelPTC();
  ParallelPTC(const ParallelPTC& other_value);
  ParallelPTC(const ParallelPTC_reason& par_reason,
    const CHARSTRING& par_module__,
    const CHARSTRING& par_name,
    const INTEGER& par_compref,
    const CHARSTRING& par_compname,
    const CHARSTRING& par_tc__loc,
    const INTEGER& par_alive__pid,
    const INTEGER& par_status);
inline ParallelPTC& operator=(const ParallelPTC& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ParallelPTC& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const ParallelPTC& other_value) const
    { return !is_equal(&other_value); }

  inline ParallelPTC_reason& reason()
    {return field_reason;}
  inline const ParallelPTC_reason& reason() const
    {return field_reason;}
  inline CHARSTRING& module__()
    {return field_module__;}
  inline const CHARSTRING& module__() const
    {return field_module__;}
  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline INTEGER& compref()
    {return field_compref;}
  inline const INTEGER& compref() const
    {return field_compref;}
  inline CHARSTRING& compname()
    {return field_compname;}
  inline const CHARSTRING& compname() const
    {return field_compname;}
  inline CHARSTRING& tc__loc()
    {return field_tc__loc;}
  inline const CHARSTRING& tc__loc() const
    {return field_tc__loc;}
  inline INTEGER& alive__pid()
    {return field_alive__pid;}
  inline const INTEGER& alive__pid() const
    {return field_alive__pid;}
  inline INTEGER& status()
    {return field_status;}
  inline const INTEGER& status() const
    {return field_status;}
Base_Type* clone() const { return new ParallelPTC(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 8; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class ParallelPTC_template : public Record_Template {
void set_specific();
public:
ParallelPTC_template(): Record_Template() {}
ParallelPTC_template(template_sel other_value): Record_Template(other_value) {}
ParallelPTC_template(const ParallelPTC& other_value): Record_Template() { copy_value(&other_value); }
ParallelPTC_template(const OPTIONAL<ParallelPTC>& other_value): Record_Template() { copy_optional(&other_value); }
ParallelPTC_template(const ParallelPTC_template& other_value): Record_Template() { copy_template(other_value); }
ParallelPTC_template& operator=(template_sel other_value);
ParallelPTC_template& operator=(const ParallelPTC& other_value);
ParallelPTC_template& operator=(const OPTIONAL<ParallelPTC>& other_value);
ParallelPTC_template& operator=(const ParallelPTC_template& other_value);
inline boolean match(const ParallelPTC& other_value) const { return matchv(&other_value); }
inline void log_match(const ParallelPTC& match_value) const { log_matchv(&match_value); }
ParallelPTC valueof() const;
inline ParallelPTC_template& list_item(unsigned int list_index) const { return *(static_cast<ParallelPTC_template*>(get_list_item(list_index))); }
ParallelPTC_reason_template& reason();
const ParallelPTC_reason_template& reason() const;
CHARSTRING_template& module__();
const CHARSTRING_template& module__() const;
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
INTEGER_template& compref();
const INTEGER_template& compref() const;
CHARSTRING_template& compname();
const CHARSTRING_template& compname() const;
CHARSTRING_template& tc__loc();
const CHARSTRING_template& tc__loc() const;
INTEGER_template& alive__pid();
const INTEGER_template& alive__pid() const;
INTEGER_template& status();
const INTEGER_template& status() const;
Record_Template* create() const { return new ParallelPTC_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class PTC__exit : public Record_Type {
  INTEGER field_compref;
  INTEGER field_pid;
  INTEGER field_statuscode;
  Base_Type* fld_vec[3];
  void init_vec();
public:
  PTC__exit();
  PTC__exit(const PTC__exit& other_value);
  PTC__exit(const INTEGER& par_compref,
    const INTEGER& par_pid,
    const INTEGER& par_statuscode);
inline PTC__exit& operator=(const PTC__exit& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PTC__exit& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const PTC__exit& other_value) const
    { return !is_equal(&other_value); }

  inline INTEGER& compref()
    {return field_compref;}
  inline const INTEGER& compref() const
    {return field_compref;}
  inline INTEGER& pid()
    {return field_pid;}
  inline const INTEGER& pid() const
    {return field_pid;}
  inline INTEGER& statuscode()
    {return field_statuscode;}
  inline const INTEGER& statuscode() const
    {return field_statuscode;}
Base_Type* clone() const { return new PTC__exit(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 3; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class PTC__exit_template : public Record_Template {
void set_specific();
public:
PTC__exit_template(): Record_Template() {}
PTC__exit_template(template_sel other_value): Record_Template(other_value) {}
PTC__exit_template(const PTC__exit& other_value): Record_Template() { copy_value(&other_value); }
PTC__exit_template(const OPTIONAL<PTC__exit>& other_value): Record_Template() { copy_optional(&other_value); }
PTC__exit_template(const PTC__exit_template& other_value): Record_Template() { copy_template(other_value); }
PTC__exit_template& operator=(template_sel other_value);
PTC__exit_template& operator=(const PTC__exit& other_value);
PTC__exit_template& operator=(const OPTIONAL<PTC__exit>& other_value);
PTC__exit_template& operator=(const PTC__exit_template& other_value);
inline boolean match(const PTC__exit& other_value) const { return matchv(&other_value); }
inline void log_match(const PTC__exit& match_value) const { log_matchv(&match_value); }
PTC__exit valueof() const;
inline PTC__exit_template& list_item(unsigned int list_index) const { return *(static_cast<PTC__exit_template*>(get_list_item(list_index))); }
INTEGER_template& compref();
const INTEGER_template& compref() const;
INTEGER_template& pid();
const INTEGER_template& pid() const;
INTEGER_template& statuscode();
const INTEGER_template& statuscode() const;
Record_Template* create() const { return new PTC__exit_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class ParPort_operation : public Enum_Type { // enum
friend class ParPort_operation_template;
public:
enum enum_type { connect__ = 0, disconnect__ = 1, map__ = 2, unmap__ = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
ParPort_operation();
ParPort_operation(int other_value);
ParPort_operation(enum_type other_value);
ParPort_operation(const ParPort_operation& other_value);

ParPort_operation& operator=(int other_value);
ParPort_operation& operator=(enum_type other_value);
ParPort_operation& operator=(const ParPort_operation& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const ParPort_operation& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ParPort_operation& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const ParPort_operation& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const ParPort_operation& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const ParPort_operation& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const ParPort_operation& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const ParPort_operation& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ParPort_operation_template : public Base_Template {
union {
ParPort_operation::enum_type single_value;
struct {
unsigned int n_values;
ParPort_operation_template *list_value;
} value_list;
};

void copy_template(const ParPort_operation_template& other_value);

public:
ParPort_operation_template();
ParPort_operation_template(template_sel other_value);
ParPort_operation_template(int other_value);
ParPort_operation_template(ParPort_operation::enum_type other_value);
ParPort_operation_template(const ParPort_operation& other_value);
ParPort_operation_template(const OPTIONAL<ParPort_operation>& other_value);
ParPort_operation_template(const ParPort_operation_template& other_value);
~ParPort_operation_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
ParPort_operation_template& operator=(template_sel other_value);
ParPort_operation_template& operator=(int other_value);
ParPort_operation_template& operator=(ParPort_operation::enum_type other_value);
ParPort_operation_template& operator=(const ParPort_operation& other_value);
ParPort_operation_template& operator=(const OPTIONAL<ParPort_operation>& other_value);
ParPort_operation_template& operator=(const ParPort_operation_template& other_value);

boolean match(ParPort_operation::enum_type other_value) const;
boolean match(const ParPort_operation& other_value) const;
ParPort_operation::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ParPort_operation_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const ParPort_operation& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class ParPort : public Record_Type {
  ParPort_operation field_operation;
  INTEGER field_srcCompref;
  INTEGER field_dstCompref;
  CHARSTRING field_srcPort;
  CHARSTRING field_dstPort;
  Base_Type* fld_vec[5];
  void init_vec();
public:
  ParPort();
  ParPort(const ParPort& other_value);
  ParPort(const ParPort_operation& par_operation,
    const INTEGER& par_srcCompref,
    const INTEGER& par_dstCompref,
    const CHARSTRING& par_srcPort,
    const CHARSTRING& par_dstPort);
inline ParPort& operator=(const ParPort& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ParPort& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const ParPort& other_value) const
    { return !is_equal(&other_value); }

  inline ParPort_operation& operation()
    {return field_operation;}
  inline const ParPort_operation& operation() const
    {return field_operation;}
  inline INTEGER& srcCompref()
    {return field_srcCompref;}
  inline const INTEGER& srcCompref() const
    {return field_srcCompref;}
  inline INTEGER& dstCompref()
    {return field_dstCompref;}
  inline const INTEGER& dstCompref() const
    {return field_dstCompref;}
  inline CHARSTRING& srcPort()
    {return field_srcPort;}
  inline const CHARSTRING& srcPort() const
    {return field_srcPort;}
  inline CHARSTRING& dstPort()
    {return field_dstPort;}
  inline const CHARSTRING& dstPort() const
    {return field_dstPort;}
Base_Type* clone() const { return new ParPort(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 5; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class ParPort_template : public Record_Template {
void set_specific();
public:
ParPort_template(): Record_Template() {}
ParPort_template(template_sel other_value): Record_Template(other_value) {}
ParPort_template(const ParPort& other_value): Record_Template() { copy_value(&other_value); }
ParPort_template(const OPTIONAL<ParPort>& other_value): Record_Template() { copy_optional(&other_value); }
ParPort_template(const ParPort_template& other_value): Record_Template() { copy_template(other_value); }
ParPort_template& operator=(template_sel other_value);
ParPort_template& operator=(const ParPort& other_value);
ParPort_template& operator=(const OPTIONAL<ParPort>& other_value);
ParPort_template& operator=(const ParPort_template& other_value);
inline boolean match(const ParPort& other_value) const { return matchv(&other_value); }
inline void log_match(const ParPort& match_value) const { log_matchv(&match_value); }
ParPort valueof() const;
inline ParPort_template& list_item(unsigned int list_index) const { return *(static_cast<ParPort_template*>(get_list_item(list_index))); }
ParPort_operation_template& operation();
const ParPort_operation_template& operation() const;
INTEGER_template& srcCompref();
const INTEGER_template& srcCompref() const;
INTEGER_template& dstCompref();
const INTEGER_template& dstCompref() const;
CHARSTRING_template& srcPort();
const CHARSTRING_template& srcPort() const;
CHARSTRING_template& dstPort();
const CHARSTRING_template& dstPort() const;
Record_Template* create() const { return new ParPort_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class ParallelEvent : public Record_Type {
  ParallelEvent_choice field_choice;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  ParallelEvent();
  ParallelEvent(const ParallelEvent& other_value);
  ParallelEvent(const ParallelEvent_choice& par_choice);
inline ParallelEvent& operator=(const ParallelEvent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ParallelEvent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const ParallelEvent& other_value) const
    { return !is_equal(&other_value); }

  inline ParallelEvent_choice& choice()
    {return field_choice;}
  inline const ParallelEvent_choice& choice() const
    {return field_choice;}
Base_Type* clone() const { return new ParallelEvent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class ParallelEvent_template : public Record_Template {
void set_specific();
public:
ParallelEvent_template(): Record_Template() {}
ParallelEvent_template(template_sel other_value): Record_Template(other_value) {}
ParallelEvent_template(const ParallelEvent& other_value): Record_Template() { copy_value(&other_value); }
ParallelEvent_template(const OPTIONAL<ParallelEvent>& other_value): Record_Template() { copy_optional(&other_value); }
ParallelEvent_template(const ParallelEvent_template& other_value): Record_Template() { copy_template(other_value); }
ParallelEvent_template& operator=(template_sel other_value);
ParallelEvent_template& operator=(const ParallelEvent& other_value);
ParallelEvent_template& operator=(const OPTIONAL<ParallelEvent>& other_value);
ParallelEvent_template& operator=(const ParallelEvent_template& other_value);
inline boolean match(const ParallelEvent& other_value) const { return matchv(&other_value); }
inline void log_match(const ParallelEvent& match_value) const { log_matchv(&match_value); }
ParallelEvent valueof() const;
inline ParallelEvent_template& list_item(unsigned int list_index) const { return *(static_cast<ParallelEvent_template*>(get_list_item(list_index))); }
ParallelEvent_choice_template& choice();
const ParallelEvent_choice_template& choice() const;
Record_Template* create() const { return new ParallelEvent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class TestcaseEvent_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_testcaseStarted = 1, ALT_testcaseFinished = 2 };
private:
union_selection_type union_selection;
union {
QualifiedName *field_testcaseStarted;
TestcaseType *field_testcaseFinished;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const TestcaseEvent_choice& other_value);

public:
TestcaseEvent_choice();
TestcaseEvent_choice(const TestcaseEvent_choice& other_value);
~TestcaseEvent_choice();
TestcaseEvent_choice& operator=(const TestcaseEvent_choice& other_value);
boolean operator==(const TestcaseEvent_choice& other_value) const;
inline boolean operator!=(const TestcaseEvent_choice& other_value) const { return !(*this == other_value); }
QualifiedName& testcaseStarted();
const QualifiedName& testcaseStarted() const;
TestcaseType& testcaseFinished();
const TestcaseType& testcaseFinished() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class TestcaseEvent_choice_template : public Base_Template {
union {
struct {
TestcaseEvent_choice::union_selection_type union_selection;
union {
QualifiedName_template *field_testcaseStarted;
TestcaseType_template *field_testcaseFinished;
};
} single_value;
struct {
unsigned int n_values;
TestcaseEvent_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const TestcaseEvent_choice& other_value);

void copy_template(const TestcaseEvent_choice_template& other_value);

public:
TestcaseEvent_choice_template();
TestcaseEvent_choice_template(template_sel other_value);
TestcaseEvent_choice_template(const TestcaseEvent_choice& other_value);
TestcaseEvent_choice_template(const OPTIONAL<TestcaseEvent_choice>& other_value);
TestcaseEvent_choice_template(const TestcaseEvent_choice_template& other_value);
~TestcaseEvent_choice_template();
void clean_up();
TestcaseEvent_choice_template& operator=(template_sel other_value);
TestcaseEvent_choice_template& operator=(const TestcaseEvent_choice& other_value);
TestcaseEvent_choice_template& operator=(const OPTIONAL<TestcaseEvent_choice>& other_value);
TestcaseEvent_choice_template& operator=(const TestcaseEvent_choice_template& other_value);
boolean match(const TestcaseEvent_choice& other_value) const;
boolean is_value() const;TestcaseEvent_choice valueof() const;
TestcaseEvent_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
QualifiedName_template& testcaseStarted();
const QualifiedName_template& testcaseStarted() const;
TestcaseType_template& testcaseFinished();
const TestcaseType_template& testcaseFinished() const;
boolean ischosen(TestcaseEvent_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const TestcaseEvent_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class QualifiedName : public Record_Type {
  CHARSTRING field_module__name;
  CHARSTRING field_testcase__name;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  QualifiedName();
  QualifiedName(const QualifiedName& other_value);
  QualifiedName(const CHARSTRING& par_module__name,
    const CHARSTRING& par_testcase__name);
inline QualifiedName& operator=(const QualifiedName& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const QualifiedName& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const QualifiedName& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& module__name()
    {return field_module__name;}
  inline const CHARSTRING& module__name() const
    {return field_module__name;}
  inline CHARSTRING& testcase__name()
    {return field_testcase__name;}
  inline const CHARSTRING& testcase__name() const
    {return field_testcase__name;}
Base_Type* clone() const { return new QualifiedName(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class QualifiedName_template : public Record_Template {
void set_specific();
public:
QualifiedName_template(): Record_Template() {}
QualifiedName_template(template_sel other_value): Record_Template(other_value) {}
QualifiedName_template(const QualifiedName& other_value): Record_Template() { copy_value(&other_value); }
QualifiedName_template(const OPTIONAL<QualifiedName>& other_value): Record_Template() { copy_optional(&other_value); }
QualifiedName_template(const QualifiedName_template& other_value): Record_Template() { copy_template(other_value); }
QualifiedName_template& operator=(template_sel other_value);
QualifiedName_template& operator=(const QualifiedName& other_value);
QualifiedName_template& operator=(const OPTIONAL<QualifiedName>& other_value);
QualifiedName_template& operator=(const QualifiedName_template& other_value);
inline boolean match(const QualifiedName& other_value) const { return matchv(&other_value); }
inline void log_match(const QualifiedName& match_value) const { log_matchv(&match_value); }
QualifiedName valueof() const;
inline QualifiedName_template& list_item(unsigned int list_index) const { return *(static_cast<QualifiedName_template*>(get_list_item(list_index))); }
CHARSTRING_template& module__name();
const CHARSTRING_template& module__name() const;
CHARSTRING_template& testcase__name();
const CHARSTRING_template& testcase__name() const;
Record_Template* create() const { return new QualifiedName_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class Verdict : public Enum_Type { // enum
friend class Verdict_template;
public:
enum enum_type { v0none = 0, v1pass = 1, v2inconc = 2, v3fail = 3, v4error = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
Verdict();
Verdict(int other_value);
Verdict(enum_type other_value);
Verdict(const Verdict& other_value);

Verdict& operator=(int other_value);
Verdict& operator=(enum_type other_value);
Verdict& operator=(const Verdict& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Verdict& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Verdict& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Verdict& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Verdict& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Verdict& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Verdict& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Verdict& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Verdict_template : public Base_Template {
union {
Verdict::enum_type single_value;
struct {
unsigned int n_values;
Verdict_template *list_value;
} value_list;
};

void copy_template(const Verdict_template& other_value);

public:
Verdict_template();
Verdict_template(template_sel other_value);
Verdict_template(int other_value);
Verdict_template(Verdict::enum_type other_value);
Verdict_template(const Verdict& other_value);
Verdict_template(const OPTIONAL<Verdict>& other_value);
Verdict_template(const Verdict_template& other_value);
~Verdict_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Verdict_template& operator=(template_sel other_value);
Verdict_template& operator=(int other_value);
Verdict_template& operator=(Verdict::enum_type other_value);
Verdict_template& operator=(const Verdict& other_value);
Verdict_template& operator=(const OPTIONAL<Verdict>& other_value);
Verdict_template& operator=(const Verdict_template& other_value);

boolean match(Verdict::enum_type other_value) const;
boolean match(const Verdict& other_value) const;
Verdict::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Verdict_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const Verdict& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class TestcaseType : public Record_Type {
  QualifiedName field_name;
  Verdict field_verdict;
  CHARSTRING field_reason;
  Base_Type* fld_vec[3];
  void init_vec();
public:
  TestcaseType();
  TestcaseType(const TestcaseType& other_value);
  TestcaseType(const QualifiedName& par_name,
    const Verdict& par_verdict,
    const CHARSTRING& par_reason);
inline TestcaseType& operator=(const TestcaseType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TestcaseType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const TestcaseType& other_value) const
    { return !is_equal(&other_value); }

  inline QualifiedName& name()
    {return field_name;}
  inline const QualifiedName& name() const
    {return field_name;}
  inline Verdict& verdict()
    {return field_verdict;}
  inline const Verdict& verdict() const
    {return field_verdict;}
  inline CHARSTRING& reason()
    {return field_reason;}
  inline const CHARSTRING& reason() const
    {return field_reason;}
Base_Type* clone() const { return new TestcaseType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 3; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class TestcaseType_template : public Record_Template {
void set_specific();
public:
TestcaseType_template(): Record_Template() {}
TestcaseType_template(template_sel other_value): Record_Template(other_value) {}
TestcaseType_template(const TestcaseType& other_value): Record_Template() { copy_value(&other_value); }
TestcaseType_template(const OPTIONAL<TestcaseType>& other_value): Record_Template() { copy_optional(&other_value); }
TestcaseType_template(const TestcaseType_template& other_value): Record_Template() { copy_template(other_value); }
TestcaseType_template& operator=(template_sel other_value);
TestcaseType_template& operator=(const TestcaseType& other_value);
TestcaseType_template& operator=(const OPTIONAL<TestcaseType>& other_value);
TestcaseType_template& operator=(const TestcaseType_template& other_value);
inline boolean match(const TestcaseType& other_value) const { return matchv(&other_value); }
inline void log_match(const TestcaseType& match_value) const { log_matchv(&match_value); }
TestcaseType valueof() const;
inline TestcaseType_template& list_item(unsigned int list_index) const { return *(static_cast<TestcaseType_template*>(get_list_item(list_index))); }
QualifiedName_template& name();
const QualifiedName_template& name() const;
Verdict_template& verdict();
const Verdict_template& verdict() const;
CHARSTRING_template& reason();
const CHARSTRING_template& reason() const;
Record_Template* create() const { return new TestcaseType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class TestcaseEvent : public Record_Type {
  TestcaseEvent_choice field_choice;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  TestcaseEvent();
  TestcaseEvent(const TestcaseEvent& other_value);
  TestcaseEvent(const TestcaseEvent_choice& par_choice);
inline TestcaseEvent& operator=(const TestcaseEvent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TestcaseEvent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const TestcaseEvent& other_value) const
    { return !is_equal(&other_value); }

  inline TestcaseEvent_choice& choice()
    {return field_choice;}
  inline const TestcaseEvent_choice& choice() const
    {return field_choice;}
Base_Type* clone() const { return new TestcaseEvent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class TestcaseEvent_template : public Record_Template {
void set_specific();
public:
TestcaseEvent_template(): Record_Template() {}
TestcaseEvent_template(template_sel other_value): Record_Template(other_value) {}
TestcaseEvent_template(const TestcaseEvent& other_value): Record_Template() { copy_value(&other_value); }
TestcaseEvent_template(const OPTIONAL<TestcaseEvent>& other_value): Record_Template() { copy_optional(&other_value); }
TestcaseEvent_template(const TestcaseEvent_template& other_value): Record_Template() { copy_template(other_value); }
TestcaseEvent_template& operator=(template_sel other_value);
TestcaseEvent_template& operator=(const TestcaseEvent& other_value);
TestcaseEvent_template& operator=(const OPTIONAL<TestcaseEvent>& other_value);
TestcaseEvent_template& operator=(const TestcaseEvent_template& other_value);
inline boolean match(const TestcaseEvent& other_value) const { return matchv(&other_value); }
inline void log_match(const TestcaseEvent& match_value) const { log_matchv(&match_value); }
TestcaseEvent valueof() const;
inline TestcaseEvent_template& list_item(unsigned int list_index) const { return *(static_cast<TestcaseEvent_template*>(get_list_item(list_index))); }
TestcaseEvent_choice_template& choice();
const TestcaseEvent_choice_template& choice() const;
Record_Template* create() const { return new TestcaseEvent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class PortEvent_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_portQueue = 1, ALT_portState = 2, ALT_procPortSend = 3, ALT_procPortRecv = 4, ALT_msgPortSend = 5, ALT_msgPortRecv = 6, ALT_dualMapped = 7, ALT_dualDiscard = 8, ALT_portMisc = 9 };
private:
union_selection_type union_selection;
union {
Port__Queue *field_portQueue;
Port__State *field_portState;
Proc__port__out *field_procPortSend;
Proc__port__in *field_procPortRecv;
Msg__port__send *field_msgPortSend;
Msg__port__recv *field_msgPortRecv;
Dualface__mapped *field_dualMapped;
Dualface__discard *field_dualDiscard;
Port__Misc *field_portMisc;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const PortEvent_choice& other_value);

public:
PortEvent_choice();
PortEvent_choice(const PortEvent_choice& other_value);
~PortEvent_choice();
PortEvent_choice& operator=(const PortEvent_choice& other_value);
boolean operator==(const PortEvent_choice& other_value) const;
inline boolean operator!=(const PortEvent_choice& other_value) const { return !(*this == other_value); }
Port__Queue& portQueue();
const Port__Queue& portQueue() const;
Port__State& portState();
const Port__State& portState() const;
Proc__port__out& procPortSend();
const Proc__port__out& procPortSend() const;
Proc__port__in& procPortRecv();
const Proc__port__in& procPortRecv() const;
Msg__port__send& msgPortSend();
const Msg__port__send& msgPortSend() const;
Msg__port__recv& msgPortRecv();
const Msg__port__recv& msgPortRecv() const;
Dualface__mapped& dualMapped();
const Dualface__mapped& dualMapped() const;
Dualface__discard& dualDiscard();
const Dualface__discard& dualDiscard() const;
Port__Misc& portMisc();
const Port__Misc& portMisc() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class PortEvent_choice_template : public Base_Template {
union {
struct {
PortEvent_choice::union_selection_type union_selection;
union {
Port__Queue_template *field_portQueue;
Port__State_template *field_portState;
Proc__port__out_template *field_procPortSend;
Proc__port__in_template *field_procPortRecv;
Msg__port__send_template *field_msgPortSend;
Msg__port__recv_template *field_msgPortRecv;
Dualface__mapped_template *field_dualMapped;
Dualface__discard_template *field_dualDiscard;
Port__Misc_template *field_portMisc;
};
} single_value;
struct {
unsigned int n_values;
PortEvent_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const PortEvent_choice& other_value);

void copy_template(const PortEvent_choice_template& other_value);

public:
PortEvent_choice_template();
PortEvent_choice_template(template_sel other_value);
PortEvent_choice_template(const PortEvent_choice& other_value);
PortEvent_choice_template(const OPTIONAL<PortEvent_choice>& other_value);
PortEvent_choice_template(const PortEvent_choice_template& other_value);
~PortEvent_choice_template();
void clean_up();
PortEvent_choice_template& operator=(template_sel other_value);
PortEvent_choice_template& operator=(const PortEvent_choice& other_value);
PortEvent_choice_template& operator=(const OPTIONAL<PortEvent_choice>& other_value);
PortEvent_choice_template& operator=(const PortEvent_choice_template& other_value);
boolean match(const PortEvent_choice& other_value) const;
boolean is_value() const;PortEvent_choice valueof() const;
PortEvent_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
Port__Queue_template& portQueue();
const Port__Queue_template& portQueue() const;
Port__State_template& portState();
const Port__State_template& portState() const;
Proc__port__out_template& procPortSend();
const Proc__port__out_template& procPortSend() const;
Proc__port__in_template& procPortRecv();
const Proc__port__in_template& procPortRecv() const;
Msg__port__send_template& msgPortSend();
const Msg__port__send_template& msgPortSend() const;
Msg__port__recv_template& msgPortRecv();
const Msg__port__recv_template& msgPortRecv() const;
Dualface__mapped_template& dualMapped();
const Dualface__mapped_template& dualMapped() const;
Dualface__discard_template& dualDiscard();
const Dualface__discard_template& dualDiscard() const;
Port__Misc_template& portMisc();
const Port__Misc_template& portMisc() const;
boolean ischosen(PortEvent_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const PortEvent_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Port__Queue_operation : public Enum_Type { // enum
friend class Port__Queue_operation_template;
public:
enum enum_type { enqueue__msg = 0, enqueue__call = 1, enqueue__reply = 2, enqueue__exception = 3, extract__msg = 4, extract__op = 5, UNKNOWN_VALUE = 6, UNBOUND_VALUE = 7 };
private:
enum_type enum_value;

public:
Port__Queue_operation();
Port__Queue_operation(int other_value);
Port__Queue_operation(enum_type other_value);
Port__Queue_operation(const Port__Queue_operation& other_value);

Port__Queue_operation& operator=(int other_value);
Port__Queue_operation& operator=(enum_type other_value);
Port__Queue_operation& operator=(const Port__Queue_operation& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Port__Queue_operation& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Port__Queue_operation& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Port__Queue_operation& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Port__Queue_operation& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Port__Queue_operation& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Port__Queue_operation& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Port__Queue_operation& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Port__Queue_operation_template : public Base_Template {
union {
Port__Queue_operation::enum_type single_value;
struct {
unsigned int n_values;
Port__Queue_operation_template *list_value;
} value_list;
};

void copy_template(const Port__Queue_operation_template& other_value);

public:
Port__Queue_operation_template();
Port__Queue_operation_template(template_sel other_value);
Port__Queue_operation_template(int other_value);
Port__Queue_operation_template(Port__Queue_operation::enum_type other_value);
Port__Queue_operation_template(const Port__Queue_operation& other_value);
Port__Queue_operation_template(const OPTIONAL<Port__Queue_operation>& other_value);
Port__Queue_operation_template(const Port__Queue_operation_template& other_value);
~Port__Queue_operation_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Port__Queue_operation_template& operator=(template_sel other_value);
Port__Queue_operation_template& operator=(int other_value);
Port__Queue_operation_template& operator=(Port__Queue_operation::enum_type other_value);
Port__Queue_operation_template& operator=(const Port__Queue_operation& other_value);
Port__Queue_operation_template& operator=(const OPTIONAL<Port__Queue_operation>& other_value);
Port__Queue_operation_template& operator=(const Port__Queue_operation_template& other_value);

boolean match(Port__Queue_operation::enum_type other_value) const;
boolean match(const Port__Queue_operation& other_value) const;
Port__Queue_operation::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Port__Queue_operation_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const Port__Queue_operation& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class Port__Queue : public Record_Type {
  Port__Queue_operation field_operation;
  CHARSTRING field_port__name;
  INTEGER field_compref;
  INTEGER field_msgid;
  CHARSTRING field_address__;
  CHARSTRING field_param__;
  Base_Type* fld_vec[6];
  void init_vec();
public:
  Port__Queue();
  Port__Queue(const Port__Queue& other_value);
  Port__Queue(const Port__Queue_operation& par_operation,
    const CHARSTRING& par_port__name,
    const INTEGER& par_compref,
    const INTEGER& par_msgid,
    const CHARSTRING& par_address__,
    const CHARSTRING& par_param__);
inline Port__Queue& operator=(const Port__Queue& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const Port__Queue& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const Port__Queue& other_value) const
    { return !is_equal(&other_value); }

  inline Port__Queue_operation& operation()
    {return field_operation;}
  inline const Port__Queue_operation& operation() const
    {return field_operation;}
  inline CHARSTRING& port__name()
    {return field_port__name;}
  inline const CHARSTRING& port__name() const
    {return field_port__name;}
  inline INTEGER& compref()
    {return field_compref;}
  inline const INTEGER& compref() const
    {return field_compref;}
  inline INTEGER& msgid()
    {return field_msgid;}
  inline const INTEGER& msgid() const
    {return field_msgid;}
  inline CHARSTRING& address__()
    {return field_address__;}
  inline const CHARSTRING& address__() const
    {return field_address__;}
  inline CHARSTRING& param__()
    {return field_param__;}
  inline const CHARSTRING& param__() const
    {return field_param__;}
Base_Type* clone() const { return new Port__Queue(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 6; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class Port__Queue_template : public Record_Template {
void set_specific();
public:
Port__Queue_template(): Record_Template() {}
Port__Queue_template(template_sel other_value): Record_Template(other_value) {}
Port__Queue_template(const Port__Queue& other_value): Record_Template() { copy_value(&other_value); }
Port__Queue_template(const OPTIONAL<Port__Queue>& other_value): Record_Template() { copy_optional(&other_value); }
Port__Queue_template(const Port__Queue_template& other_value): Record_Template() { copy_template(other_value); }
Port__Queue_template& operator=(template_sel other_value);
Port__Queue_template& operator=(const Port__Queue& other_value);
Port__Queue_template& operator=(const OPTIONAL<Port__Queue>& other_value);
Port__Queue_template& operator=(const Port__Queue_template& other_value);
inline boolean match(const Port__Queue& other_value) const { return matchv(&other_value); }
inline void log_match(const Port__Queue& match_value) const { log_matchv(&match_value); }
Port__Queue valueof() const;
inline Port__Queue_template& list_item(unsigned int list_index) const { return *(static_cast<Port__Queue_template*>(get_list_item(list_index))); }
Port__Queue_operation_template& operation();
const Port__Queue_operation_template& operation() const;
CHARSTRING_template& port__name();
const CHARSTRING_template& port__name() const;
INTEGER_template& compref();
const INTEGER_template& compref() const;
INTEGER_template& msgid();
const INTEGER_template& msgid() const;
CHARSTRING_template& address__();
const CHARSTRING_template& address__() const;
CHARSTRING_template& param__();
const CHARSTRING_template& param__() const;
Record_Template* create() const { return new Port__Queue_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class Port__State_operation : public Enum_Type { // enum
friend class Port__State_operation_template;
public:
enum enum_type { started = 0, stopped = 1, halted = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
Port__State_operation();
Port__State_operation(int other_value);
Port__State_operation(enum_type other_value);
Port__State_operation(const Port__State_operation& other_value);

Port__State_operation& operator=(int other_value);
Port__State_operation& operator=(enum_type other_value);
Port__State_operation& operator=(const Port__State_operation& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Port__State_operation& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Port__State_operation& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Port__State_operation& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Port__State_operation& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Port__State_operation& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Port__State_operation& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Port__State_operation& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Port__State_operation_template : public Base_Template {
union {
Port__State_operation::enum_type single_value;
struct {
unsigned int n_values;
Port__State_operation_template *list_value;
} value_list;
};

void copy_template(const Port__State_operation_template& other_value);

public:
Port__State_operation_template();
Port__State_operation_template(template_sel other_value);
Port__State_operation_template(int other_value);
Port__State_operation_template(Port__State_operation::enum_type other_value);
Port__State_operation_template(const Port__State_operation& other_value);
Port__State_operation_template(const OPTIONAL<Port__State_operation>& other_value);
Port__State_operation_template(const Port__State_operation_template& other_value);
~Port__State_operation_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Port__State_operation_template& operator=(template_sel other_value);
Port__State_operation_template& operator=(int other_value);
Port__State_operation_template& operator=(Port__State_operation::enum_type other_value);
Port__State_operation_template& operator=(const Port__State_operation& other_value);
Port__State_operation_template& operator=(const OPTIONAL<Port__State_operation>& other_value);
Port__State_operation_template& operator=(const Port__State_operation_template& other_value);

boolean match(Port__State_operation::enum_type other_value) const;
boolean match(const Port__State_operation& other_value) const;
Port__State_operation::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Port__State_operation_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const Port__State_operation& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class Port__State : public Record_Type {
  Port__State_operation field_operation;
  CHARSTRING field_port__name;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  Port__State();
  Port__State(const Port__State& other_value);
  Port__State(const Port__State_operation& par_operation,
    const CHARSTRING& par_port__name);
inline Port__State& operator=(const Port__State& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const Port__State& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const Port__State& other_value) const
    { return !is_equal(&other_value); }

  inline Port__State_operation& operation()
    {return field_operation;}
  inline const Port__State_operation& operation() const
    {return field_operation;}
  inline CHARSTRING& port__name()
    {return field_port__name;}
  inline const CHARSTRING& port__name() const
    {return field_port__name;}
Base_Type* clone() const { return new Port__State(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class Port__State_template : public Record_Template {
void set_specific();
public:
Port__State_template(): Record_Template() {}
Port__State_template(template_sel other_value): Record_Template(other_value) {}
Port__State_template(const Port__State& other_value): Record_Template() { copy_value(&other_value); }
Port__State_template(const OPTIONAL<Port__State>& other_value): Record_Template() { copy_optional(&other_value); }
Port__State_template(const Port__State_template& other_value): Record_Template() { copy_template(other_value); }
Port__State_template& operator=(template_sel other_value);
Port__State_template& operator=(const Port__State& other_value);
Port__State_template& operator=(const OPTIONAL<Port__State>& other_value);
Port__State_template& operator=(const Port__State_template& other_value);
inline boolean match(const Port__State& other_value) const { return matchv(&other_value); }
inline void log_match(const Port__State& match_value) const { log_matchv(&match_value); }
Port__State valueof() const;
inline Port__State_template& list_item(unsigned int list_index) const { return *(static_cast<Port__State_template*>(get_list_item(list_index))); }
Port__State_operation_template& operation();
const Port__State_operation_template& operation() const;
CHARSTRING_template& port__name();
const CHARSTRING_template& port__name() const;
Record_Template* create() const { return new Port__State_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class Port__oper : public Enum_Type { // enum
friend class Port__oper_template;
public:
enum enum_type { call__op = 0, exception__op = 1, reply__op = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
Port__oper();
Port__oper(int other_value);
Port__oper(enum_type other_value);
Port__oper(const Port__oper& other_value);

Port__oper& operator=(int other_value);
Port__oper& operator=(enum_type other_value);
Port__oper& operator=(const Port__oper& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Port__oper& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Port__oper& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Port__oper& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Port__oper& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Port__oper& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Port__oper& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Port__oper& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Port__oper_template : public Base_Template {
union {
Port__oper::enum_type single_value;
struct {
unsigned int n_values;
Port__oper_template *list_value;
} value_list;
};

void copy_template(const Port__oper_template& other_value);

public:
Port__oper_template();
Port__oper_template(template_sel other_value);
Port__oper_template(int other_value);
Port__oper_template(Port__oper::enum_type other_value);
Port__oper_template(const Port__oper& other_value);
Port__oper_template(const OPTIONAL<Port__oper>& other_value);
Port__oper_template(const Port__oper_template& other_value);
~Port__oper_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Port__oper_template& operator=(template_sel other_value);
Port__oper_template& operator=(int other_value);
Port__oper_template& operator=(Port__oper::enum_type other_value);
Port__oper_template& operator=(const Port__oper& other_value);
Port__oper_template& operator=(const OPTIONAL<Port__oper>& other_value);
Port__oper_template& operator=(const Port__oper_template& other_value);

boolean match(Port__oper::enum_type other_value) const;
boolean match(const Port__oper& other_value) const;
Port__oper::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Port__oper_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const Port__oper& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class Proc__port__out : public Record_Type {
  CHARSTRING field_port__name;
  Port__oper field_operation;
  INTEGER field_compref;
  CHARSTRING field_sys__name;
  CHARSTRING field_parameter;
  Base_Type* fld_vec[5];
  void init_vec();
public:
  Proc__port__out();
  Proc__port__out(const Proc__port__out& other_value);
  Proc__port__out(const CHARSTRING& par_port__name,
    const Port__oper& par_operation,
    const INTEGER& par_compref,
    const CHARSTRING& par_sys__name,
    const CHARSTRING& par_parameter);
inline Proc__port__out& operator=(const Proc__port__out& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const Proc__port__out& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const Proc__port__out& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& port__name()
    {return field_port__name;}
  inline const CHARSTRING& port__name() const
    {return field_port__name;}
  inline Port__oper& operation()
    {return field_operation;}
  inline const Port__oper& operation() const
    {return field_operation;}
  inline INTEGER& compref()
    {return field_compref;}
  inline const INTEGER& compref() const
    {return field_compref;}
  inline CHARSTRING& sys__name()
    {return field_sys__name;}
  inline const CHARSTRING& sys__name() const
    {return field_sys__name;}
  inline CHARSTRING& parameter()
    {return field_parameter;}
  inline const CHARSTRING& parameter() const
    {return field_parameter;}
Base_Type* clone() const { return new Proc__port__out(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 5; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class Proc__port__out_template : public Record_Template {
void set_specific();
public:
Proc__port__out_template(): Record_Template() {}
Proc__port__out_template(template_sel other_value): Record_Template(other_value) {}
Proc__port__out_template(const Proc__port__out& other_value): Record_Template() { copy_value(&other_value); }
Proc__port__out_template(const OPTIONAL<Proc__port__out>& other_value): Record_Template() { copy_optional(&other_value); }
Proc__port__out_template(const Proc__port__out_template& other_value): Record_Template() { copy_template(other_value); }
Proc__port__out_template& operator=(template_sel other_value);
Proc__port__out_template& operator=(const Proc__port__out& other_value);
Proc__port__out_template& operator=(const OPTIONAL<Proc__port__out>& other_value);
Proc__port__out_template& operator=(const Proc__port__out_template& other_value);
inline boolean match(const Proc__port__out& other_value) const { return matchv(&other_value); }
inline void log_match(const Proc__port__out& match_value) const { log_matchv(&match_value); }
Proc__port__out valueof() const;
inline Proc__port__out_template& list_item(unsigned int list_index) const { return *(static_cast<Proc__port__out_template*>(get_list_item(list_index))); }
CHARSTRING_template& port__name();
const CHARSTRING_template& port__name() const;
Port__oper_template& operation();
const Port__oper_template& operation() const;
INTEGER_template& compref();
const INTEGER_template& compref() const;
CHARSTRING_template& sys__name();
const CHARSTRING_template& sys__name() const;
CHARSTRING_template& parameter();
const CHARSTRING_template& parameter() const;
Record_Template* create() const { return new Proc__port__out_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class Proc__port__in : public Record_Type {
  CHARSTRING field_port__name;
  Port__oper field_operation;
  INTEGER field_compref;
  BOOLEAN field_check__;
  CHARSTRING field_parameter;
  INTEGER field_msgid;
  Base_Type* fld_vec[6];
  void init_vec();
public:
  Proc__port__in();
  Proc__port__in(const Proc__port__in& other_value);
  Proc__port__in(const CHARSTRING& par_port__name,
    const Port__oper& par_operation,
    const INTEGER& par_compref,
    const BOOLEAN& par_check__,
    const CHARSTRING& par_parameter,
    const INTEGER& par_msgid);
inline Proc__port__in& operator=(const Proc__port__in& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const Proc__port__in& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const Proc__port__in& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& port__name()
    {return field_port__name;}
  inline const CHARSTRING& port__name() const
    {return field_port__name;}
  inline Port__oper& operation()
    {return field_operation;}
  inline const Port__oper& operation() const
    {return field_operation;}
  inline INTEGER& compref()
    {return field_compref;}
  inline const INTEGER& compref() const
    {return field_compref;}
  inline BOOLEAN& check__()
    {return field_check__;}
  inline const BOOLEAN& check__() const
    {return field_check__;}
  inline CHARSTRING& parameter()
    {return field_parameter;}
  inline const CHARSTRING& parameter() const
    {return field_parameter;}
  inline INTEGER& msgid()
    {return field_msgid;}
  inline const INTEGER& msgid() const
    {return field_msgid;}
Base_Type* clone() const { return new Proc__port__in(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 6; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class Proc__port__in_template : public Record_Template {
void set_specific();
public:
Proc__port__in_template(): Record_Template() {}
Proc__port__in_template(template_sel other_value): Record_Template(other_value) {}
Proc__port__in_template(const Proc__port__in& other_value): Record_Template() { copy_value(&other_value); }
Proc__port__in_template(const OPTIONAL<Proc__port__in>& other_value): Record_Template() { copy_optional(&other_value); }
Proc__port__in_template(const Proc__port__in_template& other_value): Record_Template() { copy_template(other_value); }
Proc__port__in_template& operator=(template_sel other_value);
Proc__port__in_template& operator=(const Proc__port__in& other_value);
Proc__port__in_template& operator=(const OPTIONAL<Proc__port__in>& other_value);
Proc__port__in_template& operator=(const Proc__port__in_template& other_value);
inline boolean match(const Proc__port__in& other_value) const { return matchv(&other_value); }
inline void log_match(const Proc__port__in& match_value) const { log_matchv(&match_value); }
Proc__port__in valueof() const;
inline Proc__port__in_template& list_item(unsigned int list_index) const { return *(static_cast<Proc__port__in_template*>(get_list_item(list_index))); }
CHARSTRING_template& port__name();
const CHARSTRING_template& port__name() const;
Port__oper_template& operation();
const Port__oper_template& operation() const;
INTEGER_template& compref();
const INTEGER_template& compref() const;
BOOLEAN_template& check__();
const BOOLEAN_template& check__() const;
CHARSTRING_template& parameter();
const CHARSTRING_template& parameter() const;
INTEGER_template& msgid();
const INTEGER_template& msgid() const;
Record_Template* create() const { return new Proc__port__in_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class Msg__port__send : public Record_Type {
  CHARSTRING field_port__name;
  INTEGER field_compref;
  CHARSTRING field_parameter;
  Base_Type* fld_vec[3];
  void init_vec();
public:
  Msg__port__send();
  Msg__port__send(const Msg__port__send& other_value);
  Msg__port__send(const CHARSTRING& par_port__name,
    const INTEGER& par_compref,
    const CHARSTRING& par_parameter);
inline Msg__port__send& operator=(const Msg__port__send& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const Msg__port__send& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const Msg__port__send& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& port__name()
    {return field_port__name;}
  inline const CHARSTRING& port__name() const
    {return field_port__name;}
  inline INTEGER& compref()
    {return field_compref;}
  inline const INTEGER& compref() const
    {return field_compref;}
  inline CHARSTRING& parameter()
    {return field_parameter;}
  inline const CHARSTRING& parameter() const
    {return field_parameter;}
Base_Type* clone() const { return new Msg__port__send(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 3; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class Msg__port__send_template : public Record_Template {
void set_specific();
public:
Msg__port__send_template(): Record_Template() {}
Msg__port__send_template(template_sel other_value): Record_Template(other_value) {}
Msg__port__send_template(const Msg__port__send& other_value): Record_Template() { copy_value(&other_value); }
Msg__port__send_template(const OPTIONAL<Msg__port__send>& other_value): Record_Template() { copy_optional(&other_value); }
Msg__port__send_template(const Msg__port__send_template& other_value): Record_Template() { copy_template(other_value); }
Msg__port__send_template& operator=(template_sel other_value);
Msg__port__send_template& operator=(const Msg__port__send& other_value);
Msg__port__send_template& operator=(const OPTIONAL<Msg__port__send>& other_value);
Msg__port__send_template& operator=(const Msg__port__send_template& other_value);
inline boolean match(const Msg__port__send& other_value) const { return matchv(&other_value); }
inline void log_match(const Msg__port__send& match_value) const { log_matchv(&match_value); }
Msg__port__send valueof() const;
inline Msg__port__send_template& list_item(unsigned int list_index) const { return *(static_cast<Msg__port__send_template*>(get_list_item(list_index))); }
CHARSTRING_template& port__name();
const CHARSTRING_template& port__name() const;
INTEGER_template& compref();
const INTEGER_template& compref() const;
CHARSTRING_template& parameter();
const CHARSTRING_template& parameter() const;
Record_Template* create() const { return new Msg__port__send_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class Msg__port__recv_operation : public Enum_Type { // enum
friend class Msg__port__recv_operation_template;
public:
enum enum_type { receive__op = 0, check__receive__op = 1, trigger__op = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
Msg__port__recv_operation();
Msg__port__recv_operation(int other_value);
Msg__port__recv_operation(enum_type other_value);
Msg__port__recv_operation(const Msg__port__recv_operation& other_value);

Msg__port__recv_operation& operator=(int other_value);
Msg__port__recv_operation& operator=(enum_type other_value);
Msg__port__recv_operation& operator=(const Msg__port__recv_operation& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Msg__port__recv_operation& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Msg__port__recv_operation& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Msg__port__recv_operation& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Msg__port__recv_operation& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Msg__port__recv_operation& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Msg__port__recv_operation& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Msg__port__recv_operation& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Msg__port__recv_operation_template : public Base_Template {
union {
Msg__port__recv_operation::enum_type single_value;
struct {
unsigned int n_values;
Msg__port__recv_operation_template *list_value;
} value_list;
};

void copy_template(const Msg__port__recv_operation_template& other_value);

public:
Msg__port__recv_operation_template();
Msg__port__recv_operation_template(template_sel other_value);
Msg__port__recv_operation_template(int other_value);
Msg__port__recv_operation_template(Msg__port__recv_operation::enum_type other_value);
Msg__port__recv_operation_template(const Msg__port__recv_operation& other_value);
Msg__port__recv_operation_template(const OPTIONAL<Msg__port__recv_operation>& other_value);
Msg__port__recv_operation_template(const Msg__port__recv_operation_template& other_value);
~Msg__port__recv_operation_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Msg__port__recv_operation_template& operator=(template_sel other_value);
Msg__port__recv_operation_template& operator=(int other_value);
Msg__port__recv_operation_template& operator=(Msg__port__recv_operation::enum_type other_value);
Msg__port__recv_operation_template& operator=(const Msg__port__recv_operation& other_value);
Msg__port__recv_operation_template& operator=(const OPTIONAL<Msg__port__recv_operation>& other_value);
Msg__port__recv_operation_template& operator=(const Msg__port__recv_operation_template& other_value);

boolean match(Msg__port__recv_operation::enum_type other_value) const;
boolean match(const Msg__port__recv_operation& other_value) const;
Msg__port__recv_operation::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Msg__port__recv_operation_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const Msg__port__recv_operation& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class Msg__port__recv : public Record_Type {
  CHARSTRING field_port__name;
  Msg__port__recv_operation field_operation;
  INTEGER field_compref;
  CHARSTRING field_sys__name;
  CHARSTRING field_parameter;
  INTEGER field_msgid;
  Base_Type* fld_vec[6];
  void init_vec();
public:
  Msg__port__recv();
  Msg__port__recv(const Msg__port__recv& other_value);
  Msg__port__recv(const CHARSTRING& par_port__name,
    const Msg__port__recv_operation& par_operation,
    const INTEGER& par_compref,
    const CHARSTRING& par_sys__name,
    const CHARSTRING& par_parameter,
    const INTEGER& par_msgid);
inline Msg__port__recv& operator=(const Msg__port__recv& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const Msg__port__recv& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const Msg__port__recv& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& port__name()
    {return field_port__name;}
  inline const CHARSTRING& port__name() const
    {return field_port__name;}
  inline Msg__port__recv_operation& operation()
    {return field_operation;}
  inline const Msg__port__recv_operation& operation() const
    {return field_operation;}
  inline INTEGER& compref()
    {return field_compref;}
  inline const INTEGER& compref() const
    {return field_compref;}
  inline CHARSTRING& sys__name()
    {return field_sys__name;}
  inline const CHARSTRING& sys__name() const
    {return field_sys__name;}
  inline CHARSTRING& parameter()
    {return field_parameter;}
  inline const CHARSTRING& parameter() const
    {return field_parameter;}
  inline INTEGER& msgid()
    {return field_msgid;}
  inline const INTEGER& msgid() const
    {return field_msgid;}
Base_Type* clone() const { return new Msg__port__recv(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 6; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class Msg__port__recv_template : public Record_Template {
void set_specific();
public:
Msg__port__recv_template(): Record_Template() {}
Msg__port__recv_template(template_sel other_value): Record_Template(other_value) {}
Msg__port__recv_template(const Msg__port__recv& other_value): Record_Template() { copy_value(&other_value); }
Msg__port__recv_template(const OPTIONAL<Msg__port__recv>& other_value): Record_Template() { copy_optional(&other_value); }
Msg__port__recv_template(const Msg__port__recv_template& other_value): Record_Template() { copy_template(other_value); }
Msg__port__recv_template& operator=(template_sel other_value);
Msg__port__recv_template& operator=(const Msg__port__recv& other_value);
Msg__port__recv_template& operator=(const OPTIONAL<Msg__port__recv>& other_value);
Msg__port__recv_template& operator=(const Msg__port__recv_template& other_value);
inline boolean match(const Msg__port__recv& other_value) const { return matchv(&other_value); }
inline void log_match(const Msg__port__recv& match_value) const { log_matchv(&match_value); }
Msg__port__recv valueof() const;
inline Msg__port__recv_template& list_item(unsigned int list_index) const { return *(static_cast<Msg__port__recv_template*>(get_list_item(list_index))); }
CHARSTRING_template& port__name();
const CHARSTRING_template& port__name() const;
Msg__port__recv_operation_template& operation();
const Msg__port__recv_operation_template& operation() const;
INTEGER_template& compref();
const INTEGER_template& compref() const;
CHARSTRING_template& sys__name();
const CHARSTRING_template& sys__name() const;
CHARSTRING_template& parameter();
const CHARSTRING_template& parameter() const;
INTEGER_template& msgid();
const INTEGER_template& msgid() const;
Record_Template* create() const { return new Msg__port__recv_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class Dualface__mapped : public Record_Type {
  BOOLEAN field_incoming;
  CHARSTRING field_target__type;
  CHARSTRING field_value__;
  INTEGER field_msgid;
  Base_Type* fld_vec[4];
  void init_vec();
public:
  Dualface__mapped();
  Dualface__mapped(const Dualface__mapped& other_value);
  Dualface__mapped(const BOOLEAN& par_incoming,
    const CHARSTRING& par_target__type,
    const CHARSTRING& par_value__,
    const INTEGER& par_msgid);
inline Dualface__mapped& operator=(const Dualface__mapped& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const Dualface__mapped& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const Dualface__mapped& other_value) const
    { return !is_equal(&other_value); }

  inline BOOLEAN& incoming()
    {return field_incoming;}
  inline const BOOLEAN& incoming() const
    {return field_incoming;}
  inline CHARSTRING& target__type()
    {return field_target__type;}
  inline const CHARSTRING& target__type() const
    {return field_target__type;}
  inline CHARSTRING& value__()
    {return field_value__;}
  inline const CHARSTRING& value__() const
    {return field_value__;}
  inline INTEGER& msgid()
    {return field_msgid;}
  inline const INTEGER& msgid() const
    {return field_msgid;}
Base_Type* clone() const { return new Dualface__mapped(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 4; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class Dualface__mapped_template : public Record_Template {
void set_specific();
public:
Dualface__mapped_template(): Record_Template() {}
Dualface__mapped_template(template_sel other_value): Record_Template(other_value) {}
Dualface__mapped_template(const Dualface__mapped& other_value): Record_Template() { copy_value(&other_value); }
Dualface__mapped_template(const OPTIONAL<Dualface__mapped>& other_value): Record_Template() { copy_optional(&other_value); }
Dualface__mapped_template(const Dualface__mapped_template& other_value): Record_Template() { copy_template(other_value); }
Dualface__mapped_template& operator=(template_sel other_value);
Dualface__mapped_template& operator=(const Dualface__mapped& other_value);
Dualface__mapped_template& operator=(const OPTIONAL<Dualface__mapped>& other_value);
Dualface__mapped_template& operator=(const Dualface__mapped_template& other_value);
inline boolean match(const Dualface__mapped& other_value) const { return matchv(&other_value); }
inline void log_match(const Dualface__mapped& match_value) const { log_matchv(&match_value); }
Dualface__mapped valueof() const;
inline Dualface__mapped_template& list_item(unsigned int list_index) const { return *(static_cast<Dualface__mapped_template*>(get_list_item(list_index))); }
BOOLEAN_template& incoming();
const BOOLEAN_template& incoming() const;
CHARSTRING_template& target__type();
const CHARSTRING_template& target__type() const;
CHARSTRING_template& value__();
const CHARSTRING_template& value__() const;
INTEGER_template& msgid();
const INTEGER_template& msgid() const;
Record_Template* create() const { return new Dualface__mapped_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class Dualface__discard : public Record_Type {
  BOOLEAN field_incoming;
  CHARSTRING field_target__type;
  CHARSTRING field_port__name;
  BOOLEAN field_unhandled;
  Base_Type* fld_vec[4];
  void init_vec();
public:
  Dualface__discard();
  Dualface__discard(const Dualface__discard& other_value);
  Dualface__discard(const BOOLEAN& par_incoming,
    const CHARSTRING& par_target__type,
    const CHARSTRING& par_port__name,
    const BOOLEAN& par_unhandled);
inline Dualface__discard& operator=(const Dualface__discard& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const Dualface__discard& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const Dualface__discard& other_value) const
    { return !is_equal(&other_value); }

  inline BOOLEAN& incoming()
    {return field_incoming;}
  inline const BOOLEAN& incoming() const
    {return field_incoming;}
  inline CHARSTRING& target__type()
    {return field_target__type;}
  inline const CHARSTRING& target__type() const
    {return field_target__type;}
  inline CHARSTRING& port__name()
    {return field_port__name;}
  inline const CHARSTRING& port__name() const
    {return field_port__name;}
  inline BOOLEAN& unhandled()
    {return field_unhandled;}
  inline const BOOLEAN& unhandled() const
    {return field_unhandled;}
Base_Type* clone() const { return new Dualface__discard(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 4; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class Dualface__discard_template : public Record_Template {
void set_specific();
public:
Dualface__discard_template(): Record_Template() {}
Dualface__discard_template(template_sel other_value): Record_Template(other_value) {}
Dualface__discard_template(const Dualface__discard& other_value): Record_Template() { copy_value(&other_value); }
Dualface__discard_template(const OPTIONAL<Dualface__discard>& other_value): Record_Template() { copy_optional(&other_value); }
Dualface__discard_template(const Dualface__discard_template& other_value): Record_Template() { copy_template(other_value); }
Dualface__discard_template& operator=(template_sel other_value);
Dualface__discard_template& operator=(const Dualface__discard& other_value);
Dualface__discard_template& operator=(const OPTIONAL<Dualface__discard>& other_value);
Dualface__discard_template& operator=(const Dualface__discard_template& other_value);
inline boolean match(const Dualface__discard& other_value) const { return matchv(&other_value); }
inline void log_match(const Dualface__discard& match_value) const { log_matchv(&match_value); }
Dualface__discard valueof() const;
inline Dualface__discard_template& list_item(unsigned int list_index) const { return *(static_cast<Dualface__discard_template*>(get_list_item(list_index))); }
BOOLEAN_template& incoming();
const BOOLEAN_template& incoming() const;
CHARSTRING_template& target__type();
const CHARSTRING_template& target__type() const;
CHARSTRING_template& port__name();
const CHARSTRING_template& port__name() const;
BOOLEAN_template& unhandled();
const BOOLEAN_template& unhandled() const;
Record_Template* create() const { return new Dualface__discard_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class Port__Misc_reason : public Enum_Type { // enum
friend class Port__Misc_reason_template;
public:
enum enum_type { removing__unterminated__connection = 0, removing__unterminated__mapping = 1, port__was__cleared = 2, local__connection__established = 3, local__connection__terminated = 4, port__is__waiting__for__connection__tcp = 5, port__is__waiting__for__connection__unix = 6, connection__established = 7, destroying__unestablished__connection = 8, terminating__connection = 9, sending__termination__request__failed = 10, termination__request__received = 11, acknowledging__termination__request__failed = 12, sending__would__block = 13, connection__accepted = 14, connection__reset__by__peer = 15, connection__closed__by__peer = 16, port__disconnected = 17, port__was__mapped__to__system = 18, port__was__unmapped__from__system = 19, UNKNOWN_VALUE = 20, UNBOUND_VALUE = 21 };
private:
enum_type enum_value;

public:
Port__Misc_reason();
Port__Misc_reason(int other_value);
Port__Misc_reason(enum_type other_value);
Port__Misc_reason(const Port__Misc_reason& other_value);

Port__Misc_reason& operator=(int other_value);
Port__Misc_reason& operator=(enum_type other_value);
Port__Misc_reason& operator=(const Port__Misc_reason& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Port__Misc_reason& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Port__Misc_reason& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Port__Misc_reason& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Port__Misc_reason& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Port__Misc_reason& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Port__Misc_reason& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Port__Misc_reason& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Port__Misc_reason_template : public Base_Template {
union {
Port__Misc_reason::enum_type single_value;
struct {
unsigned int n_values;
Port__Misc_reason_template *list_value;
} value_list;
};

void copy_template(const Port__Misc_reason_template& other_value);

public:
Port__Misc_reason_template();
Port__Misc_reason_template(template_sel other_value);
Port__Misc_reason_template(int other_value);
Port__Misc_reason_template(Port__Misc_reason::enum_type other_value);
Port__Misc_reason_template(const Port__Misc_reason& other_value);
Port__Misc_reason_template(const OPTIONAL<Port__Misc_reason>& other_value);
Port__Misc_reason_template(const Port__Misc_reason_template& other_value);
~Port__Misc_reason_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Port__Misc_reason_template& operator=(template_sel other_value);
Port__Misc_reason_template& operator=(int other_value);
Port__Misc_reason_template& operator=(Port__Misc_reason::enum_type other_value);
Port__Misc_reason_template& operator=(const Port__Misc_reason& other_value);
Port__Misc_reason_template& operator=(const OPTIONAL<Port__Misc_reason>& other_value);
Port__Misc_reason_template& operator=(const Port__Misc_reason_template& other_value);

boolean match(Port__Misc_reason::enum_type other_value) const;
boolean match(const Port__Misc_reason& other_value) const;
Port__Misc_reason::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Port__Misc_reason_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const Port__Misc_reason& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class Port__Misc : public Record_Type {
  Port__Misc_reason field_reason;
  CHARSTRING field_port__name;
  INTEGER field_remote__component;
  CHARSTRING field_remote__port;
  CHARSTRING field_ip__address;
  INTEGER field_tcp__port;
  INTEGER field_new__size;
  Base_Type* fld_vec[7];
  void init_vec();
public:
  Port__Misc();
  Port__Misc(const Port__Misc& other_value);
  Port__Misc(const Port__Misc_reason& par_reason,
    const CHARSTRING& par_port__name,
    const INTEGER& par_remote__component,
    const CHARSTRING& par_remote__port,
    const CHARSTRING& par_ip__address,
    const INTEGER& par_tcp__port,
    const INTEGER& par_new__size);
inline Port__Misc& operator=(const Port__Misc& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const Port__Misc& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const Port__Misc& other_value) const
    { return !is_equal(&other_value); }

  inline Port__Misc_reason& reason()
    {return field_reason;}
  inline const Port__Misc_reason& reason() const
    {return field_reason;}
  inline CHARSTRING& port__name()
    {return field_port__name;}
  inline const CHARSTRING& port__name() const
    {return field_port__name;}
  inline INTEGER& remote__component()
    {return field_remote__component;}
  inline const INTEGER& remote__component() const
    {return field_remote__component;}
  inline CHARSTRING& remote__port()
    {return field_remote__port;}
  inline const CHARSTRING& remote__port() const
    {return field_remote__port;}
  inline CHARSTRING& ip__address()
    {return field_ip__address;}
  inline const CHARSTRING& ip__address() const
    {return field_ip__address;}
  inline INTEGER& tcp__port()
    {return field_tcp__port;}
  inline const INTEGER& tcp__port() const
    {return field_tcp__port;}
  inline INTEGER& new__size()
    {return field_new__size;}
  inline const INTEGER& new__size() const
    {return field_new__size;}
Base_Type* clone() const { return new Port__Misc(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 7; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class Port__Misc_template : public Record_Template {
void set_specific();
public:
Port__Misc_template(): Record_Template() {}
Port__Misc_template(template_sel other_value): Record_Template(other_value) {}
Port__Misc_template(const Port__Misc& other_value): Record_Template() { copy_value(&other_value); }
Port__Misc_template(const OPTIONAL<Port__Misc>& other_value): Record_Template() { copy_optional(&other_value); }
Port__Misc_template(const Port__Misc_template& other_value): Record_Template() { copy_template(other_value); }
Port__Misc_template& operator=(template_sel other_value);
Port__Misc_template& operator=(const Port__Misc& other_value);
Port__Misc_template& operator=(const OPTIONAL<Port__Misc>& other_value);
Port__Misc_template& operator=(const Port__Misc_template& other_value);
inline boolean match(const Port__Misc& other_value) const { return matchv(&other_value); }
inline void log_match(const Port__Misc& match_value) const { log_matchv(&match_value); }
Port__Misc valueof() const;
inline Port__Misc_template& list_item(unsigned int list_index) const { return *(static_cast<Port__Misc_template*>(get_list_item(list_index))); }
Port__Misc_reason_template& reason();
const Port__Misc_reason_template& reason() const;
CHARSTRING_template& port__name();
const CHARSTRING_template& port__name() const;
INTEGER_template& remote__component();
const INTEGER_template& remote__component() const;
CHARSTRING_template& remote__port();
const CHARSTRING_template& remote__port() const;
CHARSTRING_template& ip__address();
const CHARSTRING_template& ip__address() const;
INTEGER_template& tcp__port();
const INTEGER_template& tcp__port() const;
INTEGER_template& new__size();
const INTEGER_template& new__size() const;
Record_Template* create() const { return new Port__Misc_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class PortEvent : public Record_Type {
  PortEvent_choice field_choice;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  PortEvent();
  PortEvent(const PortEvent& other_value);
  PortEvent(const PortEvent_choice& par_choice);
inline PortEvent& operator=(const PortEvent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PortEvent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const PortEvent& other_value) const
    { return !is_equal(&other_value); }

  inline PortEvent_choice& choice()
    {return field_choice;}
  inline const PortEvent_choice& choice() const
    {return field_choice;}
Base_Type* clone() const { return new PortEvent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class PortEvent_template : public Record_Template {
void set_specific();
public:
PortEvent_template(): Record_Template() {}
PortEvent_template(template_sel other_value): Record_Template(other_value) {}
PortEvent_template(const PortEvent& other_value): Record_Template() { copy_value(&other_value); }
PortEvent_template(const OPTIONAL<PortEvent>& other_value): Record_Template() { copy_optional(&other_value); }
PortEvent_template(const PortEvent_template& other_value): Record_Template() { copy_template(other_value); }
PortEvent_template& operator=(template_sel other_value);
PortEvent_template& operator=(const PortEvent& other_value);
PortEvent_template& operator=(const OPTIONAL<PortEvent>& other_value);
PortEvent_template& operator=(const PortEvent_template& other_value);
inline boolean match(const PortEvent& other_value) const { return matchv(&other_value); }
inline void log_match(const PortEvent& match_value) const { log_matchv(&match_value); }
PortEvent valueof() const;
inline PortEvent_template& list_item(unsigned int list_index) const { return *(static_cast<PortEvent_template*>(get_list_item(list_index))); }
PortEvent_choice_template& choice();
const PortEvent_choice_template& choice() const;
Record_Template* create() const { return new PortEvent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class StatisticsType_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_verdictStatistics = 1, ALT_controlpartStart = 2, ALT_controlpartFinish = 3, ALT_controlpartErrors = 4 };
private:
union_selection_type union_selection;
union {
StatisticsType_choice_verdictStatistics *field_verdictStatistics;
CHARSTRING *field_controlpartStart;
CHARSTRING *field_controlpartFinish;
INTEGER *field_controlpartErrors;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const StatisticsType_choice& other_value);

public:
StatisticsType_choice();
StatisticsType_choice(const StatisticsType_choice& other_value);
~StatisticsType_choice();
StatisticsType_choice& operator=(const StatisticsType_choice& other_value);
boolean operator==(const StatisticsType_choice& other_value) const;
inline boolean operator!=(const StatisticsType_choice& other_value) const { return !(*this == other_value); }
StatisticsType_choice_verdictStatistics& verdictStatistics();
const StatisticsType_choice_verdictStatistics& verdictStatistics() const;
CHARSTRING& controlpartStart();
const CHARSTRING& controlpartStart() const;
CHARSTRING& controlpartFinish();
const CHARSTRING& controlpartFinish() const;
INTEGER& controlpartErrors();
const INTEGER& controlpartErrors() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class StatisticsType_choice_template : public Base_Template {
union {
struct {
StatisticsType_choice::union_selection_type union_selection;
union {
StatisticsType_choice_verdictStatistics_template *field_verdictStatistics;
CHARSTRING_template *field_controlpartStart;
CHARSTRING_template *field_controlpartFinish;
INTEGER_template *field_controlpartErrors;
};
} single_value;
struct {
unsigned int n_values;
StatisticsType_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const StatisticsType_choice& other_value);

void copy_template(const StatisticsType_choice_template& other_value);

public:
StatisticsType_choice_template();
StatisticsType_choice_template(template_sel other_value);
StatisticsType_choice_template(const StatisticsType_choice& other_value);
StatisticsType_choice_template(const OPTIONAL<StatisticsType_choice>& other_value);
StatisticsType_choice_template(const StatisticsType_choice_template& other_value);
~StatisticsType_choice_template();
void clean_up();
StatisticsType_choice_template& operator=(template_sel other_value);
StatisticsType_choice_template& operator=(const StatisticsType_choice& other_value);
StatisticsType_choice_template& operator=(const OPTIONAL<StatisticsType_choice>& other_value);
StatisticsType_choice_template& operator=(const StatisticsType_choice_template& other_value);
boolean match(const StatisticsType_choice& other_value) const;
boolean is_value() const;StatisticsType_choice valueof() const;
StatisticsType_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
StatisticsType_choice_verdictStatistics_template& verdictStatistics();
const StatisticsType_choice_verdictStatistics_template& verdictStatistics() const;
CHARSTRING_template& controlpartStart();
const CHARSTRING_template& controlpartStart() const;
CHARSTRING_template& controlpartFinish();
const CHARSTRING_template& controlpartFinish() const;
INTEGER_template& controlpartErrors();
const INTEGER_template& controlpartErrors() const;
boolean ischosen(StatisticsType_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const StatisticsType_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class StatisticsType_choice_verdictStatistics : public Record_Type {
  INTEGER field_none__;
  FLOAT field_nonePercent;
  INTEGER field_pass__;
  FLOAT field_passPercent;
  INTEGER field_inconc__;
  FLOAT field_inconcPercent;
  INTEGER field_fail__;
  FLOAT field_failPercent;
  INTEGER field_error__;
  FLOAT field_errorPercent;
  Base_Type* fld_vec[10];
  void init_vec();
public:
  StatisticsType_choice_verdictStatistics();
  StatisticsType_choice_verdictStatistics(const StatisticsType_choice_verdictStatistics& other_value);
  StatisticsType_choice_verdictStatistics(const INTEGER& par_none__,
    const FLOAT& par_nonePercent,
    const INTEGER& par_pass__,
    const FLOAT& par_passPercent,
    const INTEGER& par_inconc__,
    const FLOAT& par_inconcPercent,
    const INTEGER& par_fail__,
    const FLOAT& par_failPercent,
    const INTEGER& par_error__,
    const FLOAT& par_errorPercent);
inline StatisticsType_choice_verdictStatistics& operator=(const StatisticsType_choice_verdictStatistics& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const StatisticsType_choice_verdictStatistics& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const StatisticsType_choice_verdictStatistics& other_value) const
    { return !is_equal(&other_value); }

  inline INTEGER& none__()
    {return field_none__;}
  inline const INTEGER& none__() const
    {return field_none__;}
  inline FLOAT& nonePercent()
    {return field_nonePercent;}
  inline const FLOAT& nonePercent() const
    {return field_nonePercent;}
  inline INTEGER& pass__()
    {return field_pass__;}
  inline const INTEGER& pass__() const
    {return field_pass__;}
  inline FLOAT& passPercent()
    {return field_passPercent;}
  inline const FLOAT& passPercent() const
    {return field_passPercent;}
  inline INTEGER& inconc__()
    {return field_inconc__;}
  inline const INTEGER& inconc__() const
    {return field_inconc__;}
  inline FLOAT& inconcPercent()
    {return field_inconcPercent;}
  inline const FLOAT& inconcPercent() const
    {return field_inconcPercent;}
  inline INTEGER& fail__()
    {return field_fail__;}
  inline const INTEGER& fail__() const
    {return field_fail__;}
  inline FLOAT& failPercent()
    {return field_failPercent;}
  inline const FLOAT& failPercent() const
    {return field_failPercent;}
  inline INTEGER& error__()
    {return field_error__;}
  inline const INTEGER& error__() const
    {return field_error__;}
  inline FLOAT& errorPercent()
    {return field_errorPercent;}
  inline const FLOAT& errorPercent() const
    {return field_errorPercent;}
Base_Type* clone() const { return new StatisticsType_choice_verdictStatistics(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 10; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class StatisticsType_choice_verdictStatistics_template : public Record_Template {
void set_specific();
public:
StatisticsType_choice_verdictStatistics_template(): Record_Template() {}
StatisticsType_choice_verdictStatistics_template(template_sel other_value): Record_Template(other_value) {}
StatisticsType_choice_verdictStatistics_template(const StatisticsType_choice_verdictStatistics& other_value): Record_Template() { copy_value(&other_value); }
StatisticsType_choice_verdictStatistics_template(const OPTIONAL<StatisticsType_choice_verdictStatistics>& other_value): Record_Template() { copy_optional(&other_value); }
StatisticsType_choice_verdictStatistics_template(const StatisticsType_choice_verdictStatistics_template& other_value): Record_Template() { copy_template(other_value); }
StatisticsType_choice_verdictStatistics_template& operator=(template_sel other_value);
StatisticsType_choice_verdictStatistics_template& operator=(const StatisticsType_choice_verdictStatistics& other_value);
StatisticsType_choice_verdictStatistics_template& operator=(const OPTIONAL<StatisticsType_choice_verdictStatistics>& other_value);
StatisticsType_choice_verdictStatistics_template& operator=(const StatisticsType_choice_verdictStatistics_template& other_value);
inline boolean match(const StatisticsType_choice_verdictStatistics& other_value) const { return matchv(&other_value); }
inline void log_match(const StatisticsType_choice_verdictStatistics& match_value) const { log_matchv(&match_value); }
StatisticsType_choice_verdictStatistics valueof() const;
inline StatisticsType_choice_verdictStatistics_template& list_item(unsigned int list_index) const { return *(static_cast<StatisticsType_choice_verdictStatistics_template*>(get_list_item(list_index))); }
INTEGER_template& none__();
const INTEGER_template& none__() const;
FLOAT_template& nonePercent();
const FLOAT_template& nonePercent() const;
INTEGER_template& pass__();
const INTEGER_template& pass__() const;
FLOAT_template& passPercent();
const FLOAT_template& passPercent() const;
INTEGER_template& inconc__();
const INTEGER_template& inconc__() const;
FLOAT_template& inconcPercent();
const FLOAT_template& inconcPercent() const;
INTEGER_template& fail__();
const INTEGER_template& fail__() const;
FLOAT_template& failPercent();
const FLOAT_template& failPercent() const;
INTEGER_template& error__();
const INTEGER_template& error__() const;
FLOAT_template& errorPercent();
const FLOAT_template& errorPercent() const;
Record_Template* create() const { return new StatisticsType_choice_verdictStatistics_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class StatisticsType : public Record_Type {
  StatisticsType_choice field_choice;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  StatisticsType();
  StatisticsType(const StatisticsType& other_value);
  StatisticsType(const StatisticsType_choice& par_choice);
inline StatisticsType& operator=(const StatisticsType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const StatisticsType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const StatisticsType& other_value) const
    { return !is_equal(&other_value); }

  inline StatisticsType_choice& choice()
    {return field_choice;}
  inline const StatisticsType_choice& choice() const
    {return field_choice;}
Base_Type* clone() const { return new StatisticsType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class StatisticsType_template : public Record_Template {
void set_specific();
public:
StatisticsType_template(): Record_Template() {}
StatisticsType_template(template_sel other_value): Record_Template(other_value) {}
StatisticsType_template(const StatisticsType& other_value): Record_Template() { copy_value(&other_value); }
StatisticsType_template(const OPTIONAL<StatisticsType>& other_value): Record_Template() { copy_optional(&other_value); }
StatisticsType_template(const StatisticsType_template& other_value): Record_Template() { copy_template(other_value); }
StatisticsType_template& operator=(template_sel other_value);
StatisticsType_template& operator=(const StatisticsType& other_value);
StatisticsType_template& operator=(const OPTIONAL<StatisticsType>& other_value);
StatisticsType_template& operator=(const StatisticsType_template& other_value);
inline boolean match(const StatisticsType& other_value) const { return matchv(&other_value); }
inline void log_match(const StatisticsType& match_value) const { log_matchv(&match_value); }
StatisticsType valueof() const;
inline StatisticsType_template& list_item(unsigned int list_index) const { return *(static_cast<StatisticsType_template*>(get_list_item(list_index))); }
StatisticsType_choice_template& choice();
const StatisticsType_choice_template& choice() const;
Record_Template* create() const { return new StatisticsType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class TimerEvent_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_readTimer = 1, ALT_startTimer = 2, ALT_guardTimer = 3, ALT_stopTimer = 4, ALT_timeoutTimer = 5, ALT_timeoutAnyTimer = 6, ALT_unqualifiedTimer = 7 };
private:
union_selection_type union_selection;
union {
TimerType *field_readTimer;
TimerType *field_startTimer;
TimerGuardType *field_guardTimer;
TimerType *field_stopTimer;
TimerType *field_timeoutTimer;
TimerAnyTimeoutType *field_timeoutAnyTimer;
CHARSTRING *field_unqualifiedTimer;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const TimerEvent_choice& other_value);

public:
TimerEvent_choice();
TimerEvent_choice(const TimerEvent_choice& other_value);
~TimerEvent_choice();
TimerEvent_choice& operator=(const TimerEvent_choice& other_value);
boolean operator==(const TimerEvent_choice& other_value) const;
inline boolean operator!=(const TimerEvent_choice& other_value) const { return !(*this == other_value); }
TimerType& readTimer();
const TimerType& readTimer() const;
TimerType& startTimer();
const TimerType& startTimer() const;
TimerGuardType& guardTimer();
const TimerGuardType& guardTimer() const;
TimerType& stopTimer();
const TimerType& stopTimer() const;
TimerType& timeoutTimer();
const TimerType& timeoutTimer() const;
TimerAnyTimeoutType& timeoutAnyTimer();
const TimerAnyTimeoutType& timeoutAnyTimer() const;
CHARSTRING& unqualifiedTimer();
const CHARSTRING& unqualifiedTimer() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class TimerEvent_choice_template : public Base_Template {
union {
struct {
TimerEvent_choice::union_selection_type union_selection;
union {
TimerType_template *field_readTimer;
TimerType_template *field_startTimer;
TimerGuardType_template *field_guardTimer;
TimerType_template *field_stopTimer;
TimerType_template *field_timeoutTimer;
TimerAnyTimeoutType_template *field_timeoutAnyTimer;
CHARSTRING_template *field_unqualifiedTimer;
};
} single_value;
struct {
unsigned int n_values;
TimerEvent_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const TimerEvent_choice& other_value);

void copy_template(const TimerEvent_choice_template& other_value);

public:
TimerEvent_choice_template();
TimerEvent_choice_template(template_sel other_value);
TimerEvent_choice_template(const TimerEvent_choice& other_value);
TimerEvent_choice_template(const OPTIONAL<TimerEvent_choice>& other_value);
TimerEvent_choice_template(const TimerEvent_choice_template& other_value);
~TimerEvent_choice_template();
void clean_up();
TimerEvent_choice_template& operator=(template_sel other_value);
TimerEvent_choice_template& operator=(const TimerEvent_choice& other_value);
TimerEvent_choice_template& operator=(const OPTIONAL<TimerEvent_choice>& other_value);
TimerEvent_choice_template& operator=(const TimerEvent_choice_template& other_value);
boolean match(const TimerEvent_choice& other_value) const;
boolean is_value() const;TimerEvent_choice valueof() const;
TimerEvent_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
TimerType_template& readTimer();
const TimerType_template& readTimer() const;
TimerType_template& startTimer();
const TimerType_template& startTimer() const;
TimerGuardType_template& guardTimer();
const TimerGuardType_template& guardTimer() const;
TimerType_template& stopTimer();
const TimerType_template& stopTimer() const;
TimerType_template& timeoutTimer();
const TimerType_template& timeoutTimer() const;
TimerAnyTimeoutType_template& timeoutAnyTimer();
const TimerAnyTimeoutType_template& timeoutAnyTimer() const;
CHARSTRING_template& unqualifiedTimer();
const CHARSTRING_template& unqualifiedTimer() const;
boolean ischosen(TimerEvent_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const TimerEvent_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class TimerType : public Record_Type {
  CHARSTRING field_name;
  FLOAT field_value__;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  TimerType();
  TimerType(const TimerType& other_value);
  TimerType(const CHARSTRING& par_name,
    const FLOAT& par_value__);
inline TimerType& operator=(const TimerType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TimerType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const TimerType& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline FLOAT& value__()
    {return field_value__;}
  inline const FLOAT& value__() const
    {return field_value__;}
Base_Type* clone() const { return new TimerType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class TimerType_template : public Record_Template {
void set_specific();
public:
TimerType_template(): Record_Template() {}
TimerType_template(template_sel other_value): Record_Template(other_value) {}
TimerType_template(const TimerType& other_value): Record_Template() { copy_value(&other_value); }
TimerType_template(const OPTIONAL<TimerType>& other_value): Record_Template() { copy_optional(&other_value); }
TimerType_template(const TimerType_template& other_value): Record_Template() { copy_template(other_value); }
TimerType_template& operator=(template_sel other_value);
TimerType_template& operator=(const TimerType& other_value);
TimerType_template& operator=(const OPTIONAL<TimerType>& other_value);
TimerType_template& operator=(const TimerType_template& other_value);
inline boolean match(const TimerType& other_value) const { return matchv(&other_value); }
inline void log_match(const TimerType& match_value) const { log_matchv(&match_value); }
TimerType valueof() const;
inline TimerType_template& list_item(unsigned int list_index) const { return *(static_cast<TimerType_template*>(get_list_item(list_index))); }
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
FLOAT_template& value__();
const FLOAT_template& value__() const;
Record_Template* create() const { return new TimerType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class TimerGuardType : public Record_Type {
  FLOAT field_value__;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  TimerGuardType();
  TimerGuardType(const TimerGuardType& other_value);
  TimerGuardType(const FLOAT& par_value__);
inline TimerGuardType& operator=(const TimerGuardType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TimerGuardType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const TimerGuardType& other_value) const
    { return !is_equal(&other_value); }

  inline FLOAT& value__()
    {return field_value__;}
  inline const FLOAT& value__() const
    {return field_value__;}
Base_Type* clone() const { return new TimerGuardType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class TimerGuardType_template : public Record_Template {
void set_specific();
public:
TimerGuardType_template(): Record_Template() {}
TimerGuardType_template(template_sel other_value): Record_Template(other_value) {}
TimerGuardType_template(const TimerGuardType& other_value): Record_Template() { copy_value(&other_value); }
TimerGuardType_template(const OPTIONAL<TimerGuardType>& other_value): Record_Template() { copy_optional(&other_value); }
TimerGuardType_template(const TimerGuardType_template& other_value): Record_Template() { copy_template(other_value); }
TimerGuardType_template& operator=(template_sel other_value);
TimerGuardType_template& operator=(const TimerGuardType& other_value);
TimerGuardType_template& operator=(const OPTIONAL<TimerGuardType>& other_value);
TimerGuardType_template& operator=(const TimerGuardType_template& other_value);
inline boolean match(const TimerGuardType& other_value) const { return matchv(&other_value); }
inline void log_match(const TimerGuardType& match_value) const { log_matchv(&match_value); }
TimerGuardType valueof() const;
inline TimerGuardType_template& list_item(unsigned int list_index) const { return *(static_cast<TimerGuardType_template*>(get_list_item(list_index))); }
FLOAT_template& value__();
const FLOAT_template& value__() const;
Record_Template* create() const { return new TimerGuardType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class TimerAnyTimeoutType : public Empty_Record_Type {
public:
  TimerAnyTimeoutType();
  TimerAnyTimeoutType(const TimerAnyTimeoutType& other_value): Empty_Record_Type(other_value) {}
  TimerAnyTimeoutType(null_type) {bound_flag = TRUE;}
inline TimerAnyTimeoutType& operator=(const TimerAnyTimeoutType& other_value) { set_value(&other_value); return *this; }

inline TimerAnyTimeoutType& operator=(null_type) { bound_flag = TRUE; return *this; }
inline boolean operator==(const TimerAnyTimeoutType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const TimerAnyTimeoutType& other_value) const
    { return !is_equal(&other_value); }

Base_Type* clone() const { return new TimerAnyTimeoutType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
};

class TimerAnyTimeoutType_template : public Empty_Record_Template {
public:
TimerAnyTimeoutType_template(): Empty_Record_Template() {}
TimerAnyTimeoutType_template(null_type) : Empty_Record_Template() { set_selection(SPECIFIC_VALUE); }
TimerAnyTimeoutType_template(template_sel other_value): Empty_Record_Template(other_value) {}
TimerAnyTimeoutType_template(const TimerAnyTimeoutType& other_value): Empty_Record_Template() { copy_value(&other_value); }
TimerAnyTimeoutType_template(const OPTIONAL<TimerAnyTimeoutType>& other_value): Empty_Record_Template() { copy_optional(&other_value); }
TimerAnyTimeoutType_template(const TimerAnyTimeoutType_template& other_value): Empty_Record_Template() { copy_template(other_value); }
TimerAnyTimeoutType_template& operator=(template_sel other_value);
TimerAnyTimeoutType_template& operator=(const TimerAnyTimeoutType& other_value);
TimerAnyTimeoutType_template& operator=(const OPTIONAL<TimerAnyTimeoutType>& other_value);
TimerAnyTimeoutType_template& operator=(const TimerAnyTimeoutType_template& other_value);
TimerAnyTimeoutType_template& operator=(null_type other_value);
inline boolean match(const TimerAnyTimeoutType& other_value) const { return matchv(&other_value); }
inline void log_match(const TimerAnyTimeoutType& match_value) const { log_matchv(&match_value); }
TimerAnyTimeoutType valueof() const;
inline TimerAnyTimeoutType_template& list_item(unsigned int list_index) const { return *(static_cast<TimerAnyTimeoutType_template*>(get_list_item(list_index))); }
Empty_Record_Template* create() const { return new TimerAnyTimeoutType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class TimerEvent : public Record_Type {
  TimerEvent_choice field_choice;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  TimerEvent();
  TimerEvent(const TimerEvent& other_value);
  TimerEvent(const TimerEvent_choice& par_choice);
inline TimerEvent& operator=(const TimerEvent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TimerEvent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const TimerEvent& other_value) const
    { return !is_equal(&other_value); }

  inline TimerEvent_choice& choice()
    {return field_choice;}
  inline const TimerEvent_choice& choice() const
    {return field_choice;}
Base_Type* clone() const { return new TimerEvent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class TimerEvent_template : public Record_Template {
void set_specific();
public:
TimerEvent_template(): Record_Template() {}
TimerEvent_template(template_sel other_value): Record_Template(other_value) {}
TimerEvent_template(const TimerEvent& other_value): Record_Template() { copy_value(&other_value); }
TimerEvent_template(const OPTIONAL<TimerEvent>& other_value): Record_Template() { copy_optional(&other_value); }
TimerEvent_template(const TimerEvent_template& other_value): Record_Template() { copy_template(other_value); }
TimerEvent_template& operator=(template_sel other_value);
TimerEvent_template& operator=(const TimerEvent& other_value);
TimerEvent_template& operator=(const OPTIONAL<TimerEvent>& other_value);
TimerEvent_template& operator=(const TimerEvent_template& other_value);
inline boolean match(const TimerEvent& other_value) const { return matchv(&other_value); }
inline void log_match(const TimerEvent& match_value) const { log_matchv(&match_value); }
TimerEvent valueof() const;
inline TimerEvent_template& list_item(unsigned int list_index) const { return *(static_cast<TimerEvent_template*>(get_list_item(list_index))); }
TimerEvent_choice_template& choice();
const TimerEvent_choice_template& choice() const;
Record_Template* create() const { return new TimerEvent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class VerdictOp_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_setVerdict = 1, ALT_getVerdict = 2, ALT_finalVerdict = 3 };
private:
union_selection_type union_selection;
union {
SetVerdictType *field_setVerdict;
Verdict *field_getVerdict;
FinalVerdictType *field_finalVerdict;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const VerdictOp_choice& other_value);

public:
VerdictOp_choice();
VerdictOp_choice(const VerdictOp_choice& other_value);
~VerdictOp_choice();
VerdictOp_choice& operator=(const VerdictOp_choice& other_value);
boolean operator==(const VerdictOp_choice& other_value) const;
inline boolean operator!=(const VerdictOp_choice& other_value) const { return !(*this == other_value); }
SetVerdictType& setVerdict();
const SetVerdictType& setVerdict() const;
Verdict& getVerdict();
const Verdict& getVerdict() const;
FinalVerdictType& finalVerdict();
const FinalVerdictType& finalVerdict() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class VerdictOp_choice_template : public Base_Template {
union {
struct {
VerdictOp_choice::union_selection_type union_selection;
union {
SetVerdictType_template *field_setVerdict;
Verdict_template *field_getVerdict;
FinalVerdictType_template *field_finalVerdict;
};
} single_value;
struct {
unsigned int n_values;
VerdictOp_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const VerdictOp_choice& other_value);

void copy_template(const VerdictOp_choice_template& other_value);

public:
VerdictOp_choice_template();
VerdictOp_choice_template(template_sel other_value);
VerdictOp_choice_template(const VerdictOp_choice& other_value);
VerdictOp_choice_template(const OPTIONAL<VerdictOp_choice>& other_value);
VerdictOp_choice_template(const VerdictOp_choice_template& other_value);
~VerdictOp_choice_template();
void clean_up();
VerdictOp_choice_template& operator=(template_sel other_value);
VerdictOp_choice_template& operator=(const VerdictOp_choice& other_value);
VerdictOp_choice_template& operator=(const OPTIONAL<VerdictOp_choice>& other_value);
VerdictOp_choice_template& operator=(const VerdictOp_choice_template& other_value);
boolean match(const VerdictOp_choice& other_value) const;
boolean is_value() const;VerdictOp_choice valueof() const;
VerdictOp_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
SetVerdictType_template& setVerdict();
const SetVerdictType_template& setVerdict() const;
Verdict_template& getVerdict();
const Verdict_template& getVerdict() const;
FinalVerdictType_template& finalVerdict();
const FinalVerdictType_template& finalVerdict() const;
boolean ischosen(VerdictOp_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const VerdictOp_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class SetVerdictType : public Record_Type {
  Verdict field_newVerdict;
  Verdict field_oldVerdict;
  Verdict field_localVerdict;
  OPTIONAL<CHARSTRING> field_oldReason;
  OPTIONAL<CHARSTRING> field_newReason;
  Base_Type* fld_vec[5];
  void init_vec();
public:
  SetVerdictType();
  SetVerdictType(const SetVerdictType& other_value);
  SetVerdictType(const Verdict& par_newVerdict,
    const Verdict& par_oldVerdict,
    const Verdict& par_localVerdict,
    const OPTIONAL<CHARSTRING>& par_oldReason,
    const OPTIONAL<CHARSTRING>& par_newReason);
inline SetVerdictType& operator=(const SetVerdictType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const SetVerdictType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const SetVerdictType& other_value) const
    { return !is_equal(&other_value); }

  inline Verdict& newVerdict()
    {return field_newVerdict;}
  inline const Verdict& newVerdict() const
    {return field_newVerdict;}
  inline Verdict& oldVerdict()
    {return field_oldVerdict;}
  inline const Verdict& oldVerdict() const
    {return field_oldVerdict;}
  inline Verdict& localVerdict()
    {return field_localVerdict;}
  inline const Verdict& localVerdict() const
    {return field_localVerdict;}
  inline OPTIONAL<CHARSTRING>& oldReason()
    {return field_oldReason;}
  inline const OPTIONAL<CHARSTRING>& oldReason() const
    {return field_oldReason;}
  inline OPTIONAL<CHARSTRING>& newReason()
    {return field_newReason;}
  inline const OPTIONAL<CHARSTRING>& newReason() const
    {return field_newReason;}
Base_Type* clone() const { return new SetVerdictType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 5; }
int optional_count() const { return 2; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const int optional_indexes[];
const int* get_optional_indexes() const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class SetVerdictType_template : public Record_Template {
void set_specific();
public:
SetVerdictType_template(): Record_Template() {}
SetVerdictType_template(template_sel other_value): Record_Template(other_value) {}
SetVerdictType_template(const SetVerdictType& other_value): Record_Template() { copy_value(&other_value); }
SetVerdictType_template(const OPTIONAL<SetVerdictType>& other_value): Record_Template() { copy_optional(&other_value); }
SetVerdictType_template(const SetVerdictType_template& other_value): Record_Template() { copy_template(other_value); }
SetVerdictType_template& operator=(template_sel other_value);
SetVerdictType_template& operator=(const SetVerdictType& other_value);
SetVerdictType_template& operator=(const OPTIONAL<SetVerdictType>& other_value);
SetVerdictType_template& operator=(const SetVerdictType_template& other_value);
inline boolean match(const SetVerdictType& other_value) const { return matchv(&other_value); }
inline void log_match(const SetVerdictType& match_value) const { log_matchv(&match_value); }
SetVerdictType valueof() const;
inline SetVerdictType_template& list_item(unsigned int list_index) const { return *(static_cast<SetVerdictType_template*>(get_list_item(list_index))); }
Verdict_template& newVerdict();
const Verdict_template& newVerdict() const;
Verdict_template& oldVerdict();
const Verdict_template& oldVerdict() const;
Verdict_template& localVerdict();
const Verdict_template& localVerdict() const;
CHARSTRING_template& oldReason();
const CHARSTRING_template& oldReason() const;
CHARSTRING_template& newReason();
const CHARSTRING_template& newReason() const;
Record_Template* create() const { return new SetVerdictType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class FinalVerdictType_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_info = 1, ALT_notification = 2 };
private:
union_selection_type union_selection;
union {
FinalVerdictInfo *field_info;
FinalVerdictType_choice_notification *field_notification;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const FinalVerdictType_choice& other_value);

public:
FinalVerdictType_choice();
FinalVerdictType_choice(const FinalVerdictType_choice& other_value);
~FinalVerdictType_choice();
FinalVerdictType_choice& operator=(const FinalVerdictType_choice& other_value);
boolean operator==(const FinalVerdictType_choice& other_value) const;
inline boolean operator!=(const FinalVerdictType_choice& other_value) const { return !(*this == other_value); }
FinalVerdictInfo& info();
const FinalVerdictInfo& info() const;
FinalVerdictType_choice_notification& notification();
const FinalVerdictType_choice_notification& notification() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class FinalVerdictType_choice_template : public Base_Template {
union {
struct {
FinalVerdictType_choice::union_selection_type union_selection;
union {
FinalVerdictInfo_template *field_info;
FinalVerdictType_choice_notification_template *field_notification;
};
} single_value;
struct {
unsigned int n_values;
FinalVerdictType_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const FinalVerdictType_choice& other_value);

void copy_template(const FinalVerdictType_choice_template& other_value);

public:
FinalVerdictType_choice_template();
FinalVerdictType_choice_template(template_sel other_value);
FinalVerdictType_choice_template(const FinalVerdictType_choice& other_value);
FinalVerdictType_choice_template(const OPTIONAL<FinalVerdictType_choice>& other_value);
FinalVerdictType_choice_template(const FinalVerdictType_choice_template& other_value);
~FinalVerdictType_choice_template();
void clean_up();
FinalVerdictType_choice_template& operator=(template_sel other_value);
FinalVerdictType_choice_template& operator=(const FinalVerdictType_choice& other_value);
FinalVerdictType_choice_template& operator=(const OPTIONAL<FinalVerdictType_choice>& other_value);
FinalVerdictType_choice_template& operator=(const FinalVerdictType_choice_template& other_value);
boolean match(const FinalVerdictType_choice& other_value) const;
boolean is_value() const;FinalVerdictType_choice valueof() const;
FinalVerdictType_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
FinalVerdictInfo_template& info();
const FinalVerdictInfo_template& info() const;
FinalVerdictType_choice_notification_template& notification();
const FinalVerdictType_choice_notification_template& notification() const;
boolean ischosen(FinalVerdictType_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const FinalVerdictType_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class FinalVerdictInfo : public Record_Type {
  BOOLEAN field_is__ptc;
  Verdict field_ptc__verdict;
  Verdict field_local__verdict;
  Verdict field_new__verdict;
  OPTIONAL<CHARSTRING> field_verdict__reason;
  OPTIONAL<INTEGER> field_ptc__compref;
  OPTIONAL<CHARSTRING> field_ptc__name;
  Base_Type* fld_vec[7];
  void init_vec();
public:
  FinalVerdictInfo();
  FinalVerdictInfo(const FinalVerdictInfo& other_value);
  FinalVerdictInfo(const BOOLEAN& par_is__ptc,
    const Verdict& par_ptc__verdict,
    const Verdict& par_local__verdict,
    const Verdict& par_new__verdict,
    const OPTIONAL<CHARSTRING>& par_verdict__reason,
    const OPTIONAL<INTEGER>& par_ptc__compref,
    const OPTIONAL<CHARSTRING>& par_ptc__name);
inline FinalVerdictInfo& operator=(const FinalVerdictInfo& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const FinalVerdictInfo& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const FinalVerdictInfo& other_value) const
    { return !is_equal(&other_value); }

  inline BOOLEAN& is__ptc()
    {return field_is__ptc;}
  inline const BOOLEAN& is__ptc() const
    {return field_is__ptc;}
  inline Verdict& ptc__verdict()
    {return field_ptc__verdict;}
  inline const Verdict& ptc__verdict() const
    {return field_ptc__verdict;}
  inline Verdict& local__verdict()
    {return field_local__verdict;}
  inline const Verdict& local__verdict() const
    {return field_local__verdict;}
  inline Verdict& new__verdict()
    {return field_new__verdict;}
  inline const Verdict& new__verdict() const
    {return field_new__verdict;}
  inline OPTIONAL<CHARSTRING>& verdict__reason()
    {return field_verdict__reason;}
  inline const OPTIONAL<CHARSTRING>& verdict__reason() const
    {return field_verdict__reason;}
  inline OPTIONAL<INTEGER>& ptc__compref()
    {return field_ptc__compref;}
  inline const OPTIONAL<INTEGER>& ptc__compref() const
    {return field_ptc__compref;}
  inline OPTIONAL<CHARSTRING>& ptc__name()
    {return field_ptc__name;}
  inline const OPTIONAL<CHARSTRING>& ptc__name() const
    {return field_ptc__name;}
Base_Type* clone() const { return new FinalVerdictInfo(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 7; }
int optional_count() const { return 3; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const int optional_indexes[];
const int* get_optional_indexes() const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class FinalVerdictInfo_template : public Record_Template {
void set_specific();
public:
FinalVerdictInfo_template(): Record_Template() {}
FinalVerdictInfo_template(template_sel other_value): Record_Template(other_value) {}
FinalVerdictInfo_template(const FinalVerdictInfo& other_value): Record_Template() { copy_value(&other_value); }
FinalVerdictInfo_template(const OPTIONAL<FinalVerdictInfo>& other_value): Record_Template() { copy_optional(&other_value); }
FinalVerdictInfo_template(const FinalVerdictInfo_template& other_value): Record_Template() { copy_template(other_value); }
FinalVerdictInfo_template& operator=(template_sel other_value);
FinalVerdictInfo_template& operator=(const FinalVerdictInfo& other_value);
FinalVerdictInfo_template& operator=(const OPTIONAL<FinalVerdictInfo>& other_value);
FinalVerdictInfo_template& operator=(const FinalVerdictInfo_template& other_value);
inline boolean match(const FinalVerdictInfo& other_value) const { return matchv(&other_value); }
inline void log_match(const FinalVerdictInfo& match_value) const { log_matchv(&match_value); }
FinalVerdictInfo valueof() const;
inline FinalVerdictInfo_template& list_item(unsigned int list_index) const { return *(static_cast<FinalVerdictInfo_template*>(get_list_item(list_index))); }
BOOLEAN_template& is__ptc();
const BOOLEAN_template& is__ptc() const;
Verdict_template& ptc__verdict();
const Verdict_template& ptc__verdict() const;
Verdict_template& local__verdict();
const Verdict_template& local__verdict() const;
Verdict_template& new__verdict();
const Verdict_template& new__verdict() const;
CHARSTRING_template& verdict__reason();
const CHARSTRING_template& verdict__reason() const;
INTEGER_template& ptc__compref();
const INTEGER_template& ptc__compref() const;
CHARSTRING_template& ptc__name();
const CHARSTRING_template& ptc__name() const;
Record_Template* create() const { return new FinalVerdictInfo_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class FinalVerdictType_choice_notification : public Enum_Type { // enum
friend class FinalVerdictType_choice_notification_template;
public:
enum enum_type { no__ptcs__were__created = 0, setting__final__verdict__of__the__test__case = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
FinalVerdictType_choice_notification();
FinalVerdictType_choice_notification(int other_value);
FinalVerdictType_choice_notification(enum_type other_value);
FinalVerdictType_choice_notification(const FinalVerdictType_choice_notification& other_value);

FinalVerdictType_choice_notification& operator=(int other_value);
FinalVerdictType_choice_notification& operator=(enum_type other_value);
FinalVerdictType_choice_notification& operator=(const FinalVerdictType_choice_notification& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const FinalVerdictType_choice_notification& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const FinalVerdictType_choice_notification& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const FinalVerdictType_choice_notification& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const FinalVerdictType_choice_notification& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const FinalVerdictType_choice_notification& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const FinalVerdictType_choice_notification& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const FinalVerdictType_choice_notification& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class FinalVerdictType_choice_notification_template : public Base_Template {
union {
FinalVerdictType_choice_notification::enum_type single_value;
struct {
unsigned int n_values;
FinalVerdictType_choice_notification_template *list_value;
} value_list;
};

void copy_template(const FinalVerdictType_choice_notification_template& other_value);

public:
FinalVerdictType_choice_notification_template();
FinalVerdictType_choice_notification_template(template_sel other_value);
FinalVerdictType_choice_notification_template(int other_value);
FinalVerdictType_choice_notification_template(FinalVerdictType_choice_notification::enum_type other_value);
FinalVerdictType_choice_notification_template(const FinalVerdictType_choice_notification& other_value);
FinalVerdictType_choice_notification_template(const OPTIONAL<FinalVerdictType_choice_notification>& other_value);
FinalVerdictType_choice_notification_template(const FinalVerdictType_choice_notification_template& other_value);
~FinalVerdictType_choice_notification_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
FinalVerdictType_choice_notification_template& operator=(template_sel other_value);
FinalVerdictType_choice_notification_template& operator=(int other_value);
FinalVerdictType_choice_notification_template& operator=(FinalVerdictType_choice_notification::enum_type other_value);
FinalVerdictType_choice_notification_template& operator=(const FinalVerdictType_choice_notification& other_value);
FinalVerdictType_choice_notification_template& operator=(const OPTIONAL<FinalVerdictType_choice_notification>& other_value);
FinalVerdictType_choice_notification_template& operator=(const FinalVerdictType_choice_notification_template& other_value);

boolean match(FinalVerdictType_choice_notification::enum_type other_value) const;
boolean match(const FinalVerdictType_choice_notification& other_value) const;
FinalVerdictType_choice_notification::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
FinalVerdictType_choice_notification_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const FinalVerdictType_choice_notification& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class FinalVerdictType : public Record_Type {
  FinalVerdictType_choice field_choice;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  FinalVerdictType();
  FinalVerdictType(const FinalVerdictType& other_value);
  FinalVerdictType(const FinalVerdictType_choice& par_choice);
inline FinalVerdictType& operator=(const FinalVerdictType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const FinalVerdictType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const FinalVerdictType& other_value) const
    { return !is_equal(&other_value); }

  inline FinalVerdictType_choice& choice()
    {return field_choice;}
  inline const FinalVerdictType_choice& choice() const
    {return field_choice;}
Base_Type* clone() const { return new FinalVerdictType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class FinalVerdictType_template : public Record_Template {
void set_specific();
public:
FinalVerdictType_template(): Record_Template() {}
FinalVerdictType_template(template_sel other_value): Record_Template(other_value) {}
FinalVerdictType_template(const FinalVerdictType& other_value): Record_Template() { copy_value(&other_value); }
FinalVerdictType_template(const OPTIONAL<FinalVerdictType>& other_value): Record_Template() { copy_optional(&other_value); }
FinalVerdictType_template(const FinalVerdictType_template& other_value): Record_Template() { copy_template(other_value); }
FinalVerdictType_template& operator=(template_sel other_value);
FinalVerdictType_template& operator=(const FinalVerdictType& other_value);
FinalVerdictType_template& operator=(const OPTIONAL<FinalVerdictType>& other_value);
FinalVerdictType_template& operator=(const FinalVerdictType_template& other_value);
inline boolean match(const FinalVerdictType& other_value) const { return matchv(&other_value); }
inline void log_match(const FinalVerdictType& match_value) const { log_matchv(&match_value); }
FinalVerdictType valueof() const;
inline FinalVerdictType_template& list_item(unsigned int list_index) const { return *(static_cast<FinalVerdictType_template*>(get_list_item(list_index))); }
FinalVerdictType_choice_template& choice();
const FinalVerdictType_choice_template& choice() const;
Record_Template* create() const { return new FinalVerdictType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class VerdictOp : public Record_Type {
  VerdictOp_choice field_choice;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  VerdictOp();
  VerdictOp(const VerdictOp& other_value);
  VerdictOp(const VerdictOp_choice& par_choice);
inline VerdictOp& operator=(const VerdictOp& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const VerdictOp& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const VerdictOp& other_value) const
    { return !is_equal(&other_value); }

  inline VerdictOp_choice& choice()
    {return field_choice;}
  inline const VerdictOp_choice& choice() const
    {return field_choice;}
Base_Type* clone() const { return new VerdictOp(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class VerdictOp_template : public Record_Template {
void set_specific();
public:
VerdictOp_template(): Record_Template() {}
VerdictOp_template(template_sel other_value): Record_Template(other_value) {}
VerdictOp_template(const VerdictOp& other_value): Record_Template() { copy_value(&other_value); }
VerdictOp_template(const OPTIONAL<VerdictOp>& other_value): Record_Template() { copy_optional(&other_value); }
VerdictOp_template(const VerdictOp_template& other_value): Record_Template() { copy_template(other_value); }
VerdictOp_template& operator=(template_sel other_value);
VerdictOp_template& operator=(const VerdictOp& other_value);
VerdictOp_template& operator=(const OPTIONAL<VerdictOp>& other_value);
VerdictOp_template& operator=(const VerdictOp_template& other_value);
inline boolean match(const VerdictOp& other_value) const { return matchv(&other_value); }
inline void log_match(const VerdictOp& match_value) const { log_matchv(&match_value); }
VerdictOp valueof() const;
inline VerdictOp_template& list_item(unsigned int list_index) const { return *(static_cast<VerdictOp_template*>(get_list_item(list_index))); }
VerdictOp_choice_template& choice();
const VerdictOp_choice_template& choice() const;
Record_Template* create() const { return new VerdictOp_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class MatchingEvent_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_matchingDone = 1, ALT_matchingSuccess = 2, ALT_matchingFailure = 3, ALT_matchingProblem = 4, ALT_matchingTimeout = 5 };
private:
union_selection_type union_selection;
union {
MatchingDoneType *field_matchingDone;
MatchingSuccessType *field_matchingSuccess;
MatchingFailureType *field_matchingFailure;
MatchingProblemType *field_matchingProblem;
MatchingTimeout *field_matchingTimeout;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const MatchingEvent_choice& other_value);

public:
MatchingEvent_choice();
MatchingEvent_choice(const MatchingEvent_choice& other_value);
~MatchingEvent_choice();
MatchingEvent_choice& operator=(const MatchingEvent_choice& other_value);
boolean operator==(const MatchingEvent_choice& other_value) const;
inline boolean operator!=(const MatchingEvent_choice& other_value) const { return !(*this == other_value); }
MatchingDoneType& matchingDone();
const MatchingDoneType& matchingDone() const;
MatchingSuccessType& matchingSuccess();
const MatchingSuccessType& matchingSuccess() const;
MatchingFailureType& matchingFailure();
const MatchingFailureType& matchingFailure() const;
MatchingProblemType& matchingProblem();
const MatchingProblemType& matchingProblem() const;
MatchingTimeout& matchingTimeout();
const MatchingTimeout& matchingTimeout() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class MatchingEvent_choice_template : public Base_Template {
union {
struct {
MatchingEvent_choice::union_selection_type union_selection;
union {
MatchingDoneType_template *field_matchingDone;
MatchingSuccessType_template *field_matchingSuccess;
MatchingFailureType_template *field_matchingFailure;
MatchingProblemType_template *field_matchingProblem;
MatchingTimeout_template *field_matchingTimeout;
};
} single_value;
struct {
unsigned int n_values;
MatchingEvent_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const MatchingEvent_choice& other_value);

void copy_template(const MatchingEvent_choice_template& other_value);

public:
MatchingEvent_choice_template();
MatchingEvent_choice_template(template_sel other_value);
MatchingEvent_choice_template(const MatchingEvent_choice& other_value);
MatchingEvent_choice_template(const OPTIONAL<MatchingEvent_choice>& other_value);
MatchingEvent_choice_template(const MatchingEvent_choice_template& other_value);
~MatchingEvent_choice_template();
void clean_up();
MatchingEvent_choice_template& operator=(template_sel other_value);
MatchingEvent_choice_template& operator=(const MatchingEvent_choice& other_value);
MatchingEvent_choice_template& operator=(const OPTIONAL<MatchingEvent_choice>& other_value);
MatchingEvent_choice_template& operator=(const MatchingEvent_choice_template& other_value);
boolean match(const MatchingEvent_choice& other_value) const;
boolean is_value() const;MatchingEvent_choice valueof() const;
MatchingEvent_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
MatchingDoneType_template& matchingDone();
const MatchingDoneType_template& matchingDone() const;
MatchingSuccessType_template& matchingSuccess();
const MatchingSuccessType_template& matchingSuccess() const;
MatchingFailureType_template& matchingFailure();
const MatchingFailureType_template& matchingFailure() const;
MatchingProblemType_template& matchingProblem();
const MatchingProblemType_template& matchingProblem() const;
MatchingTimeout_template& matchingTimeout();
const MatchingTimeout_template& matchingTimeout() const;
boolean ischosen(MatchingEvent_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const MatchingEvent_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class MatchingDoneType_reason : public Enum_Type { // enum
friend class MatchingDoneType_reason_template;
public:
enum enum_type { done__failed__wrong__return__type = 0, done__failed__no__return = 1, any__component__done__successful = 2, any__component__done__failed = 3, all__component__done__successful = 4, any__component__killed__successful = 5, any__component__killed__failed = 6, all__component__killed__successful = 7, UNKNOWN_VALUE = 8, UNBOUND_VALUE = 9 };
private:
enum_type enum_value;

public:
MatchingDoneType_reason();
MatchingDoneType_reason(int other_value);
MatchingDoneType_reason(enum_type other_value);
MatchingDoneType_reason(const MatchingDoneType_reason& other_value);

MatchingDoneType_reason& operator=(int other_value);
MatchingDoneType_reason& operator=(enum_type other_value);
MatchingDoneType_reason& operator=(const MatchingDoneType_reason& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const MatchingDoneType_reason& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MatchingDoneType_reason& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const MatchingDoneType_reason& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const MatchingDoneType_reason& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const MatchingDoneType_reason& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const MatchingDoneType_reason& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const MatchingDoneType_reason& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class MatchingDoneType_reason_template : public Base_Template {
union {
MatchingDoneType_reason::enum_type single_value;
struct {
unsigned int n_values;
MatchingDoneType_reason_template *list_value;
} value_list;
};

void copy_template(const MatchingDoneType_reason_template& other_value);

public:
MatchingDoneType_reason_template();
MatchingDoneType_reason_template(template_sel other_value);
MatchingDoneType_reason_template(int other_value);
MatchingDoneType_reason_template(MatchingDoneType_reason::enum_type other_value);
MatchingDoneType_reason_template(const MatchingDoneType_reason& other_value);
MatchingDoneType_reason_template(const OPTIONAL<MatchingDoneType_reason>& other_value);
MatchingDoneType_reason_template(const MatchingDoneType_reason_template& other_value);
~MatchingDoneType_reason_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
MatchingDoneType_reason_template& operator=(template_sel other_value);
MatchingDoneType_reason_template& operator=(int other_value);
MatchingDoneType_reason_template& operator=(MatchingDoneType_reason::enum_type other_value);
MatchingDoneType_reason_template& operator=(const MatchingDoneType_reason& other_value);
MatchingDoneType_reason_template& operator=(const OPTIONAL<MatchingDoneType_reason>& other_value);
MatchingDoneType_reason_template& operator=(const MatchingDoneType_reason_template& other_value);

boolean match(MatchingDoneType_reason::enum_type other_value) const;
boolean match(const MatchingDoneType_reason& other_value) const;
MatchingDoneType_reason::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MatchingDoneType_reason_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const MatchingDoneType_reason& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class MatchingDoneType : public Record_Type {
  MatchingDoneType_reason field_reason;
  CHARSTRING field_type__;
  INTEGER field_ptc;
  CHARSTRING field_return__type;
  Base_Type* fld_vec[4];
  void init_vec();
public:
  MatchingDoneType();
  MatchingDoneType(const MatchingDoneType& other_value);
  MatchingDoneType(const MatchingDoneType_reason& par_reason,
    const CHARSTRING& par_type__,
    const INTEGER& par_ptc,
    const CHARSTRING& par_return__type);
inline MatchingDoneType& operator=(const MatchingDoneType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const MatchingDoneType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const MatchingDoneType& other_value) const
    { return !is_equal(&other_value); }

  inline MatchingDoneType_reason& reason()
    {return field_reason;}
  inline const MatchingDoneType_reason& reason() const
    {return field_reason;}
  inline CHARSTRING& type__()
    {return field_type__;}
  inline const CHARSTRING& type__() const
    {return field_type__;}
  inline INTEGER& ptc()
    {return field_ptc;}
  inline const INTEGER& ptc() const
    {return field_ptc;}
  inline CHARSTRING& return__type()
    {return field_return__type;}
  inline const CHARSTRING& return__type() const
    {return field_return__type;}
Base_Type* clone() const { return new MatchingDoneType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 4; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class MatchingDoneType_template : public Record_Template {
void set_specific();
public:
MatchingDoneType_template(): Record_Template() {}
MatchingDoneType_template(template_sel other_value): Record_Template(other_value) {}
MatchingDoneType_template(const MatchingDoneType& other_value): Record_Template() { copy_value(&other_value); }
MatchingDoneType_template(const OPTIONAL<MatchingDoneType>& other_value): Record_Template() { copy_optional(&other_value); }
MatchingDoneType_template(const MatchingDoneType_template& other_value): Record_Template() { copy_template(other_value); }
MatchingDoneType_template& operator=(template_sel other_value);
MatchingDoneType_template& operator=(const MatchingDoneType& other_value);
MatchingDoneType_template& operator=(const OPTIONAL<MatchingDoneType>& other_value);
MatchingDoneType_template& operator=(const MatchingDoneType_template& other_value);
inline boolean match(const MatchingDoneType& other_value) const { return matchv(&other_value); }
inline void log_match(const MatchingDoneType& match_value) const { log_matchv(&match_value); }
MatchingDoneType valueof() const;
inline MatchingDoneType_template& list_item(unsigned int list_index) const { return *(static_cast<MatchingDoneType_template*>(get_list_item(list_index))); }
MatchingDoneType_reason_template& reason();
const MatchingDoneType_reason_template& reason() const;
CHARSTRING_template& type__();
const CHARSTRING_template& type__() const;
INTEGER_template& ptc();
const INTEGER_template& ptc() const;
CHARSTRING_template& return__type();
const CHARSTRING_template& return__type() const;
Record_Template* create() const { return new MatchingDoneType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class PortType : public Enum_Type { // enum
friend class PortType_template;
public:
enum enum_type { message__ = 0, procedure__ = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
PortType();
PortType(int other_value);
PortType(enum_type other_value);
PortType(const PortType& other_value);

PortType& operator=(int other_value);
PortType& operator=(enum_type other_value);
PortType& operator=(const PortType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const PortType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PortType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const PortType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const PortType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const PortType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const PortType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const PortType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PortType_template : public Base_Template {
union {
PortType::enum_type single_value;
struct {
unsigned int n_values;
PortType_template *list_value;
} value_list;
};

void copy_template(const PortType_template& other_value);

public:
PortType_template();
PortType_template(template_sel other_value);
PortType_template(int other_value);
PortType_template(PortType::enum_type other_value);
PortType_template(const PortType& other_value);
PortType_template(const OPTIONAL<PortType>& other_value);
PortType_template(const PortType_template& other_value);
~PortType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
PortType_template& operator=(template_sel other_value);
PortType_template& operator=(int other_value);
PortType_template& operator=(PortType::enum_type other_value);
PortType_template& operator=(const PortType& other_value);
PortType_template& operator=(const OPTIONAL<PortType>& other_value);
PortType_template& operator=(const PortType_template& other_value);

boolean match(PortType::enum_type other_value) const;
boolean match(const PortType& other_value) const;
PortType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PortType_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const PortType& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class MatchingSuccessType : public Record_Type {
  PortType field_port__type;
  CHARSTRING field_port__name;
  CHARSTRING field_info;
  Base_Type* fld_vec[3];
  void init_vec();
public:
  MatchingSuccessType();
  MatchingSuccessType(const MatchingSuccessType& other_value);
  MatchingSuccessType(const PortType& par_port__type,
    const CHARSTRING& par_port__name,
    const CHARSTRING& par_info);
inline MatchingSuccessType& operator=(const MatchingSuccessType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const MatchingSuccessType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const MatchingSuccessType& other_value) const
    { return !is_equal(&other_value); }

  inline PortType& port__type()
    {return field_port__type;}
  inline const PortType& port__type() const
    {return field_port__type;}
  inline CHARSTRING& port__name()
    {return field_port__name;}
  inline const CHARSTRING& port__name() const
    {return field_port__name;}
  inline CHARSTRING& info()
    {return field_info;}
  inline const CHARSTRING& info() const
    {return field_info;}
Base_Type* clone() const { return new MatchingSuccessType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 3; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class MatchingSuccessType_template : public Record_Template {
void set_specific();
public:
MatchingSuccessType_template(): Record_Template() {}
MatchingSuccessType_template(template_sel other_value): Record_Template(other_value) {}
MatchingSuccessType_template(const MatchingSuccessType& other_value): Record_Template() { copy_value(&other_value); }
MatchingSuccessType_template(const OPTIONAL<MatchingSuccessType>& other_value): Record_Template() { copy_optional(&other_value); }
MatchingSuccessType_template(const MatchingSuccessType_template& other_value): Record_Template() { copy_template(other_value); }
MatchingSuccessType_template& operator=(template_sel other_value);
MatchingSuccessType_template& operator=(const MatchingSuccessType& other_value);
MatchingSuccessType_template& operator=(const OPTIONAL<MatchingSuccessType>& other_value);
MatchingSuccessType_template& operator=(const MatchingSuccessType_template& other_value);
inline boolean match(const MatchingSuccessType& other_value) const { return matchv(&other_value); }
inline void log_match(const MatchingSuccessType& match_value) const { log_matchv(&match_value); }
MatchingSuccessType valueof() const;
inline MatchingSuccessType_template& list_item(unsigned int list_index) const { return *(static_cast<MatchingSuccessType_template*>(get_list_item(list_index))); }
PortType_template& port__type();
const PortType_template& port__type() const;
CHARSTRING_template& port__name();
const CHARSTRING_template& port__name() const;
CHARSTRING_template& info();
const CHARSTRING_template& info() const;
Record_Template* create() const { return new MatchingSuccessType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class MatchingFailureType_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_system__ = 1, ALT_compref = 2 };
private:
union_selection_type union_selection;
union {
CHARSTRING *field_system__;
INTEGER *field_compref;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const MatchingFailureType_choice& other_value);

public:
MatchingFailureType_choice();
MatchingFailureType_choice(const MatchingFailureType_choice& other_value);
~MatchingFailureType_choice();
MatchingFailureType_choice& operator=(const MatchingFailureType_choice& other_value);
boolean operator==(const MatchingFailureType_choice& other_value) const;
inline boolean operator!=(const MatchingFailureType_choice& other_value) const { return !(*this == other_value); }
CHARSTRING& system__();
const CHARSTRING& system__() const;
INTEGER& compref();
const INTEGER& compref() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
int XER_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const;
};

class MatchingFailureType_choice_template : public Base_Template {
union {
struct {
MatchingFailureType_choice::union_selection_type union_selection;
union {
CHARSTRING_template *field_system__;
INTEGER_template *field_compref;
};
} single_value;
struct {
unsigned int n_values;
MatchingFailureType_choice_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const MatchingFailureType_choice& other_value);

void copy_template(const MatchingFailureType_choice_template& other_value);

public:
MatchingFailureType_choice_template();
MatchingFailureType_choice_template(template_sel other_value);
MatchingFailureType_choice_template(const MatchingFailureType_choice& other_value);
MatchingFailureType_choice_template(const OPTIONAL<MatchingFailureType_choice>& other_value);
MatchingFailureType_choice_template(const MatchingFailureType_choice_template& other_value);
~MatchingFailureType_choice_template();
void clean_up();
MatchingFailureType_choice_template& operator=(template_sel other_value);
MatchingFailureType_choice_template& operator=(const MatchingFailureType_choice& other_value);
MatchingFailureType_choice_template& operator=(const OPTIONAL<MatchingFailureType_choice>& other_value);
MatchingFailureType_choice_template& operator=(const MatchingFailureType_choice_template& other_value);
boolean match(const MatchingFailureType_choice& other_value) const;
boolean is_value() const;MatchingFailureType_choice valueof() const;
MatchingFailureType_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
CHARSTRING_template& system__();
const CHARSTRING_template& system__() const;
INTEGER_template& compref();
const INTEGER_template& compref() const;
boolean ischosen(MatchingFailureType_choice::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const MatchingFailureType_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class MatchingFailureType_reason : public Enum_Type { // enum
friend class MatchingFailureType_reason_template;
public:
enum enum_type { sender__does__not__match__from__clause = 0, sender__is__not__system = 1, message__does__not__match__template = 2, parameters__of__call__do__not__match__template = 3, parameters__of__reply__do__not__match__template = 4, exception__does__not__match__template = 5, not__an__exception__for__signature = 6, UNKNOWN_VALUE = 7, UNBOUND_VALUE = 8 };
private:
enum_type enum_value;

public:
MatchingFailureType_reason();
MatchingFailureType_reason(int other_value);
MatchingFailureType_reason(enum_type other_value);
MatchingFailureType_reason(const MatchingFailureType_reason& other_value);

MatchingFailureType_reason& operator=(int other_value);
MatchingFailureType_reason& operator=(enum_type other_value);
MatchingFailureType_reason& operator=(const MatchingFailureType_reason& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const MatchingFailureType_reason& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MatchingFailureType_reason& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const MatchingFailureType_reason& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const MatchingFailureType_reason& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const MatchingFailureType_reason& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const MatchingFailureType_reason& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const MatchingFailureType_reason& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class MatchingFailureType_reason_template : public Base_Template {
union {
MatchingFailureType_reason::enum_type single_value;
struct {
unsigned int n_values;
MatchingFailureType_reason_template *list_value;
} value_list;
};

void copy_template(const MatchingFailureType_reason_template& other_value);

public:
MatchingFailureType_reason_template();
MatchingFailureType_reason_template(template_sel other_value);
MatchingFailureType_reason_template(int other_value);
MatchingFailureType_reason_template(MatchingFailureType_reason::enum_type other_value);
MatchingFailureType_reason_template(const MatchingFailureType_reason& other_value);
MatchingFailureType_reason_template(const OPTIONAL<MatchingFailureType_reason>& other_value);
MatchingFailureType_reason_template(const MatchingFailureType_reason_template& other_value);
~MatchingFailureType_reason_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
MatchingFailureType_reason_template& operator=(template_sel other_value);
MatchingFailureType_reason_template& operator=(int other_value);
MatchingFailureType_reason_template& operator=(MatchingFailureType_reason::enum_type other_value);
MatchingFailureType_reason_template& operator=(const MatchingFailureType_reason& other_value);
MatchingFailureType_reason_template& operator=(const OPTIONAL<MatchingFailureType_reason>& other_value);
MatchingFailureType_reason_template& operator=(const MatchingFailureType_reason_template& other_value);

boolean match(MatchingFailureType_reason::enum_type other_value) const;
boolean match(const MatchingFailureType_reason& other_value) const;
MatchingFailureType_reason::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MatchingFailureType_reason_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const MatchingFailureType_reason& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class MatchingFailureType : public Record_Type {
  PortType field_port__type;
  CHARSTRING field_port__name;
  MatchingFailureType_choice field_choice;
  MatchingFailureType_reason field_reason;
  CHARSTRING field_info;
  Base_Type* fld_vec[5];
  void init_vec();
public:
  MatchingFailureType();
  MatchingFailureType(const MatchingFailureType& other_value);
  MatchingFailureType(const PortType& par_port__type,
    const CHARSTRING& par_port__name,
    const MatchingFailureType_choice& par_choice,
    const MatchingFailureType_reason& par_reason,
    const CHARSTRING& par_info);
inline MatchingFailureType& operator=(const MatchingFailureType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const MatchingFailureType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const MatchingFailureType& other_value) const
    { return !is_equal(&other_value); }

  inline PortType& port__type()
    {return field_port__type;}
  inline const PortType& port__type() const
    {return field_port__type;}
  inline CHARSTRING& port__name()
    {return field_port__name;}
  inline const CHARSTRING& port__name() const
    {return field_port__name;}
  inline MatchingFailureType_choice& choice()
    {return field_choice;}
  inline const MatchingFailureType_choice& choice() const
    {return field_choice;}
  inline MatchingFailureType_reason& reason()
    {return field_reason;}
  inline const MatchingFailureType_reason& reason() const
    {return field_reason;}
  inline CHARSTRING& info()
    {return field_info;}
  inline const CHARSTRING& info() const
    {return field_info;}
Base_Type* clone() const { return new MatchingFailureType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 5; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class MatchingFailureType_template : public Record_Template {
void set_specific();
public:
MatchingFailureType_template(): Record_Template() {}
MatchingFailureType_template(template_sel other_value): Record_Template(other_value) {}
MatchingFailureType_template(const MatchingFailureType& other_value): Record_Template() { copy_value(&other_value); }
MatchingFailureType_template(const OPTIONAL<MatchingFailureType>& other_value): Record_Template() { copy_optional(&other_value); }
MatchingFailureType_template(const MatchingFailureType_template& other_value): Record_Template() { copy_template(other_value); }
MatchingFailureType_template& operator=(template_sel other_value);
MatchingFailureType_template& operator=(const MatchingFailureType& other_value);
MatchingFailureType_template& operator=(const OPTIONAL<MatchingFailureType>& other_value);
MatchingFailureType_template& operator=(const MatchingFailureType_template& other_value);
inline boolean match(const MatchingFailureType& other_value) const { return matchv(&other_value); }
inline void log_match(const MatchingFailureType& match_value) const { log_matchv(&match_value); }
MatchingFailureType valueof() const;
inline MatchingFailureType_template& list_item(unsigned int list_index) const { return *(static_cast<MatchingFailureType_template*>(get_list_item(list_index))); }
PortType_template& port__type();
const PortType_template& port__type() const;
CHARSTRING_template& port__name();
const CHARSTRING_template& port__name() const;
MatchingFailureType_choice_template& choice();
const MatchingFailureType_choice_template& choice() const;
MatchingFailureType_reason_template& reason();
const MatchingFailureType_reason_template& reason() const;
CHARSTRING_template& info();
const CHARSTRING_template& info() const;
Record_Template* create() const { return new MatchingFailureType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class MatchingProblemType_reason : public Enum_Type { // enum
friend class MatchingProblemType_reason_template;
public:
enum enum_type { port__not__started__and__queue__empty = 0, no__incoming__types = 1, no__incoming__signatures = 2, no__outgoing__blocking__signatures = 3, no__outgoing__blocking__signatures__that__support__exceptions = 4, component__has__no__ports = 5, UNKNOWN_VALUE = 6, UNBOUND_VALUE = 7 };
private:
enum_type enum_value;

public:
MatchingProblemType_reason();
MatchingProblemType_reason(int other_value);
MatchingProblemType_reason(enum_type other_value);
MatchingProblemType_reason(const MatchingProblemType_reason& other_value);

MatchingProblemType_reason& operator=(int other_value);
MatchingProblemType_reason& operator=(enum_type other_value);
MatchingProblemType_reason& operator=(const MatchingProblemType_reason& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const MatchingProblemType_reason& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MatchingProblemType_reason& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const MatchingProblemType_reason& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const MatchingProblemType_reason& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const MatchingProblemType_reason& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const MatchingProblemType_reason& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const MatchingProblemType_reason& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class MatchingProblemType_reason_template : public Base_Template {
union {
MatchingProblemType_reason::enum_type single_value;
struct {
unsigned int n_values;
MatchingProblemType_reason_template *list_value;
} value_list;
};

void copy_template(const MatchingProblemType_reason_template& other_value);

public:
MatchingProblemType_reason_template();
MatchingProblemType_reason_template(template_sel other_value);
MatchingProblemType_reason_template(int other_value);
MatchingProblemType_reason_template(MatchingProblemType_reason::enum_type other_value);
MatchingProblemType_reason_template(const MatchingProblemType_reason& other_value);
MatchingProblemType_reason_template(const OPTIONAL<MatchingProblemType_reason>& other_value);
MatchingProblemType_reason_template(const MatchingProblemType_reason_template& other_value);
~MatchingProblemType_reason_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
MatchingProblemType_reason_template& operator=(template_sel other_value);
MatchingProblemType_reason_template& operator=(int other_value);
MatchingProblemType_reason_template& operator=(MatchingProblemType_reason::enum_type other_value);
MatchingProblemType_reason_template& operator=(const MatchingProblemType_reason& other_value);
MatchingProblemType_reason_template& operator=(const OPTIONAL<MatchingProblemType_reason>& other_value);
MatchingProblemType_reason_template& operator=(const MatchingProblemType_reason_template& other_value);

boolean match(MatchingProblemType_reason::enum_type other_value) const;
boolean match(const MatchingProblemType_reason& other_value) const;
MatchingProblemType_reason::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MatchingProblemType_reason_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const MatchingProblemType_reason& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class MatchingProblemType_operation : public Enum_Type { // enum
friend class MatchingProblemType_operation_template;
public:
enum enum_type { receive__ = 0, trigger__ = 1, getcall__ = 2, getreply__ = 3, catch__ = 4, check__ = 5, UNKNOWN_VALUE = 6, UNBOUND_VALUE = 7 };
private:
enum_type enum_value;

public:
MatchingProblemType_operation();
MatchingProblemType_operation(int other_value);
MatchingProblemType_operation(enum_type other_value);
MatchingProblemType_operation(const MatchingProblemType_operation& other_value);

MatchingProblemType_operation& operator=(int other_value);
MatchingProblemType_operation& operator=(enum_type other_value);
MatchingProblemType_operation& operator=(const MatchingProblemType_operation& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const MatchingProblemType_operation& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MatchingProblemType_operation& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const MatchingProblemType_operation& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const MatchingProblemType_operation& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const MatchingProblemType_operation& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const MatchingProblemType_operation& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const MatchingProblemType_operation& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class MatchingProblemType_operation_template : public Base_Template {
union {
MatchingProblemType_operation::enum_type single_value;
struct {
unsigned int n_values;
MatchingProblemType_operation_template *list_value;
} value_list;
};

void copy_template(const MatchingProblemType_operation_template& other_value);

public:
MatchingProblemType_operation_template();
MatchingProblemType_operation_template(template_sel other_value);
MatchingProblemType_operation_template(int other_value);
MatchingProblemType_operation_template(MatchingProblemType_operation::enum_type other_value);
MatchingProblemType_operation_template(const MatchingProblemType_operation& other_value);
MatchingProblemType_operation_template(const OPTIONAL<MatchingProblemType_operation>& other_value);
MatchingProblemType_operation_template(const MatchingProblemType_operation_template& other_value);
~MatchingProblemType_operation_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
MatchingProblemType_operation_template& operator=(template_sel other_value);
MatchingProblemType_operation_template& operator=(int other_value);
MatchingProblemType_operation_template& operator=(MatchingProblemType_operation::enum_type other_value);
MatchingProblemType_operation_template& operator=(const MatchingProblemType_operation& other_value);
MatchingProblemType_operation_template& operator=(const OPTIONAL<MatchingProblemType_operation>& other_value);
MatchingProblemType_operation_template& operator=(const MatchingProblemType_operation_template& other_value);

boolean match(MatchingProblemType_operation::enum_type other_value) const;
boolean match(const MatchingProblemType_operation& other_value) const;
MatchingProblemType_operation::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MatchingProblemType_operation_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const MatchingProblemType_operation& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class MatchingProblemType : public Record_Type {
  CHARSTRING field_port__name;
  MatchingProblemType_reason field_reason;
  MatchingProblemType_operation field_operation;
  BOOLEAN field_check__;
  BOOLEAN field_any__port;
  Base_Type* fld_vec[5];
  void init_vec();
public:
  MatchingProblemType();
  MatchingProblemType(const MatchingProblemType& other_value);
  MatchingProblemType(const CHARSTRING& par_port__name,
    const MatchingProblemType_reason& par_reason,
    const MatchingProblemType_operation& par_operation,
    const BOOLEAN& par_check__,
    const BOOLEAN& par_any__port);
inline MatchingProblemType& operator=(const MatchingProblemType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const MatchingProblemType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const MatchingProblemType& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& port__name()
    {return field_port__name;}
  inline const CHARSTRING& port__name() const
    {return field_port__name;}
  inline MatchingProblemType_reason& reason()
    {return field_reason;}
  inline const MatchingProblemType_reason& reason() const
    {return field_reason;}
  inline MatchingProblemType_operation& operation()
    {return field_operation;}
  inline const MatchingProblemType_operation& operation() const
    {return field_operation;}
  inline BOOLEAN& check__()
    {return field_check__;}
  inline const BOOLEAN& check__() const
    {return field_check__;}
  inline BOOLEAN& any__port()
    {return field_any__port;}
  inline const BOOLEAN& any__port() const
    {return field_any__port;}
Base_Type* clone() const { return new MatchingProblemType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 5; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class MatchingProblemType_template : public Record_Template {
void set_specific();
public:
MatchingProblemType_template(): Record_Template() {}
MatchingProblemType_template(template_sel other_value): Record_Template(other_value) {}
MatchingProblemType_template(const MatchingProblemType& other_value): Record_Template() { copy_value(&other_value); }
MatchingProblemType_template(const OPTIONAL<MatchingProblemType>& other_value): Record_Template() { copy_optional(&other_value); }
MatchingProblemType_template(const MatchingProblemType_template& other_value): Record_Template() { copy_template(other_value); }
MatchingProblemType_template& operator=(template_sel other_value);
MatchingProblemType_template& operator=(const MatchingProblemType& other_value);
MatchingProblemType_template& operator=(const OPTIONAL<MatchingProblemType>& other_value);
MatchingProblemType_template& operator=(const MatchingProblemType_template& other_value);
inline boolean match(const MatchingProblemType& other_value) const { return matchv(&other_value); }
inline void log_match(const MatchingProblemType& match_value) const { log_matchv(&match_value); }
MatchingProblemType valueof() const;
inline MatchingProblemType_template& list_item(unsigned int list_index) const { return *(static_cast<MatchingProblemType_template*>(get_list_item(list_index))); }
CHARSTRING_template& port__name();
const CHARSTRING_template& port__name() const;
MatchingProblemType_reason_template& reason();
const MatchingProblemType_reason_template& reason() const;
MatchingProblemType_operation_template& operation();
const MatchingProblemType_operation_template& operation() const;
BOOLEAN_template& check__();
const BOOLEAN_template& check__() const;
BOOLEAN_template& any__port();
const BOOLEAN_template& any__port() const;
Record_Template* create() const { return new MatchingProblemType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class MatchingTimeout : public Record_Type {
  OPTIONAL<CHARSTRING> field_timer__name;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  MatchingTimeout();
  MatchingTimeout(const MatchingTimeout& other_value);
  MatchingTimeout(const OPTIONAL<CHARSTRING>& par_timer__name);
inline MatchingTimeout& operator=(const MatchingTimeout& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const MatchingTimeout& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const MatchingTimeout& other_value) const
    { return !is_equal(&other_value); }

  inline OPTIONAL<CHARSTRING>& timer__name()
    {return field_timer__name;}
  inline const OPTIONAL<CHARSTRING>& timer__name() const
    {return field_timer__name;}
Base_Type* clone() const { return new MatchingTimeout(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
int optional_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const int optional_indexes[];
const int* get_optional_indexes() const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class MatchingTimeout_template : public Record_Template {
void set_specific();
public:
MatchingTimeout_template(): Record_Template() {}
MatchingTimeout_template(template_sel other_value): Record_Template(other_value) {}
MatchingTimeout_template(const MatchingTimeout& other_value): Record_Template() { copy_value(&other_value); }
MatchingTimeout_template(const OPTIONAL<MatchingTimeout>& other_value): Record_Template() { copy_optional(&other_value); }
MatchingTimeout_template(const MatchingTimeout_template& other_value): Record_Template() { copy_template(other_value); }
MatchingTimeout_template& operator=(template_sel other_value);
MatchingTimeout_template& operator=(const MatchingTimeout& other_value);
MatchingTimeout_template& operator=(const OPTIONAL<MatchingTimeout>& other_value);
MatchingTimeout_template& operator=(const MatchingTimeout_template& other_value);
inline boolean match(const MatchingTimeout& other_value) const { return matchv(&other_value); }
inline void log_match(const MatchingTimeout& match_value) const { log_matchv(&match_value); }
MatchingTimeout valueof() const;
inline MatchingTimeout_template& list_item(unsigned int list_index) const { return *(static_cast<MatchingTimeout_template*>(get_list_item(list_index))); }
CHARSTRING_template& timer__name();
const CHARSTRING_template& timer__name() const;
Record_Template* create() const { return new MatchingTimeout_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class MatchingEvent : public Record_Type {
  MatchingEvent_choice field_choice;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  MatchingEvent();
  MatchingEvent(const MatchingEvent& other_value);
  MatchingEvent(const MatchingEvent_choice& par_choice);
inline MatchingEvent& operator=(const MatchingEvent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const MatchingEvent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const MatchingEvent& other_value) const
    { return !is_equal(&other_value); }

  inline MatchingEvent_choice& choice()
    {return field_choice;}
  inline const MatchingEvent_choice& choice() const
    {return field_choice;}
Base_Type* clone() const { return new MatchingEvent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class MatchingEvent_template : public Record_Template {
void set_specific();
public:
MatchingEvent_template(): Record_Template() {}
MatchingEvent_template(template_sel other_value): Record_Template(other_value) {}
MatchingEvent_template(const MatchingEvent& other_value): Record_Template() { copy_value(&other_value); }
MatchingEvent_template(const OPTIONAL<MatchingEvent>& other_value): Record_Template() { copy_optional(&other_value); }
MatchingEvent_template(const MatchingEvent_template& other_value): Record_Template() { copy_template(other_value); }
MatchingEvent_template& operator=(template_sel other_value);
MatchingEvent_template& operator=(const MatchingEvent& other_value);
MatchingEvent_template& operator=(const OPTIONAL<MatchingEvent>& other_value);
MatchingEvent_template& operator=(const MatchingEvent_template& other_value);
inline boolean match(const MatchingEvent& other_value) const { return matchv(&other_value); }
inline void log_match(const MatchingEvent& match_value) const { log_matchv(&match_value); }
MatchingEvent valueof() const;
inline MatchingEvent_template& list_item(unsigned int list_index) const { return *(static_cast<MatchingEvent_template*>(get_list_item(list_index))); }
MatchingEvent_choice_template& choice();
const MatchingEvent_choice_template& choice() const;
Record_Template* create() const { return new MatchingEvent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class ExecutionSummaryType : public Record_Type {
  INTEGER field_numberOfTestcases;
  CHARSTRING field_overallStatistics;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  ExecutionSummaryType();
  ExecutionSummaryType(const ExecutionSummaryType& other_value);
  ExecutionSummaryType(const INTEGER& par_numberOfTestcases,
    const CHARSTRING& par_overallStatistics);
inline ExecutionSummaryType& operator=(const ExecutionSummaryType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ExecutionSummaryType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const ExecutionSummaryType& other_value) const
    { return !is_equal(&other_value); }

  inline INTEGER& numberOfTestcases()
    {return field_numberOfTestcases;}
  inline const INTEGER& numberOfTestcases() const
    {return field_numberOfTestcases;}
  inline CHARSTRING& overallStatistics()
    {return field_overallStatistics;}
  inline const CHARSTRING& overallStatistics() const
    {return field_overallStatistics;}
Base_Type* clone() const { return new ExecutionSummaryType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class ExecutionSummaryType_template : public Record_Template {
void set_specific();
public:
ExecutionSummaryType_template(): Record_Template() {}
ExecutionSummaryType_template(template_sel other_value): Record_Template(other_value) {}
ExecutionSummaryType_template(const ExecutionSummaryType& other_value): Record_Template() { copy_value(&other_value); }
ExecutionSummaryType_template(const OPTIONAL<ExecutionSummaryType>& other_value): Record_Template() { copy_optional(&other_value); }
ExecutionSummaryType_template(const ExecutionSummaryType_template& other_value): Record_Template() { copy_template(other_value); }
ExecutionSummaryType_template& operator=(template_sel other_value);
ExecutionSummaryType_template& operator=(const ExecutionSummaryType& other_value);
ExecutionSummaryType_template& operator=(const OPTIONAL<ExecutionSummaryType>& other_value);
ExecutionSummaryType_template& operator=(const ExecutionSummaryType_template& other_value);
inline boolean match(const ExecutionSummaryType& other_value) const { return matchv(&other_value); }
inline void log_match(const ExecutionSummaryType& match_value) const { log_matchv(&match_value); }
ExecutionSummaryType valueof() const;
inline ExecutionSummaryType_template& list_item(unsigned int list_index) const { return *(static_cast<ExecutionSummaryType_template*>(get_list_item(list_index))); }
INTEGER_template& numberOfTestcases();
const INTEGER_template& numberOfTestcases() const;
CHARSTRING_template& overallStatistics();
const CHARSTRING_template& overallStatistics() const;
Record_Template* create() const { return new ExecutionSummaryType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class LogEventType : public Record_Type {
  LogEventType_choice field_choice;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  LogEventType();
  LogEventType(const LogEventType& other_value);
  LogEventType(const LogEventType_choice& par_choice);
inline LogEventType& operator=(const LogEventType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const LogEventType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const LogEventType& other_value) const
    { return !is_equal(&other_value); }

  inline LogEventType_choice& choice()
    {return field_choice;}
  inline const LogEventType_choice& choice() const
    {return field_choice;}
Base_Type* clone() const { return new LogEventType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class LogEventType_template : public Record_Template {
void set_specific();
public:
LogEventType_template(): Record_Template() {}
LogEventType_template(template_sel other_value): Record_Template(other_value) {}
LogEventType_template(const LogEventType& other_value): Record_Template() { copy_value(&other_value); }
LogEventType_template(const OPTIONAL<LogEventType>& other_value): Record_Template() { copy_optional(&other_value); }
LogEventType_template(const LogEventType_template& other_value): Record_Template() { copy_template(other_value); }
LogEventType_template& operator=(template_sel other_value);
LogEventType_template& operator=(const LogEventType& other_value);
LogEventType_template& operator=(const OPTIONAL<LogEventType>& other_value);
LogEventType_template& operator=(const LogEventType_template& other_value);
inline boolean match(const LogEventType& other_value) const { return matchv(&other_value); }
inline void log_match(const LogEventType& match_value) const { log_matchv(&match_value); }
LogEventType valueof() const;
inline LogEventType_template& list_item(unsigned int list_index) const { return *(static_cast<LogEventType_template*>(get_list_item(list_index))); }
LogEventType_choice_template& choice();
const LogEventType_choice_template& choice() const;
Record_Template* create() const { return new LogEventType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class TitanLogEvent : public Record_Type {
  TimestampType field_timestamp;
  TitanLogEvent_sourceInfo__list field_sourceInfo__list;
  INTEGER field_severity;
  LogEventType field_logEvent;
  Base_Type* fld_vec[4];
  void init_vec();
public:
  TitanLogEvent();
  TitanLogEvent(const TitanLogEvent& other_value);
  TitanLogEvent(const TimestampType& par_timestamp,
    const TitanLogEvent_sourceInfo__list& par_sourceInfo__list,
    const INTEGER& par_severity,
    const LogEventType& par_logEvent);
inline TitanLogEvent& operator=(const TitanLogEvent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TitanLogEvent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const TitanLogEvent& other_value) const
    { return !is_equal(&other_value); }

  inline TimestampType& timestamp()
    {return field_timestamp;}
  inline const TimestampType& timestamp() const
    {return field_timestamp;}
  inline TitanLogEvent_sourceInfo__list& sourceInfo__list()
    {return field_sourceInfo__list;}
  inline const TitanLogEvent_sourceInfo__list& sourceInfo__list() const
    {return field_sourceInfo__list;}
  inline INTEGER& severity()
    {return field_severity;}
  inline const INTEGER& severity() const
    {return field_severity;}
  inline LogEventType& logEvent()
    {return field_logEvent;}
  inline const LogEventType& logEvent() const
    {return field_logEvent;}
Base_Type* clone() const { return new TitanLogEvent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 4; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class TitanLogEvent_template : public Record_Template {
void set_specific();
public:
TitanLogEvent_template(): Record_Template() {}
TitanLogEvent_template(template_sel other_value): Record_Template(other_value) {}
TitanLogEvent_template(const TitanLogEvent& other_value): Record_Template() { copy_value(&other_value); }
TitanLogEvent_template(const OPTIONAL<TitanLogEvent>& other_value): Record_Template() { copy_optional(&other_value); }
TitanLogEvent_template(const TitanLogEvent_template& other_value): Record_Template() { copy_template(other_value); }
TitanLogEvent_template& operator=(template_sel other_value);
TitanLogEvent_template& operator=(const TitanLogEvent& other_value);
TitanLogEvent_template& operator=(const OPTIONAL<TitanLogEvent>& other_value);
TitanLogEvent_template& operator=(const TitanLogEvent_template& other_value);
inline boolean match(const TitanLogEvent& other_value) const { return matchv(&other_value); }
inline void log_match(const TitanLogEvent& match_value) const { log_matchv(&match_value); }
TitanLogEvent valueof() const;
inline TitanLogEvent_template& list_item(unsigned int list_index) const { return *(static_cast<TitanLogEvent_template*>(get_list_item(list_index))); }
TimestampType_template& timestamp();
const TimestampType_template& timestamp() const;
TitanLogEvent_sourceInfo__list_template& sourceInfo__list();
const TitanLogEvent_sourceInfo__list_template& sourceInfo__list() const;
INTEGER_template& severity();
const INTEGER_template& severity() const;
LogEventType_template& logEvent();
const LogEventType_template& logEvent() const;
Record_Template* create() const { return new TitanLogEvent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class TitanLog_sequence__list_0 : public Record_Type {
  ComponentIDType field_entityId;
  TitanLog_sequence__list_0_event__list field_event__list;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  TitanLog_sequence__list_0();
  TitanLog_sequence__list_0(const TitanLog_sequence__list_0& other_value);
  TitanLog_sequence__list_0(const ComponentIDType& par_entityId,
    const TitanLog_sequence__list_0_event__list& par_event__list);
inline TitanLog_sequence__list_0& operator=(const TitanLog_sequence__list_0& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TitanLog_sequence__list_0& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const TitanLog_sequence__list_0& other_value) const
    { return !is_equal(&other_value); }

  inline ComponentIDType& entityId()
    {return field_entityId;}
  inline const ComponentIDType& entityId() const
    {return field_entityId;}
  inline TitanLog_sequence__list_0_event__list& event__list()
    {return field_event__list;}
  inline const TitanLog_sequence__list_0_event__list& event__list() const
    {return field_event__list;}
Base_Type* clone() const { return new TitanLog_sequence__list_0(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class TitanLog_sequence__list_0_template : public Record_Template {
void set_specific();
public:
TitanLog_sequence__list_0_template(): Record_Template() {}
TitanLog_sequence__list_0_template(template_sel other_value): Record_Template(other_value) {}
TitanLog_sequence__list_0_template(const TitanLog_sequence__list_0& other_value): Record_Template() { copy_value(&other_value); }
TitanLog_sequence__list_0_template(const OPTIONAL<TitanLog_sequence__list_0>& other_value): Record_Template() { copy_optional(&other_value); }
TitanLog_sequence__list_0_template(const TitanLog_sequence__list_0_template& other_value): Record_Template() { copy_template(other_value); }
TitanLog_sequence__list_0_template& operator=(template_sel other_value);
TitanLog_sequence__list_0_template& operator=(const TitanLog_sequence__list_0& other_value);
TitanLog_sequence__list_0_template& operator=(const OPTIONAL<TitanLog_sequence__list_0>& other_value);
TitanLog_sequence__list_0_template& operator=(const TitanLog_sequence__list_0_template& other_value);
inline boolean match(const TitanLog_sequence__list_0& other_value) const { return matchv(&other_value); }
inline void log_match(const TitanLog_sequence__list_0& match_value) const { log_matchv(&match_value); }
TitanLog_sequence__list_0 valueof() const;
inline TitanLog_sequence__list_0_template& list_item(unsigned int list_index) const { return *(static_cast<TitanLog_sequence__list_0_template*>(get_list_item(list_index))); }
ComponentIDType_template& entityId();
const ComponentIDType_template& entityId() const;
TitanLog_sequence__list_0_event__list_template& event__list();
const TitanLog_sequence__list_0_event__list_template& event__list() const;
Record_Template* create() const { return new TitanLog_sequence__list_0_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class TitanLog : public Record_Type {
  TitanLog_sequence__list field_sequence__list;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  TitanLog();
  TitanLog(const TitanLog& other_value);
  TitanLog(const TitanLog_sequence__list& par_sequence__list);
inline TitanLog& operator=(const TitanLog& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TitanLog& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const TitanLog& other_value) const
    { return !is_equal(&other_value); }

  inline TitanLog_sequence__list& sequence__list()
    {return field_sequence__list;}
  inline const TitanLog_sequence__list& sequence__list() const
    {return field_sequence__list;}
Base_Type* clone() const { return new TitanLog(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class TitanLog_template : public Record_Template {
void set_specific();
public:
TitanLog_template(): Record_Template() {}
TitanLog_template(template_sel other_value): Record_Template(other_value) {}
TitanLog_template(const TitanLog& other_value): Record_Template() { copy_value(&other_value); }
TitanLog_template(const OPTIONAL<TitanLog>& other_value): Record_Template() { copy_optional(&other_value); }
TitanLog_template(const TitanLog_template& other_value): Record_Template() { copy_template(other_value); }
TitanLog_template& operator=(template_sel other_value);
TitanLog_template& operator=(const TitanLog& other_value);
TitanLog_template& operator=(const OPTIONAL<TitanLog>& other_value);
TitanLog_template& operator=(const TitanLog_template& other_value);
inline boolean match(const TitanLog& other_value) const { return matchv(&other_value); }
inline void log_match(const TitanLog& match_value) const { log_matchv(&match_value); }
TitanLog valueof() const;
inline TitanLog_template& list_item(unsigned int list_index) const { return *(static_cast<TitanLog_template*>(get_list_item(list_index))); }
TitanLog_sequence__list_template& sequence__list();
const TitanLog_sequence__list_template& sequence__list() const;
Record_Template* create() const { return new TitanLog_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class TitanSingleLogEvent : public Record_Type {
  ComponentIDType field_entityId;
  TitanLogEvent field_event;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  TitanSingleLogEvent();
  TitanSingleLogEvent(const TitanSingleLogEvent& other_value);
  TitanSingleLogEvent(const ComponentIDType& par_entityId,
    const TitanLogEvent& par_event);
inline TitanSingleLogEvent& operator=(const TitanSingleLogEvent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const TitanSingleLogEvent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const TitanSingleLogEvent& other_value) const
    { return !is_equal(&other_value); }

  inline ComponentIDType& entityId()
    {return field_entityId;}
  inline const ComponentIDType& entityId() const
    {return field_entityId;}
  inline TitanLogEvent& event()
    {return field_event;}
  inline const TitanLogEvent& event() const
    {return field_event;}
Base_Type* clone() const { return new TitanSingleLogEvent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class TitanSingleLogEvent_template : public Record_Template {
void set_specific();
public:
TitanSingleLogEvent_template(): Record_Template() {}
TitanSingleLogEvent_template(template_sel other_value): Record_Template(other_value) {}
TitanSingleLogEvent_template(const TitanSingleLogEvent& other_value): Record_Template() { copy_value(&other_value); }
TitanSingleLogEvent_template(const OPTIONAL<TitanSingleLogEvent>& other_value): Record_Template() { copy_optional(&other_value); }
TitanSingleLogEvent_template(const TitanSingleLogEvent_template& other_value): Record_Template() { copy_template(other_value); }
TitanSingleLogEvent_template& operator=(template_sel other_value);
TitanSingleLogEvent_template& operator=(const TitanSingleLogEvent& other_value);
TitanSingleLogEvent_template& operator=(const OPTIONAL<TitanSingleLogEvent>& other_value);
TitanSingleLogEvent_template& operator=(const TitanSingleLogEvent_template& other_value);
inline boolean match(const TitanSingleLogEvent& other_value) const { return matchv(&other_value); }
inline void log_match(const TitanSingleLogEvent& match_value) const { log_matchv(&match_value); }
TitanSingleLogEvent valueof() const;
inline TitanSingleLogEvent_template& list_item(unsigned int list_index) const { return *(static_cast<TitanSingleLogEvent_template*>(get_list_item(list_index))); }
ComponentIDType_template& entityId();
const ComponentIDType_template& entityId() const;
TitanLogEvent_template& event();
const TitanLogEvent_template& event() const;
Record_Template* create() const { return new TitanSingleLogEvent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class ErrorEvent : public Record_Type {
  CHARSTRING field_text;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  ErrorEvent();
  ErrorEvent(const ErrorEvent& other_value);
  ErrorEvent(const CHARSTRING& par_text);
inline ErrorEvent& operator=(const ErrorEvent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ErrorEvent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const ErrorEvent& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& text()
    {return field_text;}
  inline const CHARSTRING& text() const
    {return field_text;}
Base_Type* clone() const { return new ErrorEvent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class ErrorEvent_template : public Record_Template {
void set_specific();
public:
ErrorEvent_template(): Record_Template() {}
ErrorEvent_template(template_sel other_value): Record_Template(other_value) {}
ErrorEvent_template(const ErrorEvent& other_value): Record_Template() { copy_value(&other_value); }
ErrorEvent_template(const OPTIONAL<ErrorEvent>& other_value): Record_Template() { copy_optional(&other_value); }
ErrorEvent_template(const ErrorEvent_template& other_value): Record_Template() { copy_template(other_value); }
ErrorEvent_template& operator=(template_sel other_value);
ErrorEvent_template& operator=(const ErrorEvent& other_value);
ErrorEvent_template& operator=(const OPTIONAL<ErrorEvent>& other_value);
ErrorEvent_template& operator=(const ErrorEvent_template& other_value);
inline boolean match(const ErrorEvent& other_value) const { return matchv(&other_value); }
inline void log_match(const ErrorEvent& match_value) const { log_matchv(&match_value); }
ErrorEvent valueof() const;
inline ErrorEvent_template& list_item(unsigned int list_index) const { return *(static_cast<ErrorEvent_template*>(get_list_item(list_index))); }
CHARSTRING_template& text();
const CHARSTRING_template& text() const;
Record_Template* create() const { return new ErrorEvent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class WarningEvent : public Record_Type {
  CHARSTRING field_text;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  WarningEvent();
  WarningEvent(const WarningEvent& other_value);
  WarningEvent(const CHARSTRING& par_text);
inline WarningEvent& operator=(const WarningEvent& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const WarningEvent& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const WarningEvent& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& text()
    {return field_text;}
  inline const CHARSTRING& text() const
    {return field_text;}
Base_Type* clone() const { return new WarningEvent(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class WarningEvent_template : public Record_Template {
void set_specific();
public:
WarningEvent_template(): Record_Template() {}
WarningEvent_template(template_sel other_value): Record_Template(other_value) {}
WarningEvent_template(const WarningEvent& other_value): Record_Template() { copy_value(&other_value); }
WarningEvent_template(const OPTIONAL<WarningEvent>& other_value): Record_Template() { copy_optional(&other_value); }
WarningEvent_template(const WarningEvent_template& other_value): Record_Template() { copy_template(other_value); }
WarningEvent_template& operator=(template_sel other_value);
WarningEvent_template& operator=(const WarningEvent& other_value);
WarningEvent_template& operator=(const OPTIONAL<WarningEvent>& other_value);
WarningEvent_template& operator=(const WarningEvent_template& other_value);
inline boolean match(const WarningEvent& other_value) const { return matchv(&other_value); }
inline void log_match(const WarningEvent& match_value) const { log_matchv(&match_value); }
WarningEvent valueof() const;
inline WarningEvent_template& list_item(unsigned int list_index) const { return *(static_cast<WarningEvent_template*>(get_list_item(list_index))); }
CHARSTRING_template& text();
const CHARSTRING_template& text() const;
Record_Template* create() const { return new WarningEvent_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class VerdictType : public Record_Type {
  Verdict field_fromVerdict;
  Verdict field_toVerdict;
  OPTIONAL<CHARSTRING> field_verdictReason;
  Base_Type* fld_vec[3];
  void init_vec();
public:
  VerdictType();
  VerdictType(const VerdictType& other_value);
  VerdictType(const Verdict& par_fromVerdict,
    const Verdict& par_toVerdict,
    const OPTIONAL<CHARSTRING>& par_verdictReason);
inline VerdictType& operator=(const VerdictType& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const VerdictType& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const VerdictType& other_value) const
    { return !is_equal(&other_value); }

  inline Verdict& fromVerdict()
    {return field_fromVerdict;}
  inline const Verdict& fromVerdict() const
    {return field_fromVerdict;}
  inline Verdict& toVerdict()
    {return field_toVerdict;}
  inline const Verdict& toVerdict() const
    {return field_toVerdict;}
  inline OPTIONAL<CHARSTRING>& verdictReason()
    {return field_verdictReason;}
  inline const OPTIONAL<CHARSTRING>& verdictReason() const
    {return field_verdictReason;}
Base_Type* clone() const { return new VerdictType(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 3; }
int optional_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const int optional_indexes[];
const int* get_optional_indexes() const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class VerdictType_template : public Record_Template {
void set_specific();
public:
VerdictType_template(): Record_Template() {}
VerdictType_template(template_sel other_value): Record_Template(other_value) {}
VerdictType_template(const VerdictType& other_value): Record_Template() { copy_value(&other_value); }
VerdictType_template(const OPTIONAL<VerdictType>& other_value): Record_Template() { copy_optional(&other_value); }
VerdictType_template(const VerdictType_template& other_value): Record_Template() { copy_template(other_value); }
VerdictType_template& operator=(template_sel other_value);
VerdictType_template& operator=(const VerdictType& other_value);
VerdictType_template& operator=(const OPTIONAL<VerdictType>& other_value);
VerdictType_template& operator=(const VerdictType_template& other_value);
inline boolean match(const VerdictType& other_value) const { return matchv(&other_value); }
inline void log_match(const VerdictType& match_value) const { log_matchv(&match_value); }
VerdictType valueof() const;
inline VerdictType_template& list_item(unsigned int list_index) const { return *(static_cast<VerdictType_template*>(get_list_item(list_index))); }
Verdict_template& fromVerdict();
const Verdict_template& fromVerdict() const;
Verdict_template& toVerdict();
const Verdict_template& toVerdict() const;
CHARSTRING_template& verdictReason();
const CHARSTRING_template& verdictReason() const;
Record_Template* create() const { return new VerdictType_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class Parallel_reason : public Enum_Type { // enum
friend class Parallel_reason_template;
public:
enum enum_type { creating__new__ptc = 0, function__stopped = 1, terminating__test__component__exec = 2, stopping__ptc = 3, stop__no__effect = 4, stopping__all__ptcs = 5, stop__all__no__effect = 6, killing__ptc = 7, kill__no__effect = 8, killing__all__ptcs = 9, kill__all__no__effect = 10, connecting__ports = 11, disconnecting__ports = 12, mapping__ports = 13, unmapping__ports = 14, kill__request__from__mc = 15, killing__component = 16, process__already__terminated = 17, compref__not__exist = 18, UNKNOWN_VALUE = 19, UNBOUND_VALUE = 20 };
private:
enum_type enum_value;

public:
Parallel_reason();
Parallel_reason(int other_value);
Parallel_reason(enum_type other_value);
Parallel_reason(const Parallel_reason& other_value);

Parallel_reason& operator=(int other_value);
Parallel_reason& operator=(enum_type other_value);
Parallel_reason& operator=(const Parallel_reason& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Parallel_reason& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Parallel_reason& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Parallel_reason& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Parallel_reason& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Parallel_reason& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Parallel_reason& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Parallel_reason& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
boolean can_start_v(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Parallel_reason_template : public Base_Template {
union {
Parallel_reason::enum_type single_value;
struct {
unsigned int n_values;
Parallel_reason_template *list_value;
} value_list;
};

void copy_template(const Parallel_reason_template& other_value);

public:
Parallel_reason_template();
Parallel_reason_template(template_sel other_value);
Parallel_reason_template(int other_value);
Parallel_reason_template(Parallel_reason::enum_type other_value);
Parallel_reason_template(const Parallel_reason& other_value);
Parallel_reason_template(const OPTIONAL<Parallel_reason>& other_value);
Parallel_reason_template(const Parallel_reason_template& other_value);
~Parallel_reason_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Parallel_reason_template& operator=(template_sel other_value);
Parallel_reason_template& operator=(int other_value);
Parallel_reason_template& operator=(Parallel_reason::enum_type other_value);
Parallel_reason_template& operator=(const Parallel_reason& other_value);
Parallel_reason_template& operator=(const OPTIONAL<Parallel_reason>& other_value);
Parallel_reason_template& operator=(const Parallel_reason_template& other_value);

boolean match(Parallel_reason::enum_type other_value) const;
boolean match(const Parallel_reason& other_value) const;
Parallel_reason::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Parallel_reason_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value) const;
void log_matchv(const Base_Type* match_value) const;
void log() const;
void log_match(const Parallel_reason& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
};

class Parallel : public Record_Type {
  Parallel_reason field_reason;
  BOOLEAN field_alive__;
  CHARSTRING field_function__name;
  INTEGER field_src__compref;
  CHARSTRING field_src__port;
  INTEGER field_dst__compref;
  CHARSTRING field_dst__port;
  Base_Type* fld_vec[7];
  void init_vec();
public:
  Parallel();
  Parallel(const Parallel& other_value);
  Parallel(const Parallel_reason& par_reason,
    const BOOLEAN& par_alive__,
    const CHARSTRING& par_function__name,
    const INTEGER& par_src__compref,
    const CHARSTRING& par_src__port,
    const INTEGER& par_dst__compref,
    const CHARSTRING& par_dst__port);
inline Parallel& operator=(const Parallel& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const Parallel& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const Parallel& other_value) const
    { return !is_equal(&other_value); }

  inline Parallel_reason& reason()
    {return field_reason;}
  inline const Parallel_reason& reason() const
    {return field_reason;}
  inline BOOLEAN& alive__()
    {return field_alive__;}
  inline const BOOLEAN& alive__() const
    {return field_alive__;}
  inline CHARSTRING& function__name()
    {return field_function__name;}
  inline const CHARSTRING& function__name() const
    {return field_function__name;}
  inline INTEGER& src__compref()
    {return field_src__compref;}
  inline const INTEGER& src__compref() const
    {return field_src__compref;}
  inline CHARSTRING& src__port()
    {return field_src__port;}
  inline const CHARSTRING& src__port() const
    {return field_src__port;}
  inline INTEGER& dst__compref()
    {return field_dst__compref;}
  inline const INTEGER& dst__compref() const
    {return field_dst__compref;}
  inline CHARSTRING& dst__port()
    {return field_dst__port;}
  inline const CHARSTRING& dst__port() const
    {return field_dst__port;}
Base_Type* clone() const { return new Parallel(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 7; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class Parallel_template : public Record_Template {
void set_specific();
public:
Parallel_template(): Record_Template() {}
Parallel_template(template_sel other_value): Record_Template(other_value) {}
Parallel_template(const Parallel& other_value): Record_Template() { copy_value(&other_value); }
Parallel_template(const OPTIONAL<Parallel>& other_value): Record_Template() { copy_optional(&other_value); }
Parallel_template(const Parallel_template& other_value): Record_Template() { copy_template(other_value); }
Parallel_template& operator=(template_sel other_value);
Parallel_template& operator=(const Parallel& other_value);
Parallel_template& operator=(const OPTIONAL<Parallel>& other_value);
Parallel_template& operator=(const Parallel_template& other_value);
inline boolean match(const Parallel& other_value) const { return matchv(&other_value); }
inline void log_match(const Parallel& match_value) const { log_matchv(&match_value); }
Parallel valueof() const;
inline Parallel_template& list_item(unsigned int list_index) const { return *(static_cast<Parallel_template*>(get_list_item(list_index))); }
Parallel_reason_template& reason();
const Parallel_reason_template& reason() const;
BOOLEAN_template& alive__();
const BOOLEAN_template& alive__() const;
CHARSTRING_template& function__name();
const CHARSTRING_template& function__name() const;
INTEGER_template& src__compref();
const INTEGER_template& src__compref() const;
CHARSTRING_template& src__port();
const CHARSTRING_template& src__port() const;
INTEGER_template& dst__compref();
const INTEGER_template& dst__compref() const;
CHARSTRING_template& dst__port();
const CHARSTRING_template& dst__port() const;
Record_Template* create() const { return new Parallel_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class StartFunction : public Record_Type {
  CHARSTRING field_function__name;
  INTEGER field_compref;
  StartFunction_parameter__list field_parameter__list;
  Base_Type* fld_vec[3];
  void init_vec();
public:
  StartFunction();
  StartFunction(const StartFunction& other_value);
  StartFunction(const CHARSTRING& par_function__name,
    const INTEGER& par_compref,
    const StartFunction_parameter__list& par_parameter__list);
inline StartFunction& operator=(const StartFunction& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const StartFunction& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const StartFunction& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& function__name()
    {return field_function__name;}
  inline const CHARSTRING& function__name() const
    {return field_function__name;}
  inline INTEGER& compref()
    {return field_compref;}
  inline const INTEGER& compref() const
    {return field_compref;}
  inline StartFunction_parameter__list& parameter__list()
    {return field_parameter__list;}
  inline const StartFunction_parameter__list& parameter__list() const
    {return field_parameter__list;}
Base_Type* clone() const { return new StartFunction(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 3; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

static const XERdescriptor_t* xer_descriptors[];
const XERdescriptor_t* xer_descr(int p_index) const;
virtual boolean can_start_v(const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
static  boolean can_start  (const char *name, const char *prefix, XERdescriptor_t const& xd, unsigned int flavor);
};

class StartFunction_template : public Record_Template {
void set_specific();
public:
StartFunction_template(): Record_Template() {}
StartFunction_template(template_sel other_value): Record_Template(other_value) {}
StartFunction_template(const StartFunction& other_value): Record_Template() { copy_value(&other_value); }
StartFunction_template(const OPTIONAL<StartFunction>& other_value): Record_Template() { copy_optional(&other_value); }
StartFunction_template(const StartFunction_template& other_value): Record_Template() { copy_template(other_value); }
StartFunction_template& operator=(template_sel other_value);
StartFunction_template& operator=(const StartFunction& other_value);
StartFunction_template& operator=(const OPTIONAL<StartFunction>& other_value);
StartFunction_template& operator=(const StartFunction_template& other_value);
inline boolean match(const StartFunction& other_value) const { return matchv(&other_value); }
inline void log_match(const StartFunction& match_value) const { log_matchv(&match_value); }
StartFunction valueof() const;
inline StartFunction_template& list_item(unsigned int list_index) const { return *(static_cast<StartFunction_template*>(get_list_item(list_index))); }
CHARSTRING_template& function__name();
const CHARSTRING_template& function__name() const;
INTEGER_template& compref();
const INTEGER_template& compref() const;
StartFunction_parameter__list_template& parameter__list();
const StartFunction_parameter__list_template& parameter__list() const;
Record_Template* create() const { return new StartFunction_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};


/* Global variable declarations */

extern const XERdescriptor_t TitanLog_sequence__list_xer_;
extern const TTCN_JSONdescriptor_t TitanLog_sequence__list_json_;
extern const TTCN_Typedescriptor_t TitanLog_sequence__list_descr_;
extern const XERdescriptor_t ComponentIDType_id_xer_;
extern const TTCN_Typedescriptor_t ComponentIDType_id_descr_;
extern const XERdescriptor_t ComponentIDType_name_xer_;
extern const TTCN_Typedescriptor_t ComponentIDType_name_descr_;
extern const XERdescriptor_t ComponentIDType_xer_;
extern const TTCN_JSONdescriptor_t ComponentIDType_json_;
extern const TTCN_Typedescriptor_t ComponentIDType_descr_;
extern const XERdescriptor_t TitanLog_sequence__list_0_entityId_xer_;
extern const TTCN_Typedescriptor_t TitanLog_sequence__list_0_entityId_descr_;
extern const XERdescriptor_t TitanLog_sequence__list_0_event__list_xer_;
extern const TTCN_JSONdescriptor_t TitanLog_sequence__list_0_event__list_json_;
extern const TTCN_Typedescriptor_t TitanLog_sequence__list_0_event__list_descr_;
extern const XERdescriptor_t TimestampType_seconds_xer_;
extern const TTCN_Typedescriptor_t TimestampType_seconds_descr_;
extern const XERdescriptor_t TimestampType_microSeconds_xer_;
extern const TTCN_Typedescriptor_t TimestampType_microSeconds_descr_;
extern const XERdescriptor_t TimestampType_xer_;
extern const TTCN_JSONdescriptor_t TimestampType_json_;
extern const TTCN_Typedescriptor_t TimestampType_descr_;
extern const XERdescriptor_t TitanLogEvent_timestamp_xer_;
extern const TTCN_Typedescriptor_t TitanLogEvent_timestamp_descr_;
extern const XERdescriptor_t TitanLogEvent_sourceInfo__list_xer_;
extern const TTCN_JSONdescriptor_t TitanLogEvent_sourceInfo__list_json_;
extern const TTCN_Typedescriptor_t TitanLogEvent_sourceInfo__list_descr_;
extern const XERdescriptor_t LocationInfo_filename_xer_;
extern const TTCN_Typedescriptor_t LocationInfo_filename_descr_;
extern const XERdescriptor_t LocationInfo_line_xer_;
extern const TTCN_Typedescriptor_t LocationInfo_line_descr_;
extern const XERdescriptor_t LocationInfo_ent__name_xer_;
extern const TTCN_Typedescriptor_t LocationInfo_ent__name_descr_;
extern const XERdescriptor_t LocationInfo_ent__type_xer_;
extern const TTCN_JSONdescriptor_t LocationInfo_ent__type_json_;
extern const TTCN_Typedescriptor_t LocationInfo_ent__type_descr_;
extern const XERdescriptor_t LocationInfo_xer_;
extern const TTCN_JSONdescriptor_t LocationInfo_json_;
extern const TTCN_Typedescriptor_t LocationInfo_descr_;
extern const XERdescriptor_t TitanLogEvent_sourceInfo__list_0_xer_;
extern const TTCN_Typedescriptor_t TitanLogEvent_sourceInfo__list_0_descr_;
extern const XERdescriptor_t TitanLogEvent_severity_xer_;
extern const TTCN_Typedescriptor_t TitanLogEvent_severity_descr_;
extern const XERdescriptor_t LogEventType_choice_xer_;
extern const TTCN_JSONdescriptor_t LogEventType_choice_json_;
extern const TTCN_Typedescriptor_t LogEventType_choice_descr_;
extern const XERdescriptor_t Strings_str__list_xer_;
extern const TTCN_JSONdescriptor_t Strings_str__list_json_;
extern const TTCN_Typedescriptor_t Strings_str__list_descr_;
extern const XERdescriptor_t Strings_str__list_0_xer_;
extern const TTCN_Typedescriptor_t Strings_str__list_0_descr_;
extern const XERdescriptor_t Strings_xer_;
extern const TTCN_JSONdescriptor_t Strings_json_;
extern const TTCN_Typedescriptor_t Strings_descr_;
extern const XERdescriptor_t LogEventType_choice_actionEvent_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_actionEvent_descr_;
extern const XERdescriptor_t DefaultEvent_choice_xer_;
extern const TTCN_JSONdescriptor_t DefaultEvent_choice_json_;
extern const TTCN_Typedescriptor_t DefaultEvent_choice_descr_;
extern const XERdescriptor_t DefaultOp_name_xer_;
extern const TTCN_Typedescriptor_t DefaultOp_name_descr_;
extern const XERdescriptor_t DefaultOp_id_xer_;
extern const TTCN_Typedescriptor_t DefaultOp_id_descr_;
extern const XERdescriptor_t DefaultEnd_xer_;
extern const TTCN_JSONdescriptor_t DefaultEnd_json_;
extern const TTCN_Typedescriptor_t DefaultEnd_descr_;
extern const XERdescriptor_t DefaultOp_end_xer_;
extern const TTCN_Typedescriptor_t DefaultOp_end_descr_;
extern const XERdescriptor_t DefaultOp_xer_;
extern const TTCN_JSONdescriptor_t DefaultOp_json_;
extern const TTCN_Typedescriptor_t DefaultOp_descr_;
extern const XERdescriptor_t DefaultEvent_choice_defaultopActivate_xer_;
extern const TTCN_Typedescriptor_t DefaultEvent_choice_defaultopActivate_descr_;
extern const XERdescriptor_t DefaultEvent_choice_defaultopDeactivate_xer_;
extern const TTCN_Typedescriptor_t DefaultEvent_choice_defaultopDeactivate_descr_;
extern const XERdescriptor_t DefaultEvent_choice_defaultopExit_xer_;
extern const TTCN_Typedescriptor_t DefaultEvent_choice_defaultopExit_descr_;
extern const XERdescriptor_t DefaultEvent_xer_;
extern const TTCN_JSONdescriptor_t DefaultEvent_json_;
extern const TTCN_Typedescriptor_t DefaultEvent_descr_;
extern const XERdescriptor_t LogEventType_choice_defaultEvent_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_defaultEvent_descr_;
extern const XERdescriptor_t Categorized_category_xer_;
extern const TTCN_Typedescriptor_t Categorized_category_descr_;
extern const XERdescriptor_t Categorized_text_xer_;
extern const TTCN_Typedescriptor_t Categorized_text_descr_;
extern const XERdescriptor_t Categorized_xer_;
extern const TTCN_JSONdescriptor_t Categorized_json_;
extern const TTCN_Typedescriptor_t Categorized_descr_;
extern const XERdescriptor_t LogEventType_choice_errorLog_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_errorLog_descr_;
extern const XERdescriptor_t ExecutorEvent_choice_xer_;
extern const TTCN_JSONdescriptor_t ExecutorEvent_choice_json_;
extern const TTCN_Typedescriptor_t ExecutorEvent_choice_descr_;
extern const XERdescriptor_t ExecutorRuntime_reason_xer_;
extern const TTCN_JSONdescriptor_t ExecutorRuntime_reason_json_;
extern const TTCN_Typedescriptor_t ExecutorRuntime_reason_descr_;
extern const XERdescriptor_t ExecutorRuntime_xer_;
extern const TTCN_JSONdescriptor_t ExecutorRuntime_json_;
extern const TTCN_Typedescriptor_t ExecutorRuntime_descr_;
extern const XERdescriptor_t ExecutorRuntime_module__name_xer_;
extern const TTCN_Typedescriptor_t ExecutorRuntime_module__name_descr_;
extern const XERdescriptor_t ExecutorRuntime_testcase__name_xer_;
extern const TTCN_Typedescriptor_t ExecutorRuntime_testcase__name_descr_;
extern const XERdescriptor_t ExecutorRuntime_pid_xer_;
extern const TTCN_Typedescriptor_t ExecutorRuntime_pid_descr_;
extern const XERdescriptor_t ExecutorRuntime_fd__setsize_xer_;
extern const TTCN_Typedescriptor_t ExecutorRuntime_fd__setsize_descr_;
extern const XERdescriptor_t ExecutorEvent_choice_executorRuntime_xer_;
extern const TTCN_Typedescriptor_t ExecutorEvent_choice_executorRuntime_descr_;
extern const XERdescriptor_t ExecutorConfigdata_reason_xer_;
extern const TTCN_JSONdescriptor_t ExecutorConfigdata_reason_json_;
extern const TTCN_Typedescriptor_t ExecutorConfigdata_reason_descr_;
extern const XERdescriptor_t ExecutorConfigdata_xer_;
extern const TTCN_JSONdescriptor_t ExecutorConfigdata_json_;
extern const TTCN_Typedescriptor_t ExecutorConfigdata_descr_;
extern const XERdescriptor_t ExecutorConfigdata_param___xer_;
extern const TTCN_Typedescriptor_t ExecutorConfigdata_param___descr_;
extern const XERdescriptor_t ExecutorEvent_choice_executorConfigdata_xer_;
extern const TTCN_Typedescriptor_t ExecutorEvent_choice_executorConfigdata_descr_;
extern const XERdescriptor_t ExecutorEvent_choice_extcommandStart_xer_;
extern const TTCN_Typedescriptor_t ExecutorEvent_choice_extcommandStart_descr_;
extern const XERdescriptor_t ExecutorEvent_choice_extcommandSuccess_xer_;
extern const TTCN_Typedescriptor_t ExecutorEvent_choice_extcommandSuccess_descr_;
extern const XERdescriptor_t ExecutorComponent_reason_xer_;
extern const TTCN_JSONdescriptor_t ExecutorComponent_reason_json_;
extern const TTCN_Typedescriptor_t ExecutorComponent_reason_descr_;
extern const XERdescriptor_t ExecutorComponent_xer_;
extern const TTCN_JSONdescriptor_t ExecutorComponent_json_;
extern const TTCN_Typedescriptor_t ExecutorComponent_descr_;
extern const XERdescriptor_t ExecutorComponent_compref_xer_;
extern const TTCN_Typedescriptor_t ExecutorComponent_compref_descr_;
extern const XERdescriptor_t ExecutorEvent_choice_executorComponent_xer_;
extern const TTCN_Typedescriptor_t ExecutorEvent_choice_executorComponent_descr_;
extern const XERdescriptor_t ExecutorEvent_choice_logOptions_xer_;
extern const TTCN_Typedescriptor_t ExecutorEvent_choice_logOptions_descr_;
extern const XERdescriptor_t ExecutorUnqualified_reason_xer_;
extern const TTCN_JSONdescriptor_t ExecutorUnqualified_reason_json_;
extern const TTCN_Typedescriptor_t ExecutorUnqualified_reason_descr_;
extern const XERdescriptor_t ExecutorUnqualified_name_xer_;
extern const TTCN_Typedescriptor_t ExecutorUnqualified_name_descr_;
extern const XERdescriptor_t ExecutorUnqualified_addr_xer_;
extern const TTCN_Typedescriptor_t ExecutorUnqualified_addr_descr_;
extern const XERdescriptor_t ExecutorUnqualified_port___xer_;
extern const TTCN_Typedescriptor_t ExecutorUnqualified_port___descr_;
extern const XERdescriptor_t ExecutorUnqualified_xer_;
extern const TTCN_JSONdescriptor_t ExecutorUnqualified_json_;
extern const TTCN_Typedescriptor_t ExecutorUnqualified_descr_;
extern const XERdescriptor_t ExecutorEvent_choice_executorMisc_xer_;
extern const TTCN_Typedescriptor_t ExecutorEvent_choice_executorMisc_descr_;
extern const XERdescriptor_t ExecutorEvent_xer_;
extern const TTCN_JSONdescriptor_t ExecutorEvent_json_;
extern const TTCN_Typedescriptor_t ExecutorEvent_descr_;
extern const XERdescriptor_t LogEventType_choice_executorEvent_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_executorEvent_descr_;
extern const XERdescriptor_t FunctionEvent_choice_xer_;
extern const TTCN_JSONdescriptor_t FunctionEvent_choice_json_;
extern const TTCN_Typedescriptor_t FunctionEvent_choice_descr_;
extern const XERdescriptor_t FunctionEvent_choice_unqualified_xer_;
extern const TTCN_Typedescriptor_t FunctionEvent_choice_unqualified_descr_;
extern const XERdescriptor_t RandomAction_xer_;
extern const TTCN_JSONdescriptor_t RandomAction_json_;
extern const TTCN_Typedescriptor_t RandomAction_descr_;
extern const XERdescriptor_t FunctionEvent_choice_random_operation_xer_;
extern const TTCN_Typedescriptor_t FunctionEvent_choice_random_operation_descr_;
extern const XERdescriptor_t FunctionEvent_choice_random_retval_xer_;
extern const TTCN_Typedescriptor_t FunctionEvent_choice_random_retval_descr_;
extern const XERdescriptor_t FunctionEvent_choice_random_intseed_xer_;
extern const TTCN_Typedescriptor_t FunctionEvent_choice_random_intseed_descr_;
extern const XERdescriptor_t FunctionEvent_choice_random_xer_;
extern const TTCN_JSONdescriptor_t FunctionEvent_choice_random_json_;
extern const TTCN_Typedescriptor_t FunctionEvent_choice_random_descr_;
extern const XERdescriptor_t FunctionEvent_xer_;
extern const TTCN_JSONdescriptor_t FunctionEvent_json_;
extern const TTCN_Typedescriptor_t FunctionEvent_descr_;
extern const XERdescriptor_t LogEventType_choice_functionEvent_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_functionEvent_descr_;
extern const XERdescriptor_t ParallelEvent_choice_xer_;
extern const TTCN_JSONdescriptor_t ParallelEvent_choice_json_;
extern const TTCN_Typedescriptor_t ParallelEvent_choice_descr_;
extern const XERdescriptor_t ParallelPTC_reason_xer_;
extern const TTCN_JSONdescriptor_t ParallelPTC_reason_json_;
extern const TTCN_Typedescriptor_t ParallelPTC_reason_descr_;
extern const XERdescriptor_t ParallelPTC_module___xer_;
extern const TTCN_Typedescriptor_t ParallelPTC_module___descr_;
extern const XERdescriptor_t ParallelPTC_name_xer_;
extern const TTCN_Typedescriptor_t ParallelPTC_name_descr_;
extern const XERdescriptor_t ParallelPTC_compref_xer_;
extern const TTCN_Typedescriptor_t ParallelPTC_compref_descr_;
extern const XERdescriptor_t ParallelPTC_compname_xer_;
extern const TTCN_Typedescriptor_t ParallelPTC_compname_descr_;
extern const XERdescriptor_t ParallelPTC_tc__loc_xer_;
extern const TTCN_Typedescriptor_t ParallelPTC_tc__loc_descr_;
extern const XERdescriptor_t ParallelPTC_alive__pid_xer_;
extern const TTCN_Typedescriptor_t ParallelPTC_alive__pid_descr_;
extern const XERdescriptor_t ParallelPTC_status_xer_;
extern const TTCN_Typedescriptor_t ParallelPTC_status_descr_;
extern const XERdescriptor_t ParallelPTC_xer_;
extern const TTCN_JSONdescriptor_t ParallelPTC_json_;
extern const TTCN_Typedescriptor_t ParallelPTC_descr_;
extern const XERdescriptor_t ParallelEvent_choice_parallelPTC_xer_;
extern const TTCN_Typedescriptor_t ParallelEvent_choice_parallelPTC_descr_;
extern const XERdescriptor_t PTC__exit_compref_xer_;
extern const TTCN_Typedescriptor_t PTC__exit_compref_descr_;
extern const XERdescriptor_t PTC__exit_pid_xer_;
extern const TTCN_Typedescriptor_t PTC__exit_pid_descr_;
extern const XERdescriptor_t PTC__exit_statuscode_xer_;
extern const TTCN_Typedescriptor_t PTC__exit_statuscode_descr_;
extern const XERdescriptor_t PTC__exit_xer_;
extern const TTCN_JSONdescriptor_t PTC__exit_json_;
extern const TTCN_Typedescriptor_t PTC__exit_descr_;
extern const XERdescriptor_t ParallelEvent_choice_parallelPTC__exit_xer_;
extern const TTCN_Typedescriptor_t ParallelEvent_choice_parallelPTC__exit_descr_;
extern const XERdescriptor_t ParPort_operation_xer_;
extern const TTCN_JSONdescriptor_t ParPort_operation_json_;
extern const TTCN_Typedescriptor_t ParPort_operation_descr_;
extern const XERdescriptor_t ParPort_srcCompref_xer_;
extern const TTCN_Typedescriptor_t ParPort_srcCompref_descr_;
extern const XERdescriptor_t ParPort_dstCompref_xer_;
extern const TTCN_Typedescriptor_t ParPort_dstCompref_descr_;
extern const XERdescriptor_t ParPort_srcPort_xer_;
extern const TTCN_Typedescriptor_t ParPort_srcPort_descr_;
extern const XERdescriptor_t ParPort_dstPort_xer_;
extern const TTCN_Typedescriptor_t ParPort_dstPort_descr_;
extern const XERdescriptor_t ParPort_xer_;
extern const TTCN_JSONdescriptor_t ParPort_json_;
extern const TTCN_Typedescriptor_t ParPort_descr_;
extern const XERdescriptor_t ParallelEvent_choice_parallelPort_xer_;
extern const TTCN_Typedescriptor_t ParallelEvent_choice_parallelPort_descr_;
extern const XERdescriptor_t ParallelEvent_xer_;
extern const TTCN_JSONdescriptor_t ParallelEvent_json_;
extern const TTCN_Typedescriptor_t ParallelEvent_descr_;
extern const XERdescriptor_t LogEventType_choice_parallelEvent_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_parallelEvent_descr_;
extern const XERdescriptor_t TestcaseEvent_choice_xer_;
extern const TTCN_JSONdescriptor_t TestcaseEvent_choice_json_;
extern const TTCN_Typedescriptor_t TestcaseEvent_choice_descr_;
extern const XERdescriptor_t QualifiedName_module__name_xer_;
extern const TTCN_Typedescriptor_t QualifiedName_module__name_descr_;
extern const XERdescriptor_t QualifiedName_testcase__name_xer_;
extern const TTCN_Typedescriptor_t QualifiedName_testcase__name_descr_;
extern const XERdescriptor_t QualifiedName_xer_;
extern const TTCN_JSONdescriptor_t QualifiedName_json_;
extern const TTCN_Typedescriptor_t QualifiedName_descr_;
extern const XERdescriptor_t TestcaseEvent_choice_testcaseStarted_xer_;
extern const TTCN_Typedescriptor_t TestcaseEvent_choice_testcaseStarted_descr_;
extern const XERdescriptor_t TestcaseType_name_xer_;
extern const TTCN_Typedescriptor_t TestcaseType_name_descr_;
extern const XERdescriptor_t Verdict_xer_;
extern const TTCN_JSONdescriptor_t Verdict_json_;
extern const TTCN_Typedescriptor_t Verdict_descr_;
extern const XERdescriptor_t TestcaseType_verdict_xer_;
extern const TTCN_Typedescriptor_t TestcaseType_verdict_descr_;
extern const XERdescriptor_t TestcaseType_reason_xer_;
extern const TTCN_Typedescriptor_t TestcaseType_reason_descr_;
extern const XERdescriptor_t TestcaseType_xer_;
extern const TTCN_JSONdescriptor_t TestcaseType_json_;
extern const TTCN_Typedescriptor_t TestcaseType_descr_;
extern const XERdescriptor_t TestcaseEvent_choice_testcaseFinished_xer_;
extern const TTCN_Typedescriptor_t TestcaseEvent_choice_testcaseFinished_descr_;
extern const XERdescriptor_t TestcaseEvent_xer_;
extern const TTCN_JSONdescriptor_t TestcaseEvent_json_;
extern const TTCN_Typedescriptor_t TestcaseEvent_descr_;
extern const XERdescriptor_t LogEventType_choice_testcaseOp_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_testcaseOp_descr_;
extern const XERdescriptor_t PortEvent_choice_xer_;
extern const TTCN_JSONdescriptor_t PortEvent_choice_json_;
extern const TTCN_Typedescriptor_t PortEvent_choice_descr_;
extern const XERdescriptor_t Port__Queue_operation_xer_;
extern const TTCN_JSONdescriptor_t Port__Queue_operation_json_;
extern const TTCN_Typedescriptor_t Port__Queue_operation_descr_;
extern const XERdescriptor_t Port__Queue_port__name_xer_;
extern const TTCN_Typedescriptor_t Port__Queue_port__name_descr_;
extern const XERdescriptor_t Port__Queue_compref_xer_;
extern const TTCN_Typedescriptor_t Port__Queue_compref_descr_;
extern const XERdescriptor_t Port__Queue_msgid_xer_;
extern const TTCN_Typedescriptor_t Port__Queue_msgid_descr_;
extern const XERdescriptor_t Port__Queue_address___xer_;
extern const TTCN_Typedescriptor_t Port__Queue_address___descr_;
extern const XERdescriptor_t Port__Queue_param___xer_;
extern const TTCN_Typedescriptor_t Port__Queue_param___descr_;
extern const XERdescriptor_t Port__Queue_xer_;
extern const TTCN_JSONdescriptor_t Port__Queue_json_;
extern const TTCN_Typedescriptor_t Port__Queue_descr_;
extern const XERdescriptor_t PortEvent_choice_portQueue_xer_;
extern const TTCN_Typedescriptor_t PortEvent_choice_portQueue_descr_;
extern const XERdescriptor_t Port__State_operation_xer_;
extern const TTCN_JSONdescriptor_t Port__State_operation_json_;
extern const TTCN_Typedescriptor_t Port__State_operation_descr_;
extern const XERdescriptor_t Port__State_port__name_xer_;
extern const TTCN_Typedescriptor_t Port__State_port__name_descr_;
extern const XERdescriptor_t Port__State_xer_;
extern const TTCN_JSONdescriptor_t Port__State_json_;
extern const TTCN_Typedescriptor_t Port__State_descr_;
extern const XERdescriptor_t PortEvent_choice_portState_xer_;
extern const TTCN_Typedescriptor_t PortEvent_choice_portState_descr_;
extern const XERdescriptor_t Proc__port__out_port__name_xer_;
extern const TTCN_Typedescriptor_t Proc__port__out_port__name_descr_;
extern const XERdescriptor_t Port__oper_xer_;
extern const TTCN_JSONdescriptor_t Port__oper_json_;
extern const TTCN_Typedescriptor_t Port__oper_descr_;
extern const XERdescriptor_t Proc__port__out_operation_xer_;
extern const TTCN_Typedescriptor_t Proc__port__out_operation_descr_;
extern const XERdescriptor_t Proc__port__out_compref_xer_;
extern const TTCN_Typedescriptor_t Proc__port__out_compref_descr_;
extern const XERdescriptor_t Proc__port__out_sys__name_xer_;
extern const TTCN_Typedescriptor_t Proc__port__out_sys__name_descr_;
extern const XERdescriptor_t Proc__port__out_parameter_xer_;
extern const TTCN_Typedescriptor_t Proc__port__out_parameter_descr_;
extern const XERdescriptor_t Proc__port__out_xer_;
extern const TTCN_JSONdescriptor_t Proc__port__out_json_;
extern const TTCN_Typedescriptor_t Proc__port__out_descr_;
extern const XERdescriptor_t PortEvent_choice_procPortSend_xer_;
extern const TTCN_Typedescriptor_t PortEvent_choice_procPortSend_descr_;
extern const XERdescriptor_t Proc__port__in_port__name_xer_;
extern const TTCN_Typedescriptor_t Proc__port__in_port__name_descr_;
extern const XERdescriptor_t Proc__port__in_operation_xer_;
extern const TTCN_Typedescriptor_t Proc__port__in_operation_descr_;
extern const XERdescriptor_t Proc__port__in_compref_xer_;
extern const TTCN_Typedescriptor_t Proc__port__in_compref_descr_;
extern const XERdescriptor_t Proc__port__in_check___xer_;
extern const TTCN_Typedescriptor_t Proc__port__in_check___descr_;
extern const XERdescriptor_t Proc__port__in_parameter_xer_;
extern const TTCN_Typedescriptor_t Proc__port__in_parameter_descr_;
extern const XERdescriptor_t Proc__port__in_msgid_xer_;
extern const TTCN_Typedescriptor_t Proc__port__in_msgid_descr_;
extern const XERdescriptor_t Proc__port__in_xer_;
extern const TTCN_JSONdescriptor_t Proc__port__in_json_;
extern const TTCN_Typedescriptor_t Proc__port__in_descr_;
extern const XERdescriptor_t PortEvent_choice_procPortRecv_xer_;
extern const TTCN_Typedescriptor_t PortEvent_choice_procPortRecv_descr_;
extern const XERdescriptor_t Msg__port__send_port__name_xer_;
extern const TTCN_Typedescriptor_t Msg__port__send_port__name_descr_;
extern const XERdescriptor_t Msg__port__send_compref_xer_;
extern const TTCN_Typedescriptor_t Msg__port__send_compref_descr_;
extern const XERdescriptor_t Msg__port__send_parameter_xer_;
extern const TTCN_Typedescriptor_t Msg__port__send_parameter_descr_;
extern const XERdescriptor_t Msg__port__send_xer_;
extern const TTCN_JSONdescriptor_t Msg__port__send_json_;
extern const TTCN_Typedescriptor_t Msg__port__send_descr_;
extern const XERdescriptor_t PortEvent_choice_msgPortSend_xer_;
extern const TTCN_Typedescriptor_t PortEvent_choice_msgPortSend_descr_;
extern const XERdescriptor_t Msg__port__recv_port__name_xer_;
extern const TTCN_Typedescriptor_t Msg__port__recv_port__name_descr_;
extern const XERdescriptor_t Msg__port__recv_operation_xer_;
extern const TTCN_JSONdescriptor_t Msg__port__recv_operation_json_;
extern const TTCN_Typedescriptor_t Msg__port__recv_operation_descr_;
extern const XERdescriptor_t Msg__port__recv_compref_xer_;
extern const TTCN_Typedescriptor_t Msg__port__recv_compref_descr_;
extern const XERdescriptor_t Msg__port__recv_sys__name_xer_;
extern const TTCN_Typedescriptor_t Msg__port__recv_sys__name_descr_;
extern const XERdescriptor_t Msg__port__recv_parameter_xer_;
extern const TTCN_Typedescriptor_t Msg__port__recv_parameter_descr_;
extern const XERdescriptor_t Msg__port__recv_msgid_xer_;
extern const TTCN_Typedescriptor_t Msg__port__recv_msgid_descr_;
extern const XERdescriptor_t Msg__port__recv_xer_;
extern const TTCN_JSONdescriptor_t Msg__port__recv_json_;
extern const TTCN_Typedescriptor_t Msg__port__recv_descr_;
extern const XERdescriptor_t PortEvent_choice_msgPortRecv_xer_;
extern const TTCN_Typedescriptor_t PortEvent_choice_msgPortRecv_descr_;
extern const XERdescriptor_t Dualface__mapped_incoming_xer_;
extern const TTCN_Typedescriptor_t Dualface__mapped_incoming_descr_;
extern const XERdescriptor_t Dualface__mapped_target__type_xer_;
extern const TTCN_Typedescriptor_t Dualface__mapped_target__type_descr_;
extern const XERdescriptor_t Dualface__mapped_value___xer_;
extern const TTCN_Typedescriptor_t Dualface__mapped_value___descr_;
extern const XERdescriptor_t Dualface__mapped_msgid_xer_;
extern const TTCN_Typedescriptor_t Dualface__mapped_msgid_descr_;
extern const XERdescriptor_t Dualface__mapped_xer_;
extern const TTCN_JSONdescriptor_t Dualface__mapped_json_;
extern const TTCN_Typedescriptor_t Dualface__mapped_descr_;
extern const XERdescriptor_t PortEvent_choice_dualMapped_xer_;
extern const TTCN_Typedescriptor_t PortEvent_choice_dualMapped_descr_;
extern const XERdescriptor_t Dualface__discard_incoming_xer_;
extern const TTCN_Typedescriptor_t Dualface__discard_incoming_descr_;
extern const XERdescriptor_t Dualface__discard_target__type_xer_;
extern const TTCN_Typedescriptor_t Dualface__discard_target__type_descr_;
extern const XERdescriptor_t Dualface__discard_port__name_xer_;
extern const TTCN_Typedescriptor_t Dualface__discard_port__name_descr_;
extern const XERdescriptor_t Dualface__discard_unhandled_xer_;
extern const TTCN_Typedescriptor_t Dualface__discard_unhandled_descr_;
extern const XERdescriptor_t Dualface__discard_xer_;
extern const TTCN_JSONdescriptor_t Dualface__discard_json_;
extern const TTCN_Typedescriptor_t Dualface__discard_descr_;
extern const XERdescriptor_t PortEvent_choice_dualDiscard_xer_;
extern const TTCN_Typedescriptor_t PortEvent_choice_dualDiscard_descr_;
extern const XERdescriptor_t Port__Misc_reason_xer_;
extern const TTCN_JSONdescriptor_t Port__Misc_reason_json_;
extern const TTCN_Typedescriptor_t Port__Misc_reason_descr_;
extern const XERdescriptor_t Port__Misc_port__name_xer_;
extern const TTCN_Typedescriptor_t Port__Misc_port__name_descr_;
extern const XERdescriptor_t Port__Misc_remote__component_xer_;
extern const TTCN_Typedescriptor_t Port__Misc_remote__component_descr_;
extern const XERdescriptor_t Port__Misc_remote__port_xer_;
extern const TTCN_Typedescriptor_t Port__Misc_remote__port_descr_;
extern const XERdescriptor_t Port__Misc_ip__address_xer_;
extern const TTCN_Typedescriptor_t Port__Misc_ip__address_descr_;
extern const XERdescriptor_t Port__Misc_tcp__port_xer_;
extern const TTCN_Typedescriptor_t Port__Misc_tcp__port_descr_;
extern const XERdescriptor_t Port__Misc_new__size_xer_;
extern const TTCN_Typedescriptor_t Port__Misc_new__size_descr_;
extern const XERdescriptor_t Port__Misc_xer_;
extern const TTCN_JSONdescriptor_t Port__Misc_json_;
extern const TTCN_Typedescriptor_t Port__Misc_descr_;
extern const XERdescriptor_t PortEvent_choice_portMisc_xer_;
extern const TTCN_Typedescriptor_t PortEvent_choice_portMisc_descr_;
extern const XERdescriptor_t PortEvent_xer_;
extern const TTCN_JSONdescriptor_t PortEvent_json_;
extern const TTCN_Typedescriptor_t PortEvent_descr_;
extern const XERdescriptor_t LogEventType_choice_portEvent_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_portEvent_descr_;
extern const XERdescriptor_t StatisticsType_choice_xer_;
extern const TTCN_JSONdescriptor_t StatisticsType_choice_json_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_descr_;
extern const XERdescriptor_t StatisticsType_choice_verdictStatistics_none___xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_verdictStatistics_none___descr_;
extern const XERdescriptor_t StatisticsType_choice_verdictStatistics_nonePercent_xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_verdictStatistics_nonePercent_descr_;
extern const XERdescriptor_t StatisticsType_choice_verdictStatistics_pass___xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_verdictStatistics_pass___descr_;
extern const XERdescriptor_t StatisticsType_choice_verdictStatistics_passPercent_xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_verdictStatistics_passPercent_descr_;
extern const XERdescriptor_t StatisticsType_choice_verdictStatistics_inconc___xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_verdictStatistics_inconc___descr_;
extern const XERdescriptor_t StatisticsType_choice_verdictStatistics_inconcPercent_xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_verdictStatistics_inconcPercent_descr_;
extern const XERdescriptor_t StatisticsType_choice_verdictStatistics_fail___xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_verdictStatistics_fail___descr_;
extern const XERdescriptor_t StatisticsType_choice_verdictStatistics_failPercent_xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_verdictStatistics_failPercent_descr_;
extern const XERdescriptor_t StatisticsType_choice_verdictStatistics_error___xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_verdictStatistics_error___descr_;
extern const XERdescriptor_t StatisticsType_choice_verdictStatistics_errorPercent_xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_verdictStatistics_errorPercent_descr_;
extern const XERdescriptor_t StatisticsType_choice_verdictStatistics_xer_;
extern const TTCN_JSONdescriptor_t StatisticsType_choice_verdictStatistics_json_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_verdictStatistics_descr_;
extern const XERdescriptor_t StatisticsType_choice_controlpartStart_xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_controlpartStart_descr_;
extern const XERdescriptor_t StatisticsType_choice_controlpartFinish_xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_controlpartFinish_descr_;
extern const XERdescriptor_t StatisticsType_choice_controlpartErrors_xer_;
extern const TTCN_Typedescriptor_t StatisticsType_choice_controlpartErrors_descr_;
extern const XERdescriptor_t StatisticsType_xer_;
extern const TTCN_JSONdescriptor_t StatisticsType_json_;
extern const TTCN_Typedescriptor_t StatisticsType_descr_;
extern const XERdescriptor_t LogEventType_choice_statistics_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_statistics_descr_;
extern const XERdescriptor_t TimerEvent_choice_xer_;
extern const TTCN_JSONdescriptor_t TimerEvent_choice_json_;
extern const TTCN_Typedescriptor_t TimerEvent_choice_descr_;
extern const XERdescriptor_t TimerType_name_xer_;
extern const TTCN_Typedescriptor_t TimerType_name_descr_;
extern const XERdescriptor_t TimerType_value___xer_;
extern const TTCN_Typedescriptor_t TimerType_value___descr_;
extern const XERdescriptor_t TimerType_xer_;
extern const TTCN_JSONdescriptor_t TimerType_json_;
extern const TTCN_Typedescriptor_t TimerType_descr_;
extern const XERdescriptor_t TimerEvent_choice_readTimer_xer_;
extern const TTCN_Typedescriptor_t TimerEvent_choice_readTimer_descr_;
extern const XERdescriptor_t TimerEvent_choice_startTimer_xer_;
extern const TTCN_Typedescriptor_t TimerEvent_choice_startTimer_descr_;
extern const XERdescriptor_t TimerGuardType_value___xer_;
extern const TTCN_Typedescriptor_t TimerGuardType_value___descr_;
extern const XERdescriptor_t TimerGuardType_xer_;
extern const TTCN_JSONdescriptor_t TimerGuardType_json_;
extern const TTCN_Typedescriptor_t TimerGuardType_descr_;
extern const XERdescriptor_t TimerEvent_choice_guardTimer_xer_;
extern const TTCN_Typedescriptor_t TimerEvent_choice_guardTimer_descr_;
extern const XERdescriptor_t TimerEvent_choice_stopTimer_xer_;
extern const TTCN_Typedescriptor_t TimerEvent_choice_stopTimer_descr_;
extern const XERdescriptor_t TimerEvent_choice_timeoutTimer_xer_;
extern const TTCN_Typedescriptor_t TimerEvent_choice_timeoutTimer_descr_;
extern const XERdescriptor_t TimerAnyTimeoutType_xer_;
extern const TTCN_JSONdescriptor_t TimerAnyTimeoutType_json_;
extern const TTCN_Typedescriptor_t TimerAnyTimeoutType_descr_;
extern const XERdescriptor_t TimerEvent_choice_timeoutAnyTimer_xer_;
extern const TTCN_Typedescriptor_t TimerEvent_choice_timeoutAnyTimer_descr_;
extern const XERdescriptor_t TimerEvent_choice_unqualifiedTimer_xer_;
extern const TTCN_Typedescriptor_t TimerEvent_choice_unqualifiedTimer_descr_;
extern const XERdescriptor_t TimerEvent_xer_;
extern const TTCN_JSONdescriptor_t TimerEvent_json_;
extern const TTCN_Typedescriptor_t TimerEvent_descr_;
extern const XERdescriptor_t LogEventType_choice_timerEvent_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_timerEvent_descr_;
extern const XERdescriptor_t LogEventType_choice_userLog_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_userLog_descr_;
extern const XERdescriptor_t VerdictOp_choice_xer_;
extern const TTCN_JSONdescriptor_t VerdictOp_choice_json_;
extern const TTCN_Typedescriptor_t VerdictOp_choice_descr_;
extern const XERdescriptor_t SetVerdictType_newVerdict_xer_;
extern const TTCN_Typedescriptor_t SetVerdictType_newVerdict_descr_;
extern const XERdescriptor_t SetVerdictType_oldVerdict_xer_;
extern const TTCN_Typedescriptor_t SetVerdictType_oldVerdict_descr_;
extern const XERdescriptor_t SetVerdictType_localVerdict_xer_;
extern const TTCN_Typedescriptor_t SetVerdictType_localVerdict_descr_;
extern const XERdescriptor_t SetVerdictType_xer_;
extern const TTCN_JSONdescriptor_t SetVerdictType_json_;
extern const TTCN_Typedescriptor_t SetVerdictType_descr_;
extern const XERdescriptor_t SetVerdictType_oldReason_xer_;
extern const TTCN_Typedescriptor_t SetVerdictType_oldReason_descr_;
extern const XERdescriptor_t SetVerdictType_newReason_xer_;
extern const TTCN_Typedescriptor_t SetVerdictType_newReason_descr_;
extern const XERdescriptor_t VerdictOp_choice_setVerdict_xer_;
extern const TTCN_Typedescriptor_t VerdictOp_choice_setVerdict_descr_;
extern const XERdescriptor_t VerdictOp_choice_getVerdict_xer_;
extern const TTCN_Typedescriptor_t VerdictOp_choice_getVerdict_descr_;
extern const XERdescriptor_t FinalVerdictType_choice_xer_;
extern const TTCN_JSONdescriptor_t FinalVerdictType_choice_json_;
extern const TTCN_Typedescriptor_t FinalVerdictType_choice_descr_;
extern const XERdescriptor_t FinalVerdictInfo_is__ptc_xer_;
extern const TTCN_Typedescriptor_t FinalVerdictInfo_is__ptc_descr_;
extern const XERdescriptor_t FinalVerdictInfo_ptc__verdict_xer_;
extern const TTCN_Typedescriptor_t FinalVerdictInfo_ptc__verdict_descr_;
extern const XERdescriptor_t FinalVerdictInfo_local__verdict_xer_;
extern const TTCN_Typedescriptor_t FinalVerdictInfo_local__verdict_descr_;
extern const XERdescriptor_t FinalVerdictInfo_new__verdict_xer_;
extern const TTCN_Typedescriptor_t FinalVerdictInfo_new__verdict_descr_;
extern const XERdescriptor_t FinalVerdictInfo_xer_;
extern const TTCN_JSONdescriptor_t FinalVerdictInfo_json_;
extern const TTCN_Typedescriptor_t FinalVerdictInfo_descr_;
extern const XERdescriptor_t FinalVerdictInfo_verdict__reason_xer_;
extern const TTCN_Typedescriptor_t FinalVerdictInfo_verdict__reason_descr_;
extern const XERdescriptor_t FinalVerdictInfo_ptc__compref_xer_;
extern const TTCN_Typedescriptor_t FinalVerdictInfo_ptc__compref_descr_;
extern const XERdescriptor_t FinalVerdictInfo_ptc__name_xer_;
extern const TTCN_Typedescriptor_t FinalVerdictInfo_ptc__name_descr_;
extern const XERdescriptor_t FinalVerdictType_choice_info_xer_;
extern const TTCN_Typedescriptor_t FinalVerdictType_choice_info_descr_;
extern const XERdescriptor_t FinalVerdictType_choice_notification_xer_;
extern const TTCN_JSONdescriptor_t FinalVerdictType_choice_notification_json_;
extern const TTCN_Typedescriptor_t FinalVerdictType_choice_notification_descr_;
extern const XERdescriptor_t FinalVerdictType_xer_;
extern const TTCN_JSONdescriptor_t FinalVerdictType_json_;
extern const TTCN_Typedescriptor_t FinalVerdictType_descr_;
extern const XERdescriptor_t VerdictOp_choice_finalVerdict_xer_;
extern const TTCN_Typedescriptor_t VerdictOp_choice_finalVerdict_descr_;
extern const XERdescriptor_t VerdictOp_xer_;
extern const TTCN_JSONdescriptor_t VerdictOp_json_;
extern const TTCN_Typedescriptor_t VerdictOp_descr_;
extern const XERdescriptor_t LogEventType_choice_verdictOp_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_verdictOp_descr_;
extern const XERdescriptor_t LogEventType_choice_warningLog_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_warningLog_descr_;
extern const XERdescriptor_t MatchingEvent_choice_xer_;
extern const TTCN_JSONdescriptor_t MatchingEvent_choice_json_;
extern const TTCN_Typedescriptor_t MatchingEvent_choice_descr_;
extern const XERdescriptor_t MatchingDoneType_reason_xer_;
extern const TTCN_JSONdescriptor_t MatchingDoneType_reason_json_;
extern const TTCN_Typedescriptor_t MatchingDoneType_reason_descr_;
extern const XERdescriptor_t MatchingDoneType_type___xer_;
extern const TTCN_Typedescriptor_t MatchingDoneType_type___descr_;
extern const XERdescriptor_t MatchingDoneType_ptc_xer_;
extern const TTCN_Typedescriptor_t MatchingDoneType_ptc_descr_;
extern const XERdescriptor_t MatchingDoneType_return__type_xer_;
extern const TTCN_Typedescriptor_t MatchingDoneType_return__type_descr_;
extern const XERdescriptor_t MatchingDoneType_xer_;
extern const TTCN_JSONdescriptor_t MatchingDoneType_json_;
extern const TTCN_Typedescriptor_t MatchingDoneType_descr_;
extern const XERdescriptor_t MatchingEvent_choice_matchingDone_xer_;
extern const TTCN_Typedescriptor_t MatchingEvent_choice_matchingDone_descr_;
extern const XERdescriptor_t PortType_xer_;
extern const TTCN_JSONdescriptor_t PortType_json_;
extern const TTCN_Typedescriptor_t PortType_descr_;
extern const XERdescriptor_t MatchingSuccessType_port__type_xer_;
extern const TTCN_Typedescriptor_t MatchingSuccessType_port__type_descr_;
extern const XERdescriptor_t MatchingSuccessType_port__name_xer_;
extern const TTCN_Typedescriptor_t MatchingSuccessType_port__name_descr_;
extern const XERdescriptor_t MatchingSuccessType_info_xer_;
extern const TTCN_Typedescriptor_t MatchingSuccessType_info_descr_;
extern const XERdescriptor_t MatchingSuccessType_xer_;
extern const TTCN_JSONdescriptor_t MatchingSuccessType_json_;
extern const TTCN_Typedescriptor_t MatchingSuccessType_descr_;
extern const XERdescriptor_t MatchingEvent_choice_matchingSuccess_xer_;
extern const TTCN_Typedescriptor_t MatchingEvent_choice_matchingSuccess_descr_;
extern const XERdescriptor_t MatchingFailureType_port__type_xer_;
extern const TTCN_Typedescriptor_t MatchingFailureType_port__type_descr_;
extern const XERdescriptor_t MatchingFailureType_port__name_xer_;
extern const TTCN_Typedescriptor_t MatchingFailureType_port__name_descr_;
extern const XERdescriptor_t MatchingFailureType_choice_xer_;
extern const TTCN_JSONdescriptor_t MatchingFailureType_choice_json_;
extern const TTCN_Typedescriptor_t MatchingFailureType_choice_descr_;
extern const XERdescriptor_t MatchingFailureType_choice_system___xer_;
extern const TTCN_Typedescriptor_t MatchingFailureType_choice_system___descr_;
extern const XERdescriptor_t MatchingFailureType_choice_compref_xer_;
extern const TTCN_Typedescriptor_t MatchingFailureType_choice_compref_descr_;
extern const XERdescriptor_t MatchingFailureType_reason_xer_;
extern const TTCN_JSONdescriptor_t MatchingFailureType_reason_json_;
extern const TTCN_Typedescriptor_t MatchingFailureType_reason_descr_;
extern const XERdescriptor_t MatchingFailureType_info_xer_;
extern const TTCN_Typedescriptor_t MatchingFailureType_info_descr_;
extern const XERdescriptor_t MatchingFailureType_xer_;
extern const TTCN_JSONdescriptor_t MatchingFailureType_json_;
extern const TTCN_Typedescriptor_t MatchingFailureType_descr_;
extern const XERdescriptor_t MatchingEvent_choice_matchingFailure_xer_;
extern const TTCN_Typedescriptor_t MatchingEvent_choice_matchingFailure_descr_;
extern const XERdescriptor_t MatchingProblemType_port__name_xer_;
extern const TTCN_Typedescriptor_t MatchingProblemType_port__name_descr_;
extern const XERdescriptor_t MatchingProblemType_reason_xer_;
extern const TTCN_JSONdescriptor_t MatchingProblemType_reason_json_;
extern const TTCN_Typedescriptor_t MatchingProblemType_reason_descr_;
extern const XERdescriptor_t MatchingProblemType_operation_xer_;
extern const TTCN_JSONdescriptor_t MatchingProblemType_operation_json_;
extern const TTCN_Typedescriptor_t MatchingProblemType_operation_descr_;
extern const XERdescriptor_t MatchingProblemType_check___xer_;
extern const TTCN_Typedescriptor_t MatchingProblemType_check___descr_;
extern const XERdescriptor_t MatchingProblemType_any__port_xer_;
extern const TTCN_Typedescriptor_t MatchingProblemType_any__port_descr_;
extern const XERdescriptor_t MatchingProblemType_xer_;
extern const TTCN_JSONdescriptor_t MatchingProblemType_json_;
extern const TTCN_Typedescriptor_t MatchingProblemType_descr_;
extern const XERdescriptor_t MatchingEvent_choice_matchingProblem_xer_;
extern const TTCN_Typedescriptor_t MatchingEvent_choice_matchingProblem_descr_;
extern const XERdescriptor_t MatchingTimeout_xer_;
extern const TTCN_JSONdescriptor_t MatchingTimeout_json_;
extern const TTCN_Typedescriptor_t MatchingTimeout_descr_;
extern const XERdescriptor_t MatchingTimeout_timer__name_xer_;
extern const TTCN_Typedescriptor_t MatchingTimeout_timer__name_descr_;
extern const XERdescriptor_t MatchingEvent_choice_matchingTimeout_xer_;
extern const TTCN_Typedescriptor_t MatchingEvent_choice_matchingTimeout_descr_;
extern const XERdescriptor_t MatchingEvent_xer_;
extern const TTCN_JSONdescriptor_t MatchingEvent_json_;
extern const TTCN_Typedescriptor_t MatchingEvent_descr_;
extern const XERdescriptor_t LogEventType_choice_matchingEvent_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_matchingEvent_descr_;
extern const XERdescriptor_t LogEventType_choice_debugLog_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_debugLog_descr_;
extern const XERdescriptor_t ExecutionSummaryType_numberOfTestcases_xer_;
extern const TTCN_Typedescriptor_t ExecutionSummaryType_numberOfTestcases_descr_;
extern const XERdescriptor_t ExecutionSummaryType_overallStatistics_xer_;
extern const TTCN_Typedescriptor_t ExecutionSummaryType_overallStatistics_descr_;
extern const XERdescriptor_t ExecutionSummaryType_xer_;
extern const TTCN_JSONdescriptor_t ExecutionSummaryType_json_;
extern const TTCN_Typedescriptor_t ExecutionSummaryType_descr_;
extern const XERdescriptor_t LogEventType_choice_executionSummary_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_executionSummary_descr_;
extern const XERdescriptor_t LogEventType_choice_unhandledEvent_xer_;
extern const TTCN_Typedescriptor_t LogEventType_choice_unhandledEvent_descr_;
extern const XERdescriptor_t LogEventType_xer_;
extern const TTCN_JSONdescriptor_t LogEventType_json_;
extern const TTCN_Typedescriptor_t LogEventType_descr_;
extern const XERdescriptor_t TitanLogEvent_logEvent_xer_;
extern const TTCN_Typedescriptor_t TitanLogEvent_logEvent_descr_;
extern const XERdescriptor_t TitanLogEvent_xer_;
extern const TTCN_JSONdescriptor_t TitanLogEvent_json_;
extern const TTCN_Typedescriptor_t TitanLogEvent_descr_;
extern const XERdescriptor_t TitanLog_sequence__list_0_event__list_0_xer_;
extern const TTCN_Typedescriptor_t TitanLog_sequence__list_0_event__list_0_descr_;
extern const XERdescriptor_t TitanLog_sequence__list_0_xer_;
extern const TTCN_JSONdescriptor_t TitanLog_sequence__list_0_json_;
extern const TTCN_Typedescriptor_t TitanLog_sequence__list_0_descr_;
extern const XERdescriptor_t TitanLog_xer_;
extern const TTCN_JSONdescriptor_t TitanLog_json_;
extern const TTCN_Typedescriptor_t TitanLog_descr_;
extern const XERdescriptor_t TitanSingleLogEvent_entityId_xer_;
extern const TTCN_Typedescriptor_t TitanSingleLogEvent_entityId_descr_;
extern const XERdescriptor_t TitanSingleLogEvent_event_xer_;
extern const TTCN_Typedescriptor_t TitanSingleLogEvent_event_descr_;
extern const XERdescriptor_t TitanSingleLogEvent_xer_;
extern const TTCN_JSONdescriptor_t TitanSingleLogEvent_json_;
extern const TTCN_Typedescriptor_t TitanSingleLogEvent_descr_;
extern const XERdescriptor_t ErrorEvent_text_xer_;
extern const TTCN_Typedescriptor_t ErrorEvent_text_descr_;
extern const XERdescriptor_t ErrorEvent_xer_;
extern const TTCN_JSONdescriptor_t ErrorEvent_json_;
extern const TTCN_Typedescriptor_t ErrorEvent_descr_;
extern const XERdescriptor_t WarningEvent_text_xer_;
extern const TTCN_Typedescriptor_t WarningEvent_text_descr_;
extern const XERdescriptor_t WarningEvent_xer_;
extern const TTCN_JSONdescriptor_t WarningEvent_json_;
extern const TTCN_Typedescriptor_t WarningEvent_descr_;
extern const XERdescriptor_t VerdictType_fromVerdict_xer_;
extern const TTCN_Typedescriptor_t VerdictType_fromVerdict_descr_;
extern const XERdescriptor_t VerdictType_toVerdict_xer_;
extern const TTCN_Typedescriptor_t VerdictType_toVerdict_descr_;
extern const XERdescriptor_t VerdictType_xer_;
extern const TTCN_JSONdescriptor_t VerdictType_json_;
extern const TTCN_Typedescriptor_t VerdictType_descr_;
extern const XERdescriptor_t VerdictType_verdictReason_xer_;
extern const TTCN_Typedescriptor_t VerdictType_verdictReason_descr_;
extern const XERdescriptor_t Parallel_reason_xer_;
extern const TTCN_JSONdescriptor_t Parallel_reason_json_;
extern const TTCN_Typedescriptor_t Parallel_reason_descr_;
extern const XERdescriptor_t Parallel_alive___xer_;
extern const TTCN_Typedescriptor_t Parallel_alive___descr_;
extern const XERdescriptor_t Parallel_function__name_xer_;
extern const TTCN_Typedescriptor_t Parallel_function__name_descr_;
extern const XERdescriptor_t Parallel_src__compref_xer_;
extern const TTCN_Typedescriptor_t Parallel_src__compref_descr_;
extern const XERdescriptor_t Parallel_src__port_xer_;
extern const TTCN_Typedescriptor_t Parallel_src__port_descr_;
extern const XERdescriptor_t Parallel_dst__compref_xer_;
extern const TTCN_Typedescriptor_t Parallel_dst__compref_descr_;
extern const XERdescriptor_t Parallel_dst__port_xer_;
extern const TTCN_Typedescriptor_t Parallel_dst__port_descr_;
extern const XERdescriptor_t Parallel_xer_;
extern const TTCN_JSONdescriptor_t Parallel_json_;
extern const TTCN_Typedescriptor_t Parallel_descr_;
extern const XERdescriptor_t StartFunction_function__name_xer_;
extern const TTCN_Typedescriptor_t StartFunction_function__name_descr_;
extern const XERdescriptor_t StartFunction_compref_xer_;
extern const TTCN_Typedescriptor_t StartFunction_compref_descr_;
extern const XERdescriptor_t StartFunction_parameter__list_xer_;
extern const TTCN_JSONdescriptor_t StartFunction_parameter__list_json_;
extern const TTCN_Typedescriptor_t StartFunction_parameter__list_descr_;
extern const XERdescriptor_t StartFunction_parameter__list_0_xer_;
extern const TTCN_Typedescriptor_t StartFunction_parameter__list_0_descr_;
extern const XERdescriptor_t StartFunction_xer_;
extern const TTCN_JSONdescriptor_t StartFunction_json_;
extern const TTCN_Typedescriptor_t StartFunction_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
