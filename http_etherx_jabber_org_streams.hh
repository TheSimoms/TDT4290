// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for user (user@user-multicom) on Fri Oct  9 11:34:10 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

#ifndef http__etherx__jabber__org__streams_HH
#define http__etherx__jabber__org__streams_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "jabber_client.hh"
#include "jabber_server.hh"
#include "urn_ietf_params_xml_ns_xmpp_sasl.hh"
#include "urn_ietf_params_xml_ns_xmpp_streams.hh"
#include "urn_ietf_params_xml_ns_xmpp_tls.hh"

#if TTCN3_VERSION != 50300
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef http__etherx__jabber__org__streams_HH
#endif

namespace http__etherx__jabber__org__streams {

/* Forward declarations of classes */

class Stream_elem__list;
class Stream_elem__list_template;
class Stream;
class Stream_template;
class Features_elem__list;
class Features_elem__list_template;
class Features;
class Features_template;
class Stream_choice;
class Stream_choice_template;
class Stream_choice_choice__list;
class Stream_choice_choice__list_template;
class Stream_choice_choice__list_0;
class Stream_choice_choice__list_0_template;
class Stream_choice_choice__list__1;
class Stream_choice_choice__list__1_template;
class Stream_choice_choice__list__1_0;
class Stream_choice_choice__list__1_0_template;
class Error;
class Error_template;

} /* end of namespace */

#ifndef http__etherx__jabber__org__streams_HH
#define http__etherx__jabber__org__streams_HH

namespace http__etherx__jabber__org__streams {

/* Type definitions */

typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING Stream_attr;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template Stream_attr_template;

/* Class definitions */

class Stream_elem__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
UNIVERSAL_CHARSTRING **value_elements;
} *val_ptr;

static const UNIVERSAL_CHARSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const Stream_elem__list& other_value);

public:
  typedef UNIVERSAL_CHARSTRING of_type;
Stream_elem__list();
Stream_elem__list(null_type other_value);
Stream_elem__list(const Stream_elem__list& other_value);
~Stream_elem__list();

void clean_up();
Stream_elem__list& operator=(null_type other_value);
Stream_elem__list& operator=(const Stream_elem__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const Stream_elem__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Stream_elem__list& other_value) const { return !(*this == other_value); }

UNIVERSAL_CHARSTRING& operator[](int index_value);
UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value) const;

Stream_elem__list operator<<=(int rotate_count) const;
Stream_elem__list operator<<=(const INTEGER& rotate_count) const;
Stream_elem__list operator>>=(int rotate_count) const;
Stream_elem__list operator>>=(const INTEGER& rotate_count) const;

Stream_elem__list operator+(const Stream_elem__list& other_value) const;

Stream_elem__list substr(int index, int returncount) const;

Stream_elem__list replace(int index, int len, const Stream_elem__list& repl) const;

Stream_elem__list replace(int index, int len, const Stream_elem__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Stream_elem__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
UNIVERSAL_CHARSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
Stream_elem__list_template *list_value;
} value_list;
};
void copy_value(const Stream_elem__list& other_value);
void copy_template(const Stream_elem__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
Stream_elem__list_template();
Stream_elem__list_template(template_sel other_value);
Stream_elem__list_template(null_type other_value);
Stream_elem__list_template(const Stream_elem__list& other_value);
Stream_elem__list_template(const OPTIONAL<Stream_elem__list>& other_value);
Stream_elem__list_template(const Stream_elem__list_template& other_value);
~Stream_elem__list_template();

void clean_up();
Stream_elem__list_template& operator=(template_sel other_value);
Stream_elem__list_template& operator=(null_type other_value);
Stream_elem__list_template& operator=(const Stream_elem__list& other_value);
Stream_elem__list_template& operator=(const OPTIONAL<Stream_elem__list>& other_value);
Stream_elem__list_template& operator=(const Stream_elem__list_template& other_value);

UNIVERSAL_CHARSTRING_template& operator[](int index_value);
UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING_template& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const Stream_elem__list& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
Stream_elem__list valueof() const;
Stream_elem__list substr(int index, int returncount) const;

Stream_elem__list replace(int index, int len, const Stream_elem__list_template& repl) const;

Stream_elem__list replace(int index, int len, const Stream_elem__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
Stream_elem__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Stream_elem__list& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Stream : public Base_Type {
  OPTIONAL<UNIVERSAL_CHARSTRING> field_from__;
  OPTIONAL<UNIVERSAL_CHARSTRING> field_id;
  OPTIONAL<CHARSTRING> field_lang;
  OPTIONAL<UNIVERSAL_CHARSTRING> field_to__;
  OPTIONAL<FLOAT> field_version;
  Stream_attr field_attr;
  OPTIONAL<Features> field_features;
  OPTIONAL<UNIVERSAL_CHARSTRING> field_elem;
  OPTIONAL<UNIVERSAL_CHARSTRING> field_elem__1;
  Stream_elem__list field_elem__list;
  OPTIONAL<Stream_choice> field_choice;
  OPTIONAL<Error> field_error__;
  boolean bound_flag;
public:
  Stream();
  Stream(const OPTIONAL<UNIVERSAL_CHARSTRING>& par_from__,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_id,
    const OPTIONAL<CHARSTRING>& par_lang,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_to__,
    const OPTIONAL<FLOAT>& par_version,
    const Stream_attr& par_attr,
    const OPTIONAL<Features>& par_features,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_elem,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_elem__1,
    const Stream_elem__list& par_elem__list,
    const OPTIONAL<Stream_choice>& par_choice,
    const OPTIONAL<Error>& par_error__);
  Stream(const Stream& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Stream& operator=(const Stream& other_value);
  boolean operator==(const Stream& other_value) const;
  inline boolean operator!=(const Stream& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<UNIVERSAL_CHARSTRING>& from__()
    {return field_from__;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& from__() const
    {return field_from__;}
  inline OPTIONAL<UNIVERSAL_CHARSTRING>& id()
    {return field_id;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& id() const
    {return field_id;}
  inline OPTIONAL<CHARSTRING>& lang()
    {return field_lang;}
  inline const OPTIONAL<CHARSTRING>& lang() const
    {return field_lang;}
  inline OPTIONAL<UNIVERSAL_CHARSTRING>& to__()
    {return field_to__;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& to__() const
    {return field_to__;}
  inline OPTIONAL<FLOAT>& version()
    {return field_version;}
  inline const OPTIONAL<FLOAT>& version() const
    {return field_version;}
  inline Stream_attr& attr()
    {return field_attr;}
  inline const Stream_attr& attr() const
    {return field_attr;}
  inline OPTIONAL<Features>& features()
    {return field_features;}
  inline const OPTIONAL<Features>& features() const
    {return field_features;}
  inline OPTIONAL<UNIVERSAL_CHARSTRING>& elem()
    {return field_elem;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& elem() const
    {return field_elem;}
  inline OPTIONAL<UNIVERSAL_CHARSTRING>& elem__1()
    {return field_elem__1;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& elem__1() const
    {return field_elem__1;}
  inline Stream_elem__list& elem__list()
    {return field_elem__list;}
  inline const Stream_elem__list& elem__list() const
    {return field_elem__list;}
  inline OPTIONAL<Stream_choice>& choice()
    {return field_choice;}
  inline const OPTIONAL<Stream_choice>& choice() const
    {return field_choice;}
  inline OPTIONAL<Error>& error__()
    {return field_error__;}
  inline const OPTIONAL<Error>& error__() const
    {return field_error__;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Stream_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Stream_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Stream& other_value);
void copy_template(const Stream_template& other_value);

public:
Stream_template();
Stream_template(template_sel other_value);
Stream_template(const Stream& other_value);
Stream_template(const OPTIONAL<Stream>& other_value);
Stream_template(const Stream_template& other_value);
~Stream_template();
Stream_template& operator=(template_sel other_value);
Stream_template& operator=(const Stream& other_value);
Stream_template& operator=(const OPTIONAL<Stream>& other_value);
Stream_template& operator=(const Stream_template& other_value);
boolean match(const Stream& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Stream valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Stream_template& list_item(unsigned int list_index) const;
UNIVERSAL_CHARSTRING_template& from__();
const UNIVERSAL_CHARSTRING_template& from__() const;
UNIVERSAL_CHARSTRING_template& id();
const UNIVERSAL_CHARSTRING_template& id() const;
CHARSTRING_template& lang();
const CHARSTRING_template& lang() const;
UNIVERSAL_CHARSTRING_template& to__();
const UNIVERSAL_CHARSTRING_template& to__() const;
FLOAT_template& version();
const FLOAT_template& version() const;
Stream_attr_template& attr();
const Stream_attr_template& attr() const;
Features_template& features();
const Features_template& features() const;
UNIVERSAL_CHARSTRING_template& elem();
const UNIVERSAL_CHARSTRING_template& elem() const;
UNIVERSAL_CHARSTRING_template& elem__1();
const UNIVERSAL_CHARSTRING_template& elem__1() const;
Stream_elem__list_template& elem__list();
const Stream_elem__list_template& elem__list() const;
Stream_choice_template& choice();
const Stream_choice_template& choice() const;
Error_template& error__();
const Error_template& error__() const;
int size_of() const;
void log() const;
void log_match(const Stream& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class Features_elem__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
UNIVERSAL_CHARSTRING **value_elements;
} *val_ptr;

static const UNIVERSAL_CHARSTRING UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const Features_elem__list& other_value);

public:
  typedef UNIVERSAL_CHARSTRING of_type;
Features_elem__list();
Features_elem__list(null_type other_value);
Features_elem__list(const Features_elem__list& other_value);
~Features_elem__list();

void clean_up();
Features_elem__list& operator=(null_type other_value);
Features_elem__list& operator=(const Features_elem__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const Features_elem__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Features_elem__list& other_value) const { return !(*this == other_value); }

UNIVERSAL_CHARSTRING& operator[](int index_value);
UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING& operator[](const INTEGER& index_value) const;

Features_elem__list operator<<=(int rotate_count) const;
Features_elem__list operator<<=(const INTEGER& rotate_count) const;
Features_elem__list operator>>=(int rotate_count) const;
Features_elem__list operator>>=(const INTEGER& rotate_count) const;

Features_elem__list operator+(const Features_elem__list& other_value) const;

Features_elem__list substr(int index, int returncount) const;

Features_elem__list replace(int index, int len, const Features_elem__list& repl) const;

Features_elem__list replace(int index, int len, const Features_elem__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Features_elem__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
UNIVERSAL_CHARSTRING_template **value_elements;
} single_value;
struct {
unsigned int n_values;
Features_elem__list_template *list_value;
} value_list;
};
void copy_value(const Features_elem__list& other_value);
void copy_template(const Features_elem__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
Features_elem__list_template();
Features_elem__list_template(template_sel other_value);
Features_elem__list_template(null_type other_value);
Features_elem__list_template(const Features_elem__list& other_value);
Features_elem__list_template(const OPTIONAL<Features_elem__list>& other_value);
Features_elem__list_template(const Features_elem__list_template& other_value);
~Features_elem__list_template();

void clean_up();
Features_elem__list_template& operator=(template_sel other_value);
Features_elem__list_template& operator=(null_type other_value);
Features_elem__list_template& operator=(const Features_elem__list& other_value);
Features_elem__list_template& operator=(const OPTIONAL<Features_elem__list>& other_value);
Features_elem__list_template& operator=(const Features_elem__list_template& other_value);

UNIVERSAL_CHARSTRING_template& operator[](int index_value);
UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value);
const UNIVERSAL_CHARSTRING_template& operator[](int index_value) const;
const UNIVERSAL_CHARSTRING_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const Features_elem__list& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
Features_elem__list valueof() const;
Features_elem__list substr(int index, int returncount) const;

Features_elem__list replace(int index, int len, const Features_elem__list_template& repl) const;

Features_elem__list replace(int index, int len, const Features_elem__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
Features_elem__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Features_elem__list& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Features : public Base_Type {
  Features_elem__list field_elem__list;
  boolean bound_flag;
public:
  Features();
  Features(const Features_elem__list& par_elem__list);
  Features(const Features& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Features& operator=(const Features& other_value);
  boolean operator==(const Features& other_value) const;
  inline boolean operator!=(const Features& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline Features_elem__list& elem__list()
    {return field_elem__list;}
  inline const Features_elem__list& elem__list() const
    {return field_elem__list;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Features_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Features_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Features& other_value);
void copy_template(const Features_template& other_value);

public:
Features_template();
Features_template(template_sel other_value);
Features_template(const Features& other_value);
Features_template(const OPTIONAL<Features>& other_value);
Features_template(const Features_template& other_value);
~Features_template();
Features_template& operator=(template_sel other_value);
Features_template& operator=(const Features& other_value);
Features_template& operator=(const OPTIONAL<Features>& other_value);
Features_template& operator=(const Features_template& other_value);
boolean match(const Features& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Features valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Features_template& list_item(unsigned int list_index) const;
Features_elem__list_template& elem__list();
const Features_elem__list_template& elem__list() const;
int size_of() const;
void log() const;
void log_match(const Features& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class Stream_choice : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_choice__list = 1, ALT_choice__list__1 = 2 };
private:
union_selection_type union_selection;
union {
Stream_choice_choice__list *field_choice__list;
Stream_choice_choice__list__1 *field_choice__list__1;
};
void copy_value(const Stream_choice& other_value);

public:
Stream_choice();
Stream_choice(const Stream_choice& other_value);
~Stream_choice();
Stream_choice& operator=(const Stream_choice& other_value);
boolean operator==(const Stream_choice& other_value) const;
inline boolean operator!=(const Stream_choice& other_value) const { return !(*this == other_value); }
Stream_choice_choice__list& choice__list();
const Stream_choice_choice__list& choice__list() const;
Stream_choice_choice__list__1& choice__list__1();
const Stream_choice_choice__list__1& choice__list__1() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Stream_choice_template : public Base_Template {
union {
struct {
Stream_choice::union_selection_type union_selection;
union {
Stream_choice_choice__list_template *field_choice__list;
Stream_choice_choice__list__1_template *field_choice__list__1;
};
} single_value;
struct {
unsigned int n_values;
Stream_choice_template *list_value;
} value_list;
};
void copy_value(const Stream_choice& other_value);

void copy_template(const Stream_choice_template& other_value);

public:
Stream_choice_template();
Stream_choice_template(template_sel other_value);
Stream_choice_template(const Stream_choice& other_value);
Stream_choice_template(const OPTIONAL<Stream_choice>& other_value);
Stream_choice_template(const Stream_choice_template& other_value);
~Stream_choice_template();
void clean_up();
Stream_choice_template& operator=(template_sel other_value);
Stream_choice_template& operator=(const Stream_choice& other_value);
Stream_choice_template& operator=(const OPTIONAL<Stream_choice>& other_value);
Stream_choice_template& operator=(const Stream_choice_template& other_value);
boolean match(const Stream_choice& other_value) const;
boolean is_value() const;Stream_choice valueof() const;
Stream_choice_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
Stream_choice_choice__list_template& choice__list();
const Stream_choice_choice__list_template& choice__list() const;
Stream_choice_choice__list__1_template& choice__list__1();
const Stream_choice_choice__list__1_template& choice__list__1() const;
boolean ischosen(Stream_choice::union_selection_type checked_selection) const;
void log() const;
void log_match(const Stream_choice& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Stream_choice_choice__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Stream_choice_choice__list_0 **value_elements;
} *val_ptr;

static const Stream_choice_choice__list_0 UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const Stream_choice_choice__list& other_value);

public:
  typedef Stream_choice_choice__list_0 of_type;
Stream_choice_choice__list();
Stream_choice_choice__list(null_type other_value);
Stream_choice_choice__list(const Stream_choice_choice__list& other_value);
~Stream_choice_choice__list();

void clean_up();
Stream_choice_choice__list& operator=(null_type other_value);
Stream_choice_choice__list& operator=(const Stream_choice_choice__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const Stream_choice_choice__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Stream_choice_choice__list& other_value) const { return !(*this == other_value); }

Stream_choice_choice__list_0& operator[](int index_value);
Stream_choice_choice__list_0& operator[](const INTEGER& index_value);
const Stream_choice_choice__list_0& operator[](int index_value) const;
const Stream_choice_choice__list_0& operator[](const INTEGER& index_value) const;

Stream_choice_choice__list operator<<=(int rotate_count) const;
Stream_choice_choice__list operator<<=(const INTEGER& rotate_count) const;
Stream_choice_choice__list operator>>=(int rotate_count) const;
Stream_choice_choice__list operator>>=(const INTEGER& rotate_count) const;

Stream_choice_choice__list operator+(const Stream_choice_choice__list& other_value) const;

Stream_choice_choice__list substr(int index, int returncount) const;

Stream_choice_choice__list replace(int index, int len, const Stream_choice_choice__list& repl) const;

Stream_choice_choice__list replace(int index, int len, const Stream_choice_choice__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Stream_choice_choice__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
Stream_choice_choice__list_0_template **value_elements;
} single_value;
struct {
unsigned int n_values;
Stream_choice_choice__list_template *list_value;
} value_list;
};
void copy_value(const Stream_choice_choice__list& other_value);
void copy_template(const Stream_choice_choice__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
Stream_choice_choice__list_template();
Stream_choice_choice__list_template(template_sel other_value);
Stream_choice_choice__list_template(null_type other_value);
Stream_choice_choice__list_template(const Stream_choice_choice__list& other_value);
Stream_choice_choice__list_template(const OPTIONAL<Stream_choice_choice__list>& other_value);
Stream_choice_choice__list_template(const Stream_choice_choice__list_template& other_value);
~Stream_choice_choice__list_template();

void clean_up();
Stream_choice_choice__list_template& operator=(template_sel other_value);
Stream_choice_choice__list_template& operator=(null_type other_value);
Stream_choice_choice__list_template& operator=(const Stream_choice_choice__list& other_value);
Stream_choice_choice__list_template& operator=(const OPTIONAL<Stream_choice_choice__list>& other_value);
Stream_choice_choice__list_template& operator=(const Stream_choice_choice__list_template& other_value);

Stream_choice_choice__list_0_template& operator[](int index_value);
Stream_choice_choice__list_0_template& operator[](const INTEGER& index_value);
const Stream_choice_choice__list_0_template& operator[](int index_value) const;
const Stream_choice_choice__list_0_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const Stream_choice_choice__list& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
Stream_choice_choice__list valueof() const;
Stream_choice_choice__list substr(int index, int returncount) const;

Stream_choice_choice__list replace(int index, int len, const Stream_choice_choice__list_template& repl) const;

Stream_choice_choice__list replace(int index, int len, const Stream_choice_choice__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
Stream_choice_choice__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Stream_choice_choice__list& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Stream_choice_choice__list_0 : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_message__ = 1, ALT_presence = 2, ALT_iq = 3 };
private:
union_selection_type union_selection;
union {
jabber__server::Message *field_message__;
jabber__server::Presence *field_presence;
jabber__server::Iq *field_iq;
};
void copy_value(const Stream_choice_choice__list_0& other_value);

public:
Stream_choice_choice__list_0();
Stream_choice_choice__list_0(const Stream_choice_choice__list_0& other_value);
~Stream_choice_choice__list_0();
Stream_choice_choice__list_0& operator=(const Stream_choice_choice__list_0& other_value);
boolean operator==(const Stream_choice_choice__list_0& other_value) const;
inline boolean operator!=(const Stream_choice_choice__list_0& other_value) const { return !(*this == other_value); }
jabber__server::Message& message__();
const jabber__server::Message& message__() const;
jabber__server::Presence& presence();
const jabber__server::Presence& presence() const;
jabber__server::Iq& iq();
const jabber__server::Iq& iq() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Stream_choice_choice__list_0_template : public Base_Template {
union {
struct {
Stream_choice_choice__list_0::union_selection_type union_selection;
union {
jabber__server::Message_template *field_message__;
jabber__server::Presence_template *field_presence;
jabber__server::Iq_template *field_iq;
};
} single_value;
struct {
unsigned int n_values;
Stream_choice_choice__list_0_template *list_value;
} value_list;
};
void copy_value(const Stream_choice_choice__list_0& other_value);

void copy_template(const Stream_choice_choice__list_0_template& other_value);

public:
Stream_choice_choice__list_0_template();
Stream_choice_choice__list_0_template(template_sel other_value);
Stream_choice_choice__list_0_template(const Stream_choice_choice__list_0& other_value);
Stream_choice_choice__list_0_template(const OPTIONAL<Stream_choice_choice__list_0>& other_value);
Stream_choice_choice__list_0_template(const Stream_choice_choice__list_0_template& other_value);
~Stream_choice_choice__list_0_template();
void clean_up();
Stream_choice_choice__list_0_template& operator=(template_sel other_value);
Stream_choice_choice__list_0_template& operator=(const Stream_choice_choice__list_0& other_value);
Stream_choice_choice__list_0_template& operator=(const OPTIONAL<Stream_choice_choice__list_0>& other_value);
Stream_choice_choice__list_0_template& operator=(const Stream_choice_choice__list_0_template& other_value);
boolean match(const Stream_choice_choice__list_0& other_value) const;
boolean is_value() const;Stream_choice_choice__list_0 valueof() const;
Stream_choice_choice__list_0_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
jabber__server::Message_template& message__();
const jabber__server::Message_template& message__() const;
jabber__server::Presence_template& presence();
const jabber__server::Presence_template& presence() const;
jabber__server::Iq_template& iq();
const jabber__server::Iq_template& iq() const;
boolean ischosen(Stream_choice_choice__list_0::union_selection_type checked_selection) const;
void log() const;
void log_match(const Stream_choice_choice__list_0& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Stream_choice_choice__list__1 : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Stream_choice_choice__list__1_0 **value_elements;
} *val_ptr;

static const Stream_choice_choice__list__1_0 UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const Stream_choice_choice__list__1& other_value);

public:
  typedef Stream_choice_choice__list__1_0 of_type;
Stream_choice_choice__list__1();
Stream_choice_choice__list__1(null_type other_value);
Stream_choice_choice__list__1(const Stream_choice_choice__list__1& other_value);
~Stream_choice_choice__list__1();

void clean_up();
Stream_choice_choice__list__1& operator=(null_type other_value);
Stream_choice_choice__list__1& operator=(const Stream_choice_choice__list__1& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const Stream_choice_choice__list__1& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Stream_choice_choice__list__1& other_value) const { return !(*this == other_value); }

Stream_choice_choice__list__1_0& operator[](int index_value);
Stream_choice_choice__list__1_0& operator[](const INTEGER& index_value);
const Stream_choice_choice__list__1_0& operator[](int index_value) const;
const Stream_choice_choice__list__1_0& operator[](const INTEGER& index_value) const;

Stream_choice_choice__list__1 operator<<=(int rotate_count) const;
Stream_choice_choice__list__1 operator<<=(const INTEGER& rotate_count) const;
Stream_choice_choice__list__1 operator>>=(int rotate_count) const;
Stream_choice_choice__list__1 operator>>=(const INTEGER& rotate_count) const;

Stream_choice_choice__list__1 operator+(const Stream_choice_choice__list__1& other_value) const;

Stream_choice_choice__list__1 substr(int index, int returncount) const;

Stream_choice_choice__list__1 replace(int index, int len, const Stream_choice_choice__list__1& repl) const;

Stream_choice_choice__list__1 replace(int index, int len, const Stream_choice_choice__list__1_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Stream_choice_choice__list__1_template : public Record_Of_Template {
union {
struct {
int n_elements;
Stream_choice_choice__list__1_0_template **value_elements;
} single_value;
struct {
unsigned int n_values;
Stream_choice_choice__list__1_template *list_value;
} value_list;
};
void copy_value(const Stream_choice_choice__list__1& other_value);
void copy_template(const Stream_choice_choice__list__1_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
Stream_choice_choice__list__1_template();
Stream_choice_choice__list__1_template(template_sel other_value);
Stream_choice_choice__list__1_template(null_type other_value);
Stream_choice_choice__list__1_template(const Stream_choice_choice__list__1& other_value);
Stream_choice_choice__list__1_template(const OPTIONAL<Stream_choice_choice__list__1>& other_value);
Stream_choice_choice__list__1_template(const Stream_choice_choice__list__1_template& other_value);
~Stream_choice_choice__list__1_template();

void clean_up();
Stream_choice_choice__list__1_template& operator=(template_sel other_value);
Stream_choice_choice__list__1_template& operator=(null_type other_value);
Stream_choice_choice__list__1_template& operator=(const Stream_choice_choice__list__1& other_value);
Stream_choice_choice__list__1_template& operator=(const OPTIONAL<Stream_choice_choice__list__1>& other_value);
Stream_choice_choice__list__1_template& operator=(const Stream_choice_choice__list__1_template& other_value);

Stream_choice_choice__list__1_0_template& operator[](int index_value);
Stream_choice_choice__list__1_0_template& operator[](const INTEGER& index_value);
const Stream_choice_choice__list__1_0_template& operator[](int index_value) const;
const Stream_choice_choice__list__1_0_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const Stream_choice_choice__list__1& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
Stream_choice_choice__list__1 valueof() const;
Stream_choice_choice__list__1 substr(int index, int returncount) const;

Stream_choice_choice__list__1 replace(int index, int len, const Stream_choice_choice__list__1_template& repl) const;

Stream_choice_choice__list__1 replace(int index, int len, const Stream_choice_choice__list__1& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
Stream_choice_choice__list__1_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Stream_choice_choice__list__1& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Stream_choice_choice__list__1_0 : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_message__ = 1, ALT_presence = 2, ALT_iq = 3 };
private:
union_selection_type union_selection;
union {
jabber__client::Message *field_message__;
jabber__client::Presence *field_presence;
jabber__client::Iq *field_iq;
};
void copy_value(const Stream_choice_choice__list__1_0& other_value);

public:
Stream_choice_choice__list__1_0();
Stream_choice_choice__list__1_0(const Stream_choice_choice__list__1_0& other_value);
~Stream_choice_choice__list__1_0();
Stream_choice_choice__list__1_0& operator=(const Stream_choice_choice__list__1_0& other_value);
boolean operator==(const Stream_choice_choice__list__1_0& other_value) const;
inline boolean operator!=(const Stream_choice_choice__list__1_0& other_value) const { return !(*this == other_value); }
jabber__client::Message& message__();
const jabber__client::Message& message__() const;
jabber__client::Presence& presence();
const jabber__client::Presence& presence() const;
jabber__client::Iq& iq();
const jabber__client::Iq& iq() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Stream_choice_choice__list__1_0_template : public Base_Template {
union {
struct {
Stream_choice_choice__list__1_0::union_selection_type union_selection;
union {
jabber__client::Message_template *field_message__;
jabber__client::Presence_template *field_presence;
jabber__client::Iq_template *field_iq;
};
} single_value;
struct {
unsigned int n_values;
Stream_choice_choice__list__1_0_template *list_value;
} value_list;
};
void copy_value(const Stream_choice_choice__list__1_0& other_value);

void copy_template(const Stream_choice_choice__list__1_0_template& other_value);

public:
Stream_choice_choice__list__1_0_template();
Stream_choice_choice__list__1_0_template(template_sel other_value);
Stream_choice_choice__list__1_0_template(const Stream_choice_choice__list__1_0& other_value);
Stream_choice_choice__list__1_0_template(const OPTIONAL<Stream_choice_choice__list__1_0>& other_value);
Stream_choice_choice__list__1_0_template(const Stream_choice_choice__list__1_0_template& other_value);
~Stream_choice_choice__list__1_0_template();
void clean_up();
Stream_choice_choice__list__1_0_template& operator=(template_sel other_value);
Stream_choice_choice__list__1_0_template& operator=(const Stream_choice_choice__list__1_0& other_value);
Stream_choice_choice__list__1_0_template& operator=(const OPTIONAL<Stream_choice_choice__list__1_0>& other_value);
Stream_choice_choice__list__1_0_template& operator=(const Stream_choice_choice__list__1_0_template& other_value);
boolean match(const Stream_choice_choice__list__1_0& other_value) const;
boolean is_value() const;Stream_choice_choice__list__1_0 valueof() const;
Stream_choice_choice__list__1_0_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
jabber__client::Message_template& message__();
const jabber__client::Message_template& message__() const;
jabber__client::Presence_template& presence();
const jabber__client::Presence_template& presence() const;
jabber__client::Iq_template& iq();
const jabber__client::Iq_template& iq() const;
boolean ischosen(Stream_choice_choice__list__1_0::union_selection_type checked_selection) const;
void log() const;
void log_match(const Stream_choice_choice__list__1_0& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Error : public Base_Type {
  urn__ietf__params__xml__ns__xmpp__streams::StreamErrorGroup field_streamErrorGroup;
  OPTIONAL<urn__ietf__params__xml__ns__xmpp__streams::Text> field_text;
  OPTIONAL<UNIVERSAL_CHARSTRING> field_elem;
  boolean bound_flag;
public:
  Error();
  Error(const urn__ietf__params__xml__ns__xmpp__streams::StreamErrorGroup& par_streamErrorGroup,
    const OPTIONAL<urn__ietf__params__xml__ns__xmpp__streams::Text>& par_text,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_elem);
  Error(const Error& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Error& operator=(const Error& other_value);
  boolean operator==(const Error& other_value) const;
  inline boolean operator!=(const Error& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline urn__ietf__params__xml__ns__xmpp__streams::StreamErrorGroup& streamErrorGroup()
    {return field_streamErrorGroup;}
  inline const urn__ietf__params__xml__ns__xmpp__streams::StreamErrorGroup& streamErrorGroup() const
    {return field_streamErrorGroup;}
  inline OPTIONAL<urn__ietf__params__xml__ns__xmpp__streams::Text>& text()
    {return field_text;}
  inline const OPTIONAL<urn__ietf__params__xml__ns__xmpp__streams::Text>& text() const
    {return field_text;}
  inline OPTIONAL<UNIVERSAL_CHARSTRING>& elem()
    {return field_elem;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& elem() const
    {return field_elem;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Error_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Error_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Error& other_value);
void copy_template(const Error_template& other_value);

public:
Error_template();
Error_template(template_sel other_value);
Error_template(const Error& other_value);
Error_template(const OPTIONAL<Error>& other_value);
Error_template(const Error_template& other_value);
~Error_template();
Error_template& operator=(template_sel other_value);
Error_template& operator=(const Error& other_value);
Error_template& operator=(const OPTIONAL<Error>& other_value);
Error_template& operator=(const Error_template& other_value);
boolean match(const Error& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Error valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Error_template& list_item(unsigned int list_index) const;
urn__ietf__params__xml__ns__xmpp__streams::StreamErrorGroup_template& streamErrorGroup();
const urn__ietf__params__xml__ns__xmpp__streams::StreamErrorGroup_template& streamErrorGroup() const;
urn__ietf__params__xml__ns__xmpp__streams::Text_template& text();
const urn__ietf__params__xml__ns__xmpp__streams::Text_template& text() const;
UNIVERSAL_CHARSTRING_template& elem();
const UNIVERSAL_CHARSTRING_template& elem() const;
int size_of() const;
void log() const;
void log_match(const Error& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const Stream_elem__list& other_value);
inline boolean operator!=(null_type null_value, const Stream_elem__list& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Features_elem__list& other_value);
inline boolean operator!=(null_type null_value, const Features_elem__list& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Stream_choice_choice__list& other_value);
inline boolean operator!=(null_type null_value, const Stream_choice_choice__list& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Stream_choice_choice__list__1& other_value);
inline boolean operator!=(null_type null_value, const Stream_choice_choice__list__1& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const XERdescriptor_t Stream_attr_xer_;
extern const TTCN_JSONdescriptor_t Stream_attr_json_;
extern const TTCN_Typedescriptor_t Stream_attr_descr_;
extern const XERdescriptor_t Stream_attr_0_xer_;
extern const TTCN_Typedescriptor_t Stream_attr_0_descr_;
extern const XERdescriptor_t Stream_elem__list_xer_;
extern const TTCN_JSONdescriptor_t Stream_elem__list_json_;
extern const TTCN_Typedescriptor_t Stream_elem__list_descr_;
extern const XERdescriptor_t Stream_elem__list_0_xer_;
extern const TTCN_Typedescriptor_t Stream_elem__list_0_descr_;
extern const XERdescriptor_t Stream_xer_;
extern const TTCN_JSONdescriptor_t Stream_json_;
extern const TTCN_Typedescriptor_t Stream_descr_;
extern const XERdescriptor_t Stream_from___xer_;
extern const TTCN_Typedescriptor_t Stream_from___descr_;
extern const XERdescriptor_t Stream_id_xer_;
extern const TTCN_Typedescriptor_t Stream_id_descr_;
extern const XERdescriptor_t Stream_lang_xer_;
extern const TTCN_Typedescriptor_t Stream_lang_descr_;
extern const XERdescriptor_t Stream_to___xer_;
extern const TTCN_Typedescriptor_t Stream_to___descr_;
extern const XERdescriptor_t Stream_version_xer_;
extern const TTCN_Typedescriptor_t Stream_version_descr_;
extern const XERdescriptor_t Features_elem__list_xer_;
extern const TTCN_JSONdescriptor_t Features_elem__list_json_;
extern const TTCN_Typedescriptor_t Features_elem__list_descr_;
extern const XERdescriptor_t Features_elem__list_0_xer_;
extern const TTCN_Typedescriptor_t Features_elem__list_0_descr_;
extern const XERdescriptor_t Features_xer_;
extern const TTCN_JSONdescriptor_t Features_json_;
extern const TTCN_Typedescriptor_t Features_descr_;
extern const XERdescriptor_t Stream_features_xer_;
extern const TTCN_Typedescriptor_t Stream_features_descr_;
extern const XERdescriptor_t Stream_elem_xer_;
extern const TTCN_Typedescriptor_t Stream_elem_descr_;
extern const XERdescriptor_t Stream_elem__1_xer_;
extern const TTCN_Typedescriptor_t Stream_elem__1_descr_;
extern const XERdescriptor_t Stream_choice_xer_;
extern const TTCN_JSONdescriptor_t Stream_choice_json_;
extern const TTCN_Typedescriptor_t Stream_choice_descr_;
extern const XERdescriptor_t Stream_choice_choice__list_xer_;
extern const TTCN_JSONdescriptor_t Stream_choice_choice__list_json_;
extern const TTCN_Typedescriptor_t Stream_choice_choice__list_descr_;
extern const XERdescriptor_t Stream_choice_choice__list_0_xer_;
extern const TTCN_JSONdescriptor_t Stream_choice_choice__list_0_json_;
extern const TTCN_Typedescriptor_t Stream_choice_choice__list_0_descr_;
extern const XERdescriptor_t Stream_choice_choice__list_0_message___xer_;
extern const TTCN_Typedescriptor_t Stream_choice_choice__list_0_message___descr_;
extern const XERdescriptor_t Stream_choice_choice__list_0_presence_xer_;
extern const TTCN_Typedescriptor_t Stream_choice_choice__list_0_presence_descr_;
extern const XERdescriptor_t Stream_choice_choice__list_0_iq_xer_;
extern const TTCN_Typedescriptor_t Stream_choice_choice__list_0_iq_descr_;
extern const XERdescriptor_t Stream_choice_choice__list__1_xer_;
extern const TTCN_JSONdescriptor_t Stream_choice_choice__list__1_json_;
extern const TTCN_Typedescriptor_t Stream_choice_choice__list__1_descr_;
extern const XERdescriptor_t Stream_choice_choice__list__1_0_xer_;
extern const TTCN_JSONdescriptor_t Stream_choice_choice__list__1_0_json_;
extern const TTCN_Typedescriptor_t Stream_choice_choice__list__1_0_descr_;
extern const XERdescriptor_t Stream_choice_choice__list__1_0_message___xer_;
extern const TTCN_Typedescriptor_t Stream_choice_choice__list__1_0_message___descr_;
extern const XERdescriptor_t Stream_choice_choice__list__1_0_presence_xer_;
extern const TTCN_Typedescriptor_t Stream_choice_choice__list__1_0_presence_descr_;
extern const XERdescriptor_t Stream_choice_choice__list__1_0_iq_xer_;
extern const TTCN_Typedescriptor_t Stream_choice_choice__list__1_0_iq_descr_;
extern const XERdescriptor_t Error_streamErrorGroup_xer_;
extern const TTCN_Typedescriptor_t Error_streamErrorGroup_descr_;
extern const XERdescriptor_t Error_xer_;
extern const TTCN_JSONdescriptor_t Error_json_;
extern const TTCN_Typedescriptor_t Error_descr_;
extern const XERdescriptor_t Error_text_xer_;
extern const TTCN_Typedescriptor_t Error_text_descr_;
extern const XERdescriptor_t Error_elem_xer_;
extern const TTCN_Typedescriptor_t Error_elem_descr_;
extern const XERdescriptor_t Stream_error___xer_;
extern const TTCN_Typedescriptor_t Stream_error___descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
