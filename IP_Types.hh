// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for user (user@user-multicom) on Fri Sep 25 13:42:36 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

#ifndef IP__Types_HH
#define IP__Types_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "General_Types.hh"

#if TTCN3_VERSION != 50300
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef IP__Types_HH
#endif

namespace IP__Types {

/* Forward declarations of classes */

class IP__MINE__header;
class IP__MINE__header_template;
class IP__AH__header;
class IP__AH__header_template;
class IP__ESP__header__part;
class IP__ESP__header__part_template;
class IP__ESP__NULL__tail;
class IP__ESP__NULL__tail_template;
class IP__ESP__tail__part;
class IP__ESP__tail__part_template;
class IP__ESP__header;
class IP__ESP__header_template;
class IP__GRE2__header;
class IP__GRE2__header_template;
class IPv4__extension__headers;
class IPv4__extension__headers_template;
class IPv4__extension__header;
class IPv4__extension__header_template;
class IPv4__header;
class IPv4__header_template;
class IPv4__packet;
class IPv4__packet_template;
class IPv4msg__SP__PT;
class ASP__IPv4;
class ASP__IPv4_template;
class IPv4__ASP__SP__PT;
class IPv6__Fragment__header;
class IPv6__Fragment__header_template;
class IPv6__extension__headers;
class IPv6__extension__headers_template;
class IPv6__extension__header;
class IPv6__extension__header_template;
class IPv6__general__IPv6__extension__header;
class IPv6__general__IPv6__extension__header_template;
class IPv6__header;
class IPv6__header_template;
class IPv6__packet;
class IPv6__packet_template;
class IPv6msg__SP__PT;

} /* end of namespace */

#ifndef IP__Types_HH
#define IP__Types_HH

namespace IP__Types {

/* Type definitions */

typedef BITSTRING BIT7__BO__LAST;
typedef BITSTRING_template BIT7__BO__LAST_template;
typedef CHARSTRING IPV4ADDR;
typedef CHARSTRING_template IPV4ADDR_template;

/* Class definitions */

class IP__MINE__header : public Base_Type {
  INTEGER field_protocol;
  BITSTRING field_s__bit;
  BITSTRING field_reserved;
  INTEGER field_cksum;
  OCTETSTRING field_dstaddr;
  OPTIONAL<OCTETSTRING> field_srcaddr;
  boolean bound_flag;
public:
  IP__MINE__header();
  IP__MINE__header(const INTEGER& par_protocol,
    const BITSTRING& par_s__bit,
    const BITSTRING& par_reserved,
    const INTEGER& par_cksum,
    const OCTETSTRING& par_dstaddr,
    const OPTIONAL<OCTETSTRING>& par_srcaddr);
  IP__MINE__header(const IP__MINE__header& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IP__MINE__header& operator=(const IP__MINE__header& other_value);
  boolean operator==(const IP__MINE__header& other_value) const;
  inline boolean operator!=(const IP__MINE__header& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& protocol()
    {return field_protocol;}
  inline const INTEGER& protocol() const
    {return field_protocol;}
  inline BITSTRING& s__bit()
    {return field_s__bit;}
  inline const BITSTRING& s__bit() const
    {return field_s__bit;}
  inline BITSTRING& reserved()
    {return field_reserved;}
  inline const BITSTRING& reserved() const
    {return field_reserved;}
  inline INTEGER& cksum()
    {return field_cksum;}
  inline const INTEGER& cksum() const
    {return field_cksum;}
  inline OCTETSTRING& dstaddr()
    {return field_dstaddr;}
  inline const OCTETSTRING& dstaddr() const
    {return field_dstaddr;}
  inline OPTIONAL<OCTETSTRING>& srcaddr()
    {return field_srcaddr;}
  inline const OPTIONAL<OCTETSTRING>& srcaddr() const
    {return field_srcaddr;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IP__MINE__header_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IP__MINE__header_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IP__MINE__header& other_value);
void copy_template(const IP__MINE__header_template& other_value);

public:
IP__MINE__header_template();
IP__MINE__header_template(template_sel other_value);
IP__MINE__header_template(const IP__MINE__header& other_value);
IP__MINE__header_template(const OPTIONAL<IP__MINE__header>& other_value);
IP__MINE__header_template(const IP__MINE__header_template& other_value);
~IP__MINE__header_template();
IP__MINE__header_template& operator=(template_sel other_value);
IP__MINE__header_template& operator=(const IP__MINE__header& other_value);
IP__MINE__header_template& operator=(const OPTIONAL<IP__MINE__header>& other_value);
IP__MINE__header_template& operator=(const IP__MINE__header_template& other_value);
boolean match(const IP__MINE__header& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IP__MINE__header valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IP__MINE__header_template& list_item(unsigned int list_index) const;
INTEGER_template& protocol();
const INTEGER_template& protocol() const;
BITSTRING_template& s__bit();
const BITSTRING_template& s__bit() const;
BITSTRING_template& reserved();
const BITSTRING_template& reserved() const;
INTEGER_template& cksum();
const INTEGER_template& cksum() const;
OCTETSTRING_template& dstaddr();
const OCTETSTRING_template& dstaddr() const;
OCTETSTRING_template& srcaddr();
const OCTETSTRING_template& srcaddr() const;
int size_of() const;
void log() const;
void log_match(const IP__MINE__header& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IP__AH__header : public Base_Type {
  INTEGER field_next__hdr;
  INTEGER field_payload__len;
  OCTETSTRING field_reserved;
  INTEGER field_spi;
  BITSTRING field_sn;
  OCTETSTRING field_auth__data;
  boolean bound_flag;
public:
  IP__AH__header();
  IP__AH__header(const INTEGER& par_next__hdr,
    const INTEGER& par_payload__len,
    const OCTETSTRING& par_reserved,
    const INTEGER& par_spi,
    const BITSTRING& par_sn,
    const OCTETSTRING& par_auth__data);
  IP__AH__header(const IP__AH__header& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IP__AH__header& operator=(const IP__AH__header& other_value);
  boolean operator==(const IP__AH__header& other_value) const;
  inline boolean operator!=(const IP__AH__header& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& next__hdr()
    {return field_next__hdr;}
  inline const INTEGER& next__hdr() const
    {return field_next__hdr;}
  inline INTEGER& payload__len()
    {return field_payload__len;}
  inline const INTEGER& payload__len() const
    {return field_payload__len;}
  inline OCTETSTRING& reserved()
    {return field_reserved;}
  inline const OCTETSTRING& reserved() const
    {return field_reserved;}
  inline INTEGER& spi()
    {return field_spi;}
  inline const INTEGER& spi() const
    {return field_spi;}
  inline BITSTRING& sn()
    {return field_sn;}
  inline const BITSTRING& sn() const
    {return field_sn;}
  inline OCTETSTRING& auth__data()
    {return field_auth__data;}
  inline const OCTETSTRING& auth__data() const
    {return field_auth__data;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IP__AH__header_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IP__AH__header_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IP__AH__header& other_value);
void copy_template(const IP__AH__header_template& other_value);

public:
IP__AH__header_template();
IP__AH__header_template(template_sel other_value);
IP__AH__header_template(const IP__AH__header& other_value);
IP__AH__header_template(const OPTIONAL<IP__AH__header>& other_value);
IP__AH__header_template(const IP__AH__header_template& other_value);
~IP__AH__header_template();
IP__AH__header_template& operator=(template_sel other_value);
IP__AH__header_template& operator=(const IP__AH__header& other_value);
IP__AH__header_template& operator=(const OPTIONAL<IP__AH__header>& other_value);
IP__AH__header_template& operator=(const IP__AH__header_template& other_value);
boolean match(const IP__AH__header& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IP__AH__header valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IP__AH__header_template& list_item(unsigned int list_index) const;
INTEGER_template& next__hdr();
const INTEGER_template& next__hdr() const;
INTEGER_template& payload__len();
const INTEGER_template& payload__len() const;
OCTETSTRING_template& reserved();
const OCTETSTRING_template& reserved() const;
INTEGER_template& spi();
const INTEGER_template& spi() const;
BITSTRING_template& sn();
const BITSTRING_template& sn() const;
OCTETSTRING_template& auth__data();
const OCTETSTRING_template& auth__data() const;
int size_of() const;
void log() const;
void log_match(const IP__AH__header& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IP__ESP__header__part : public Base_Type {
  INTEGER field_spi;
  BITSTRING field_sn;
  boolean bound_flag;
public:
  IP__ESP__header__part();
  IP__ESP__header__part(const INTEGER& par_spi,
    const BITSTRING& par_sn);
  IP__ESP__header__part(const IP__ESP__header__part& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IP__ESP__header__part& operator=(const IP__ESP__header__part& other_value);
  boolean operator==(const IP__ESP__header__part& other_value) const;
  inline boolean operator!=(const IP__ESP__header__part& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& spi()
    {return field_spi;}
  inline const INTEGER& spi() const
    {return field_spi;}
  inline BITSTRING& sn()
    {return field_sn;}
  inline const BITSTRING& sn() const
    {return field_sn;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IP__ESP__header__part_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IP__ESP__header__part_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IP__ESP__header__part& other_value);
void copy_template(const IP__ESP__header__part_template& other_value);

public:
IP__ESP__header__part_template();
IP__ESP__header__part_template(template_sel other_value);
IP__ESP__header__part_template(const IP__ESP__header__part& other_value);
IP__ESP__header__part_template(const OPTIONAL<IP__ESP__header__part>& other_value);
IP__ESP__header__part_template(const IP__ESP__header__part_template& other_value);
~IP__ESP__header__part_template();
IP__ESP__header__part_template& operator=(template_sel other_value);
IP__ESP__header__part_template& operator=(const IP__ESP__header__part& other_value);
IP__ESP__header__part_template& operator=(const OPTIONAL<IP__ESP__header__part>& other_value);
IP__ESP__header__part_template& operator=(const IP__ESP__header__part_template& other_value);
boolean match(const IP__ESP__header__part& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IP__ESP__header__part valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IP__ESP__header__part_template& list_item(unsigned int list_index) const;
INTEGER_template& spi();
const INTEGER_template& spi() const;
BITSTRING_template& sn();
const BITSTRING_template& sn() const;
int size_of() const;
void log() const;
void log_match(const IP__ESP__header__part& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IP__ESP__NULL__tail : public Base_Type {
  OPTIONAL<OCTETSTRING> field_padding;
  INTEGER field_pad__length;
  INTEGER field_next__hdr;
  OCTETSTRING field_auth__data;
  boolean bound_flag;
public:
  IP__ESP__NULL__tail();
  IP__ESP__NULL__tail(const OPTIONAL<OCTETSTRING>& par_padding,
    const INTEGER& par_pad__length,
    const INTEGER& par_next__hdr,
    const OCTETSTRING& par_auth__data);
  IP__ESP__NULL__tail(const IP__ESP__NULL__tail& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IP__ESP__NULL__tail& operator=(const IP__ESP__NULL__tail& other_value);
  boolean operator==(const IP__ESP__NULL__tail& other_value) const;
  inline boolean operator!=(const IP__ESP__NULL__tail& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<OCTETSTRING>& padding()
    {return field_padding;}
  inline const OPTIONAL<OCTETSTRING>& padding() const
    {return field_padding;}
  inline INTEGER& pad__length()
    {return field_pad__length;}
  inline const INTEGER& pad__length() const
    {return field_pad__length;}
  inline INTEGER& next__hdr()
    {return field_next__hdr;}
  inline const INTEGER& next__hdr() const
    {return field_next__hdr;}
  inline OCTETSTRING& auth__data()
    {return field_auth__data;}
  inline const OCTETSTRING& auth__data() const
    {return field_auth__data;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IP__ESP__NULL__tail_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IP__ESP__NULL__tail_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IP__ESP__NULL__tail& other_value);
void copy_template(const IP__ESP__NULL__tail_template& other_value);

public:
IP__ESP__NULL__tail_template();
IP__ESP__NULL__tail_template(template_sel other_value);
IP__ESP__NULL__tail_template(const IP__ESP__NULL__tail& other_value);
IP__ESP__NULL__tail_template(const OPTIONAL<IP__ESP__NULL__tail>& other_value);
IP__ESP__NULL__tail_template(const IP__ESP__NULL__tail_template& other_value);
~IP__ESP__NULL__tail_template();
IP__ESP__NULL__tail_template& operator=(template_sel other_value);
IP__ESP__NULL__tail_template& operator=(const IP__ESP__NULL__tail& other_value);
IP__ESP__NULL__tail_template& operator=(const OPTIONAL<IP__ESP__NULL__tail>& other_value);
IP__ESP__NULL__tail_template& operator=(const IP__ESP__NULL__tail_template& other_value);
boolean match(const IP__ESP__NULL__tail& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IP__ESP__NULL__tail valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IP__ESP__NULL__tail_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& padding();
const OCTETSTRING_template& padding() const;
INTEGER_template& pad__length();
const INTEGER_template& pad__length() const;
INTEGER_template& next__hdr();
const INTEGER_template& next__hdr() const;
OCTETSTRING_template& auth__data();
const OCTETSTRING_template& auth__data() const;
int size_of() const;
void log() const;
void log_match(const IP__ESP__NULL__tail& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IP__ESP__tail__part : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_esp__null__tail = 1, ALT_raw__data = 2 };
private:
union_selection_type union_selection;
union {
IP__ESP__NULL__tail *field_esp__null__tail;
OCTETSTRING *field_raw__data;
};
void copy_value(const IP__ESP__tail__part& other_value);

public:
IP__ESP__tail__part();
IP__ESP__tail__part(const IP__ESP__tail__part& other_value);
~IP__ESP__tail__part();
IP__ESP__tail__part& operator=(const IP__ESP__tail__part& other_value);
boolean operator==(const IP__ESP__tail__part& other_value) const;
inline boolean operator!=(const IP__ESP__tail__part& other_value) const { return !(*this == other_value); }
IP__ESP__NULL__tail& esp__null__tail();
const IP__ESP__NULL__tail& esp__null__tail() const;
OCTETSTRING& raw__data();
const OCTETSTRING& raw__data() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IP__ESP__tail__part_template : public Base_Template {
union {
struct {
IP__ESP__tail__part::union_selection_type union_selection;
union {
IP__ESP__NULL__tail_template *field_esp__null__tail;
OCTETSTRING_template *field_raw__data;
};
} single_value;
struct {
unsigned int n_values;
IP__ESP__tail__part_template *list_value;
} value_list;
};
void copy_value(const IP__ESP__tail__part& other_value);

void copy_template(const IP__ESP__tail__part_template& other_value);

public:
IP__ESP__tail__part_template();
IP__ESP__tail__part_template(template_sel other_value);
IP__ESP__tail__part_template(const IP__ESP__tail__part& other_value);
IP__ESP__tail__part_template(const OPTIONAL<IP__ESP__tail__part>& other_value);
IP__ESP__tail__part_template(const IP__ESP__tail__part_template& other_value);
~IP__ESP__tail__part_template();
void clean_up();
IP__ESP__tail__part_template& operator=(template_sel other_value);
IP__ESP__tail__part_template& operator=(const IP__ESP__tail__part& other_value);
IP__ESP__tail__part_template& operator=(const OPTIONAL<IP__ESP__tail__part>& other_value);
IP__ESP__tail__part_template& operator=(const IP__ESP__tail__part_template& other_value);
boolean match(const IP__ESP__tail__part& other_value) const;
boolean is_value() const;IP__ESP__tail__part valueof() const;
IP__ESP__tail__part_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
IP__ESP__NULL__tail_template& esp__null__tail();
const IP__ESP__NULL__tail_template& esp__null__tail() const;
OCTETSTRING_template& raw__data();
const OCTETSTRING_template& raw__data() const;
boolean ischosen(IP__ESP__tail__part::union_selection_type checked_selection) const;
void log() const;
void log_match(const IP__ESP__tail__part& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class IP__ESP__header : public Base_Type {
  IP__ESP__header__part field_header;
  IP__ESP__tail__part field_tail;
  boolean bound_flag;
public:
  IP__ESP__header();
  IP__ESP__header(const IP__ESP__header__part& par_header,
    const IP__ESP__tail__part& par_tail);
  IP__ESP__header(const IP__ESP__header& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IP__ESP__header& operator=(const IP__ESP__header& other_value);
  boolean operator==(const IP__ESP__header& other_value) const;
  inline boolean operator!=(const IP__ESP__header& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline IP__ESP__header__part& header()
    {return field_header;}
  inline const IP__ESP__header__part& header() const
    {return field_header;}
  inline IP__ESP__tail__part& tail()
    {return field_tail;}
  inline const IP__ESP__tail__part& tail() const
    {return field_tail;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IP__ESP__header_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IP__ESP__header_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IP__ESP__header& other_value);
void copy_template(const IP__ESP__header_template& other_value);

public:
IP__ESP__header_template();
IP__ESP__header_template(template_sel other_value);
IP__ESP__header_template(const IP__ESP__header& other_value);
IP__ESP__header_template(const OPTIONAL<IP__ESP__header>& other_value);
IP__ESP__header_template(const IP__ESP__header_template& other_value);
~IP__ESP__header_template();
IP__ESP__header_template& operator=(template_sel other_value);
IP__ESP__header_template& operator=(const IP__ESP__header& other_value);
IP__ESP__header_template& operator=(const OPTIONAL<IP__ESP__header>& other_value);
IP__ESP__header_template& operator=(const IP__ESP__header_template& other_value);
boolean match(const IP__ESP__header& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IP__ESP__header valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IP__ESP__header_template& list_item(unsigned int list_index) const;
IP__ESP__header__part_template& header();
const IP__ESP__header__part_template& header() const;
IP__ESP__tail__part_template& tail();
const IP__ESP__tail__part_template& tail() const;
int size_of() const;
void log() const;
void log_match(const IP__ESP__header& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IP__GRE2__header : public Base_Type {
  BITSTRING field_c;
  BITSTRING field_reserved__bit;
  BITSTRING field_k;
  BITSTRING field_s;
  BITSTRING field_reserved0;
  BITSTRING field_version;
  INTEGER field_protocol__type;
  OPTIONAL<INTEGER> field_checksum;
  OPTIONAL<INTEGER> field_reserved1;
  OPTIONAL<INTEGER> field_key;
  OPTIONAL<BITSTRING> field_sn;
  boolean bound_flag;
public:
  IP__GRE2__header();
  IP__GRE2__header(const BITSTRING& par_c,
    const BITSTRING& par_reserved__bit,
    const BITSTRING& par_k,
    const BITSTRING& par_s,
    const BITSTRING& par_reserved0,
    const BITSTRING& par_version,
    const INTEGER& par_protocol__type,
    const OPTIONAL<INTEGER>& par_checksum,
    const OPTIONAL<INTEGER>& par_reserved1,
    const OPTIONAL<INTEGER>& par_key,
    const OPTIONAL<BITSTRING>& par_sn);
  IP__GRE2__header(const IP__GRE2__header& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IP__GRE2__header& operator=(const IP__GRE2__header& other_value);
  boolean operator==(const IP__GRE2__header& other_value) const;
  inline boolean operator!=(const IP__GRE2__header& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BITSTRING& c()
    {return field_c;}
  inline const BITSTRING& c() const
    {return field_c;}
  inline BITSTRING& reserved__bit()
    {return field_reserved__bit;}
  inline const BITSTRING& reserved__bit() const
    {return field_reserved__bit;}
  inline BITSTRING& k()
    {return field_k;}
  inline const BITSTRING& k() const
    {return field_k;}
  inline BITSTRING& s()
    {return field_s;}
  inline const BITSTRING& s() const
    {return field_s;}
  inline BITSTRING& reserved0()
    {return field_reserved0;}
  inline const BITSTRING& reserved0() const
    {return field_reserved0;}
  inline BITSTRING& version()
    {return field_version;}
  inline const BITSTRING& version() const
    {return field_version;}
  inline INTEGER& protocol__type()
    {return field_protocol__type;}
  inline const INTEGER& protocol__type() const
    {return field_protocol__type;}
  inline OPTIONAL<INTEGER>& checksum()
    {return field_checksum;}
  inline const OPTIONAL<INTEGER>& checksum() const
    {return field_checksum;}
  inline OPTIONAL<INTEGER>& reserved1()
    {return field_reserved1;}
  inline const OPTIONAL<INTEGER>& reserved1() const
    {return field_reserved1;}
  inline OPTIONAL<INTEGER>& key()
    {return field_key;}
  inline const OPTIONAL<INTEGER>& key() const
    {return field_key;}
  inline OPTIONAL<BITSTRING>& sn()
    {return field_sn;}
  inline const OPTIONAL<BITSTRING>& sn() const
    {return field_sn;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IP__GRE2__header_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IP__GRE2__header_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IP__GRE2__header& other_value);
void copy_template(const IP__GRE2__header_template& other_value);

public:
IP__GRE2__header_template();
IP__GRE2__header_template(template_sel other_value);
IP__GRE2__header_template(const IP__GRE2__header& other_value);
IP__GRE2__header_template(const OPTIONAL<IP__GRE2__header>& other_value);
IP__GRE2__header_template(const IP__GRE2__header_template& other_value);
~IP__GRE2__header_template();
IP__GRE2__header_template& operator=(template_sel other_value);
IP__GRE2__header_template& operator=(const IP__GRE2__header& other_value);
IP__GRE2__header_template& operator=(const OPTIONAL<IP__GRE2__header>& other_value);
IP__GRE2__header_template& operator=(const IP__GRE2__header_template& other_value);
boolean match(const IP__GRE2__header& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IP__GRE2__header valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IP__GRE2__header_template& list_item(unsigned int list_index) const;
BITSTRING_template& c();
const BITSTRING_template& c() const;
BITSTRING_template& reserved__bit();
const BITSTRING_template& reserved__bit() const;
BITSTRING_template& k();
const BITSTRING_template& k() const;
BITSTRING_template& s();
const BITSTRING_template& s() const;
BITSTRING_template& reserved0();
const BITSTRING_template& reserved0() const;
BITSTRING_template& version();
const BITSTRING_template& version() const;
INTEGER_template& protocol__type();
const INTEGER_template& protocol__type() const;
INTEGER_template& checksum();
const INTEGER_template& checksum() const;
INTEGER_template& reserved1();
const INTEGER_template& reserved1() const;
INTEGER_template& key();
const INTEGER_template& key() const;
BITSTRING_template& sn();
const BITSTRING_template& sn() const;
int size_of() const;
void log() const;
void log_match(const IP__GRE2__header& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IPv4__extension__headers : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
IPv4__extension__header **value_elements;
} *val_ptr;

static const IPv4__extension__header UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const IPv4__extension__headers& other_value);

public:
  typedef IPv4__extension__header of_type;
IPv4__extension__headers();
IPv4__extension__headers(null_type other_value);
IPv4__extension__headers(const IPv4__extension__headers& other_value);
~IPv4__extension__headers();

void clean_up();
IPv4__extension__headers& operator=(null_type other_value);
IPv4__extension__headers& operator=(const IPv4__extension__headers& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const IPv4__extension__headers& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const IPv4__extension__headers& other_value) const { return !(*this == other_value); }

IPv4__extension__header& operator[](int index_value);
IPv4__extension__header& operator[](const INTEGER& index_value);
const IPv4__extension__header& operator[](int index_value) const;
const IPv4__extension__header& operator[](const INTEGER& index_value) const;

IPv4__extension__headers operator<<=(int rotate_count) const;
IPv4__extension__headers operator<<=(const INTEGER& rotate_count) const;
IPv4__extension__headers operator>>=(int rotate_count) const;
IPv4__extension__headers operator>>=(const INTEGER& rotate_count) const;

IPv4__extension__headers operator+(const IPv4__extension__headers& other_value) const;

IPv4__extension__headers substr(int index, int returncount) const;

IPv4__extension__headers replace(int index, int len, const IPv4__extension__headers& repl) const;

IPv4__extension__headers replace(int index, int len, const IPv4__extension__headers_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IPv4__extension__headers_template : public Record_Of_Template {
union {
struct {
int n_elements;
IPv4__extension__header_template **value_elements;
} single_value;
struct {
unsigned int n_values;
IPv4__extension__headers_template *list_value;
} value_list;
};
void copy_value(const IPv4__extension__headers& other_value);
void copy_template(const IPv4__extension__headers_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
IPv4__extension__headers_template();
IPv4__extension__headers_template(template_sel other_value);
IPv4__extension__headers_template(null_type other_value);
IPv4__extension__headers_template(const IPv4__extension__headers& other_value);
IPv4__extension__headers_template(const OPTIONAL<IPv4__extension__headers>& other_value);
IPv4__extension__headers_template(const IPv4__extension__headers_template& other_value);
~IPv4__extension__headers_template();

void clean_up();
IPv4__extension__headers_template& operator=(template_sel other_value);
IPv4__extension__headers_template& operator=(null_type other_value);
IPv4__extension__headers_template& operator=(const IPv4__extension__headers& other_value);
IPv4__extension__headers_template& operator=(const OPTIONAL<IPv4__extension__headers>& other_value);
IPv4__extension__headers_template& operator=(const IPv4__extension__headers_template& other_value);

IPv4__extension__header_template& operator[](int index_value);
IPv4__extension__header_template& operator[](const INTEGER& index_value);
const IPv4__extension__header_template& operator[](int index_value) const;
const IPv4__extension__header_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const IPv4__extension__headers& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
IPv4__extension__headers valueof() const;
IPv4__extension__headers substr(int index, int returncount) const;

IPv4__extension__headers replace(int index, int len, const IPv4__extension__headers_template& repl) const;

IPv4__extension__headers replace(int index, int len, const IPv4__extension__headers& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
IPv4__extension__headers_template& list_item(unsigned int list_index);
void log() const;
void log_match(const IPv4__extension__headers& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class IPv4__extension__header : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_mine__hdr = 1, ALT_ah__hdr = 2, ALT_esp__hdr = 3, ALT_gre2__hdr = 4, ALT_raw__hdr = 5 };
private:
union_selection_type union_selection;
union {
IP__MINE__header *field_mine__hdr;
IP__AH__header *field_ah__hdr;
IP__ESP__header *field_esp__hdr;
IP__GRE2__header *field_gre2__hdr;
OCTETSTRING *field_raw__hdr;
};
void copy_value(const IPv4__extension__header& other_value);

public:
IPv4__extension__header();
IPv4__extension__header(const IPv4__extension__header& other_value);
~IPv4__extension__header();
IPv4__extension__header& operator=(const IPv4__extension__header& other_value);
boolean operator==(const IPv4__extension__header& other_value) const;
inline boolean operator!=(const IPv4__extension__header& other_value) const { return !(*this == other_value); }
IP__MINE__header& mine__hdr();
const IP__MINE__header& mine__hdr() const;
IP__AH__header& ah__hdr();
const IP__AH__header& ah__hdr() const;
IP__ESP__header& esp__hdr();
const IP__ESP__header& esp__hdr() const;
IP__GRE2__header& gre2__hdr();
const IP__GRE2__header& gre2__hdr() const;
OCTETSTRING& raw__hdr();
const OCTETSTRING& raw__hdr() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IPv4__extension__header_template : public Base_Template {
union {
struct {
IPv4__extension__header::union_selection_type union_selection;
union {
IP__MINE__header_template *field_mine__hdr;
IP__AH__header_template *field_ah__hdr;
IP__ESP__header_template *field_esp__hdr;
IP__GRE2__header_template *field_gre2__hdr;
OCTETSTRING_template *field_raw__hdr;
};
} single_value;
struct {
unsigned int n_values;
IPv4__extension__header_template *list_value;
} value_list;
};
void copy_value(const IPv4__extension__header& other_value);

void copy_template(const IPv4__extension__header_template& other_value);

public:
IPv4__extension__header_template();
IPv4__extension__header_template(template_sel other_value);
IPv4__extension__header_template(const IPv4__extension__header& other_value);
IPv4__extension__header_template(const OPTIONAL<IPv4__extension__header>& other_value);
IPv4__extension__header_template(const IPv4__extension__header_template& other_value);
~IPv4__extension__header_template();
void clean_up();
IPv4__extension__header_template& operator=(template_sel other_value);
IPv4__extension__header_template& operator=(const IPv4__extension__header& other_value);
IPv4__extension__header_template& operator=(const OPTIONAL<IPv4__extension__header>& other_value);
IPv4__extension__header_template& operator=(const IPv4__extension__header_template& other_value);
boolean match(const IPv4__extension__header& other_value) const;
boolean is_value() const;IPv4__extension__header valueof() const;
IPv4__extension__header_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
IP__MINE__header_template& mine__hdr();
const IP__MINE__header_template& mine__hdr() const;
IP__AH__header_template& ah__hdr();
const IP__AH__header_template& ah__hdr() const;
IP__ESP__header_template& esp__hdr();
const IP__ESP__header_template& esp__hdr() const;
IP__GRE2__header_template& gre2__hdr();
const IP__GRE2__header_template& gre2__hdr() const;
OCTETSTRING_template& raw__hdr();
const OCTETSTRING_template& raw__hdr() const;
boolean ischosen(IPv4__extension__header::union_selection_type checked_selection) const;
void log() const;
void log_match(const IPv4__extension__header& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class IPv4__header : public Base_Type {
  INTEGER field_ver;
  INTEGER field_hlen;
  INTEGER field_tos;
  INTEGER field_tlen;
  INTEGER field_id;
  BITSTRING field_res;
  BITSTRING field_dfrag;
  BITSTRING field_mfrag;
  INTEGER field_foffset;
  INTEGER field_ttl;
  INTEGER field_proto;
  INTEGER field_cksum;
  OCTETSTRING field_srcaddr;
  OCTETSTRING field_dstaddr;
  boolean bound_flag;
public:
  IPv4__header();
  IPv4__header(const INTEGER& par_ver,
    const INTEGER& par_hlen,
    const INTEGER& par_tos,
    const INTEGER& par_tlen,
    const INTEGER& par_id,
    const BITSTRING& par_res,
    const BITSTRING& par_dfrag,
    const BITSTRING& par_mfrag,
    const INTEGER& par_foffset,
    const INTEGER& par_ttl,
    const INTEGER& par_proto,
    const INTEGER& par_cksum,
    const OCTETSTRING& par_srcaddr,
    const OCTETSTRING& par_dstaddr);
  IPv4__header(const IPv4__header& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IPv4__header& operator=(const IPv4__header& other_value);
  boolean operator==(const IPv4__header& other_value) const;
  inline boolean operator!=(const IPv4__header& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& ver()
    {return field_ver;}
  inline const INTEGER& ver() const
    {return field_ver;}
  inline INTEGER& hlen()
    {return field_hlen;}
  inline const INTEGER& hlen() const
    {return field_hlen;}
  inline INTEGER& tos()
    {return field_tos;}
  inline const INTEGER& tos() const
    {return field_tos;}
  inline INTEGER& tlen()
    {return field_tlen;}
  inline const INTEGER& tlen() const
    {return field_tlen;}
  inline INTEGER& id()
    {return field_id;}
  inline const INTEGER& id() const
    {return field_id;}
  inline BITSTRING& res()
    {return field_res;}
  inline const BITSTRING& res() const
    {return field_res;}
  inline BITSTRING& dfrag()
    {return field_dfrag;}
  inline const BITSTRING& dfrag() const
    {return field_dfrag;}
  inline BITSTRING& mfrag()
    {return field_mfrag;}
  inline const BITSTRING& mfrag() const
    {return field_mfrag;}
  inline INTEGER& foffset()
    {return field_foffset;}
  inline const INTEGER& foffset() const
    {return field_foffset;}
  inline INTEGER& ttl()
    {return field_ttl;}
  inline const INTEGER& ttl() const
    {return field_ttl;}
  inline INTEGER& proto()
    {return field_proto;}
  inline const INTEGER& proto() const
    {return field_proto;}
  inline INTEGER& cksum()
    {return field_cksum;}
  inline const INTEGER& cksum() const
    {return field_cksum;}
  inline OCTETSTRING& srcaddr()
    {return field_srcaddr;}
  inline const OCTETSTRING& srcaddr() const
    {return field_srcaddr;}
  inline OCTETSTRING& dstaddr()
    {return field_dstaddr;}
  inline const OCTETSTRING& dstaddr() const
    {return field_dstaddr;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IPv4__header_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IPv4__header_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IPv4__header& other_value);
void copy_template(const IPv4__header_template& other_value);

public:
IPv4__header_template();
IPv4__header_template(template_sel other_value);
IPv4__header_template(const IPv4__header& other_value);
IPv4__header_template(const OPTIONAL<IPv4__header>& other_value);
IPv4__header_template(const IPv4__header_template& other_value);
~IPv4__header_template();
IPv4__header_template& operator=(template_sel other_value);
IPv4__header_template& operator=(const IPv4__header& other_value);
IPv4__header_template& operator=(const OPTIONAL<IPv4__header>& other_value);
IPv4__header_template& operator=(const IPv4__header_template& other_value);
boolean match(const IPv4__header& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IPv4__header valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IPv4__header_template& list_item(unsigned int list_index) const;
INTEGER_template& ver();
const INTEGER_template& ver() const;
INTEGER_template& hlen();
const INTEGER_template& hlen() const;
INTEGER_template& tos();
const INTEGER_template& tos() const;
INTEGER_template& tlen();
const INTEGER_template& tlen() const;
INTEGER_template& id();
const INTEGER_template& id() const;
BITSTRING_template& res();
const BITSTRING_template& res() const;
BITSTRING_template& dfrag();
const BITSTRING_template& dfrag() const;
BITSTRING_template& mfrag();
const BITSTRING_template& mfrag() const;
INTEGER_template& foffset();
const INTEGER_template& foffset() const;
INTEGER_template& ttl();
const INTEGER_template& ttl() const;
INTEGER_template& proto();
const INTEGER_template& proto() const;
INTEGER_template& cksum();
const INTEGER_template& cksum() const;
OCTETSTRING_template& srcaddr();
const OCTETSTRING_template& srcaddr() const;
OCTETSTRING_template& dstaddr();
const OCTETSTRING_template& dstaddr() const;
int size_of() const;
void log() const;
void log_match(const IPv4__header& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IPv4__packet : public Base_Type {
  IPv4__header field_header;
  OPTIONAL<IPv4__extension__headers> field_ext__headers;
  OPTIONAL<OCTETSTRING> field_payload;
  boolean bound_flag;
public:
  IPv4__packet();
  IPv4__packet(const IPv4__header& par_header,
    const OPTIONAL<IPv4__extension__headers>& par_ext__headers,
    const OPTIONAL<OCTETSTRING>& par_payload);
  IPv4__packet(const IPv4__packet& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IPv4__packet& operator=(const IPv4__packet& other_value);
  boolean operator==(const IPv4__packet& other_value) const;
  inline boolean operator!=(const IPv4__packet& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline IPv4__header& header()
    {return field_header;}
  inline const IPv4__header& header() const
    {return field_header;}
  inline OPTIONAL<IPv4__extension__headers>& ext__headers()
    {return field_ext__headers;}
  inline const OPTIONAL<IPv4__extension__headers>& ext__headers() const
    {return field_ext__headers;}
  inline OPTIONAL<OCTETSTRING>& payload()
    {return field_payload;}
  inline const OPTIONAL<OCTETSTRING>& payload() const
    {return field_payload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IPv4__packet_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IPv4__packet_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IPv4__packet& other_value);
void copy_template(const IPv4__packet_template& other_value);

public:
IPv4__packet_template();
IPv4__packet_template(template_sel other_value);
IPv4__packet_template(const IPv4__packet& other_value);
IPv4__packet_template(const OPTIONAL<IPv4__packet>& other_value);
IPv4__packet_template(const IPv4__packet_template& other_value);
~IPv4__packet_template();
IPv4__packet_template& operator=(template_sel other_value);
IPv4__packet_template& operator=(const IPv4__packet& other_value);
IPv4__packet_template& operator=(const OPTIONAL<IPv4__packet>& other_value);
IPv4__packet_template& operator=(const IPv4__packet_template& other_value);
boolean match(const IPv4__packet& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IPv4__packet valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IPv4__packet_template& list_item(unsigned int list_index) const;
IPv4__header_template& header();
const IPv4__header_template& header() const;
IPv4__extension__headers_template& ext__headers();
const IPv4__extension__headers_template& ext__headers() const;
OCTETSTRING_template& payload();
const OCTETSTRING_template& payload() const;
int size_of() const;
void log() const;
void log_match(const IPv4__packet& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IPv4msg__SP__PT : public PORT {
enum msg_selection { MESSAGE_0 };
struct msg_queue_item : public msg_queue_item_base {
msg_selection item_selection;
union {
IPv4__packet *message_0;
};
component sender_component;
};

void remove_msg_queue_head();
protected:
void clear_queue();
public:
IPv4msg__SP__PT(const char *par_port_name = NULL);
~IPv4msg__SP__PT();
void send(const IPv4__packet& send_par, const COMPONENT& destination_component);
void send(const IPv4__packet& send_par);
void send(const IPv4__packet_template& send_par, const COMPONENT& destination_component);
void send(const IPv4__packet_template& send_par);
alt_status receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status receive(const IPv4__packet_template& value_template, IPv4__packet *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const IPv4__packet_template& value_template, IPv4__packet *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const IPv4__packet_template& value_template, IPv4__packet *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
private:
void incoming_message(const IPv4__packet& incoming_par, component sender_component);
protected:
boolean process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING& slider);
};

class ASP__IPv4 {
  IPv4__packet field_ipv4__packet;
  BOOLEAN field_cksum__calc;
  boolean bound_flag;
public:
  ASP__IPv4();
  ASP__IPv4(const IPv4__packet& par_ipv4__packet,
    const BOOLEAN& par_cksum__calc);
  ASP__IPv4(const ASP__IPv4& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ASP__IPv4& operator=(const ASP__IPv4& other_value);
  boolean operator==(const ASP__IPv4& other_value) const;
  inline boolean operator!=(const ASP__IPv4& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline IPv4__packet& ipv4__packet()
    {return field_ipv4__packet;}
  inline const IPv4__packet& ipv4__packet() const
    {return field_ipv4__packet;}
  inline BOOLEAN& cksum__calc()
    {return field_cksum__calc;}
  inline const BOOLEAN& cksum__calc() const
    {return field_cksum__calc;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__IPv4_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__IPv4_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ASP__IPv4& other_value);
void copy_template(const ASP__IPv4_template& other_value);

public:
ASP__IPv4_template();
ASP__IPv4_template(template_sel other_value);
ASP__IPv4_template(const ASP__IPv4& other_value);
ASP__IPv4_template(const OPTIONAL<ASP__IPv4>& other_value);
ASP__IPv4_template(const ASP__IPv4_template& other_value);
~ASP__IPv4_template();
ASP__IPv4_template& operator=(template_sel other_value);
ASP__IPv4_template& operator=(const ASP__IPv4& other_value);
ASP__IPv4_template& operator=(const OPTIONAL<ASP__IPv4>& other_value);
ASP__IPv4_template& operator=(const ASP__IPv4_template& other_value);
boolean match(const ASP__IPv4& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__IPv4 valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__IPv4_template& list_item(unsigned int list_index) const;
IPv4__packet_template& ipv4__packet();
const IPv4__packet_template& ipv4__packet() const;
BOOLEAN_template& cksum__calc();
const BOOLEAN_template& cksum__calc() const;
int size_of() const;
void log() const;
void log_match(const ASP__IPv4& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IPv4__ASP__SP__PT : public PORT {
enum msg_selection { MESSAGE_0 };
struct msg_queue_item : public msg_queue_item_base {
msg_selection item_selection;
union {
ASP__IPv4 *message_0;
};
component sender_component;
};

void remove_msg_queue_head();
protected:
void clear_queue();
public:
IPv4__ASP__SP__PT(const char *par_port_name = NULL);
~IPv4__ASP__SP__PT();
void send(const ASP__IPv4& send_par, const COMPONENT& destination_component);
void send(const ASP__IPv4& send_par);
void send(const ASP__IPv4_template& send_par, const COMPONENT& destination_component);
void send(const ASP__IPv4_template& send_par);
alt_status receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status receive(const ASP__IPv4_template& value_template, ASP__IPv4 *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const ASP__IPv4_template& value_template, ASP__IPv4 *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const ASP__IPv4_template& value_template, ASP__IPv4 *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
private:
void incoming_message(const ASP__IPv4& incoming_par, component sender_component);
protected:
boolean process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING& slider);
};

class IPv6__Fragment__header : public Base_Type {
  INTEGER field_next__hdr;
  OCTETSTRING field_reserved;
  INTEGER field_fragmentOffset;
  BITSTRING field_reserved2;
  BITSTRING field_mFlag;
  OCTETSTRING field_identification;
  boolean bound_flag;
public:
  IPv6__Fragment__header();
  IPv6__Fragment__header(const INTEGER& par_next__hdr,
    const OCTETSTRING& par_reserved,
    const INTEGER& par_fragmentOffset,
    const BITSTRING& par_reserved2,
    const BITSTRING& par_mFlag,
    const OCTETSTRING& par_identification);
  IPv6__Fragment__header(const IPv6__Fragment__header& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IPv6__Fragment__header& operator=(const IPv6__Fragment__header& other_value);
  boolean operator==(const IPv6__Fragment__header& other_value) const;
  inline boolean operator!=(const IPv6__Fragment__header& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& next__hdr()
    {return field_next__hdr;}
  inline const INTEGER& next__hdr() const
    {return field_next__hdr;}
  inline OCTETSTRING& reserved()
    {return field_reserved;}
  inline const OCTETSTRING& reserved() const
    {return field_reserved;}
  inline INTEGER& fragmentOffset()
    {return field_fragmentOffset;}
  inline const INTEGER& fragmentOffset() const
    {return field_fragmentOffset;}
  inline BITSTRING& reserved2()
    {return field_reserved2;}
  inline const BITSTRING& reserved2() const
    {return field_reserved2;}
  inline BITSTRING& mFlag()
    {return field_mFlag;}
  inline const BITSTRING& mFlag() const
    {return field_mFlag;}
  inline OCTETSTRING& identification()
    {return field_identification;}
  inline const OCTETSTRING& identification() const
    {return field_identification;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IPv6__Fragment__header_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IPv6__Fragment__header_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IPv6__Fragment__header& other_value);
void copy_template(const IPv6__Fragment__header_template& other_value);

public:
IPv6__Fragment__header_template();
IPv6__Fragment__header_template(template_sel other_value);
IPv6__Fragment__header_template(const IPv6__Fragment__header& other_value);
IPv6__Fragment__header_template(const OPTIONAL<IPv6__Fragment__header>& other_value);
IPv6__Fragment__header_template(const IPv6__Fragment__header_template& other_value);
~IPv6__Fragment__header_template();
IPv6__Fragment__header_template& operator=(template_sel other_value);
IPv6__Fragment__header_template& operator=(const IPv6__Fragment__header& other_value);
IPv6__Fragment__header_template& operator=(const OPTIONAL<IPv6__Fragment__header>& other_value);
IPv6__Fragment__header_template& operator=(const IPv6__Fragment__header_template& other_value);
boolean match(const IPv6__Fragment__header& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IPv6__Fragment__header valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IPv6__Fragment__header_template& list_item(unsigned int list_index) const;
INTEGER_template& next__hdr();
const INTEGER_template& next__hdr() const;
OCTETSTRING_template& reserved();
const OCTETSTRING_template& reserved() const;
INTEGER_template& fragmentOffset();
const INTEGER_template& fragmentOffset() const;
BITSTRING_template& reserved2();
const BITSTRING_template& reserved2() const;
BITSTRING_template& mFlag();
const BITSTRING_template& mFlag() const;
OCTETSTRING_template& identification();
const OCTETSTRING_template& identification() const;
int size_of() const;
void log() const;
void log_match(const IPv6__Fragment__header& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IPv6__extension__headers : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
IPv6__extension__header **value_elements;
} *val_ptr;

static const IPv6__extension__header UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const IPv6__extension__headers& other_value);

public:
  typedef IPv6__extension__header of_type;
IPv6__extension__headers();
IPv6__extension__headers(null_type other_value);
IPv6__extension__headers(const IPv6__extension__headers& other_value);
~IPv6__extension__headers();

void clean_up();
IPv6__extension__headers& operator=(null_type other_value);
IPv6__extension__headers& operator=(const IPv6__extension__headers& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const IPv6__extension__headers& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const IPv6__extension__headers& other_value) const { return !(*this == other_value); }

IPv6__extension__header& operator[](int index_value);
IPv6__extension__header& operator[](const INTEGER& index_value);
const IPv6__extension__header& operator[](int index_value) const;
const IPv6__extension__header& operator[](const INTEGER& index_value) const;

IPv6__extension__headers operator<<=(int rotate_count) const;
IPv6__extension__headers operator<<=(const INTEGER& rotate_count) const;
IPv6__extension__headers operator>>=(int rotate_count) const;
IPv6__extension__headers operator>>=(const INTEGER& rotate_count) const;

IPv6__extension__headers operator+(const IPv6__extension__headers& other_value) const;

IPv6__extension__headers substr(int index, int returncount) const;

IPv6__extension__headers replace(int index, int len, const IPv6__extension__headers& repl) const;

IPv6__extension__headers replace(int index, int len, const IPv6__extension__headers_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IPv6__extension__headers_template : public Record_Of_Template {
union {
struct {
int n_elements;
IPv6__extension__header_template **value_elements;
} single_value;
struct {
unsigned int n_values;
IPv6__extension__headers_template *list_value;
} value_list;
};
void copy_value(const IPv6__extension__headers& other_value);
void copy_template(const IPv6__extension__headers_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
IPv6__extension__headers_template();
IPv6__extension__headers_template(template_sel other_value);
IPv6__extension__headers_template(null_type other_value);
IPv6__extension__headers_template(const IPv6__extension__headers& other_value);
IPv6__extension__headers_template(const OPTIONAL<IPv6__extension__headers>& other_value);
IPv6__extension__headers_template(const IPv6__extension__headers_template& other_value);
~IPv6__extension__headers_template();

void clean_up();
IPv6__extension__headers_template& operator=(template_sel other_value);
IPv6__extension__headers_template& operator=(null_type other_value);
IPv6__extension__headers_template& operator=(const IPv6__extension__headers& other_value);
IPv6__extension__headers_template& operator=(const OPTIONAL<IPv6__extension__headers>& other_value);
IPv6__extension__headers_template& operator=(const IPv6__extension__headers_template& other_value);

IPv6__extension__header_template& operator[](int index_value);
IPv6__extension__header_template& operator[](const INTEGER& index_value);
const IPv6__extension__header_template& operator[](int index_value) const;
const IPv6__extension__header_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const IPv6__extension__headers& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
IPv6__extension__headers valueof() const;
IPv6__extension__headers substr(int index, int returncount) const;

IPv6__extension__headers replace(int index, int len, const IPv6__extension__headers_template& repl) const;

IPv6__extension__headers replace(int index, int len, const IPv6__extension__headers& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
IPv6__extension__headers_template& list_item(unsigned int list_index);
void log() const;
void log_match(const IPv6__extension__headers& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class IPv6__extension__header : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_ah__hdr = 1, ALT_esp__hdr = 2, ALT_gre2__hdr = 3, ALT_general__exthdr = 4, ALT_iPv6__Fragment__header = 5, ALT_raw__hdr = 6 };
private:
union_selection_type union_selection;
union {
IP__AH__header *field_ah__hdr;
IP__ESP__header *field_esp__hdr;
IP__GRE2__header *field_gre2__hdr;
IPv6__general__IPv6__extension__header *field_general__exthdr;
IPv6__Fragment__header *field_iPv6__Fragment__header;
OCTETSTRING *field_raw__hdr;
};
void copy_value(const IPv6__extension__header& other_value);

public:
IPv6__extension__header();
IPv6__extension__header(const IPv6__extension__header& other_value);
~IPv6__extension__header();
IPv6__extension__header& operator=(const IPv6__extension__header& other_value);
boolean operator==(const IPv6__extension__header& other_value) const;
inline boolean operator!=(const IPv6__extension__header& other_value) const { return !(*this == other_value); }
IP__AH__header& ah__hdr();
const IP__AH__header& ah__hdr() const;
IP__ESP__header& esp__hdr();
const IP__ESP__header& esp__hdr() const;
IP__GRE2__header& gre2__hdr();
const IP__GRE2__header& gre2__hdr() const;
IPv6__general__IPv6__extension__header& general__exthdr();
const IPv6__general__IPv6__extension__header& general__exthdr() const;
IPv6__Fragment__header& iPv6__Fragment__header();
const IPv6__Fragment__header& iPv6__Fragment__header() const;
OCTETSTRING& raw__hdr();
const OCTETSTRING& raw__hdr() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IPv6__extension__header_template : public Base_Template {
union {
struct {
IPv6__extension__header::union_selection_type union_selection;
union {
IP__AH__header_template *field_ah__hdr;
IP__ESP__header_template *field_esp__hdr;
IP__GRE2__header_template *field_gre2__hdr;
IPv6__general__IPv6__extension__header_template *field_general__exthdr;
IPv6__Fragment__header_template *field_iPv6__Fragment__header;
OCTETSTRING_template *field_raw__hdr;
};
} single_value;
struct {
unsigned int n_values;
IPv6__extension__header_template *list_value;
} value_list;
};
void copy_value(const IPv6__extension__header& other_value);

void copy_template(const IPv6__extension__header_template& other_value);

public:
IPv6__extension__header_template();
IPv6__extension__header_template(template_sel other_value);
IPv6__extension__header_template(const IPv6__extension__header& other_value);
IPv6__extension__header_template(const OPTIONAL<IPv6__extension__header>& other_value);
IPv6__extension__header_template(const IPv6__extension__header_template& other_value);
~IPv6__extension__header_template();
void clean_up();
IPv6__extension__header_template& operator=(template_sel other_value);
IPv6__extension__header_template& operator=(const IPv6__extension__header& other_value);
IPv6__extension__header_template& operator=(const OPTIONAL<IPv6__extension__header>& other_value);
IPv6__extension__header_template& operator=(const IPv6__extension__header_template& other_value);
boolean match(const IPv6__extension__header& other_value) const;
boolean is_value() const;IPv6__extension__header valueof() const;
IPv6__extension__header_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
IP__AH__header_template& ah__hdr();
const IP__AH__header_template& ah__hdr() const;
IP__ESP__header_template& esp__hdr();
const IP__ESP__header_template& esp__hdr() const;
IP__GRE2__header_template& gre2__hdr();
const IP__GRE2__header_template& gre2__hdr() const;
IPv6__general__IPv6__extension__header_template& general__exthdr();
const IPv6__general__IPv6__extension__header_template& general__exthdr() const;
IPv6__Fragment__header_template& iPv6__Fragment__header();
const IPv6__Fragment__header_template& iPv6__Fragment__header() const;
OCTETSTRING_template& raw__hdr();
const OCTETSTRING_template& raw__hdr() const;
boolean ischosen(IPv6__extension__header::union_selection_type checked_selection) const;
void log() const;
void log_match(const IPv6__extension__header& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class IPv6__general__IPv6__extension__header : public Base_Type {
  INTEGER field_next__header;
  INTEGER field_exthdr__length;
  OCTETSTRING field_data;
  boolean bound_flag;
public:
  IPv6__general__IPv6__extension__header();
  IPv6__general__IPv6__extension__header(const INTEGER& par_next__header,
    const INTEGER& par_exthdr__length,
    const OCTETSTRING& par_data);
  IPv6__general__IPv6__extension__header(const IPv6__general__IPv6__extension__header& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IPv6__general__IPv6__extension__header& operator=(const IPv6__general__IPv6__extension__header& other_value);
  boolean operator==(const IPv6__general__IPv6__extension__header& other_value) const;
  inline boolean operator!=(const IPv6__general__IPv6__extension__header& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& next__header()
    {return field_next__header;}
  inline const INTEGER& next__header() const
    {return field_next__header;}
  inline INTEGER& exthdr__length()
    {return field_exthdr__length;}
  inline const INTEGER& exthdr__length() const
    {return field_exthdr__length;}
  inline OCTETSTRING& data()
    {return field_data;}
  inline const OCTETSTRING& data() const
    {return field_data;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IPv6__general__IPv6__extension__header_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IPv6__general__IPv6__extension__header_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IPv6__general__IPv6__extension__header& other_value);
void copy_template(const IPv6__general__IPv6__extension__header_template& other_value);

public:
IPv6__general__IPv6__extension__header_template();
IPv6__general__IPv6__extension__header_template(template_sel other_value);
IPv6__general__IPv6__extension__header_template(const IPv6__general__IPv6__extension__header& other_value);
IPv6__general__IPv6__extension__header_template(const OPTIONAL<IPv6__general__IPv6__extension__header>& other_value);
IPv6__general__IPv6__extension__header_template(const IPv6__general__IPv6__extension__header_template& other_value);
~IPv6__general__IPv6__extension__header_template();
IPv6__general__IPv6__extension__header_template& operator=(template_sel other_value);
IPv6__general__IPv6__extension__header_template& operator=(const IPv6__general__IPv6__extension__header& other_value);
IPv6__general__IPv6__extension__header_template& operator=(const OPTIONAL<IPv6__general__IPv6__extension__header>& other_value);
IPv6__general__IPv6__extension__header_template& operator=(const IPv6__general__IPv6__extension__header_template& other_value);
boolean match(const IPv6__general__IPv6__extension__header& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IPv6__general__IPv6__extension__header valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IPv6__general__IPv6__extension__header_template& list_item(unsigned int list_index) const;
INTEGER_template& next__header();
const INTEGER_template& next__header() const;
INTEGER_template& exthdr__length();
const INTEGER_template& exthdr__length() const;
OCTETSTRING_template& data();
const OCTETSTRING_template& data() const;
int size_of() const;
void log() const;
void log_match(const IPv6__general__IPv6__extension__header& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IPv6__header : public Base_Type {
  INTEGER field_ver;
  INTEGER field_trclass;
  INTEGER field_flabel;
  INTEGER field_plen;
  INTEGER field_nexthead;
  INTEGER field_hlim;
  OCTETSTRING field_srcaddr;
  OCTETSTRING field_dstaddr;
  boolean bound_flag;
public:
  IPv6__header();
  IPv6__header(const INTEGER& par_ver,
    const INTEGER& par_trclass,
    const INTEGER& par_flabel,
    const INTEGER& par_plen,
    const INTEGER& par_nexthead,
    const INTEGER& par_hlim,
    const OCTETSTRING& par_srcaddr,
    const OCTETSTRING& par_dstaddr);
  IPv6__header(const IPv6__header& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IPv6__header& operator=(const IPv6__header& other_value);
  boolean operator==(const IPv6__header& other_value) const;
  inline boolean operator!=(const IPv6__header& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& ver()
    {return field_ver;}
  inline const INTEGER& ver() const
    {return field_ver;}
  inline INTEGER& trclass()
    {return field_trclass;}
  inline const INTEGER& trclass() const
    {return field_trclass;}
  inline INTEGER& flabel()
    {return field_flabel;}
  inline const INTEGER& flabel() const
    {return field_flabel;}
  inline INTEGER& plen()
    {return field_plen;}
  inline const INTEGER& plen() const
    {return field_plen;}
  inline INTEGER& nexthead()
    {return field_nexthead;}
  inline const INTEGER& nexthead() const
    {return field_nexthead;}
  inline INTEGER& hlim()
    {return field_hlim;}
  inline const INTEGER& hlim() const
    {return field_hlim;}
  inline OCTETSTRING& srcaddr()
    {return field_srcaddr;}
  inline const OCTETSTRING& srcaddr() const
    {return field_srcaddr;}
  inline OCTETSTRING& dstaddr()
    {return field_dstaddr;}
  inline const OCTETSTRING& dstaddr() const
    {return field_dstaddr;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IPv6__header_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IPv6__header_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IPv6__header& other_value);
void copy_template(const IPv6__header_template& other_value);

public:
IPv6__header_template();
IPv6__header_template(template_sel other_value);
IPv6__header_template(const IPv6__header& other_value);
IPv6__header_template(const OPTIONAL<IPv6__header>& other_value);
IPv6__header_template(const IPv6__header_template& other_value);
~IPv6__header_template();
IPv6__header_template& operator=(template_sel other_value);
IPv6__header_template& operator=(const IPv6__header& other_value);
IPv6__header_template& operator=(const OPTIONAL<IPv6__header>& other_value);
IPv6__header_template& operator=(const IPv6__header_template& other_value);
boolean match(const IPv6__header& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IPv6__header valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IPv6__header_template& list_item(unsigned int list_index) const;
INTEGER_template& ver();
const INTEGER_template& ver() const;
INTEGER_template& trclass();
const INTEGER_template& trclass() const;
INTEGER_template& flabel();
const INTEGER_template& flabel() const;
INTEGER_template& plen();
const INTEGER_template& plen() const;
INTEGER_template& nexthead();
const INTEGER_template& nexthead() const;
INTEGER_template& hlim();
const INTEGER_template& hlim() const;
OCTETSTRING_template& srcaddr();
const OCTETSTRING_template& srcaddr() const;
OCTETSTRING_template& dstaddr();
const OCTETSTRING_template& dstaddr() const;
int size_of() const;
void log() const;
void log_match(const IPv6__header& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IPv6__packet : public Base_Type {
  IPv6__header field_header;
  OPTIONAL<IPv6__extension__headers> field_ext__headers;
  OPTIONAL<OCTETSTRING> field_payload;
  boolean bound_flag;
public:
  IPv6__packet();
  IPv6__packet(const IPv6__header& par_header,
    const OPTIONAL<IPv6__extension__headers>& par_ext__headers,
    const OPTIONAL<OCTETSTRING>& par_payload);
  IPv6__packet(const IPv6__packet& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IPv6__packet& operator=(const IPv6__packet& other_value);
  boolean operator==(const IPv6__packet& other_value) const;
  inline boolean operator!=(const IPv6__packet& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline IPv6__header& header()
    {return field_header;}
  inline const IPv6__header& header() const
    {return field_header;}
  inline OPTIONAL<IPv6__extension__headers>& ext__headers()
    {return field_ext__headers;}
  inline const OPTIONAL<IPv6__extension__headers>& ext__headers() const
    {return field_ext__headers;}
  inline OPTIONAL<OCTETSTRING>& payload()
    {return field_payload;}
  inline const OPTIONAL<OCTETSTRING>& payload() const
    {return field_payload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IPv6__packet_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IPv6__packet_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IPv6__packet& other_value);
void copy_template(const IPv6__packet_template& other_value);

public:
IPv6__packet_template();
IPv6__packet_template(template_sel other_value);
IPv6__packet_template(const IPv6__packet& other_value);
IPv6__packet_template(const OPTIONAL<IPv6__packet>& other_value);
IPv6__packet_template(const IPv6__packet_template& other_value);
~IPv6__packet_template();
IPv6__packet_template& operator=(template_sel other_value);
IPv6__packet_template& operator=(const IPv6__packet& other_value);
IPv6__packet_template& operator=(const OPTIONAL<IPv6__packet>& other_value);
IPv6__packet_template& operator=(const IPv6__packet_template& other_value);
boolean match(const IPv6__packet& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IPv6__packet valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IPv6__packet_template& list_item(unsigned int list_index) const;
IPv6__header_template& header();
const IPv6__header_template& header() const;
IPv6__extension__headers_template& ext__headers();
const IPv6__extension__headers_template& ext__headers() const;
OCTETSTRING_template& payload();
const OCTETSTRING_template& payload() const;
int size_of() const;
void log() const;
void log_match(const IPv6__packet& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class IPv6msg__SP__PT : public PORT {
enum msg_selection { MESSAGE_0 };
struct msg_queue_item : public msg_queue_item_base {
msg_selection item_selection;
union {
IPv6__packet *message_0;
};
component sender_component;
};

void remove_msg_queue_head();
protected:
void clear_queue();
public:
IPv6msg__SP__PT(const char *par_port_name = NULL);
~IPv6msg__SP__PT();
void send(const IPv6__packet& send_par, const COMPONENT& destination_component);
void send(const IPv6__packet& send_par);
void send(const IPv6__packet_template& send_par, const COMPONENT& destination_component);
void send(const IPv6__packet_template& send_par);
alt_status receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status receive(const IPv6__packet_template& value_template, IPv6__packet *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status check_receive(const IPv6__packet_template& value_template, IPv6__packet *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
alt_status trigger(const IPv6__packet_template& value_template, IPv6__packet *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr);
private:
void incoming_message(const IPv6__packet& incoming_par, component sender_component);
protected:
boolean process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING& slider);
};


/* Function prototypes */

extern OCTETSTRING f__IPv4__enc(const IPv4__packet& pdu);
extern OCTETSTRING f__IPv4__enc__eth(const IPv4__packet& pdu);
extern IPv4__packet f__IPv4__dec(const OCTETSTRING& data);
extern OCTETSTRING f__IPv4__checksum(const OCTETSTRING& data);
extern OCTETSTRING f__IPv4__addr__enc(const CHARSTRING& cs__addr);
extern CHARSTRING f__IPv4__addr__dec(const OCTETSTRING& os__addr);
extern boolean operator==(null_type null_value, const IPv4__extension__headers& other_value);
inline boolean operator!=(null_type null_value, const IPv4__extension__headers& other_value) { return !(null_value == other_value); }
extern OCTETSTRING f__IPv6__enc(const IPv6__packet& pdu);
extern IPv6__packet f__IPv6__dec(const OCTETSTRING& data);
extern OCTETSTRING f__IPv6__addr__enc(const CHARSTRING& cs__addr);
extern CHARSTRING f__IPv6__addr__dec(const OCTETSTRING& os__addr);
extern boolean operator==(null_type null_value, const IPv6__extension__headers& other_value);
inline boolean operator!=(null_type null_value, const IPv6__extension__headers& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const TTCN_RAWdescriptor_t BIT7__BO__LAST_raw_;
extern const XERdescriptor_t BIT7__BO__LAST_xer_;
extern const TTCN_Typedescriptor_t BIT7__BO__LAST_descr_;
extern const INTEGER& c__ip__proto__ipv4;
extern const INTEGER& c__ip__proto__ipv6;
extern const INTEGER& c__ip__proto__gre2;
extern const INTEGER& c__ip__proto__esp;
extern const INTEGER& c__ip__proto__ah;
extern const INTEGER& c__ip__proto__mine;
extern const INTEGER& c__ip__proto__ipv6__hopopt;
extern const INTEGER& c__ip__proto__ipv6__route;
extern const INTEGER& c__ip__proto__ipv6__frag;
extern const INTEGER& c__ip__proto__ipv6__dest;
extern const INTEGER& c__ip__proto__ipv6__nonext;
extern const INTEGER& c__ip__proto__udp;
extern const INTEGER& c__ip__proto__tcp;
extern const INTEGER& c__ip__proto__mobility;
extern const INTEGER& c__ip__gre__proto__ipv4;
extern const INTEGER& c__ip__gre__proto__ipv6;
extern const INTEGER& c__ip__gre__proto__transparentEthernetBridging;
extern const INTEGER& c__ip__version__ipv4;
extern const INTEGER& c__ip__version__ipv6;
extern const INTEGER& c__ip__proto__icmp;
extern const INTEGER& c__ip__proto__icmpv6;
extern const TTCN_RAWdescriptor_t IP__MINE__header_protocol_raw_;
extern const XERdescriptor_t IP__MINE__header_protocol_xer_;
extern const TTCN_Typedescriptor_t IP__MINE__header_protocol_descr_;
extern const TTCN_RAWdescriptor_t IP__MINE__header_s__bit_raw_;
extern const XERdescriptor_t IP__MINE__header_s__bit_xer_;
extern const TTCN_Typedescriptor_t IP__MINE__header_s__bit_descr_;
extern const TTCN_RAWdescriptor_t IP__MINE__header_reserved_raw_;
extern const XERdescriptor_t IP__MINE__header_reserved_xer_;
extern const TTCN_Typedescriptor_t IP__MINE__header_reserved_descr_;
extern const TTCN_RAWdescriptor_t IP__MINE__header_cksum_raw_;
extern const XERdescriptor_t IP__MINE__header_cksum_xer_;
extern const TTCN_Typedescriptor_t IP__MINE__header_cksum_descr_;
extern const TTCN_RAWdescriptor_t IP__MINE__header_dstaddr_raw_;
extern const XERdescriptor_t IP__MINE__header_dstaddr_xer_;
extern const TTCN_Typedescriptor_t IP__MINE__header_dstaddr_descr_;
extern const TTCN_RAWdescriptor_t IP__MINE__header_raw_;
extern const TTCN_JSONdescriptor_t IP__MINE__header_json_;
extern const TTCN_Typedescriptor_t IP__MINE__header_descr_;
extern const TTCN_RAWdescriptor_t IP__MINE__header_srcaddr_raw_;
extern const XERdescriptor_t IP__MINE__header_srcaddr_xer_;
extern const TTCN_Typedescriptor_t IP__MINE__header_srcaddr_descr_;
extern const XERdescriptor_t IP__AH__header_next__hdr_xer_;
extern const TTCN_Typedescriptor_t IP__AH__header_next__hdr_descr_;
extern const TTCN_RAWdescriptor_t IP__AH__header_payload__len_raw_;
extern const XERdescriptor_t IP__AH__header_payload__len_xer_;
extern const TTCN_Typedescriptor_t IP__AH__header_payload__len_descr_;
extern const XERdescriptor_t IP__AH__header_reserved_xer_;
extern const TTCN_Typedescriptor_t IP__AH__header_reserved_descr_;
extern const XERdescriptor_t IP__AH__header_spi_xer_;
extern const TTCN_Typedescriptor_t IP__AH__header_spi_descr_;
extern const XERdescriptor_t IP__AH__header_sn_xer_;
extern const TTCN_Typedescriptor_t IP__AH__header_sn_descr_;
extern const XERdescriptor_t IP__AH__header_auth__data_xer_;
extern const TTCN_Typedescriptor_t IP__AH__header_auth__data_descr_;
extern const TTCN_RAWdescriptor_t IP__AH__header_raw_;
extern const TTCN_JSONdescriptor_t IP__AH__header_json_;
extern const TTCN_Typedescriptor_t IP__AH__header_descr_;
extern const XERdescriptor_t IP__ESP__header__part_spi_xer_;
extern const TTCN_Typedescriptor_t IP__ESP__header__part_spi_descr_;
extern const XERdescriptor_t IP__ESP__header__part_sn_xer_;
extern const TTCN_Typedescriptor_t IP__ESP__header__part_sn_descr_;
extern const TTCN_RAWdescriptor_t IP__ESP__header__part_raw_;
extern const TTCN_JSONdescriptor_t IP__ESP__header__part_json_;
extern const TTCN_Typedescriptor_t IP__ESP__header__part_descr_;
extern const TTCN_RAWdescriptor_t IP__ESP__NULL__tail_pad__length_raw_;
extern const XERdescriptor_t IP__ESP__NULL__tail_pad__length_xer_;
extern const TTCN_Typedescriptor_t IP__ESP__NULL__tail_pad__length_descr_;
extern const XERdescriptor_t IP__ESP__NULL__tail_next__hdr_xer_;
extern const TTCN_Typedescriptor_t IP__ESP__NULL__tail_next__hdr_descr_;
extern const XERdescriptor_t IP__ESP__NULL__tail_auth__data_xer_;
extern const TTCN_Typedescriptor_t IP__ESP__NULL__tail_auth__data_descr_;
extern const TTCN_RAWdescriptor_t IP__ESP__NULL__tail_raw_;
extern const TTCN_JSONdescriptor_t IP__ESP__NULL__tail_json_;
extern const TTCN_Typedescriptor_t IP__ESP__NULL__tail_descr_;
extern const XERdescriptor_t IP__ESP__NULL__tail_padding_xer_;
extern const TTCN_Typedescriptor_t IP__ESP__NULL__tail_padding_descr_;
extern const TTCN_RAWdescriptor_t IP__ESP__tail__part_raw_;
extern const TTCN_JSONdescriptor_t IP__ESP__tail__part_json_;
extern const TTCN_Typedescriptor_t IP__ESP__tail__part_descr_;
extern const XERdescriptor_t IP__ESP__tail__part_raw__data_xer_;
extern const TTCN_Typedescriptor_t IP__ESP__tail__part_raw__data_descr_;
extern const TTCN_RAWdescriptor_t IP__ESP__header_raw_;
extern const TTCN_JSONdescriptor_t IP__ESP__header_json_;
extern const TTCN_Typedescriptor_t IP__ESP__header_descr_;
extern const TTCN_RAWdescriptor_t IP__GRE2__header_c_raw_;
extern const XERdescriptor_t IP__GRE2__header_c_xer_;
extern const TTCN_Typedescriptor_t IP__GRE2__header_c_descr_;
extern const TTCN_RAWdescriptor_t IP__GRE2__header_reserved__bit_raw_;
extern const XERdescriptor_t IP__GRE2__header_reserved__bit_xer_;
extern const TTCN_Typedescriptor_t IP__GRE2__header_reserved__bit_descr_;
extern const TTCN_RAWdescriptor_t IP__GRE2__header_k_raw_;
extern const XERdescriptor_t IP__GRE2__header_k_xer_;
extern const TTCN_Typedescriptor_t IP__GRE2__header_k_descr_;
extern const TTCN_RAWdescriptor_t IP__GRE2__header_s_raw_;
extern const XERdescriptor_t IP__GRE2__header_s_xer_;
extern const TTCN_Typedescriptor_t IP__GRE2__header_s_descr_;
extern const TTCN_RAWdescriptor_t IP__GRE2__header_reserved0_raw_;
extern const XERdescriptor_t IP__GRE2__header_reserved0_xer_;
extern const TTCN_Typedescriptor_t IP__GRE2__header_reserved0_descr_;
extern const TTCN_RAWdescriptor_t IP__GRE2__header_version_raw_;
extern const XERdescriptor_t IP__GRE2__header_version_xer_;
extern const TTCN_Typedescriptor_t IP__GRE2__header_version_descr_;
extern const TTCN_RAWdescriptor_t IP__GRE2__header_protocol__type_raw_;
extern const XERdescriptor_t IP__GRE2__header_protocol__type_xer_;
extern const TTCN_Typedescriptor_t IP__GRE2__header_protocol__type_descr_;
extern const TTCN_RAWdescriptor_t IP__GRE2__header_raw_;
extern const TTCN_JSONdescriptor_t IP__GRE2__header_json_;
extern const TTCN_Typedescriptor_t IP__GRE2__header_descr_;
extern const TTCN_RAWdescriptor_t IP__GRE2__header_checksum_raw_;
extern const XERdescriptor_t IP__GRE2__header_checksum_xer_;
extern const TTCN_Typedescriptor_t IP__GRE2__header_checksum_descr_;
extern const TTCN_RAWdescriptor_t IP__GRE2__header_reserved1_raw_;
extern const XERdescriptor_t IP__GRE2__header_reserved1_xer_;
extern const TTCN_Typedescriptor_t IP__GRE2__header_reserved1_descr_;
extern const TTCN_RAWdescriptor_t IP__GRE2__header_key_raw_;
extern const XERdescriptor_t IP__GRE2__header_key_xer_;
extern const TTCN_Typedescriptor_t IP__GRE2__header_key_descr_;
extern const TTCN_RAWdescriptor_t IP__GRE2__header_sn_raw_;
extern const XERdescriptor_t IP__GRE2__header_sn_xer_;
extern const TTCN_Typedescriptor_t IP__GRE2__header_sn_descr_;
extern const TTCN_RAWdescriptor_t IPv4__extension__headers_raw_;
extern const TTCN_JSONdescriptor_t IPv4__extension__headers_json_;
extern const TTCN_Typedescriptor_t IPv4__extension__headers_descr_;
extern const TTCN_RAWdescriptor_t IPv4__extension__header_raw_;
extern const TTCN_JSONdescriptor_t IPv4__extension__header_json_;
extern const TTCN_Typedescriptor_t IPv4__extension__header_descr_;
extern const XERdescriptor_t IPv4__extension__header_raw__hdr_xer_;
extern const TTCN_Typedescriptor_t IPv4__extension__header_raw__hdr_descr_;
extern const XERdescriptor_t IPV4ADDR_xer_;
extern const TTCN_Typedescriptor_t IPV4ADDR_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_ver_raw_;
extern const XERdescriptor_t IPv4__header_ver_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_ver_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_hlen_raw_;
extern const XERdescriptor_t IPv4__header_hlen_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_hlen_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_tos_raw_;
extern const XERdescriptor_t IPv4__header_tos_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_tos_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_tlen_raw_;
extern const XERdescriptor_t IPv4__header_tlen_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_tlen_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_id_raw_;
extern const XERdescriptor_t IPv4__header_id_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_id_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_res_raw_;
extern const XERdescriptor_t IPv4__header_res_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_res_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_dfrag_raw_;
extern const XERdescriptor_t IPv4__header_dfrag_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_dfrag_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_mfrag_raw_;
extern const XERdescriptor_t IPv4__header_mfrag_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_mfrag_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_foffset_raw_;
extern const XERdescriptor_t IPv4__header_foffset_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_foffset_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_ttl_raw_;
extern const XERdescriptor_t IPv4__header_ttl_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_ttl_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_proto_raw_;
extern const XERdescriptor_t IPv4__header_proto_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_proto_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_cksum_raw_;
extern const XERdescriptor_t IPv4__header_cksum_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_cksum_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_srcaddr_raw_;
extern const XERdescriptor_t IPv4__header_srcaddr_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_srcaddr_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_dstaddr_raw_;
extern const XERdescriptor_t IPv4__header_dstaddr_xer_;
extern const TTCN_Typedescriptor_t IPv4__header_dstaddr_descr_;
extern const TTCN_RAWdescriptor_t IPv4__header_raw_;
extern const TTCN_JSONdescriptor_t IPv4__header_json_;
extern const TTCN_Typedescriptor_t IPv4__header_descr_;
extern const TTCN_RAWdescriptor_t IPv4__packet_header_raw_;
extern const TTCN_Typedescriptor_t IPv4__packet_header_descr_;
extern const TTCN_RAWdescriptor_t IPv4__packet_raw_;
extern const TTCN_JSONdescriptor_t IPv4__packet_json_;
extern const TTCN_Typedescriptor_t IPv4__packet_descr_;
extern const TTCN_RAWdescriptor_t IPv4__packet_ext__headers_raw_;
extern const TTCN_Typedescriptor_t IPv4__packet_ext__headers_descr_;
extern const TTCN_RAWdescriptor_t IPv4__packet_payload_raw_;
extern const XERdescriptor_t IPv4__packet_payload_xer_;
extern const TTCN_Typedescriptor_t IPv4__packet_payload_descr_;
extern const XERdescriptor_t ASP__IPv4_cksum__calc_xer_;
extern const TTCN_Typedescriptor_t ASP__IPv4_cksum__calc_descr_;
extern const TTCN_Typedescriptor_t ASP__IPv4_descr_;
extern const XERdescriptor_t IPv6__Fragment__header_next__hdr_xer_;
extern const TTCN_Typedescriptor_t IPv6__Fragment__header_next__hdr_descr_;
extern const XERdescriptor_t IPv6__Fragment__header_reserved_xer_;
extern const TTCN_Typedescriptor_t IPv6__Fragment__header_reserved_descr_;
extern const TTCN_RAWdescriptor_t IPv6__Fragment__header_fragmentOffset_raw_;
extern const XERdescriptor_t IPv6__Fragment__header_fragmentOffset_xer_;
extern const TTCN_Typedescriptor_t IPv6__Fragment__header_fragmentOffset_descr_;
extern const TTCN_RAWdescriptor_t IPv6__Fragment__header_reserved2_raw_;
extern const XERdescriptor_t IPv6__Fragment__header_reserved2_xer_;
extern const TTCN_Typedescriptor_t IPv6__Fragment__header_reserved2_descr_;
extern const TTCN_RAWdescriptor_t IPv6__Fragment__header_mFlag_raw_;
extern const XERdescriptor_t IPv6__Fragment__header_mFlag_xer_;
extern const TTCN_Typedescriptor_t IPv6__Fragment__header_mFlag_descr_;
extern const XERdescriptor_t IPv6__Fragment__header_identification_xer_;
extern const TTCN_Typedescriptor_t IPv6__Fragment__header_identification_descr_;
extern const TTCN_RAWdescriptor_t IPv6__Fragment__header_raw_;
extern const TTCN_JSONdescriptor_t IPv6__Fragment__header_json_;
extern const TTCN_Typedescriptor_t IPv6__Fragment__header_descr_;
extern const TTCN_RAWdescriptor_t IPv6__extension__headers_raw_;
extern const TTCN_JSONdescriptor_t IPv6__extension__headers_json_;
extern const TTCN_Typedescriptor_t IPv6__extension__headers_descr_;
extern const TTCN_RAWdescriptor_t IPv6__extension__header_raw_;
extern const TTCN_JSONdescriptor_t IPv6__extension__header_json_;
extern const TTCN_Typedescriptor_t IPv6__extension__header_descr_;
extern const XERdescriptor_t IPv6__general__IPv6__extension__header_next__header_xer_;
extern const TTCN_Typedescriptor_t IPv6__general__IPv6__extension__header_next__header_descr_;
extern const TTCN_RAWdescriptor_t IPv6__general__IPv6__extension__header_exthdr__length_raw_;
extern const XERdescriptor_t IPv6__general__IPv6__extension__header_exthdr__length_xer_;
extern const TTCN_Typedescriptor_t IPv6__general__IPv6__extension__header_exthdr__length_descr_;
extern const XERdescriptor_t IPv6__general__IPv6__extension__header_data_xer_;
extern const TTCN_Typedescriptor_t IPv6__general__IPv6__extension__header_data_descr_;
extern const TTCN_RAWdescriptor_t IPv6__general__IPv6__extension__header_raw_;
extern const TTCN_JSONdescriptor_t IPv6__general__IPv6__extension__header_json_;
extern const TTCN_Typedescriptor_t IPv6__general__IPv6__extension__header_descr_;
extern const XERdescriptor_t IPv6__extension__header_raw__hdr_xer_;
extern const TTCN_Typedescriptor_t IPv6__extension__header_raw__hdr_descr_;
extern const TTCN_RAWdescriptor_t IPv6__header_ver_raw_;
extern const XERdescriptor_t IPv6__header_ver_xer_;
extern const TTCN_Typedescriptor_t IPv6__header_ver_descr_;
extern const TTCN_RAWdescriptor_t IPv6__header_trclass_raw_;
extern const XERdescriptor_t IPv6__header_trclass_xer_;
extern const TTCN_Typedescriptor_t IPv6__header_trclass_descr_;
extern const TTCN_RAWdescriptor_t IPv6__header_flabel_raw_;
extern const XERdescriptor_t IPv6__header_flabel_xer_;
extern const TTCN_Typedescriptor_t IPv6__header_flabel_descr_;
extern const TTCN_RAWdescriptor_t IPv6__header_plen_raw_;
extern const XERdescriptor_t IPv6__header_plen_xer_;
extern const TTCN_Typedescriptor_t IPv6__header_plen_descr_;
extern const TTCN_RAWdescriptor_t IPv6__header_nexthead_raw_;
extern const XERdescriptor_t IPv6__header_nexthead_xer_;
extern const TTCN_Typedescriptor_t IPv6__header_nexthead_descr_;
extern const TTCN_RAWdescriptor_t IPv6__header_hlim_raw_;
extern const XERdescriptor_t IPv6__header_hlim_xer_;
extern const TTCN_Typedescriptor_t IPv6__header_hlim_descr_;
extern const TTCN_RAWdescriptor_t IPv6__header_srcaddr_raw_;
extern const XERdescriptor_t IPv6__header_srcaddr_xer_;
extern const TTCN_Typedescriptor_t IPv6__header_srcaddr_descr_;
extern const TTCN_RAWdescriptor_t IPv6__header_dstaddr_raw_;
extern const XERdescriptor_t IPv6__header_dstaddr_xer_;
extern const TTCN_Typedescriptor_t IPv6__header_dstaddr_descr_;
extern const TTCN_RAWdescriptor_t IPv6__header_raw_;
extern const TTCN_JSONdescriptor_t IPv6__header_json_;
extern const TTCN_Typedescriptor_t IPv6__header_descr_;
extern const TTCN_RAWdescriptor_t IPv6__packet_header_raw_;
extern const TTCN_Typedescriptor_t IPv6__packet_header_descr_;
extern const TTCN_RAWdescriptor_t IPv6__packet_raw_;
extern const TTCN_JSONdescriptor_t IPv6__packet_json_;
extern const TTCN_Typedescriptor_t IPv6__packet_descr_;
extern const TTCN_RAWdescriptor_t IPv6__packet_ext__headers_raw_;
extern const TTCN_Typedescriptor_t IPv6__packet_ext__headers_descr_;
extern const TTCN_RAWdescriptor_t IPv6__packet_payload_raw_;
extern const XERdescriptor_t IPv6__packet_payload_xer_;
extern const TTCN_Typedescriptor_t IPv6__packet_payload_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
