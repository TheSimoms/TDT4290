// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for user (user@user-multicom) on Fri Oct  9 11:34:10 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

#ifndef jabber__x__data_HH
#define jabber__x__data_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "XSD.hh"

#if TTCN3_VERSION != 50300
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef jabber__x__data_HH
#endif

namespace jabber__x__data {

/* Forward declarations of classes */

class X_type__;
class X_type___template;
class X_field__list;
class X_field__list_template;
class Field_option__list;
class Field_option__list_template;
class Option;
class Option_template;
class Field;
class Field_template;
class Field_type__;
class Field_type___template;
class Empty;
class Empty_template;
class X_item__list;
class X_item__list_template;
class Item_field__list;
class Item_field__list_template;
class Item;
class Item_template;
class X;
class X_template;
class Reported_field__list;
class Reported_field__list_template;
class Reported;
class Reported_template;

} /* end of namespace */

#ifndef jabber__x__data_HH
#define jabber__x__data_HH

namespace jabber__x__data {

/* Type definitions */

typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING X_instructions__list;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template X_instructions__list_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING Field_value__list;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template Field_value__list_template;
typedef UNIVERSAL_CHARSTRING Value;
typedef UNIVERSAL_CHARSTRING_template Value_template;

/* Class definitions */

class X_type__ : public Base_Type { // enum
friend class X_type___template;
public:
enum enum_type { cancel = 0, form = 1, result = 2, submit = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
X_type__();
X_type__(int other_value);
X_type__(enum_type other_value);
X_type__(const X_type__& other_value);

X_type__& operator=(int other_value);
X_type__& operator=(enum_type other_value);
X_type__& operator=(const X_type__& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const X_type__& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const X_type__& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const X_type__& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const X_type__& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const X_type__& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const X_type__& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const X_type__& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class X_type___template : public Base_Template {
union {
X_type__::enum_type single_value;
struct {
unsigned int n_values;
X_type___template *list_value;
} value_list;
};

void copy_template(const X_type___template& other_value);

public:
X_type___template();
X_type___template(template_sel other_value);
X_type___template(int other_value);
X_type___template(X_type__::enum_type other_value);
X_type___template(const X_type__& other_value);
X_type___template(const OPTIONAL<X_type__>& other_value);
X_type___template(const X_type___template& other_value);
~X_type___template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
X_type___template& operator=(template_sel other_value);
X_type___template& operator=(int other_value);
X_type___template& operator=(X_type__::enum_type other_value);
X_type___template& operator=(const X_type__& other_value);
X_type___template& operator=(const OPTIONAL<X_type__>& other_value);
X_type___template& operator=(const X_type___template& other_value);

boolean match(X_type__::enum_type other_value) const;
boolean match(const X_type__& other_value) const;
X_type__::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
X_type___template& list_item(unsigned int list_index);
void log() const;
void log_match(const X_type__& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class X_field__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Field **value_elements;
} *val_ptr;

static const Field UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const X_field__list& other_value);

public:
  typedef Field of_type;
X_field__list();
X_field__list(null_type other_value);
X_field__list(const X_field__list& other_value);
~X_field__list();

void clean_up();
X_field__list& operator=(null_type other_value);
X_field__list& operator=(const X_field__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const X_field__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const X_field__list& other_value) const { return !(*this == other_value); }

Field& operator[](int index_value);
Field& operator[](const INTEGER& index_value);
const Field& operator[](int index_value) const;
const Field& operator[](const INTEGER& index_value) const;

X_field__list operator<<=(int rotate_count) const;
X_field__list operator<<=(const INTEGER& rotate_count) const;
X_field__list operator>>=(int rotate_count) const;
X_field__list operator>>=(const INTEGER& rotate_count) const;

X_field__list operator+(const X_field__list& other_value) const;

X_field__list substr(int index, int returncount) const;

X_field__list replace(int index, int len, const X_field__list& repl) const;

X_field__list replace(int index, int len, const X_field__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class X_field__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
Field_template **value_elements;
} single_value;
struct {
unsigned int n_values;
X_field__list_template *list_value;
} value_list;
};
void copy_value(const X_field__list& other_value);
void copy_template(const X_field__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
X_field__list_template();
X_field__list_template(template_sel other_value);
X_field__list_template(null_type other_value);
X_field__list_template(const X_field__list& other_value);
X_field__list_template(const OPTIONAL<X_field__list>& other_value);
X_field__list_template(const X_field__list_template& other_value);
~X_field__list_template();

void clean_up();
X_field__list_template& operator=(template_sel other_value);
X_field__list_template& operator=(null_type other_value);
X_field__list_template& operator=(const X_field__list& other_value);
X_field__list_template& operator=(const OPTIONAL<X_field__list>& other_value);
X_field__list_template& operator=(const X_field__list_template& other_value);

Field_template& operator[](int index_value);
Field_template& operator[](const INTEGER& index_value);
const Field_template& operator[](int index_value) const;
const Field_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const X_field__list& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
X_field__list valueof() const;
X_field__list substr(int index, int returncount) const;

X_field__list replace(int index, int len, const X_field__list_template& repl) const;

X_field__list replace(int index, int len, const X_field__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
X_field__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const X_field__list& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Field_option__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Option **value_elements;
} *val_ptr;

static const Option UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const Field_option__list& other_value);

public:
  typedef Option of_type;
Field_option__list();
Field_option__list(null_type other_value);
Field_option__list(const Field_option__list& other_value);
~Field_option__list();

void clean_up();
Field_option__list& operator=(null_type other_value);
Field_option__list& operator=(const Field_option__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const Field_option__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Field_option__list& other_value) const { return !(*this == other_value); }

Option& operator[](int index_value);
Option& operator[](const INTEGER& index_value);
const Option& operator[](int index_value) const;
const Option& operator[](const INTEGER& index_value) const;

Field_option__list operator<<=(int rotate_count) const;
Field_option__list operator<<=(const INTEGER& rotate_count) const;
Field_option__list operator>>=(int rotate_count) const;
Field_option__list operator>>=(const INTEGER& rotate_count) const;

Field_option__list operator+(const Field_option__list& other_value) const;

Field_option__list substr(int index, int returncount) const;

Field_option__list replace(int index, int len, const Field_option__list& repl) const;

Field_option__list replace(int index, int len, const Field_option__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Field_option__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
Option_template **value_elements;
} single_value;
struct {
unsigned int n_values;
Field_option__list_template *list_value;
} value_list;
};
void copy_value(const Field_option__list& other_value);
void copy_template(const Field_option__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
Field_option__list_template();
Field_option__list_template(template_sel other_value);
Field_option__list_template(null_type other_value);
Field_option__list_template(const Field_option__list& other_value);
Field_option__list_template(const OPTIONAL<Field_option__list>& other_value);
Field_option__list_template(const Field_option__list_template& other_value);
~Field_option__list_template();

void clean_up();
Field_option__list_template& operator=(template_sel other_value);
Field_option__list_template& operator=(null_type other_value);
Field_option__list_template& operator=(const Field_option__list& other_value);
Field_option__list_template& operator=(const OPTIONAL<Field_option__list>& other_value);
Field_option__list_template& operator=(const Field_option__list_template& other_value);

Option_template& operator[](int index_value);
Option_template& operator[](const INTEGER& index_value);
const Option_template& operator[](int index_value) const;
const Option_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const Field_option__list& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
Field_option__list valueof() const;
Field_option__list substr(int index, int returncount) const;

Field_option__list replace(int index, int len, const Field_option__list_template& repl) const;

Field_option__list replace(int index, int len, const Field_option__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
Field_option__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Field_option__list& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Option : public Base_Type {
  OPTIONAL<UNIVERSAL_CHARSTRING> field_label__;
  UNIVERSAL_CHARSTRING field_value__;
  boolean bound_flag;
public:
  Option();
  Option(const OPTIONAL<UNIVERSAL_CHARSTRING>& par_label__,
    const UNIVERSAL_CHARSTRING& par_value__);
  Option(const Option& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Option& operator=(const Option& other_value);
  boolean operator==(const Option& other_value) const;
  inline boolean operator!=(const Option& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<UNIVERSAL_CHARSTRING>& label__()
    {return field_label__;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& label__() const
    {return field_label__;}
  inline UNIVERSAL_CHARSTRING& value__()
    {return field_value__;}
  inline const UNIVERSAL_CHARSTRING& value__() const
    {return field_value__;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Option_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Option_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Option& other_value);
void copy_template(const Option_template& other_value);

public:
Option_template();
Option_template(template_sel other_value);
Option_template(const Option& other_value);
Option_template(const OPTIONAL<Option>& other_value);
Option_template(const Option_template& other_value);
~Option_template();
Option_template& operator=(template_sel other_value);
Option_template& operator=(const Option& other_value);
Option_template& operator=(const OPTIONAL<Option>& other_value);
Option_template& operator=(const Option_template& other_value);
boolean match(const Option& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Option valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Option_template& list_item(unsigned int list_index) const;
UNIVERSAL_CHARSTRING_template& label__();
const UNIVERSAL_CHARSTRING_template& label__() const;
UNIVERSAL_CHARSTRING_template& value__();
const UNIVERSAL_CHARSTRING_template& value__() const;
int size_of() const;
void log() const;
void log_match(const Option& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class Field : public Base_Type {
  OPTIONAL<UNIVERSAL_CHARSTRING> field_label__;
  OPTIONAL<Field_type__> field_type__;
  OPTIONAL<UNIVERSAL_CHARSTRING> field_var__;
  OPTIONAL<UNIVERSAL_CHARSTRING> field_desc;
  OPTIONAL<Empty> field_required;
  Field_value__list field_value__list;
  Field_option__list field_option__list;
  boolean bound_flag;
public:
  Field();
  Field(const OPTIONAL<UNIVERSAL_CHARSTRING>& par_label__,
    const OPTIONAL<Field_type__>& par_type__,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_var__,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_desc,
    const OPTIONAL<Empty>& par_required,
    const Field_value__list& par_value__list,
    const Field_option__list& par_option__list);
  Field(const Field& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Field& operator=(const Field& other_value);
  boolean operator==(const Field& other_value) const;
  inline boolean operator!=(const Field& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<UNIVERSAL_CHARSTRING>& label__()
    {return field_label__;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& label__() const
    {return field_label__;}
  inline OPTIONAL<Field_type__>& type__()
    {return field_type__;}
  inline const OPTIONAL<Field_type__>& type__() const
    {return field_type__;}
  inline OPTIONAL<UNIVERSAL_CHARSTRING>& var__()
    {return field_var__;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& var__() const
    {return field_var__;}
  inline OPTIONAL<UNIVERSAL_CHARSTRING>& desc()
    {return field_desc;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& desc() const
    {return field_desc;}
  inline OPTIONAL<Empty>& required()
    {return field_required;}
  inline const OPTIONAL<Empty>& required() const
    {return field_required;}
  inline Field_value__list& value__list()
    {return field_value__list;}
  inline const Field_value__list& value__list() const
    {return field_value__list;}
  inline Field_option__list& option__list()
    {return field_option__list;}
  inline const Field_option__list& option__list() const
    {return field_option__list;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Field_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Field_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Field& other_value);
void copy_template(const Field_template& other_value);

public:
Field_template();
Field_template(template_sel other_value);
Field_template(const Field& other_value);
Field_template(const OPTIONAL<Field>& other_value);
Field_template(const Field_template& other_value);
~Field_template();
Field_template& operator=(template_sel other_value);
Field_template& operator=(const Field& other_value);
Field_template& operator=(const OPTIONAL<Field>& other_value);
Field_template& operator=(const Field_template& other_value);
boolean match(const Field& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Field valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Field_template& list_item(unsigned int list_index) const;
UNIVERSAL_CHARSTRING_template& label__();
const UNIVERSAL_CHARSTRING_template& label__() const;
Field_type___template& type__();
const Field_type___template& type__() const;
UNIVERSAL_CHARSTRING_template& var__();
const UNIVERSAL_CHARSTRING_template& var__() const;
UNIVERSAL_CHARSTRING_template& desc();
const UNIVERSAL_CHARSTRING_template& desc() const;
Empty_template& required();
const Empty_template& required() const;
Field_value__list_template& value__list();
const Field_value__list_template& value__list() const;
Field_option__list_template& option__list();
const Field_option__list_template& option__list() const;
int size_of() const;
void log() const;
void log_match(const Field& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class Field_type__ : public Base_Type { // enum
friend class Field_type___template;
public:
enum enum_type { boolean__ = 0, fixed = 1, hidden = 2, jid__multi = 3, jid__single = 4, list__multi = 5, list__single = 6, text__multi = 7, text__private = 8, text__single = 9, UNKNOWN_VALUE = 10, UNBOUND_VALUE = 11 };
private:
enum_type enum_value;

public:
Field_type__();
Field_type__(int other_value);
Field_type__(enum_type other_value);
Field_type__(const Field_type__& other_value);

Field_type__& operator=(int other_value);
Field_type__& operator=(enum_type other_value);
Field_type__& operator=(const Field_type__& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Field_type__& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Field_type__& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Field_type__& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Field_type__& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Field_type__& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Field_type__& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Field_type__& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Field_type___template : public Base_Template {
union {
Field_type__::enum_type single_value;
struct {
unsigned int n_values;
Field_type___template *list_value;
} value_list;
};

void copy_template(const Field_type___template& other_value);

public:
Field_type___template();
Field_type___template(template_sel other_value);
Field_type___template(int other_value);
Field_type___template(Field_type__::enum_type other_value);
Field_type___template(const Field_type__& other_value);
Field_type___template(const OPTIONAL<Field_type__>& other_value);
Field_type___template(const Field_type___template& other_value);
~Field_type___template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Field_type___template& operator=(template_sel other_value);
Field_type___template& operator=(int other_value);
Field_type___template& operator=(Field_type__::enum_type other_value);
Field_type___template& operator=(const Field_type__& other_value);
Field_type___template& operator=(const OPTIONAL<Field_type__>& other_value);
Field_type___template& operator=(const Field_type___template& other_value);

boolean match(Field_type__::enum_type other_value) const;
boolean match(const Field_type__& other_value) const;
Field_type__::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Field_type___template& list_item(unsigned int list_index);
void log() const;
void log_match(const Field_type__& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Empty : public Base_Type { // enum
friend class Empty_template;
public:
enum enum_type { x = 0, UNKNOWN_VALUE = 1, UNBOUND_VALUE = 2 };
private:
enum_type enum_value;

public:
Empty();
Empty(int other_value);
Empty(enum_type other_value);
Empty(const Empty& other_value);

Empty& operator=(int other_value);
Empty& operator=(enum_type other_value);
Empty& operator=(const Empty& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Empty& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Empty& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Empty& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Empty& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Empty& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Empty& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par, boolean txt = false);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Empty& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Empty_template : public Base_Template {
union {
Empty::enum_type single_value;
struct {
unsigned int n_values;
Empty_template *list_value;
} value_list;
};

void copy_template(const Empty_template& other_value);

public:
Empty_template();
Empty_template(template_sel other_value);
Empty_template(int other_value);
Empty_template(Empty::enum_type other_value);
Empty_template(const Empty& other_value);
Empty_template(const OPTIONAL<Empty>& other_value);
Empty_template(const Empty_template& other_value);
~Empty_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Empty_template& operator=(template_sel other_value);
Empty_template& operator=(int other_value);
Empty_template& operator=(Empty::enum_type other_value);
Empty_template& operator=(const Empty& other_value);
Empty_template& operator=(const OPTIONAL<Empty>& other_value);
Empty_template& operator=(const Empty_template& other_value);

boolean match(Empty::enum_type other_value) const;
boolean match(const Empty& other_value) const;
Empty::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Empty_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Empty& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class X_item__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Item **value_elements;
} *val_ptr;

static const Item UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const X_item__list& other_value);

public:
  typedef Item of_type;
X_item__list();
X_item__list(null_type other_value);
X_item__list(const X_item__list& other_value);
~X_item__list();

void clean_up();
X_item__list& operator=(null_type other_value);
X_item__list& operator=(const X_item__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const X_item__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const X_item__list& other_value) const { return !(*this == other_value); }

Item& operator[](int index_value);
Item& operator[](const INTEGER& index_value);
const Item& operator[](int index_value) const;
const Item& operator[](const INTEGER& index_value) const;

X_item__list operator<<=(int rotate_count) const;
X_item__list operator<<=(const INTEGER& rotate_count) const;
X_item__list operator>>=(int rotate_count) const;
X_item__list operator>>=(const INTEGER& rotate_count) const;

X_item__list operator+(const X_item__list& other_value) const;

X_item__list substr(int index, int returncount) const;

X_item__list replace(int index, int len, const X_item__list& repl) const;

X_item__list replace(int index, int len, const X_item__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class X_item__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
Item_template **value_elements;
} single_value;
struct {
unsigned int n_values;
X_item__list_template *list_value;
} value_list;
};
void copy_value(const X_item__list& other_value);
void copy_template(const X_item__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
X_item__list_template();
X_item__list_template(template_sel other_value);
X_item__list_template(null_type other_value);
X_item__list_template(const X_item__list& other_value);
X_item__list_template(const OPTIONAL<X_item__list>& other_value);
X_item__list_template(const X_item__list_template& other_value);
~X_item__list_template();

void clean_up();
X_item__list_template& operator=(template_sel other_value);
X_item__list_template& operator=(null_type other_value);
X_item__list_template& operator=(const X_item__list& other_value);
X_item__list_template& operator=(const OPTIONAL<X_item__list>& other_value);
X_item__list_template& operator=(const X_item__list_template& other_value);

Item_template& operator[](int index_value);
Item_template& operator[](const INTEGER& index_value);
const Item_template& operator[](int index_value) const;
const Item_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const X_item__list& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
X_item__list valueof() const;
X_item__list substr(int index, int returncount) const;

X_item__list replace(int index, int len, const X_item__list_template& repl) const;

X_item__list replace(int index, int len, const X_item__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
X_item__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const X_item__list& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Item_field__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Field **value_elements;
} *val_ptr;

static const Field UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const Item_field__list& other_value);

public:
  typedef Field of_type;
Item_field__list();
Item_field__list(null_type other_value);
Item_field__list(const Item_field__list& other_value);
~Item_field__list();

void clean_up();
Item_field__list& operator=(null_type other_value);
Item_field__list& operator=(const Item_field__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const Item_field__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Item_field__list& other_value) const { return !(*this == other_value); }

Field& operator[](int index_value);
Field& operator[](const INTEGER& index_value);
const Field& operator[](int index_value) const;
const Field& operator[](const INTEGER& index_value) const;

Item_field__list operator<<=(int rotate_count) const;
Item_field__list operator<<=(const INTEGER& rotate_count) const;
Item_field__list operator>>=(int rotate_count) const;
Item_field__list operator>>=(const INTEGER& rotate_count) const;

Item_field__list operator+(const Item_field__list& other_value) const;

Item_field__list substr(int index, int returncount) const;

Item_field__list replace(int index, int len, const Item_field__list& repl) const;

Item_field__list replace(int index, int len, const Item_field__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Item_field__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
Field_template **value_elements;
} single_value;
struct {
unsigned int n_values;
Item_field__list_template *list_value;
} value_list;
};
void copy_value(const Item_field__list& other_value);
void copy_template(const Item_field__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
Item_field__list_template();
Item_field__list_template(template_sel other_value);
Item_field__list_template(null_type other_value);
Item_field__list_template(const Item_field__list& other_value);
Item_field__list_template(const OPTIONAL<Item_field__list>& other_value);
Item_field__list_template(const Item_field__list_template& other_value);
~Item_field__list_template();

void clean_up();
Item_field__list_template& operator=(template_sel other_value);
Item_field__list_template& operator=(null_type other_value);
Item_field__list_template& operator=(const Item_field__list& other_value);
Item_field__list_template& operator=(const OPTIONAL<Item_field__list>& other_value);
Item_field__list_template& operator=(const Item_field__list_template& other_value);

Field_template& operator[](int index_value);
Field_template& operator[](const INTEGER& index_value);
const Field_template& operator[](int index_value) const;
const Field_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const Item_field__list& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
Item_field__list valueof() const;
Item_field__list substr(int index, int returncount) const;

Item_field__list replace(int index, int len, const Item_field__list_template& repl) const;

Item_field__list replace(int index, int len, const Item_field__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
Item_field__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Item_field__list& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Item : public Base_Type {
  Item_field__list field_field__list;
  boolean bound_flag;
public:
  Item();
  Item(const Item_field__list& par_field__list);
  Item(const Item& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Item& operator=(const Item& other_value);
  boolean operator==(const Item& other_value) const;
  inline boolean operator!=(const Item& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline Item_field__list& field__list()
    {return field_field__list;}
  inline const Item_field__list& field__list() const
    {return field_field__list;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Item_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Item_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Item& other_value);
void copy_template(const Item_template& other_value);

public:
Item_template();
Item_template(template_sel other_value);
Item_template(const Item& other_value);
Item_template(const OPTIONAL<Item>& other_value);
Item_template(const Item_template& other_value);
~Item_template();
Item_template& operator=(template_sel other_value);
Item_template& operator=(const Item& other_value);
Item_template& operator=(const OPTIONAL<Item>& other_value);
Item_template& operator=(const Item_template& other_value);
boolean match(const Item& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Item valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Item_template& list_item(unsigned int list_index) const;
Item_field__list_template& field__list();
const Item_field__list_template& field__list() const;
int size_of() const;
void log() const;
void log_match(const Item& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class X : public Base_Type {
  X_type__ field_type__;
  X_instructions__list field_instructions__list;
  OPTIONAL<UNIVERSAL_CHARSTRING> field_title;
  X_field__list field_field__list;
  OPTIONAL<Reported> field_reported;
  X_item__list field_item__list;
  boolean bound_flag;
public:
  X();
  X(const X_type__& par_type__,
    const X_instructions__list& par_instructions__list,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_title,
    const X_field__list& par_field__list,
    const OPTIONAL<Reported>& par_reported,
    const X_item__list& par_item__list);
  X(const X& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  X& operator=(const X& other_value);
  boolean operator==(const X& other_value) const;
  inline boolean operator!=(const X& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline X_type__& type__()
    {return field_type__;}
  inline const X_type__& type__() const
    {return field_type__;}
  inline X_instructions__list& instructions__list()
    {return field_instructions__list;}
  inline const X_instructions__list& instructions__list() const
    {return field_instructions__list;}
  inline OPTIONAL<UNIVERSAL_CHARSTRING>& title()
    {return field_title;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& title() const
    {return field_title;}
  inline X_field__list& field__list()
    {return field_field__list;}
  inline const X_field__list& field__list() const
    {return field_field__list;}
  inline OPTIONAL<Reported>& reported()
    {return field_reported;}
  inline const OPTIONAL<Reported>& reported() const
    {return field_reported;}
  inline X_item__list& item__list()
    {return field_item__list;}
  inline const X_item__list& item__list() const
    {return field_item__list;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class X_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
X_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const X& other_value);
void copy_template(const X_template& other_value);

public:
X_template();
X_template(template_sel other_value);
X_template(const X& other_value);
X_template(const OPTIONAL<X>& other_value);
X_template(const X_template& other_value);
~X_template();
X_template& operator=(template_sel other_value);
X_template& operator=(const X& other_value);
X_template& operator=(const OPTIONAL<X>& other_value);
X_template& operator=(const X_template& other_value);
boolean match(const X& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
X valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
X_template& list_item(unsigned int list_index) const;
X_type___template& type__();
const X_type___template& type__() const;
X_instructions__list_template& instructions__list();
const X_instructions__list_template& instructions__list() const;
UNIVERSAL_CHARSTRING_template& title();
const UNIVERSAL_CHARSTRING_template& title() const;
X_field__list_template& field__list();
const X_field__list_template& field__list() const;
Reported_template& reported();
const Reported_template& reported() const;
X_item__list_template& item__list();
const X_item__list_template& item__list() const;
int size_of() const;
void log() const;
void log_match(const X& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class Reported_field__list : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Field **value_elements;
} *val_ptr;

static const Field UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const Reported_field__list& other_value);

public:
  typedef Field of_type;
Reported_field__list();
Reported_field__list(null_type other_value);
Reported_field__list(const Reported_field__list& other_value);
~Reported_field__list();

void clean_up();
Reported_field__list& operator=(null_type other_value);
Reported_field__list& operator=(const Reported_field__list& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const Reported_field__list& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reported_field__list& other_value) const { return !(*this == other_value); }

Field& operator[](int index_value);
Field& operator[](const INTEGER& index_value);
const Field& operator[](int index_value) const;
const Field& operator[](const INTEGER& index_value) const;

Reported_field__list operator<<=(int rotate_count) const;
Reported_field__list operator<<=(const INTEGER& rotate_count) const;
Reported_field__list operator>>=(int rotate_count) const;
Reported_field__list operator>>=(const INTEGER& rotate_count) const;

Reported_field__list operator+(const Reported_field__list& other_value) const;

Reported_field__list substr(int index, int returncount) const;

Reported_field__list replace(int index, int len, const Reported_field__list& repl) const;

Reported_field__list replace(int index, int len, const Reported_field__list_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const;
};

class Reported_field__list_template : public Record_Of_Template {
union {
struct {
int n_elements;
Field_template **value_elements;
} single_value;
struct {
unsigned int n_values;
Reported_field__list_template *list_value;
} value_list;
};
void copy_value(const Reported_field__list& other_value);
void copy_template(const Reported_field__list_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
Reported_field__list_template();
Reported_field__list_template(template_sel other_value);
Reported_field__list_template(null_type other_value);
Reported_field__list_template(const Reported_field__list& other_value);
Reported_field__list_template(const OPTIONAL<Reported_field__list>& other_value);
Reported_field__list_template(const Reported_field__list_template& other_value);
~Reported_field__list_template();

void clean_up();
Reported_field__list_template& operator=(template_sel other_value);
Reported_field__list_template& operator=(null_type other_value);
Reported_field__list_template& operator=(const Reported_field__list& other_value);
Reported_field__list_template& operator=(const OPTIONAL<Reported_field__list>& other_value);
Reported_field__list_template& operator=(const Reported_field__list_template& other_value);

Field_template& operator[](int index_value);
Field_template& operator[](const INTEGER& index_value);
const Field_template& operator[](int index_value) const;
const Field_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const Reported_field__list& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
Reported_field__list valueof() const;
Reported_field__list substr(int index, int returncount) const;

Reported_field__list replace(int index, int len, const Reported_field__list_template& repl) const;

Reported_field__list replace(int index, int len, const Reported_field__list& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
Reported_field__list_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Reported_field__list& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class Reported : public Base_Type {
  Reported_field__list field_field__list;
  boolean bound_flag;
public:
  Reported();
  Reported(const Reported_field__list& par_field__list);
  Reported(const Reported& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Reported& operator=(const Reported& other_value);
  boolean operator==(const Reported& other_value) const;
  inline boolean operator!=(const Reported& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline Reported_field__list& field__list()
    {return field_field__list;}
  inline const Reported_field__list& field__list() const
    {return field_field__list;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const;
};

class Reported_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Reported_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Reported& other_value);
void copy_template(const Reported_template& other_value);

public:
Reported_template();
Reported_template(template_sel other_value);
Reported_template(const Reported& other_value);
Reported_template(const OPTIONAL<Reported>& other_value);
Reported_template(const Reported_template& other_value);
~Reported_template();
Reported_template& operator=(template_sel other_value);
Reported_template& operator=(const Reported& other_value);
Reported_template& operator=(const OPTIONAL<Reported>& other_value);
Reported_template& operator=(const Reported_template& other_value);
boolean match(const Reported& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Reported valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reported_template& list_item(unsigned int list_index) const;
Reported_field__list_template& field__list();
const Reported_field__list_template& field__list() const;
int size_of() const;
void log() const;
void log_match(const Reported& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const X_field__list& other_value);
inline boolean operator!=(null_type null_value, const X_field__list& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Field_option__list& other_value);
inline boolean operator!=(null_type null_value, const Field_option__list& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const X_item__list& other_value);
inline boolean operator!=(null_type null_value, const X_item__list& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Item_field__list& other_value);
inline boolean operator!=(null_type null_value, const Item_field__list& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reported_field__list& other_value);
inline boolean operator!=(null_type null_value, const Reported_field__list& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const XERdescriptor_t X_type___xer_;
extern const TTCN_JSONdescriptor_t X_type___json_;
extern const TTCN_Typedescriptor_t X_type___descr_;
extern const XERdescriptor_t X_instructions__list_xer_;
extern const TTCN_JSONdescriptor_t X_instructions__list_json_;
extern const TTCN_Typedescriptor_t X_instructions__list_descr_;
extern const XERdescriptor_t X_instructions__list_0_xer_;
extern const TTCN_Typedescriptor_t X_instructions__list_0_descr_;
extern const XERdescriptor_t X_field__list_xer_;
extern const TTCN_JSONdescriptor_t X_field__list_json_;
extern const TTCN_Typedescriptor_t X_field__list_descr_;
extern const XERdescriptor_t Field_value__list_xer_;
extern const TTCN_JSONdescriptor_t Field_value__list_json_;
extern const TTCN_Typedescriptor_t Field_value__list_descr_;
extern const XERdescriptor_t Value_xer_;
extern const TTCN_Typedescriptor_t Value_descr_;
extern const XERdescriptor_t Field_value__list_0_xer_;
extern const TTCN_Typedescriptor_t Field_value__list_0_descr_;
extern const XERdescriptor_t Field_option__list_xer_;
extern const TTCN_JSONdescriptor_t Field_option__list_json_;
extern const TTCN_Typedescriptor_t Field_option__list_descr_;
extern const XERdescriptor_t Option_value___xer_;
extern const TTCN_Typedescriptor_t Option_value___descr_;
extern const XERdescriptor_t Option_xer_;
extern const TTCN_JSONdescriptor_t Option_json_;
extern const TTCN_Typedescriptor_t Option_descr_;
extern const XERdescriptor_t Option_label___xer_;
extern const TTCN_Typedescriptor_t Option_label___descr_;
extern const XERdescriptor_t Field_option__list_0_xer_;
extern const TTCN_Typedescriptor_t Field_option__list_0_descr_;
extern const XERdescriptor_t Field_xer_;
extern const TTCN_JSONdescriptor_t Field_json_;
extern const TTCN_Typedescriptor_t Field_descr_;
extern const XERdescriptor_t Field_label___xer_;
extern const TTCN_Typedescriptor_t Field_label___descr_;
extern const XERdescriptor_t Field_type___xer_;
extern Field_type__ Field_type___dfe;
extern const TTCN_JSONdescriptor_t Field_type___json_;
extern const TTCN_Typedescriptor_t Field_type___descr_;
extern const XERdescriptor_t Field_var___xer_;
extern const TTCN_Typedescriptor_t Field_var___descr_;
extern const XERdescriptor_t Field_desc_xer_;
extern const TTCN_Typedescriptor_t Field_desc_descr_;
extern const XERdescriptor_t Empty_xer_;
extern const TTCN_JSONdescriptor_t Empty_json_;
extern const TTCN_Typedescriptor_t Empty_descr_;
extern const XERdescriptor_t Field_required_xer_;
extern const TTCN_Typedescriptor_t Field_required_descr_;
extern const XERdescriptor_t X_field__list_0_xer_;
extern const TTCN_Typedescriptor_t X_field__list_0_descr_;
extern const XERdescriptor_t X_item__list_xer_;
extern const TTCN_JSONdescriptor_t X_item__list_json_;
extern const TTCN_Typedescriptor_t X_item__list_descr_;
extern const XERdescriptor_t Item_field__list_xer_;
extern const TTCN_JSONdescriptor_t Item_field__list_json_;
extern const TTCN_Typedescriptor_t Item_field__list_descr_;
extern const XERdescriptor_t Item_field__list_0_xer_;
extern const TTCN_Typedescriptor_t Item_field__list_0_descr_;
extern const XERdescriptor_t Item_xer_;
extern const TTCN_JSONdescriptor_t Item_json_;
extern const TTCN_Typedescriptor_t Item_descr_;
extern const XERdescriptor_t X_item__list_0_xer_;
extern const TTCN_Typedescriptor_t X_item__list_0_descr_;
extern const XERdescriptor_t X_xer_;
extern const TTCN_JSONdescriptor_t X_json_;
extern const TTCN_Typedescriptor_t X_descr_;
extern const XERdescriptor_t X_title_xer_;
extern const TTCN_Typedescriptor_t X_title_descr_;
extern const XERdescriptor_t Reported_field__list_xer_;
extern const TTCN_JSONdescriptor_t Reported_field__list_json_;
extern const TTCN_Typedescriptor_t Reported_field__list_descr_;
extern const XERdescriptor_t Reported_field__list_0_xer_;
extern const TTCN_Typedescriptor_t Reported_field__list_0_descr_;
extern const XERdescriptor_t Reported_xer_;
extern const TTCN_JSONdescriptor_t Reported_json_;
extern const TTCN_Typedescriptor_t Reported_descr_;
extern const XERdescriptor_t X_reported_xer_;
extern const TTCN_Typedescriptor_t X_reported_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
