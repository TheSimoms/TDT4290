// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for user (user@user-multicom) on Fri Sep 25 13:42:36 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

#ifndef DNS__Types_HH
#define DNS__Types_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 50300
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef DNS__Types_HH
#endif

namespace DNS__Types {

/* Forward declarations of classes */

class QueryOrResponse;
class QueryOrResponse_template;
class DnsHeader;
class DnsHeader_template;
class QResourceRecords;
class QResourceRecords_template;
class QResourceRecord;
class QResourceRecord_template;
class ResourceRecords;
class ResourceRecords_template;
class ResourceData;
class ResourceData_template;
class RDataHInfo;
class RDataHInfo_template;
class RDataMInfo;
class RDataMInfo_template;
class RDataMX;
class RDataMX_template;
class RDataSOA;
class RDataSOA_template;
class RDataWKS;
class RDataWKS_template;
class RDataSRV;
class RDataSRV_template;
class RDataNAPTR;
class RDataNAPTR_template;
class ResourceRecord;
class ResourceRecord_template;
class PDU__DNS;
class PDU__DNS_template;

} /* end of namespace */

#ifndef DNS__Types_HH
#define DNS__Types_HH

namespace DNS__Types {

/* Type definitions */

typedef INTEGER UInt16;
typedef INTEGER_template UInt16_template;
typedef INTEGER OpCode;
typedef INTEGER_template OpCode_template;
typedef INTEGER ResponseCode;
typedef INTEGER_template ResponseCode_template;
typedef CHARSTRING CharStr255;
typedef CHARSTRING_template CharStr255_template;
typedef CHARSTRING DomainName;
typedef CHARSTRING_template DomainName_template;
typedef INTEGER RRType;
typedef INTEGER_template RRType_template;
typedef INTEGER RRClass;
typedef INTEGER_template RRClass_template;
typedef OCTETSTRING UInt32;
typedef OCTETSTRING_template UInt32_template;
typedef CHARSTRING RDataCName;
typedef CHARSTRING_template RDataCName_template;
typedef CHARSTRING RDataMB;
typedef CHARSTRING_template RDataMB_template;
typedef CHARSTRING RDataMD;
typedef CHARSTRING_template RDataMD_template;
typedef CHARSTRING RDataMF;
typedef CHARSTRING_template RDataMF_template;
typedef CHARSTRING RDataMG;
typedef CHARSTRING_template RDataMG_template;
typedef CHARSTRING RDataMR;
typedef CHARSTRING_template RDataMR_template;
typedef OCTETSTRING RDataNull;
typedef OCTETSTRING_template RDataNull_template;
typedef CHARSTRING RDataNS;
typedef CHARSTRING_template RDataNS_template;
typedef CHARSTRING RDataPTR;
typedef CHARSTRING_template RDataPTR_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING RDataTXT;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING_template RDataTXT_template;
typedef OCTETSTRING RDataA;
typedef OCTETSTRING_template RDataA_template;
typedef INTEGER UInt8;
typedef INTEGER_template UInt8_template;
typedef OCTETSTRING RDataAAAA;
typedef OCTETSTRING_template RDataAAAA_template;

/* Class definitions */

class QueryOrResponse : public Base_Type { // enum
friend class QueryOrResponse_template;
public:
enum enum_type { DNS__QUERY = 0, DNS__RESPONSE = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
QueryOrResponse();
QueryOrResponse(int other_value);
QueryOrResponse(enum_type other_value);
QueryOrResponse(const QueryOrResponse& other_value);

QueryOrResponse& operator=(int other_value);
QueryOrResponse& operator=(enum_type other_value);
QueryOrResponse& operator=(const QueryOrResponse& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const QueryOrResponse& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const QueryOrResponse& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const QueryOrResponse& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const QueryOrResponse& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const QueryOrResponse& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const QueryOrResponse& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const QueryOrResponse& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class QueryOrResponse_template : public Base_Template {
union {
QueryOrResponse::enum_type single_value;
struct {
unsigned int n_values;
QueryOrResponse_template *list_value;
} value_list;
};

void copy_template(const QueryOrResponse_template& other_value);

public:
QueryOrResponse_template();
QueryOrResponse_template(template_sel other_value);
QueryOrResponse_template(int other_value);
QueryOrResponse_template(QueryOrResponse::enum_type other_value);
QueryOrResponse_template(const QueryOrResponse& other_value);
QueryOrResponse_template(const OPTIONAL<QueryOrResponse>& other_value);
QueryOrResponse_template(const QueryOrResponse_template& other_value);
~QueryOrResponse_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
QueryOrResponse_template& operator=(template_sel other_value);
QueryOrResponse_template& operator=(int other_value);
QueryOrResponse_template& operator=(QueryOrResponse::enum_type other_value);
QueryOrResponse_template& operator=(const QueryOrResponse& other_value);
QueryOrResponse_template& operator=(const OPTIONAL<QueryOrResponse>& other_value);
QueryOrResponse_template& operator=(const QueryOrResponse_template& other_value);

boolean match(QueryOrResponse::enum_type other_value) const;
boolean match(const QueryOrResponse& other_value) const;
QueryOrResponse::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
QueryOrResponse_template& list_item(unsigned int list_index);
void log() const;
void log_match(const QueryOrResponse& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class DnsHeader {
  INTEGER field_id;
  QueryOrResponse field_qr;
  INTEGER field_opCode;
  BOOLEAN field_aa;
  BOOLEAN field_tc;
  BOOLEAN field_rd;
  BOOLEAN field_ra;
  BITSTRING field_z;
  INTEGER field_rCode;
  INTEGER field_qdCount;
  INTEGER field_anCount;
  INTEGER field_nsCount;
  INTEGER field_arCount;
  boolean bound_flag;
public:
  DnsHeader();
  DnsHeader(const INTEGER& par_id,
    const QueryOrResponse& par_qr,
    const INTEGER& par_opCode,
    const BOOLEAN& par_aa,
    const BOOLEAN& par_tc,
    const BOOLEAN& par_rd,
    const BOOLEAN& par_ra,
    const BITSTRING& par_z,
    const INTEGER& par_rCode,
    const INTEGER& par_qdCount,
    const INTEGER& par_anCount,
    const INTEGER& par_nsCount,
    const INTEGER& par_arCount);
  DnsHeader(const DnsHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DnsHeader& operator=(const DnsHeader& other_value);
  boolean operator==(const DnsHeader& other_value) const;
  inline boolean operator!=(const DnsHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& id()
    {return field_id;}
  inline const INTEGER& id() const
    {return field_id;}
  inline QueryOrResponse& qr()
    {return field_qr;}
  inline const QueryOrResponse& qr() const
    {return field_qr;}
  inline INTEGER& opCode()
    {return field_opCode;}
  inline const INTEGER& opCode() const
    {return field_opCode;}
  inline BOOLEAN& aa()
    {return field_aa;}
  inline const BOOLEAN& aa() const
    {return field_aa;}
  inline BOOLEAN& tc()
    {return field_tc;}
  inline const BOOLEAN& tc() const
    {return field_tc;}
  inline BOOLEAN& rd()
    {return field_rd;}
  inline const BOOLEAN& rd() const
    {return field_rd;}
  inline BOOLEAN& ra()
    {return field_ra;}
  inline const BOOLEAN& ra() const
    {return field_ra;}
  inline BITSTRING& z()
    {return field_z;}
  inline const BITSTRING& z() const
    {return field_z;}
  inline INTEGER& rCode()
    {return field_rCode;}
  inline const INTEGER& rCode() const
    {return field_rCode;}
  inline INTEGER& qdCount()
    {return field_qdCount;}
  inline const INTEGER& qdCount() const
    {return field_qdCount;}
  inline INTEGER& anCount()
    {return field_anCount;}
  inline const INTEGER& anCount() const
    {return field_anCount;}
  inline INTEGER& nsCount()
    {return field_nsCount;}
  inline const INTEGER& nsCount() const
    {return field_nsCount;}
  inline INTEGER& arCount()
    {return field_arCount;}
  inline const INTEGER& arCount() const
    {return field_arCount;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class DnsHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DnsHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DnsHeader& other_value);
void copy_template(const DnsHeader_template& other_value);

public:
DnsHeader_template();
DnsHeader_template(template_sel other_value);
DnsHeader_template(const DnsHeader& other_value);
DnsHeader_template(const OPTIONAL<DnsHeader>& other_value);
DnsHeader_template(const DnsHeader_template& other_value);
~DnsHeader_template();
DnsHeader_template& operator=(template_sel other_value);
DnsHeader_template& operator=(const DnsHeader& other_value);
DnsHeader_template& operator=(const OPTIONAL<DnsHeader>& other_value);
DnsHeader_template& operator=(const DnsHeader_template& other_value);
boolean match(const DnsHeader& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DnsHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DnsHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& id();
const INTEGER_template& id() const;
QueryOrResponse_template& qr();
const QueryOrResponse_template& qr() const;
INTEGER_template& opCode();
const INTEGER_template& opCode() const;
BOOLEAN_template& aa();
const BOOLEAN_template& aa() const;
BOOLEAN_template& tc();
const BOOLEAN_template& tc() const;
BOOLEAN_template& rd();
const BOOLEAN_template& rd() const;
BOOLEAN_template& ra();
const BOOLEAN_template& ra() const;
BITSTRING_template& z();
const BITSTRING_template& z() const;
INTEGER_template& rCode();
const INTEGER_template& rCode() const;
INTEGER_template& qdCount();
const INTEGER_template& qdCount() const;
INTEGER_template& anCount();
const INTEGER_template& anCount() const;
INTEGER_template& nsCount();
const INTEGER_template& nsCount() const;
INTEGER_template& arCount();
const INTEGER_template& arCount() const;
int size_of() const;
void log() const;
void log_match(const DnsHeader& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class QResourceRecords : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
QResourceRecord **value_elements;
} *val_ptr;

static const QResourceRecord UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const QResourceRecords& other_value);

public:
  typedef QResourceRecord of_type;
QResourceRecords();
QResourceRecords(null_type other_value);
QResourceRecords(const QResourceRecords& other_value);
~QResourceRecords();

void clean_up();
QResourceRecords& operator=(null_type other_value);
QResourceRecords& operator=(const QResourceRecords& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const QResourceRecords& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const QResourceRecords& other_value) const { return !(*this == other_value); }

QResourceRecord& operator[](int index_value);
QResourceRecord& operator[](const INTEGER& index_value);
const QResourceRecord& operator[](int index_value) const;
const QResourceRecord& operator[](const INTEGER& index_value) const;

QResourceRecords operator<<=(int rotate_count) const;
QResourceRecords operator<<=(const INTEGER& rotate_count) const;
QResourceRecords operator>>=(int rotate_count) const;
QResourceRecords operator>>=(const INTEGER& rotate_count) const;

QResourceRecords operator+(const QResourceRecords& other_value) const;

QResourceRecords substr(int index, int returncount) const;

QResourceRecords replace(int index, int len, const QResourceRecords& repl) const;

QResourceRecords replace(int index, int len, const QResourceRecords_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class QResourceRecords_template : public Record_Of_Template {
union {
struct {
int n_elements;
QResourceRecord_template **value_elements;
} single_value;
struct {
unsigned int n_values;
QResourceRecords_template *list_value;
} value_list;
};
void copy_value(const QResourceRecords& other_value);
void copy_template(const QResourceRecords_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
QResourceRecords_template();
QResourceRecords_template(template_sel other_value);
QResourceRecords_template(null_type other_value);
QResourceRecords_template(const QResourceRecords& other_value);
QResourceRecords_template(const OPTIONAL<QResourceRecords>& other_value);
QResourceRecords_template(const QResourceRecords_template& other_value);
~QResourceRecords_template();

void clean_up();
QResourceRecords_template& operator=(template_sel other_value);
QResourceRecords_template& operator=(null_type other_value);
QResourceRecords_template& operator=(const QResourceRecords& other_value);
QResourceRecords_template& operator=(const OPTIONAL<QResourceRecords>& other_value);
QResourceRecords_template& operator=(const QResourceRecords_template& other_value);

QResourceRecord_template& operator[](int index_value);
QResourceRecord_template& operator[](const INTEGER& index_value);
const QResourceRecord_template& operator[](int index_value) const;
const QResourceRecord_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const QResourceRecords& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
QResourceRecords valueof() const;
QResourceRecords substr(int index, int returncount) const;

QResourceRecords replace(int index, int len, const QResourceRecords_template& repl) const;

QResourceRecords replace(int index, int len, const QResourceRecords& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
QResourceRecords_template& list_item(unsigned int list_index);
void log() const;
void log_match(const QResourceRecords& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class QResourceRecord {
  CHARSTRING field_qName;
  INTEGER field_qType;
  INTEGER field_qClass;
  boolean bound_flag;
public:
  QResourceRecord();
  QResourceRecord(const CHARSTRING& par_qName,
    const INTEGER& par_qType,
    const INTEGER& par_qClass);
  QResourceRecord(const QResourceRecord& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  QResourceRecord& operator=(const QResourceRecord& other_value);
  boolean operator==(const QResourceRecord& other_value) const;
  inline boolean operator!=(const QResourceRecord& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& qName()
    {return field_qName;}
  inline const CHARSTRING& qName() const
    {return field_qName;}
  inline INTEGER& qType()
    {return field_qType;}
  inline const INTEGER& qType() const
    {return field_qType;}
  inline INTEGER& qClass()
    {return field_qClass;}
  inline const INTEGER& qClass() const
    {return field_qClass;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class QResourceRecord_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
QResourceRecord_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const QResourceRecord& other_value);
void copy_template(const QResourceRecord_template& other_value);

public:
QResourceRecord_template();
QResourceRecord_template(template_sel other_value);
QResourceRecord_template(const QResourceRecord& other_value);
QResourceRecord_template(const OPTIONAL<QResourceRecord>& other_value);
QResourceRecord_template(const QResourceRecord_template& other_value);
~QResourceRecord_template();
QResourceRecord_template& operator=(template_sel other_value);
QResourceRecord_template& operator=(const QResourceRecord& other_value);
QResourceRecord_template& operator=(const OPTIONAL<QResourceRecord>& other_value);
QResourceRecord_template& operator=(const QResourceRecord_template& other_value);
boolean match(const QResourceRecord& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
QResourceRecord valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
QResourceRecord_template& list_item(unsigned int list_index) const;
CHARSTRING_template& qName();
const CHARSTRING_template& qName() const;
INTEGER_template& qType();
const INTEGER_template& qType() const;
INTEGER_template& qClass();
const INTEGER_template& qClass() const;
int size_of() const;
void log() const;
void log_match(const QResourceRecord& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class ResourceRecords : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ResourceRecord **value_elements;
} *val_ptr;

static const ResourceRecord UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ResourceRecords& other_value);

public:
  typedef ResourceRecord of_type;
ResourceRecords();
ResourceRecords(null_type other_value);
ResourceRecords(const ResourceRecords& other_value);
~ResourceRecords();

void clean_up();
ResourceRecords& operator=(null_type other_value);
ResourceRecords& operator=(const ResourceRecords& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ResourceRecords& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ResourceRecords& other_value) const { return !(*this == other_value); }

ResourceRecord& operator[](int index_value);
ResourceRecord& operator[](const INTEGER& index_value);
const ResourceRecord& operator[](int index_value) const;
const ResourceRecord& operator[](const INTEGER& index_value) const;

ResourceRecords operator<<=(int rotate_count) const;
ResourceRecords operator<<=(const INTEGER& rotate_count) const;
ResourceRecords operator>>=(int rotate_count) const;
ResourceRecords operator>>=(const INTEGER& rotate_count) const;

ResourceRecords operator+(const ResourceRecords& other_value) const;

ResourceRecords substr(int index, int returncount) const;

ResourceRecords replace(int index, int len, const ResourceRecords& repl) const;

ResourceRecords replace(int index, int len, const ResourceRecords_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ResourceRecords_template : public Record_Of_Template {
union {
struct {
int n_elements;
ResourceRecord_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ResourceRecords_template *list_value;
} value_list;
};
void copy_value(const ResourceRecords& other_value);
void copy_template(const ResourceRecords_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index);

public:
ResourceRecords_template();
ResourceRecords_template(template_sel other_value);
ResourceRecords_template(null_type other_value);
ResourceRecords_template(const ResourceRecords& other_value);
ResourceRecords_template(const OPTIONAL<ResourceRecords>& other_value);
ResourceRecords_template(const ResourceRecords_template& other_value);
~ResourceRecords_template();

void clean_up();
ResourceRecords_template& operator=(template_sel other_value);
ResourceRecords_template& operator=(null_type other_value);
ResourceRecords_template& operator=(const ResourceRecords& other_value);
ResourceRecords_template& operator=(const OPTIONAL<ResourceRecords>& other_value);
ResourceRecords_template& operator=(const ResourceRecords_template& other_value);

ResourceRecord_template& operator[](int index_value);
ResourceRecord_template& operator[](const INTEGER& index_value);
const ResourceRecord_template& operator[](int index_value) const;
const ResourceRecord_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ResourceRecords& other_value) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ResourceRecords valueof() const;
ResourceRecords substr(int index, int returncount) const;

ResourceRecords replace(int index, int len, const ResourceRecords_template& repl) const;

ResourceRecords replace(int index, int len, const ResourceRecords& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ResourceRecords_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ResourceRecords& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class ResourceData : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_cName = 1, ALT_hInfo = 2, ALT_mb = 3, ALT_md = 4, ALT_mf = 5, ALT_mg = 6, ALT_mInfo = 7, ALT_mr = 8, ALT_mx = 9, ALT_rd__null = 10, ALT_ns = 11, ALT_ptr = 12, ALT_soa = 13, ALT_txt = 14, ALT_a = 15, ALT_wks = 16, ALT_srv = 17, ALT_naptr = 18, ALT_aaaa = 19, ALT_unsupported = 20, ALT_undecodable = 21 };
private:
union_selection_type union_selection;
union {
CHARSTRING *field_cName;
RDataHInfo *field_hInfo;
CHARSTRING *field_mb;
CHARSTRING *field_md;
CHARSTRING *field_mf;
CHARSTRING *field_mg;
RDataMInfo *field_mInfo;
CHARSTRING *field_mr;
RDataMX *field_mx;
OCTETSTRING *field_rd__null;
CHARSTRING *field_ns;
CHARSTRING *field_ptr;
RDataSOA *field_soa;
RDataTXT *field_txt;
OCTETSTRING *field_a;
RDataWKS *field_wks;
RDataSRV *field_srv;
RDataNAPTR *field_naptr;
OCTETSTRING *field_aaaa;
OCTETSTRING *field_unsupported;
OCTETSTRING *field_undecodable;
};
void copy_value(const ResourceData& other_value);

public:
ResourceData();
ResourceData(const ResourceData& other_value);
~ResourceData();
ResourceData& operator=(const ResourceData& other_value);
boolean operator==(const ResourceData& other_value) const;
inline boolean operator!=(const ResourceData& other_value) const { return !(*this == other_value); }
CHARSTRING& cName();
const CHARSTRING& cName() const;
RDataHInfo& hInfo();
const RDataHInfo& hInfo() const;
CHARSTRING& mb();
const CHARSTRING& mb() const;
CHARSTRING& md();
const CHARSTRING& md() const;
CHARSTRING& mf();
const CHARSTRING& mf() const;
CHARSTRING& mg();
const CHARSTRING& mg() const;
RDataMInfo& mInfo();
const RDataMInfo& mInfo() const;
CHARSTRING& mr();
const CHARSTRING& mr() const;
RDataMX& mx();
const RDataMX& mx() const;
OCTETSTRING& rd__null();
const OCTETSTRING& rd__null() const;
CHARSTRING& ns();
const CHARSTRING& ns() const;
CHARSTRING& ptr();
const CHARSTRING& ptr() const;
RDataSOA& soa();
const RDataSOA& soa() const;
RDataTXT& txt();
const RDataTXT& txt() const;
OCTETSTRING& a();
const OCTETSTRING& a() const;
RDataWKS& wks();
const RDataWKS& wks() const;
RDataSRV& srv();
const RDataSRV& srv() const;
RDataNAPTR& naptr();
const RDataNAPTR& naptr() const;
OCTETSTRING& aaaa();
const OCTETSTRING& aaaa() const;
OCTETSTRING& unsupported();
const OCTETSTRING& unsupported() const;
OCTETSTRING& undecodable();
const OCTETSTRING& undecodable() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ResourceData_template : public Base_Template {
union {
struct {
ResourceData::union_selection_type union_selection;
union {
CHARSTRING_template *field_cName;
RDataHInfo_template *field_hInfo;
CHARSTRING_template *field_mb;
CHARSTRING_template *field_md;
CHARSTRING_template *field_mf;
CHARSTRING_template *field_mg;
RDataMInfo_template *field_mInfo;
CHARSTRING_template *field_mr;
RDataMX_template *field_mx;
OCTETSTRING_template *field_rd__null;
CHARSTRING_template *field_ns;
CHARSTRING_template *field_ptr;
RDataSOA_template *field_soa;
RDataTXT_template *field_txt;
OCTETSTRING_template *field_a;
RDataWKS_template *field_wks;
RDataSRV_template *field_srv;
RDataNAPTR_template *field_naptr;
OCTETSTRING_template *field_aaaa;
OCTETSTRING_template *field_unsupported;
OCTETSTRING_template *field_undecodable;
};
} single_value;
struct {
unsigned int n_values;
ResourceData_template *list_value;
} value_list;
};
void copy_value(const ResourceData& other_value);

void copy_template(const ResourceData_template& other_value);

public:
ResourceData_template();
ResourceData_template(template_sel other_value);
ResourceData_template(const ResourceData& other_value);
ResourceData_template(const OPTIONAL<ResourceData>& other_value);
ResourceData_template(const ResourceData_template& other_value);
~ResourceData_template();
void clean_up();
ResourceData_template& operator=(template_sel other_value);
ResourceData_template& operator=(const ResourceData& other_value);
ResourceData_template& operator=(const OPTIONAL<ResourceData>& other_value);
ResourceData_template& operator=(const ResourceData_template& other_value);
boolean match(const ResourceData& other_value) const;
boolean is_value() const;ResourceData valueof() const;
ResourceData_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
CHARSTRING_template& cName();
const CHARSTRING_template& cName() const;
RDataHInfo_template& hInfo();
const RDataHInfo_template& hInfo() const;
CHARSTRING_template& mb();
const CHARSTRING_template& mb() const;
CHARSTRING_template& md();
const CHARSTRING_template& md() const;
CHARSTRING_template& mf();
const CHARSTRING_template& mf() const;
CHARSTRING_template& mg();
const CHARSTRING_template& mg() const;
RDataMInfo_template& mInfo();
const RDataMInfo_template& mInfo() const;
CHARSTRING_template& mr();
const CHARSTRING_template& mr() const;
RDataMX_template& mx();
const RDataMX_template& mx() const;
OCTETSTRING_template& rd__null();
const OCTETSTRING_template& rd__null() const;
CHARSTRING_template& ns();
const CHARSTRING_template& ns() const;
CHARSTRING_template& ptr();
const CHARSTRING_template& ptr() const;
RDataSOA_template& soa();
const RDataSOA_template& soa() const;
RDataTXT_template& txt();
const RDataTXT_template& txt() const;
OCTETSTRING_template& a();
const OCTETSTRING_template& a() const;
RDataWKS_template& wks();
const RDataWKS_template& wks() const;
RDataSRV_template& srv();
const RDataSRV_template& srv() const;
RDataNAPTR_template& naptr();
const RDataNAPTR_template& naptr() const;
OCTETSTRING_template& aaaa();
const OCTETSTRING_template& aaaa() const;
OCTETSTRING_template& unsupported();
const OCTETSTRING_template& unsupported() const;
OCTETSTRING_template& undecodable();
const OCTETSTRING_template& undecodable() const;
boolean ischosen(ResourceData::union_selection_type checked_selection) const;
void log() const;
void log_match(const ResourceData& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present() const;
boolean match_omit() const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
};

class RDataHInfo {
  CHARSTRING field_cpu;
  CHARSTRING field_os;
  boolean bound_flag;
public:
  RDataHInfo();
  RDataHInfo(const CHARSTRING& par_cpu,
    const CHARSTRING& par_os);
  RDataHInfo(const RDataHInfo& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RDataHInfo& operator=(const RDataHInfo& other_value);
  boolean operator==(const RDataHInfo& other_value) const;
  inline boolean operator!=(const RDataHInfo& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& cpu()
    {return field_cpu;}
  inline const CHARSTRING& cpu() const
    {return field_cpu;}
  inline CHARSTRING& os()
    {return field_os;}
  inline const CHARSTRING& os() const
    {return field_os;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class RDataHInfo_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RDataHInfo_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RDataHInfo& other_value);
void copy_template(const RDataHInfo_template& other_value);

public:
RDataHInfo_template();
RDataHInfo_template(template_sel other_value);
RDataHInfo_template(const RDataHInfo& other_value);
RDataHInfo_template(const OPTIONAL<RDataHInfo>& other_value);
RDataHInfo_template(const RDataHInfo_template& other_value);
~RDataHInfo_template();
RDataHInfo_template& operator=(template_sel other_value);
RDataHInfo_template& operator=(const RDataHInfo& other_value);
RDataHInfo_template& operator=(const OPTIONAL<RDataHInfo>& other_value);
RDataHInfo_template& operator=(const RDataHInfo_template& other_value);
boolean match(const RDataHInfo& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RDataHInfo valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RDataHInfo_template& list_item(unsigned int list_index) const;
CHARSTRING_template& cpu();
const CHARSTRING_template& cpu() const;
CHARSTRING_template& os();
const CHARSTRING_template& os() const;
int size_of() const;
void log() const;
void log_match(const RDataHInfo& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class RDataMInfo {
  CHARSTRING field_rMailBx;
  CHARSTRING field_eMailBx;
  boolean bound_flag;
public:
  RDataMInfo();
  RDataMInfo(const CHARSTRING& par_rMailBx,
    const CHARSTRING& par_eMailBx);
  RDataMInfo(const RDataMInfo& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RDataMInfo& operator=(const RDataMInfo& other_value);
  boolean operator==(const RDataMInfo& other_value) const;
  inline boolean operator!=(const RDataMInfo& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& rMailBx()
    {return field_rMailBx;}
  inline const CHARSTRING& rMailBx() const
    {return field_rMailBx;}
  inline CHARSTRING& eMailBx()
    {return field_eMailBx;}
  inline const CHARSTRING& eMailBx() const
    {return field_eMailBx;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class RDataMInfo_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RDataMInfo_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RDataMInfo& other_value);
void copy_template(const RDataMInfo_template& other_value);

public:
RDataMInfo_template();
RDataMInfo_template(template_sel other_value);
RDataMInfo_template(const RDataMInfo& other_value);
RDataMInfo_template(const OPTIONAL<RDataMInfo>& other_value);
RDataMInfo_template(const RDataMInfo_template& other_value);
~RDataMInfo_template();
RDataMInfo_template& operator=(template_sel other_value);
RDataMInfo_template& operator=(const RDataMInfo& other_value);
RDataMInfo_template& operator=(const OPTIONAL<RDataMInfo>& other_value);
RDataMInfo_template& operator=(const RDataMInfo_template& other_value);
boolean match(const RDataMInfo& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RDataMInfo valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RDataMInfo_template& list_item(unsigned int list_index) const;
CHARSTRING_template& rMailBx();
const CHARSTRING_template& rMailBx() const;
CHARSTRING_template& eMailBx();
const CHARSTRING_template& eMailBx() const;
int size_of() const;
void log() const;
void log_match(const RDataMInfo& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class RDataMX {
  INTEGER field_preference;
  CHARSTRING field_exchange;
  boolean bound_flag;
public:
  RDataMX();
  RDataMX(const INTEGER& par_preference,
    const CHARSTRING& par_exchange);
  RDataMX(const RDataMX& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RDataMX& operator=(const RDataMX& other_value);
  boolean operator==(const RDataMX& other_value) const;
  inline boolean operator!=(const RDataMX& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& preference()
    {return field_preference;}
  inline const INTEGER& preference() const
    {return field_preference;}
  inline CHARSTRING& exchange()
    {return field_exchange;}
  inline const CHARSTRING& exchange() const
    {return field_exchange;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class RDataMX_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RDataMX_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RDataMX& other_value);
void copy_template(const RDataMX_template& other_value);

public:
RDataMX_template();
RDataMX_template(template_sel other_value);
RDataMX_template(const RDataMX& other_value);
RDataMX_template(const OPTIONAL<RDataMX>& other_value);
RDataMX_template(const RDataMX_template& other_value);
~RDataMX_template();
RDataMX_template& operator=(template_sel other_value);
RDataMX_template& operator=(const RDataMX& other_value);
RDataMX_template& operator=(const OPTIONAL<RDataMX>& other_value);
RDataMX_template& operator=(const RDataMX_template& other_value);
boolean match(const RDataMX& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RDataMX valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RDataMX_template& list_item(unsigned int list_index) const;
INTEGER_template& preference();
const INTEGER_template& preference() const;
CHARSTRING_template& exchange();
const CHARSTRING_template& exchange() const;
int size_of() const;
void log() const;
void log_match(const RDataMX& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class RDataSOA {
  CHARSTRING field_mName;
  CHARSTRING field_rName;
  OCTETSTRING field_serial;
  OCTETSTRING field_refresh;
  OCTETSTRING field_retry;
  OCTETSTRING field_expire;
  OCTETSTRING field_minimum;
  boolean bound_flag;
public:
  RDataSOA();
  RDataSOA(const CHARSTRING& par_mName,
    const CHARSTRING& par_rName,
    const OCTETSTRING& par_serial,
    const OCTETSTRING& par_refresh,
    const OCTETSTRING& par_retry,
    const OCTETSTRING& par_expire,
    const OCTETSTRING& par_minimum);
  RDataSOA(const RDataSOA& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RDataSOA& operator=(const RDataSOA& other_value);
  boolean operator==(const RDataSOA& other_value) const;
  inline boolean operator!=(const RDataSOA& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& mName()
    {return field_mName;}
  inline const CHARSTRING& mName() const
    {return field_mName;}
  inline CHARSTRING& rName()
    {return field_rName;}
  inline const CHARSTRING& rName() const
    {return field_rName;}
  inline OCTETSTRING& serial()
    {return field_serial;}
  inline const OCTETSTRING& serial() const
    {return field_serial;}
  inline OCTETSTRING& refresh()
    {return field_refresh;}
  inline const OCTETSTRING& refresh() const
    {return field_refresh;}
  inline OCTETSTRING& retry()
    {return field_retry;}
  inline const OCTETSTRING& retry() const
    {return field_retry;}
  inline OCTETSTRING& expire()
    {return field_expire;}
  inline const OCTETSTRING& expire() const
    {return field_expire;}
  inline OCTETSTRING& minimum()
    {return field_minimum;}
  inline const OCTETSTRING& minimum() const
    {return field_minimum;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class RDataSOA_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RDataSOA_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RDataSOA& other_value);
void copy_template(const RDataSOA_template& other_value);

public:
RDataSOA_template();
RDataSOA_template(template_sel other_value);
RDataSOA_template(const RDataSOA& other_value);
RDataSOA_template(const OPTIONAL<RDataSOA>& other_value);
RDataSOA_template(const RDataSOA_template& other_value);
~RDataSOA_template();
RDataSOA_template& operator=(template_sel other_value);
RDataSOA_template& operator=(const RDataSOA& other_value);
RDataSOA_template& operator=(const OPTIONAL<RDataSOA>& other_value);
RDataSOA_template& operator=(const RDataSOA_template& other_value);
boolean match(const RDataSOA& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RDataSOA valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RDataSOA_template& list_item(unsigned int list_index) const;
CHARSTRING_template& mName();
const CHARSTRING_template& mName() const;
CHARSTRING_template& rName();
const CHARSTRING_template& rName() const;
OCTETSTRING_template& serial();
const OCTETSTRING_template& serial() const;
OCTETSTRING_template& refresh();
const OCTETSTRING_template& refresh() const;
OCTETSTRING_template& retry();
const OCTETSTRING_template& retry() const;
OCTETSTRING_template& expire();
const OCTETSTRING_template& expire() const;
OCTETSTRING_template& minimum();
const OCTETSTRING_template& minimum() const;
int size_of() const;
void log() const;
void log_match(const RDataSOA& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class RDataWKS {
  OCTETSTRING field_addr;
  INTEGER field_protocol;
  OCTETSTRING field_bitmap;
  boolean bound_flag;
public:
  RDataWKS();
  RDataWKS(const OCTETSTRING& par_addr,
    const INTEGER& par_protocol,
    const OCTETSTRING& par_bitmap);
  RDataWKS(const RDataWKS& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RDataWKS& operator=(const RDataWKS& other_value);
  boolean operator==(const RDataWKS& other_value) const;
  inline boolean operator!=(const RDataWKS& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& addr()
    {return field_addr;}
  inline const OCTETSTRING& addr() const
    {return field_addr;}
  inline INTEGER& protocol()
    {return field_protocol;}
  inline const INTEGER& protocol() const
    {return field_protocol;}
  inline OCTETSTRING& bitmap()
    {return field_bitmap;}
  inline const OCTETSTRING& bitmap() const
    {return field_bitmap;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class RDataWKS_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RDataWKS_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RDataWKS& other_value);
void copy_template(const RDataWKS_template& other_value);

public:
RDataWKS_template();
RDataWKS_template(template_sel other_value);
RDataWKS_template(const RDataWKS& other_value);
RDataWKS_template(const OPTIONAL<RDataWKS>& other_value);
RDataWKS_template(const RDataWKS_template& other_value);
~RDataWKS_template();
RDataWKS_template& operator=(template_sel other_value);
RDataWKS_template& operator=(const RDataWKS& other_value);
RDataWKS_template& operator=(const OPTIONAL<RDataWKS>& other_value);
RDataWKS_template& operator=(const RDataWKS_template& other_value);
boolean match(const RDataWKS& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RDataWKS valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RDataWKS_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& addr();
const OCTETSTRING_template& addr() const;
INTEGER_template& protocol();
const INTEGER_template& protocol() const;
OCTETSTRING_template& bitmap();
const OCTETSTRING_template& bitmap() const;
int size_of() const;
void log() const;
void log_match(const RDataWKS& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class RDataSRV {
  INTEGER field_priority;
  INTEGER field_weight;
  INTEGER field_portnum;
  CHARSTRING field_target;
  boolean bound_flag;
public:
  RDataSRV();
  RDataSRV(const INTEGER& par_priority,
    const INTEGER& par_weight,
    const INTEGER& par_portnum,
    const CHARSTRING& par_target);
  RDataSRV(const RDataSRV& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RDataSRV& operator=(const RDataSRV& other_value);
  boolean operator==(const RDataSRV& other_value) const;
  inline boolean operator!=(const RDataSRV& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& priority()
    {return field_priority;}
  inline const INTEGER& priority() const
    {return field_priority;}
  inline INTEGER& weight()
    {return field_weight;}
  inline const INTEGER& weight() const
    {return field_weight;}
  inline INTEGER& portnum()
    {return field_portnum;}
  inline const INTEGER& portnum() const
    {return field_portnum;}
  inline CHARSTRING& target()
    {return field_target;}
  inline const CHARSTRING& target() const
    {return field_target;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class RDataSRV_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RDataSRV_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RDataSRV& other_value);
void copy_template(const RDataSRV_template& other_value);

public:
RDataSRV_template();
RDataSRV_template(template_sel other_value);
RDataSRV_template(const RDataSRV& other_value);
RDataSRV_template(const OPTIONAL<RDataSRV>& other_value);
RDataSRV_template(const RDataSRV_template& other_value);
~RDataSRV_template();
RDataSRV_template& operator=(template_sel other_value);
RDataSRV_template& operator=(const RDataSRV& other_value);
RDataSRV_template& operator=(const OPTIONAL<RDataSRV>& other_value);
RDataSRV_template& operator=(const RDataSRV_template& other_value);
boolean match(const RDataSRV& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RDataSRV valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RDataSRV_template& list_item(unsigned int list_index) const;
INTEGER_template& priority();
const INTEGER_template& priority() const;
INTEGER_template& weight();
const INTEGER_template& weight() const;
INTEGER_template& portnum();
const INTEGER_template& portnum() const;
CHARSTRING_template& target();
const CHARSTRING_template& target() const;
int size_of() const;
void log() const;
void log_match(const RDataSRV& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class RDataNAPTR {
  INTEGER field_order;
  INTEGER field_preference;
  CHARSTRING field_flags;
  CHARSTRING field_services;
  CHARSTRING field_regexpString;
  CHARSTRING field_replacement;
  boolean bound_flag;
public:
  RDataNAPTR();
  RDataNAPTR(const INTEGER& par_order,
    const INTEGER& par_preference,
    const CHARSTRING& par_flags,
    const CHARSTRING& par_services,
    const CHARSTRING& par_regexpString,
    const CHARSTRING& par_replacement);
  RDataNAPTR(const RDataNAPTR& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RDataNAPTR& operator=(const RDataNAPTR& other_value);
  boolean operator==(const RDataNAPTR& other_value) const;
  inline boolean operator!=(const RDataNAPTR& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& order()
    {return field_order;}
  inline const INTEGER& order() const
    {return field_order;}
  inline INTEGER& preference()
    {return field_preference;}
  inline const INTEGER& preference() const
    {return field_preference;}
  inline CHARSTRING& flags()
    {return field_flags;}
  inline const CHARSTRING& flags() const
    {return field_flags;}
  inline CHARSTRING& services()
    {return field_services;}
  inline const CHARSTRING& services() const
    {return field_services;}
  inline CHARSTRING& regexpString()
    {return field_regexpString;}
  inline const CHARSTRING& regexpString() const
    {return field_regexpString;}
  inline CHARSTRING& replacement()
    {return field_replacement;}
  inline const CHARSTRING& replacement() const
    {return field_replacement;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class RDataNAPTR_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RDataNAPTR_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RDataNAPTR& other_value);
void copy_template(const RDataNAPTR_template& other_value);

public:
RDataNAPTR_template();
RDataNAPTR_template(template_sel other_value);
RDataNAPTR_template(const RDataNAPTR& other_value);
RDataNAPTR_template(const OPTIONAL<RDataNAPTR>& other_value);
RDataNAPTR_template(const RDataNAPTR_template& other_value);
~RDataNAPTR_template();
RDataNAPTR_template& operator=(template_sel other_value);
RDataNAPTR_template& operator=(const RDataNAPTR& other_value);
RDataNAPTR_template& operator=(const OPTIONAL<RDataNAPTR>& other_value);
RDataNAPTR_template& operator=(const RDataNAPTR_template& other_value);
boolean match(const RDataNAPTR& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RDataNAPTR valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RDataNAPTR_template& list_item(unsigned int list_index) const;
INTEGER_template& order();
const INTEGER_template& order() const;
INTEGER_template& preference();
const INTEGER_template& preference() const;
CHARSTRING_template& flags();
const CHARSTRING_template& flags() const;
CHARSTRING_template& services();
const CHARSTRING_template& services() const;
CHARSTRING_template& regexpString();
const CHARSTRING_template& regexpString() const;
CHARSTRING_template& replacement();
const CHARSTRING_template& replacement() const;
int size_of() const;
void log() const;
void log_match(const RDataNAPTR& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class ResourceRecord {
  CHARSTRING field_name;
  INTEGER field_rrType;
  INTEGER field_rrClass;
  OCTETSTRING field_ttl;
  INTEGER field_rdLength;
  ResourceData field_rData;
  boolean bound_flag;
public:
  ResourceRecord();
  ResourceRecord(const CHARSTRING& par_name,
    const INTEGER& par_rrType,
    const INTEGER& par_rrClass,
    const OCTETSTRING& par_ttl,
    const INTEGER& par_rdLength,
    const ResourceData& par_rData);
  ResourceRecord(const ResourceRecord& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ResourceRecord& operator=(const ResourceRecord& other_value);
  boolean operator==(const ResourceRecord& other_value) const;
  inline boolean operator!=(const ResourceRecord& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline INTEGER& rrType()
    {return field_rrType;}
  inline const INTEGER& rrType() const
    {return field_rrType;}
  inline INTEGER& rrClass()
    {return field_rrClass;}
  inline const INTEGER& rrClass() const
    {return field_rrClass;}
  inline OCTETSTRING& ttl()
    {return field_ttl;}
  inline const OCTETSTRING& ttl() const
    {return field_ttl;}
  inline INTEGER& rdLength()
    {return field_rdLength;}
  inline const INTEGER& rdLength() const
    {return field_rdLength;}
  inline ResourceData& rData()
    {return field_rData;}
  inline const ResourceData& rData() const
    {return field_rData;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ResourceRecord_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ResourceRecord_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ResourceRecord& other_value);
void copy_template(const ResourceRecord_template& other_value);

public:
ResourceRecord_template();
ResourceRecord_template(template_sel other_value);
ResourceRecord_template(const ResourceRecord& other_value);
ResourceRecord_template(const OPTIONAL<ResourceRecord>& other_value);
ResourceRecord_template(const ResourceRecord_template& other_value);
~ResourceRecord_template();
ResourceRecord_template& operator=(template_sel other_value);
ResourceRecord_template& operator=(const ResourceRecord& other_value);
ResourceRecord_template& operator=(const OPTIONAL<ResourceRecord>& other_value);
ResourceRecord_template& operator=(const ResourceRecord_template& other_value);
boolean match(const ResourceRecord& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ResourceRecord valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ResourceRecord_template& list_item(unsigned int list_index) const;
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
INTEGER_template& rrType();
const INTEGER_template& rrType() const;
INTEGER_template& rrClass();
const INTEGER_template& rrClass() const;
OCTETSTRING_template& ttl();
const OCTETSTRING_template& ttl() const;
INTEGER_template& rdLength();
const INTEGER_template& rdLength() const;
ResourceData_template& rData();
const ResourceData_template& rData() const;
int size_of() const;
void log() const;
void log_match(const ResourceRecord& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};

class PDU__DNS {
  DnsHeader field_header;
  QResourceRecords field_queries;
  ResourceRecords field_answers;
  ResourceRecords field_nameServerRecords;
  ResourceRecords field_additionalRecords;
  boolean bound_flag;
public:
  PDU__DNS();
  PDU__DNS(const DnsHeader& par_header,
    const QResourceRecords& par_queries,
    const ResourceRecords& par_answers,
    const ResourceRecords& par_nameServerRecords,
    const ResourceRecords& par_additionalRecords);
  PDU__DNS(const PDU__DNS& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  PDU__DNS& operator=(const PDU__DNS& other_value);
  boolean operator==(const PDU__DNS& other_value) const;
  inline boolean operator!=(const PDU__DNS& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline DnsHeader& header()
    {return field_header;}
  inline const DnsHeader& header() const
    {return field_header;}
  inline QResourceRecords& queries()
    {return field_queries;}
  inline const QResourceRecords& queries() const
    {return field_queries;}
  inline ResourceRecords& answers()
    {return field_answers;}
  inline const ResourceRecords& answers() const
    {return field_answers;}
  inline ResourceRecords& nameServerRecords()
    {return field_nameServerRecords;}
  inline const ResourceRecords& nameServerRecords() const
    {return field_nameServerRecords;}
  inline ResourceRecords& additionalRecords()
    {return field_additionalRecords;}
  inline const ResourceRecords& additionalRecords() const
    {return field_additionalRecords;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class PDU__DNS_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
PDU__DNS_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const PDU__DNS& other_value);
void copy_template(const PDU__DNS_template& other_value);

public:
PDU__DNS_template();
PDU__DNS_template(template_sel other_value);
PDU__DNS_template(const PDU__DNS& other_value);
PDU__DNS_template(const OPTIONAL<PDU__DNS>& other_value);
PDU__DNS_template(const PDU__DNS_template& other_value);
~PDU__DNS_template();
PDU__DNS_template& operator=(template_sel other_value);
PDU__DNS_template& operator=(const PDU__DNS& other_value);
PDU__DNS_template& operator=(const OPTIONAL<PDU__DNS>& other_value);
PDU__DNS_template& operator=(const PDU__DNS_template& other_value);
boolean match(const PDU__DNS& other_value) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
PDU__DNS valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PDU__DNS_template& list_item(unsigned int list_index) const;
DnsHeader_template& header();
const DnsHeader_template& header() const;
QResourceRecords_template& queries();
const QResourceRecords_template& queries() const;
ResourceRecords_template& answers();
const ResourceRecords_template& answers() const;
ResourceRecords_template& nameServerRecords();
const ResourceRecords_template& nameServerRecords() const;
ResourceRecords_template& additionalRecords();
const ResourceRecords_template& additionalRecords() const;
int size_of() const;
void log() const;
void log_match(const PDU__DNS& match_value) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL) const;
boolean is_present() const;
boolean match_omit() const;
};


/* Function prototypes */

extern OCTETSTRING enc__PDU__DNS(const PDU__DNS& msg, const BOOLEAN& doCompression, const BOOLEAN& autoLengthCalc);
extern PDU__DNS dec__PDU__DNS(const OCTETSTRING& stream);
extern boolean operator==(null_type null_value, const QResourceRecords& other_value);
inline boolean operator!=(null_type null_value, const QResourceRecords& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ResourceRecords& other_value);
inline boolean operator!=(null_type null_value, const ResourceRecords& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const XERdescriptor_t UInt16_xer_;
extern const TTCN_Typedescriptor_t UInt16_descr_;
extern const XERdescriptor_t DnsHeader_id_xer_;
extern const TTCN_Typedescriptor_t DnsHeader_id_descr_;
extern const TTCN_Typedescriptor_t QueryOrResponse_descr_;
extern const XERdescriptor_t OpCode_xer_;
extern const TTCN_Typedescriptor_t OpCode_descr_;
extern const XERdescriptor_t DnsHeader_opCode_xer_;
extern const TTCN_Typedescriptor_t DnsHeader_opCode_descr_;
extern const XERdescriptor_t DnsHeader_aa_xer_;
extern const TTCN_Typedescriptor_t DnsHeader_aa_descr_;
extern const XERdescriptor_t DnsHeader_tc_xer_;
extern const TTCN_Typedescriptor_t DnsHeader_tc_descr_;
extern const XERdescriptor_t DnsHeader_rd_xer_;
extern const TTCN_Typedescriptor_t DnsHeader_rd_descr_;
extern const XERdescriptor_t DnsHeader_ra_xer_;
extern const TTCN_Typedescriptor_t DnsHeader_ra_descr_;
extern const TTCN_RAWdescriptor_t DnsHeader_z_raw_;
extern const XERdescriptor_t DnsHeader_z_xer_;
extern const TTCN_Typedescriptor_t DnsHeader_z_descr_;
extern const XERdescriptor_t ResponseCode_xer_;
extern const TTCN_Typedescriptor_t ResponseCode_descr_;
extern const XERdescriptor_t DnsHeader_rCode_xer_;
extern const TTCN_Typedescriptor_t DnsHeader_rCode_descr_;
extern const XERdescriptor_t DnsHeader_qdCount_xer_;
extern const TTCN_Typedescriptor_t DnsHeader_qdCount_descr_;
extern const XERdescriptor_t DnsHeader_anCount_xer_;
extern const TTCN_Typedescriptor_t DnsHeader_anCount_descr_;
extern const XERdescriptor_t DnsHeader_nsCount_xer_;
extern const TTCN_Typedescriptor_t DnsHeader_nsCount_descr_;
extern const XERdescriptor_t DnsHeader_arCount_xer_;
extern const TTCN_Typedescriptor_t DnsHeader_arCount_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_descr_;
extern const TTCN_Typedescriptor_t QResourceRecords_descr_;
extern const XERdescriptor_t CharStr255_xer_;
extern const TTCN_Typedescriptor_t CharStr255_descr_;
extern const XERdescriptor_t DomainName_xer_;
extern const TTCN_Typedescriptor_t DomainName_descr_;
extern const XERdescriptor_t QResourceRecord_qName_xer_;
extern const TTCN_Typedescriptor_t QResourceRecord_qName_descr_;
extern const XERdescriptor_t RRType_xer_;
extern const TTCN_Typedescriptor_t RRType_descr_;
extern const XERdescriptor_t QResourceRecord_qType_xer_;
extern const TTCN_Typedescriptor_t QResourceRecord_qType_descr_;
extern const XERdescriptor_t RRClass_xer_;
extern const TTCN_Typedescriptor_t RRClass_descr_;
extern const XERdescriptor_t QResourceRecord_qClass_xer_;
extern const TTCN_Typedescriptor_t QResourceRecord_qClass_descr_;
extern const TTCN_Typedescriptor_t QResourceRecord_descr_;
extern const TTCN_Typedescriptor_t ResourceRecords_descr_;
extern const XERdescriptor_t ResourceRecord_name_xer_;
extern const TTCN_Typedescriptor_t ResourceRecord_name_descr_;
extern const XERdescriptor_t ResourceRecord_rrType_xer_;
extern const TTCN_Typedescriptor_t ResourceRecord_rrType_descr_;
extern const XERdescriptor_t ResourceRecord_rrClass_xer_;
extern const TTCN_Typedescriptor_t ResourceRecord_rrClass_descr_;
extern const TTCN_RAWdescriptor_t UInt32_raw_;
extern const XERdescriptor_t UInt32_xer_;
extern const TTCN_Typedescriptor_t UInt32_descr_;
extern const XERdescriptor_t ResourceRecord_ttl_xer_;
extern const TTCN_Typedescriptor_t ResourceRecord_ttl_descr_;
extern const XERdescriptor_t ResourceRecord_rdLength_xer_;
extern const TTCN_Typedescriptor_t ResourceRecord_rdLength_descr_;
extern const TTCN_Typedescriptor_t ResourceData_descr_;
extern const XERdescriptor_t RDataCName_xer_;
extern const TTCN_Typedescriptor_t RDataCName_descr_;
extern const XERdescriptor_t ResourceData_cName_xer_;
extern const TTCN_Typedescriptor_t ResourceData_cName_descr_;
extern const XERdescriptor_t RDataHInfo_cpu_xer_;
extern const TTCN_Typedescriptor_t RDataHInfo_cpu_descr_;
extern const XERdescriptor_t RDataHInfo_os_xer_;
extern const TTCN_Typedescriptor_t RDataHInfo_os_descr_;
extern const TTCN_Typedescriptor_t RDataHInfo_descr_;
extern const XERdescriptor_t RDataMB_xer_;
extern const TTCN_Typedescriptor_t RDataMB_descr_;
extern const XERdescriptor_t ResourceData_mb_xer_;
extern const TTCN_Typedescriptor_t ResourceData_mb_descr_;
extern const XERdescriptor_t RDataMD_xer_;
extern const TTCN_Typedescriptor_t RDataMD_descr_;
extern const XERdescriptor_t ResourceData_md_xer_;
extern const TTCN_Typedescriptor_t ResourceData_md_descr_;
extern const XERdescriptor_t RDataMF_xer_;
extern const TTCN_Typedescriptor_t RDataMF_descr_;
extern const XERdescriptor_t ResourceData_mf_xer_;
extern const TTCN_Typedescriptor_t ResourceData_mf_descr_;
extern const XERdescriptor_t RDataMG_xer_;
extern const TTCN_Typedescriptor_t RDataMG_descr_;
extern const XERdescriptor_t ResourceData_mg_xer_;
extern const TTCN_Typedescriptor_t ResourceData_mg_descr_;
extern const XERdescriptor_t RDataMInfo_rMailBx_xer_;
extern const TTCN_Typedescriptor_t RDataMInfo_rMailBx_descr_;
extern const XERdescriptor_t RDataMInfo_eMailBx_xer_;
extern const TTCN_Typedescriptor_t RDataMInfo_eMailBx_descr_;
extern const TTCN_Typedescriptor_t RDataMInfo_descr_;
extern const XERdescriptor_t RDataMR_xer_;
extern const TTCN_Typedescriptor_t RDataMR_descr_;
extern const XERdescriptor_t ResourceData_mr_xer_;
extern const TTCN_Typedescriptor_t ResourceData_mr_descr_;
extern const XERdescriptor_t RDataMX_preference_xer_;
extern const TTCN_Typedescriptor_t RDataMX_preference_descr_;
extern const XERdescriptor_t RDataMX_exchange_xer_;
extern const TTCN_Typedescriptor_t RDataMX_exchange_descr_;
extern const TTCN_Typedescriptor_t RDataMX_descr_;
extern const XERdescriptor_t RDataNull_xer_;
extern const TTCN_Typedescriptor_t RDataNull_descr_;
extern const XERdescriptor_t ResourceData_rd__null_xer_;
extern const TTCN_Typedescriptor_t ResourceData_rd__null_descr_;
extern const XERdescriptor_t RDataNS_xer_;
extern const TTCN_Typedescriptor_t RDataNS_descr_;
extern const XERdescriptor_t ResourceData_ns_xer_;
extern const TTCN_Typedescriptor_t ResourceData_ns_descr_;
extern const XERdescriptor_t RDataPTR_xer_;
extern const TTCN_Typedescriptor_t RDataPTR_descr_;
extern const XERdescriptor_t ResourceData_ptr_xer_;
extern const TTCN_Typedescriptor_t ResourceData_ptr_descr_;
extern const XERdescriptor_t RDataSOA_mName_xer_;
extern const TTCN_Typedescriptor_t RDataSOA_mName_descr_;
extern const XERdescriptor_t RDataSOA_rName_xer_;
extern const TTCN_Typedescriptor_t RDataSOA_rName_descr_;
extern const XERdescriptor_t RDataSOA_serial_xer_;
extern const TTCN_Typedescriptor_t RDataSOA_serial_descr_;
extern const XERdescriptor_t RDataSOA_refresh_xer_;
extern const TTCN_Typedescriptor_t RDataSOA_refresh_descr_;
extern const XERdescriptor_t RDataSOA_retry_xer_;
extern const TTCN_Typedescriptor_t RDataSOA_retry_descr_;
extern const XERdescriptor_t RDataSOA_expire_xer_;
extern const TTCN_Typedescriptor_t RDataSOA_expire_descr_;
extern const XERdescriptor_t RDataSOA_minimum_xer_;
extern const TTCN_Typedescriptor_t RDataSOA_minimum_descr_;
extern const TTCN_Typedescriptor_t RDataSOA_descr_;
extern const TTCN_Typedescriptor_t RDataTXT_descr_;
extern const XERdescriptor_t RDataTXT_0_xer_;
extern const TTCN_Typedescriptor_t RDataTXT_0_descr_;
extern const XERdescriptor_t RDataA_xer_;
extern const TTCN_Typedescriptor_t RDataA_descr_;
extern const XERdescriptor_t ResourceData_a_xer_;
extern const TTCN_Typedescriptor_t ResourceData_a_descr_;
extern const XERdescriptor_t RDataWKS_addr_xer_;
extern const TTCN_Typedescriptor_t RDataWKS_addr_descr_;
extern const XERdescriptor_t UInt8_xer_;
extern const TTCN_Typedescriptor_t UInt8_descr_;
extern const XERdescriptor_t RDataWKS_protocol_xer_;
extern const TTCN_Typedescriptor_t RDataWKS_protocol_descr_;
extern const XERdescriptor_t RDataWKS_bitmap_xer_;
extern const TTCN_Typedescriptor_t RDataWKS_bitmap_descr_;
extern const TTCN_Typedescriptor_t RDataWKS_descr_;
extern const XERdescriptor_t RDataSRV_priority_xer_;
extern const TTCN_Typedescriptor_t RDataSRV_priority_descr_;
extern const XERdescriptor_t RDataSRV_weight_xer_;
extern const TTCN_Typedescriptor_t RDataSRV_weight_descr_;
extern const XERdescriptor_t RDataSRV_portnum_xer_;
extern const TTCN_Typedescriptor_t RDataSRV_portnum_descr_;
extern const XERdescriptor_t RDataSRV_target_xer_;
extern const TTCN_Typedescriptor_t RDataSRV_target_descr_;
extern const TTCN_Typedescriptor_t RDataSRV_descr_;
extern const XERdescriptor_t RDataNAPTR_order_xer_;
extern const TTCN_Typedescriptor_t RDataNAPTR_order_descr_;
extern const XERdescriptor_t RDataNAPTR_preference_xer_;
extern const TTCN_Typedescriptor_t RDataNAPTR_preference_descr_;
extern const XERdescriptor_t RDataNAPTR_flags_xer_;
extern const TTCN_Typedescriptor_t RDataNAPTR_flags_descr_;
extern const XERdescriptor_t RDataNAPTR_services_xer_;
extern const TTCN_Typedescriptor_t RDataNAPTR_services_descr_;
extern const XERdescriptor_t RDataNAPTR_regexpString_xer_;
extern const TTCN_Typedescriptor_t RDataNAPTR_regexpString_descr_;
extern const XERdescriptor_t RDataNAPTR_replacement_xer_;
extern const TTCN_Typedescriptor_t RDataNAPTR_replacement_descr_;
extern const TTCN_Typedescriptor_t RDataNAPTR_descr_;
extern const TTCN_RAWdescriptor_t RDataAAAA_raw_;
extern const XERdescriptor_t RDataAAAA_xer_;
extern const TTCN_Typedescriptor_t RDataAAAA_descr_;
extern const XERdescriptor_t ResourceData_aaaa_xer_;
extern const TTCN_Typedescriptor_t ResourceData_aaaa_descr_;
extern const XERdescriptor_t ResourceData_unsupported_xer_;
extern const TTCN_Typedescriptor_t ResourceData_unsupported_descr_;
extern const XERdescriptor_t ResourceData_undecodable_xer_;
extern const TTCN_Typedescriptor_t ResourceData_undecodable_descr_;
extern const TTCN_Typedescriptor_t ResourceRecord_descr_;
extern const TTCN_Typedescriptor_t PDU__DNS_descr_;
extern const INTEGER& DNS__OP__QUERY;
extern const INTEGER& DNS__OP__IQUERY;
extern const INTEGER& DNS__OP__STATUS;
extern const INTEGER& DNS__OP__UPDATE;
extern const INTEGER& DNS__NO__ERROR;
extern const INTEGER& DNS__FORMAT__ERROR;
extern const INTEGER& DNS__SERVER__FAILURE;
extern const INTEGER& DNS__NAME__ERROR;
extern const INTEGER& DNS__NOT__IMPLEMENTED;
extern const INTEGER& DNS__REFUSED;
extern const INTEGER& DNS__YXDOMAIN;
extern const INTEGER& DNS__YXRRSET;
extern const INTEGER& DNS__NXRRSET;
extern const INTEGER& DNS__NOTAUTH;
extern const INTEGER& DNS__NOTZONE;
extern const INTEGER& DNS__A;
extern const INTEGER& DNS__NS;
extern const INTEGER& DNS__MD;
extern const INTEGER& DNS__MF;
extern const INTEGER& DNS__CNAME;
extern const INTEGER& DNS__SOA;
extern const INTEGER& DNS__MB;
extern const INTEGER& DNS__MG;
extern const INTEGER& DNS__MR;
extern const INTEGER& DNS__NULL;
extern const INTEGER& DNS__WKS;
extern const INTEGER& DNS__PTR;
extern const INTEGER& DNS__HINFO;
extern const INTEGER& DNS__MINFO;
extern const INTEGER& DNS__MX;
extern const INTEGER& DNS__TXT;
extern const INTEGER& DNS__AAAA;
extern const INTEGER& DNS__SRV;
extern const INTEGER& DNS__NAPTR;
extern const INTEGER& DNS__AXFR;
extern const INTEGER& DNS__MAILB;
extern const INTEGER& DNS__MAILA;
extern const INTEGER& DNS__ALLRECORDS;
extern const INTEGER& DNS__IN;
extern const INTEGER& DNS__CS;
extern const INTEGER& DNS__CH;
extern const INTEGER& DNS__HS;
extern const INTEGER& DNS__ANYCLASS;
extern const INTEGER& DNS__NONE;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
