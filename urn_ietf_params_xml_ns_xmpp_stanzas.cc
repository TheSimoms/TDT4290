// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for user (user@user-multicom) on Wed Sep 16 13:14:39 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "urn_ietf_params_xml_ns_xmpp_stanzas.hh"

namespace urn__ietf__params__xml__ns__xmpp__stanzas {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const unsigned char module_checksum[] = { 0xc9, 0x80, 0xb9, 0x32, 0x14, 0xaf, 0x6e, 0x6d, 0x39, 0xc5, 0x9d, 0x28, 0xca, 0x41, 0x8a, 0x85 };

/* Global variable definitions */

const XERdescriptor_t       Empty_xer_ = { {"Empty>\n", "empty>\n"}, {7, 7}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_JSONdescriptor_t Empty_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t Empty_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Empty", NULL, NULL, NULL, &Empty_xer_, &Empty_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Bad__request_xer_ = { {"Bad_request>\n", "bad-request>\n"}, {13, 13}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Bad__request_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Bad_request", NULL, NULL, NULL, &Bad__request_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Conflict_xer_ = { {"Conflict>\n", "conflict>\n"}, {10, 10}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Conflict_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Conflict", NULL, NULL, NULL, &Conflict_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Feature__not__implemented_xer_ = { {"Feature_not_implemented>\n", "feature-not-implemented>\n"}, {25, 25}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Feature__not__implemented_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Feature_not_implemented", NULL, NULL, NULL, &Feature__not__implemented_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Forbidden_xer_ = { {"Forbidden>\n", "forbidden>\n"}, {11, 11}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Forbidden_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Forbidden", NULL, NULL, NULL, &Forbidden_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Gone_xer_ = { {"Gone>\n", "gone>\n"}, {6, 6}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Gone_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Gone", NULL, &UsefulTtcn3Types::utf8string_raw_, &UNIVERSAL_CHARSTRING_text_, &Gone_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Internal__server__error_xer_ = { {"Internal_server_error>\n", "internal-server-error>\n"}, {23, 23}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Internal__server__error_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Internal_server_error", NULL, NULL, NULL, &Internal__server__error_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Item__not__found_xer_ = { {"Item_not_found>\n", "item-not-found>\n"}, {16, 16}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Item__not__found_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Item_not_found", NULL, NULL, NULL, &Item__not__found_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Jid__malformed_xer_ = { {"Jid_malformed>\n", "jid-malformed>\n"}, {15, 15}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Jid__malformed_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Jid_malformed", NULL, NULL, NULL, &Jid__malformed_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Not__acceptable_xer_ = { {"Not_acceptable>\n", "not-acceptable>\n"}, {16, 16}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Not__acceptable_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Not_acceptable", NULL, NULL, NULL, &Not__acceptable_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Not__allowed_xer_ = { {"Not_allowed>\n", "not-allowed>\n"}, {13, 13}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Not__allowed_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Not_allowed", NULL, NULL, NULL, &Not__allowed_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Not__authorized_xer_ = { {"Not_authorized>\n", "not-authorized>\n"}, {16, 16}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Not__authorized_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Not_authorized", NULL, NULL, NULL, &Not__authorized_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Payment__required_xer_ = { {"Payment_required>\n", "payment-required>\n"}, {18, 18}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Payment__required_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Payment_required", NULL, NULL, NULL, &Payment__required_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Policy__violation_xer_ = { {"Policy_violation>\n", "policy-violation>\n"}, {18, 18}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Policy__violation_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Policy_violation", NULL, NULL, NULL, &Policy__violation_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Recipient__unavailable_xer_ = { {"Recipient_unavailable>\n", "recipient-unavailable>\n"}, {23, 23}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Recipient__unavailable_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Recipient_unavailable", NULL, NULL, NULL, &Recipient__unavailable_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Redirect_xer_ = { {"Redirect>\n", "redirect>\n"}, {10, 10}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Redirect_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Redirect", NULL, &UsefulTtcn3Types::utf8string_raw_, &UNIVERSAL_CHARSTRING_text_, &Redirect_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Registration__required_xer_ = { {"Registration_required>\n", "registration-required>\n"}, {23, 23}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Registration__required_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Registration_required", NULL, NULL, NULL, &Registration__required_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Remote__server__not__found_xer_ = { {"Remote_server_not_found>\n", "remote-server-not-found>\n"}, {25, 25}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Remote__server__not__found_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Remote_server_not_found", NULL, NULL, NULL, &Remote__server__not__found_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Remote__server__timeout_xer_ = { {"Remote_server_timeout>\n", "remote-server-timeout>\n"}, {23, 23}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Remote__server__timeout_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Remote_server_timeout", NULL, NULL, NULL, &Remote__server__timeout_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Resource__constraint_xer_ = { {"Resource_constraint>\n", "resource-constraint>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Resource__constraint_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Resource_constraint", NULL, NULL, NULL, &Resource__constraint_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Service__unavailable_xer_ = { {"Service_unavailable>\n", "service-unavailable>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Service__unavailable_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Service_unavailable", NULL, NULL, NULL, &Service__unavailable_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Subscription__required_xer_ = { {"Subscription_required>\n", "subscription-required>\n"}, {23, 23}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Subscription__required_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Subscription_required", NULL, NULL, NULL, &Subscription__required_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Undefined__condition_xer_ = { {"Undefined_condition>\n", "undefined-condition>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Undefined__condition_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Undefined_condition", NULL, NULL, NULL, &Undefined__condition_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Unexpected__request_xer_ = { {"Unexpected_request>\n", "unexpected-request>\n"}, {20, 20}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Unexpected__request_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Unexpected_request", NULL, NULL, NULL, &Unexpected__request_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_xer_ = { {"StanzaErrorGroup>\n", "StanzaErrorGroup>\n"}, {18, 18}, 0 |UNTAGGED, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_JSONdescriptor_t StanzaErrorGroup_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup", NULL, NULL, NULL, &StanzaErrorGroup_xer_, &StanzaErrorGroup_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_bad__request_xer_ = { {"bad_request>\n", "bad-request>\n"}, {13, 13}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_bad__request_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.bad_request", NULL, NULL, NULL, &StanzaErrorGroup_bad__request_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_conflict_xer_ = { {"conflict>\n", "conflict>\n"}, {10, 10}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_conflict_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.conflict", NULL, NULL, NULL, &StanzaErrorGroup_conflict_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_feature__not__implemented_xer_ = { {"feature_not_implemented>\n", "feature-not-implemented>\n"}, {25, 25}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_feature__not__implemented_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.feature_not_implemented", NULL, NULL, NULL, &StanzaErrorGroup_feature__not__implemented_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_forbidden_xer_ = { {"forbidden>\n", "forbidden>\n"}, {11, 11}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_forbidden_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.forbidden", NULL, NULL, NULL, &StanzaErrorGroup_forbidden_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_gone_xer_ = { {"gone>\n", "gone>\n"}, {6, 6}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_gone_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.gone", NULL, &UsefulTtcn3Types::utf8string_raw_, &UNIVERSAL_CHARSTRING_text_, &StanzaErrorGroup_gone_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_internal__server__error_xer_ = { {"internal_server_error>\n", "internal-server-error>\n"}, {23, 23}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_internal__server__error_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.internal_server_error", NULL, NULL, NULL, &StanzaErrorGroup_internal__server__error_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_item__not__found_xer_ = { {"item_not_found>\n", "item-not-found>\n"}, {16, 16}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_item__not__found_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.item_not_found", NULL, NULL, NULL, &StanzaErrorGroup_item__not__found_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_jid__malformed_xer_ = { {"jid_malformed>\n", "jid-malformed>\n"}, {15, 15}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_jid__malformed_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.jid_malformed", NULL, NULL, NULL, &StanzaErrorGroup_jid__malformed_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_not__acceptable_xer_ = { {"not_acceptable>\n", "not-acceptable>\n"}, {16, 16}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_not__acceptable_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.not_acceptable", NULL, NULL, NULL, &StanzaErrorGroup_not__acceptable_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_not__authorized_xer_ = { {"not_authorized>\n", "not-authorized>\n"}, {16, 16}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_not__authorized_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.not_authorized", NULL, NULL, NULL, &StanzaErrorGroup_not__authorized_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_not__allowed_xer_ = { {"not_allowed>\n", "not-allowed>\n"}, {13, 13}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_not__allowed_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.not_allowed", NULL, NULL, NULL, &StanzaErrorGroup_not__allowed_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_payment__required_xer_ = { {"payment_required>\n", "payment-required>\n"}, {18, 18}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_payment__required_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.payment_required", NULL, NULL, NULL, &StanzaErrorGroup_payment__required_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_policy__violation_xer_ = { {"policy_violation>\n", "policy-violation>\n"}, {18, 18}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_policy__violation_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.policy_violation", NULL, NULL, NULL, &StanzaErrorGroup_policy__violation_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_recipient__unavailable_xer_ = { {"recipient_unavailable>\n", "recipient-unavailable>\n"}, {23, 23}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_recipient__unavailable_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.recipient_unavailable", NULL, NULL, NULL, &StanzaErrorGroup_recipient__unavailable_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_redirect_xer_ = { {"redirect>\n", "redirect>\n"}, {10, 10}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_redirect_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.redirect", NULL, &UsefulTtcn3Types::utf8string_raw_, &UNIVERSAL_CHARSTRING_text_, &StanzaErrorGroup_redirect_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_registration__required_xer_ = { {"registration_required>\n", "registration-required>\n"}, {23, 23}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_registration__required_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.registration_required", NULL, NULL, NULL, &StanzaErrorGroup_registration__required_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_remote__server__not__found_xer_ = { {"remote_server_not_found>\n", "remote-server-not-found>\n"}, {25, 25}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_remote__server__not__found_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.remote_server_not_found", NULL, NULL, NULL, &StanzaErrorGroup_remote__server__not__found_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_remote__server__timeout_xer_ = { {"remote_server_timeout>\n", "remote-server-timeout>\n"}, {23, 23}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_remote__server__timeout_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.remote_server_timeout", NULL, NULL, NULL, &StanzaErrorGroup_remote__server__timeout_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_resource__constraint_xer_ = { {"resource_constraint>\n", "resource-constraint>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_resource__constraint_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.resource_constraint", NULL, NULL, NULL, &StanzaErrorGroup_resource__constraint_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_service__unavailable_xer_ = { {"service_unavailable>\n", "service-unavailable>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_service__unavailable_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.service_unavailable", NULL, NULL, NULL, &StanzaErrorGroup_service__unavailable_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_subscription__required_xer_ = { {"subscription_required>\n", "subscription-required>\n"}, {23, 23}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_subscription__required_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.subscription_required", NULL, NULL, NULL, &StanzaErrorGroup_subscription__required_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_undefined__condition_xer_ = { {"undefined_condition>\n", "undefined-condition>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_undefined__condition_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.undefined_condition", NULL, NULL, NULL, &StanzaErrorGroup_undefined__condition_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StanzaErrorGroup_unexpected__request_xer_ = { {"unexpected_request>\n", "unexpected-request>\n"}, {20, 20}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t StanzaErrorGroup_unexpected__request_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.unexpected_request", NULL, NULL, NULL, &StanzaErrorGroup_unexpected__request_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Text_base_xer_ = { {"base>\n", "base>\n"}, {6, 6}, 0 |UNTAGGED, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Text_base_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Text.base", NULL, &UsefulTtcn3Types::utf8string_raw_, &UNIVERSAL_CHARSTRING_text_, &Text_base_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Text_xer_ = { {"Text>\n", "text>\n"}, {6, 6}, 0 |HAS_1UNTAGGED, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_JSONdescriptor_t Text_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t Text_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Text", NULL, NULL, NULL, &Text_xer_, &Text_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Text_lang_xer_ = { {"lang>\n", "lang>\n"}, {6, 6}, 0 |XER_ATTRIBUTE, WHITESPACE_PRESERVE,  NULL, &module_object, 7, 0, NULL, NULL };
const TTCN_Typedescriptor_t Text_lang_descr_ = { "@urn_ietf_params_xml_ns_xmpp_stanzas.Text.lang", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Text_lang_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 21;
static const namespace_t xml_namespaces[num_namespaces+1] = {
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { "urn:ietf:params:xml:ns:xmpp-stanzas", "tq0004" },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { "http://www.w3.org/2001/XMLSchema-instance", "xsi" }
};

TTCN_Module module_object("urn_ietf_params_xml_ns_xmpp_stanzas", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 21LU, xml_namespaces, post_init_module, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_3,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

Empty::Empty()
{
enum_value = UNBOUND_VALUE;
}

Empty::Empty(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

Empty::Empty(enum_type other_value)
{
enum_value = other_value;
}

Empty::Empty(const Empty& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
enum_value = other_value.enum_value;
}

Empty& Empty::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

Empty& Empty::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

Empty& Empty::operator=(const Empty& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
enum_value = other_value.enum_value;
return *this;
}

boolean Empty::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
return enum_value == other_value;
}

boolean Empty::operator==(const Empty& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
return enum_value == other_value.enum_value;
}

boolean Empty::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
return enum_value < other_value;
}

boolean Empty::operator<(const Empty& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
return enum_value < other_value.enum_value;
}

boolean Empty::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
return enum_value > other_value;
}

boolean Empty::operator>(const Empty& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
return enum_value > other_value.enum_value;
}

const char *Empty::enum_to_str(enum_type enum_par, boolean txt)
{
switch (enum_par) {
case x: if (txt) return " "; else return "x";
default: return "<unknown>";
}
}

Empty::enum_type Empty::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, " ") || !strcmp(str_par, "x")) return x;
else return UNKNOWN_VALUE;
}

boolean Empty::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
return TRUE;
default:
return FALSE;
}
}

int Empty::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int Empty::enum2int(const Empty& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

Empty::operator Empty::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
return enum_value;
}

void Empty::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void Empty::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@urn_ietf_params_xml_ns_xmpp_stanzas.Empty");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
     param.error("Invalid enumerated value for type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
  }
}

void Empty::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
text_buf.push_int(enum_value);
}

void Empty::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.", enum_value);
}

void Empty::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Empty::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

boolean Empty::can_start(const char *name, const char *uri, const XERdescriptor_t& xd, unsigned int flavor) {
  boolean exer = is_exer(flavor);
  return check_name(name, xd, exer) && (!exer || check_namespace(uri, xd));
}

int Empty::XER_encode(const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const
{
  int encoded_length=(int)p_buf.get_len();
  const boolean e_xer = is_exer(p_flavor);
  p_flavor |= (SIMPLE_TYPE | BXER_EMPTY_ELEM);
  if (begin_xml(p_td, p_buf, p_flavor, p_indent, false) == -1) --encoded_length;
  if (!e_xer) p_buf.put_c('<');
  {
    const char * enumval = enum_to_str(enum_value, e_xer);
    p_buf.put_s(strlen(enumval), (const unsigned char*)enumval);
  }
  if (!e_xer) p_buf.put_s(2, (const unsigned char*)"/>");
  end_xml(p_td, p_buf, p_flavor, p_indent, false);
  return (int)p_buf.get_len() - encoded_length;
}

int Empty::XER_decode(const XERdescriptor_t& p_td, XmlReaderWrap& p_reader, unsigned int p_flavor, embed_values_dec_struct_t*)
{
  int rd_ok = 1, type;
  const int e_xer = is_exer(p_flavor);
  const boolean name_tag = !((!e_xer && is_record_of(p_flavor)) || (e_xer && ((p_td.xer_bits & UNTAGGED) ||(is_record_of(p_flavor) && is_exerlist(p_flavor)))));
  if (e_xer && ((p_td.xer_bits & XER_ATTRIBUTE) || is_exerlist(p_flavor))) {
    if ((p_td.xer_bits & XER_ATTRIBUTE)) verify_name(p_reader, p_td, e_xer);
    const char * value = (const char *)p_reader.Value();
    if (value) {
        enum_value = str_to_enum(value);
    }
  }
  else {
    if (name_tag)      for (; rd_ok == 1; rd_ok = p_reader.Read()) {
        type = p_reader.NodeType();
        if (XML_READER_TYPE_ELEMENT == type) {
          rd_ok = p_reader.Read();
          break;
        }
      }
    for (; rd_ok == 1; rd_ok = p_reader.Read()) {
      type = p_reader.NodeType();
      if (!e_xer && XML_READER_TYPE_ELEMENT == type) break;
      if (XML_READER_TYPE_TEXT == type) break;
    }
    const char *local_name = e_xer ? (const char *)p_reader.Value() : (const char *)p_reader.Name();
    if (!local_name) ; else    {
      for (; '\t'==*local_name || '\n'==*local_name; ++local_name) ;
      enum_value = str_to_enum(local_name);
    }
    if (name_tag)
      for (rd_ok = p_reader.Read(); rd_ok == 1; rd_ok = p_reader.Read()) {
        type = p_reader.NodeType();
        if (XML_READER_TYPE_END_ELEMENT == type) {
          rd_ok = p_reader.Read();
          break;
        }
      }
    else rd_ok = p_reader.Read();
  }
  if (e_xer && (p_flavor & EXIT_ON_ERROR) && UNKNOWN_VALUE == enum_value) clean_up();
  int decoded_length = 0;
  return decoded_length;
}

int Empty::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int Empty::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void Empty_template::copy_template(const Empty_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Empty_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
}
}

Empty_template::Empty_template()
{
}

Empty_template::Empty_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Empty_template::Empty_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!Empty::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty with unknown numeric value %d.", other_value);
single_value = (Empty::enum_type)other_value;
}

Empty_template::Empty_template(Empty::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

Empty_template::Empty_template(const Empty& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == Empty::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
single_value = other_value.enum_value;
}

Empty_template::Empty_template(const OPTIONAL<Empty>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (Empty::enum_type)(const Empty&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty from an unbound optional field.");
}
}

Empty_template::Empty_template(const Empty_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

Empty_template::~Empty_template()
{
clean_up();
}

boolean Empty_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean Empty_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != Empty::UNBOUND_VALUE;
}

void Empty_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

Empty_template& Empty_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Empty_template& Empty_template::operator=(int other_value)
{
if (!Empty::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (Empty::enum_type)other_value;
return *this;
}

Empty_template& Empty_template::operator=(Empty::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

Empty_template& Empty_template::operator=(const Empty& other_value)
{
if (other_value.enum_value == Empty::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

Empty_template& Empty_template::operator=(const OPTIONAL<Empty>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (Empty::enum_type)(const Empty&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
}
return *this;
}

Empty_template& Empty_template::operator=(const Empty_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Empty_template::match(Empty::enum_type other_value) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
}
return FALSE;
}

boolean Empty_template::match(const Empty& other_value) const
{
if (other_value.enum_value == Empty::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty with an unbound value.");
return match(other_value.enum_value);
}

Empty::enum_type Empty_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
return single_value;
}

void Empty_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Empty_template[list_length];
}

Empty_template& Empty_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
return value_list.list_value[list_index];
}

void Empty_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(Empty::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Empty_template::log_match(const Empty& match_value) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void Empty_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
}
}

void Empty_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (Empty::enum_type)text_buf.pull_int().get_val();
if (!Empty::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Empty_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
}
}

boolean Empty_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean Empty_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void Empty_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Enumerated: {
    Empty::enum_type enum_val = Empty::str_to_enum(param.get_enumerated());
    if (!Empty::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @urn_ietf_params_xml_ns_xmpp_stanzas.Empty.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@urn_ietf_params_xml_ns_xmpp_stanzas.Empty");
  }
  is_ifpresent = param.get_ifpresent();
}

void Empty_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.Empty");
}

void StanzaErrorGroup::copy_value(const StanzaErrorGroup& other_value)
{
switch (other_value.union_selection) {
case ALT_bad__request:
field_bad__request = new Empty(*other_value.field_bad__request);
break;
case ALT_conflict:
field_conflict = new Empty(*other_value.field_conflict);
break;
case ALT_feature__not__implemented:
field_feature__not__implemented = new Empty(*other_value.field_feature__not__implemented);
break;
case ALT_forbidden:
field_forbidden = new Empty(*other_value.field_forbidden);
break;
case ALT_gone:
field_gone = new UNIVERSAL_CHARSTRING(*other_value.field_gone);
break;
case ALT_internal__server__error:
field_internal__server__error = new Empty(*other_value.field_internal__server__error);
break;
case ALT_item__not__found:
field_item__not__found = new Empty(*other_value.field_item__not__found);
break;
case ALT_jid__malformed:
field_jid__malformed = new Empty(*other_value.field_jid__malformed);
break;
case ALT_not__acceptable:
field_not__acceptable = new Empty(*other_value.field_not__acceptable);
break;
case ALT_not__authorized:
field_not__authorized = new Empty(*other_value.field_not__authorized);
break;
case ALT_not__allowed:
field_not__allowed = new Empty(*other_value.field_not__allowed);
break;
case ALT_payment__required:
field_payment__required = new Empty(*other_value.field_payment__required);
break;
case ALT_policy__violation:
field_policy__violation = new Empty(*other_value.field_policy__violation);
break;
case ALT_recipient__unavailable:
field_recipient__unavailable = new Empty(*other_value.field_recipient__unavailable);
break;
case ALT_redirect:
field_redirect = new UNIVERSAL_CHARSTRING(*other_value.field_redirect);
break;
case ALT_registration__required:
field_registration__required = new Empty(*other_value.field_registration__required);
break;
case ALT_remote__server__not__found:
field_remote__server__not__found = new Empty(*other_value.field_remote__server__not__found);
break;
case ALT_remote__server__timeout:
field_remote__server__timeout = new Empty(*other_value.field_remote__server__timeout);
break;
case ALT_resource__constraint:
field_resource__constraint = new Empty(*other_value.field_resource__constraint);
break;
case ALT_service__unavailable:
field_service__unavailable = new Empty(*other_value.field_service__unavailable);
break;
case ALT_subscription__required:
field_subscription__required = new Empty(*other_value.field_subscription__required);
break;
case ALT_undefined__condition:
field_undefined__condition = new Empty(*other_value.field_undefined__condition);
break;
case ALT_unexpected__request:
field_unexpected__request = new Empty(*other_value.field_unexpected__request);
break;
default:
TTCN_error("Assignment of an unbound union value of type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
union_selection = other_value.union_selection;
}

StanzaErrorGroup::StanzaErrorGroup()
{
union_selection = UNBOUND_VALUE;
}

StanzaErrorGroup::StanzaErrorGroup(const StanzaErrorGroup& other_value)
: Base_Type(){
copy_value(other_value);
}

StanzaErrorGroup::~StanzaErrorGroup()
{
clean_up();
}

StanzaErrorGroup& StanzaErrorGroup::operator=(const StanzaErrorGroup& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean StanzaErrorGroup::operator==(const StanzaErrorGroup& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_bad__request:
return *field_bad__request == *other_value.field_bad__request;
case ALT_conflict:
return *field_conflict == *other_value.field_conflict;
case ALT_feature__not__implemented:
return *field_feature__not__implemented == *other_value.field_feature__not__implemented;
case ALT_forbidden:
return *field_forbidden == *other_value.field_forbidden;
case ALT_gone:
return *field_gone == *other_value.field_gone;
case ALT_internal__server__error:
return *field_internal__server__error == *other_value.field_internal__server__error;
case ALT_item__not__found:
return *field_item__not__found == *other_value.field_item__not__found;
case ALT_jid__malformed:
return *field_jid__malformed == *other_value.field_jid__malformed;
case ALT_not__acceptable:
return *field_not__acceptable == *other_value.field_not__acceptable;
case ALT_not__authorized:
return *field_not__authorized == *other_value.field_not__authorized;
case ALT_not__allowed:
return *field_not__allowed == *other_value.field_not__allowed;
case ALT_payment__required:
return *field_payment__required == *other_value.field_payment__required;
case ALT_policy__violation:
return *field_policy__violation == *other_value.field_policy__violation;
case ALT_recipient__unavailable:
return *field_recipient__unavailable == *other_value.field_recipient__unavailable;
case ALT_redirect:
return *field_redirect == *other_value.field_redirect;
case ALT_registration__required:
return *field_registration__required == *other_value.field_registration__required;
case ALT_remote__server__not__found:
return *field_remote__server__not__found == *other_value.field_remote__server__not__found;
case ALT_remote__server__timeout:
return *field_remote__server__timeout == *other_value.field_remote__server__timeout;
case ALT_resource__constraint:
return *field_resource__constraint == *other_value.field_resource__constraint;
case ALT_service__unavailable:
return *field_service__unavailable == *other_value.field_service__unavailable;
case ALT_subscription__required:
return *field_subscription__required == *other_value.field_subscription__required;
case ALT_undefined__condition:
return *field_undefined__condition == *other_value.field_undefined__condition;
case ALT_unexpected__request:
return *field_unexpected__request == *other_value.field_unexpected__request;
default:
return FALSE;
}
}

Empty& StanzaErrorGroup::bad__request()
{
if (union_selection != ALT_bad__request) {
clean_up();
field_bad__request = new Empty;
union_selection = ALT_bad__request;
}
return *field_bad__request;
}

const Empty& StanzaErrorGroup::bad__request() const
{
if (union_selection != ALT_bad__request) TTCN_error("Using non-selected field bad_request in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_bad__request;
}

Empty& StanzaErrorGroup::conflict()
{
if (union_selection != ALT_conflict) {
clean_up();
field_conflict = new Empty;
union_selection = ALT_conflict;
}
return *field_conflict;
}

const Empty& StanzaErrorGroup::conflict() const
{
if (union_selection != ALT_conflict) TTCN_error("Using non-selected field conflict in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_conflict;
}

Empty& StanzaErrorGroup::feature__not__implemented()
{
if (union_selection != ALT_feature__not__implemented) {
clean_up();
field_feature__not__implemented = new Empty;
union_selection = ALT_feature__not__implemented;
}
return *field_feature__not__implemented;
}

const Empty& StanzaErrorGroup::feature__not__implemented() const
{
if (union_selection != ALT_feature__not__implemented) TTCN_error("Using non-selected field feature_not_implemented in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_feature__not__implemented;
}

Empty& StanzaErrorGroup::forbidden()
{
if (union_selection != ALT_forbidden) {
clean_up();
field_forbidden = new Empty;
union_selection = ALT_forbidden;
}
return *field_forbidden;
}

const Empty& StanzaErrorGroup::forbidden() const
{
if (union_selection != ALT_forbidden) TTCN_error("Using non-selected field forbidden in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_forbidden;
}

UNIVERSAL_CHARSTRING& StanzaErrorGroup::gone()
{
if (union_selection != ALT_gone) {
clean_up();
field_gone = new UNIVERSAL_CHARSTRING;
union_selection = ALT_gone;
}
return *field_gone;
}

const UNIVERSAL_CHARSTRING& StanzaErrorGroup::gone() const
{
if (union_selection != ALT_gone) TTCN_error("Using non-selected field gone in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_gone;
}

Empty& StanzaErrorGroup::internal__server__error()
{
if (union_selection != ALT_internal__server__error) {
clean_up();
field_internal__server__error = new Empty;
union_selection = ALT_internal__server__error;
}
return *field_internal__server__error;
}

const Empty& StanzaErrorGroup::internal__server__error() const
{
if (union_selection != ALT_internal__server__error) TTCN_error("Using non-selected field internal_server_error in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_internal__server__error;
}

Empty& StanzaErrorGroup::item__not__found()
{
if (union_selection != ALT_item__not__found) {
clean_up();
field_item__not__found = new Empty;
union_selection = ALT_item__not__found;
}
return *field_item__not__found;
}

const Empty& StanzaErrorGroup::item__not__found() const
{
if (union_selection != ALT_item__not__found) TTCN_error("Using non-selected field item_not_found in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_item__not__found;
}

Empty& StanzaErrorGroup::jid__malformed()
{
if (union_selection != ALT_jid__malformed) {
clean_up();
field_jid__malformed = new Empty;
union_selection = ALT_jid__malformed;
}
return *field_jid__malformed;
}

const Empty& StanzaErrorGroup::jid__malformed() const
{
if (union_selection != ALT_jid__malformed) TTCN_error("Using non-selected field jid_malformed in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_jid__malformed;
}

Empty& StanzaErrorGroup::not__acceptable()
{
if (union_selection != ALT_not__acceptable) {
clean_up();
field_not__acceptable = new Empty;
union_selection = ALT_not__acceptable;
}
return *field_not__acceptable;
}

const Empty& StanzaErrorGroup::not__acceptable() const
{
if (union_selection != ALT_not__acceptable) TTCN_error("Using non-selected field not_acceptable in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_not__acceptable;
}

Empty& StanzaErrorGroup::not__authorized()
{
if (union_selection != ALT_not__authorized) {
clean_up();
field_not__authorized = new Empty;
union_selection = ALT_not__authorized;
}
return *field_not__authorized;
}

const Empty& StanzaErrorGroup::not__authorized() const
{
if (union_selection != ALT_not__authorized) TTCN_error("Using non-selected field not_authorized in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_not__authorized;
}

Empty& StanzaErrorGroup::not__allowed()
{
if (union_selection != ALT_not__allowed) {
clean_up();
field_not__allowed = new Empty;
union_selection = ALT_not__allowed;
}
return *field_not__allowed;
}

const Empty& StanzaErrorGroup::not__allowed() const
{
if (union_selection != ALT_not__allowed) TTCN_error("Using non-selected field not_allowed in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_not__allowed;
}

Empty& StanzaErrorGroup::payment__required()
{
if (union_selection != ALT_payment__required) {
clean_up();
field_payment__required = new Empty;
union_selection = ALT_payment__required;
}
return *field_payment__required;
}

const Empty& StanzaErrorGroup::payment__required() const
{
if (union_selection != ALT_payment__required) TTCN_error("Using non-selected field payment_required in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_payment__required;
}

Empty& StanzaErrorGroup::policy__violation()
{
if (union_selection != ALT_policy__violation) {
clean_up();
field_policy__violation = new Empty;
union_selection = ALT_policy__violation;
}
return *field_policy__violation;
}

const Empty& StanzaErrorGroup::policy__violation() const
{
if (union_selection != ALT_policy__violation) TTCN_error("Using non-selected field policy_violation in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_policy__violation;
}

Empty& StanzaErrorGroup::recipient__unavailable()
{
if (union_selection != ALT_recipient__unavailable) {
clean_up();
field_recipient__unavailable = new Empty;
union_selection = ALT_recipient__unavailable;
}
return *field_recipient__unavailable;
}

const Empty& StanzaErrorGroup::recipient__unavailable() const
{
if (union_selection != ALT_recipient__unavailable) TTCN_error("Using non-selected field recipient_unavailable in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_recipient__unavailable;
}

UNIVERSAL_CHARSTRING& StanzaErrorGroup::redirect()
{
if (union_selection != ALT_redirect) {
clean_up();
field_redirect = new UNIVERSAL_CHARSTRING;
union_selection = ALT_redirect;
}
return *field_redirect;
}

const UNIVERSAL_CHARSTRING& StanzaErrorGroup::redirect() const
{
if (union_selection != ALT_redirect) TTCN_error("Using non-selected field redirect in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_redirect;
}

Empty& StanzaErrorGroup::registration__required()
{
if (union_selection != ALT_registration__required) {
clean_up();
field_registration__required = new Empty;
union_selection = ALT_registration__required;
}
return *field_registration__required;
}

const Empty& StanzaErrorGroup::registration__required() const
{
if (union_selection != ALT_registration__required) TTCN_error("Using non-selected field registration_required in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_registration__required;
}

Empty& StanzaErrorGroup::remote__server__not__found()
{
if (union_selection != ALT_remote__server__not__found) {
clean_up();
field_remote__server__not__found = new Empty;
union_selection = ALT_remote__server__not__found;
}
return *field_remote__server__not__found;
}

const Empty& StanzaErrorGroup::remote__server__not__found() const
{
if (union_selection != ALT_remote__server__not__found) TTCN_error("Using non-selected field remote_server_not_found in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_remote__server__not__found;
}

Empty& StanzaErrorGroup::remote__server__timeout()
{
if (union_selection != ALT_remote__server__timeout) {
clean_up();
field_remote__server__timeout = new Empty;
union_selection = ALT_remote__server__timeout;
}
return *field_remote__server__timeout;
}

const Empty& StanzaErrorGroup::remote__server__timeout() const
{
if (union_selection != ALT_remote__server__timeout) TTCN_error("Using non-selected field remote_server_timeout in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_remote__server__timeout;
}

Empty& StanzaErrorGroup::resource__constraint()
{
if (union_selection != ALT_resource__constraint) {
clean_up();
field_resource__constraint = new Empty;
union_selection = ALT_resource__constraint;
}
return *field_resource__constraint;
}

const Empty& StanzaErrorGroup::resource__constraint() const
{
if (union_selection != ALT_resource__constraint) TTCN_error("Using non-selected field resource_constraint in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_resource__constraint;
}

Empty& StanzaErrorGroup::service__unavailable()
{
if (union_selection != ALT_service__unavailable) {
clean_up();
field_service__unavailable = new Empty;
union_selection = ALT_service__unavailable;
}
return *field_service__unavailable;
}

const Empty& StanzaErrorGroup::service__unavailable() const
{
if (union_selection != ALT_service__unavailable) TTCN_error("Using non-selected field service_unavailable in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_service__unavailable;
}

Empty& StanzaErrorGroup::subscription__required()
{
if (union_selection != ALT_subscription__required) {
clean_up();
field_subscription__required = new Empty;
union_selection = ALT_subscription__required;
}
return *field_subscription__required;
}

const Empty& StanzaErrorGroup::subscription__required() const
{
if (union_selection != ALT_subscription__required) TTCN_error("Using non-selected field subscription_required in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_subscription__required;
}

Empty& StanzaErrorGroup::undefined__condition()
{
if (union_selection != ALT_undefined__condition) {
clean_up();
field_undefined__condition = new Empty;
union_selection = ALT_undefined__condition;
}
return *field_undefined__condition;
}

const Empty& StanzaErrorGroup::undefined__condition() const
{
if (union_selection != ALT_undefined__condition) TTCN_error("Using non-selected field undefined_condition in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_undefined__condition;
}

Empty& StanzaErrorGroup::unexpected__request()
{
if (union_selection != ALT_unexpected__request) {
clean_up();
field_unexpected__request = new Empty;
union_selection = ALT_unexpected__request;
}
return *field_unexpected__request;
}

const Empty& StanzaErrorGroup::unexpected__request() const
{
if (union_selection != ALT_unexpected__request) TTCN_error("Using non-selected field unexpected_request in a value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *field_unexpected__request;
}

boolean StanzaErrorGroup::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return union_selection == checked_selection;
}

boolean StanzaErrorGroup::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean StanzaErrorGroup::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_bad__request: return field_bad__request->is_value();
case ALT_conflict: return field_conflict->is_value();
case ALT_feature__not__implemented: return field_feature__not__implemented->is_value();
case ALT_forbidden: return field_forbidden->is_value();
case ALT_gone: return field_gone->is_value();
case ALT_internal__server__error: return field_internal__server__error->is_value();
case ALT_item__not__found: return field_item__not__found->is_value();
case ALT_jid__malformed: return field_jid__malformed->is_value();
case ALT_not__acceptable: return field_not__acceptable->is_value();
case ALT_not__authorized: return field_not__authorized->is_value();
case ALT_not__allowed: return field_not__allowed->is_value();
case ALT_payment__required: return field_payment__required->is_value();
case ALT_policy__violation: return field_policy__violation->is_value();
case ALT_recipient__unavailable: return field_recipient__unavailable->is_value();
case ALT_redirect: return field_redirect->is_value();
case ALT_registration__required: return field_registration__required->is_value();
case ALT_remote__server__not__found: return field_remote__server__not__found->is_value();
case ALT_remote__server__timeout: return field_remote__server__timeout->is_value();
case ALT_resource__constraint: return field_resource__constraint->is_value();
case ALT_service__unavailable: return field_service__unavailable->is_value();
case ALT_subscription__required: return field_subscription__required->is_value();
case ALT_undefined__condition: return field_undefined__condition->is_value();
case ALT_unexpected__request: return field_unexpected__request->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void StanzaErrorGroup::clean_up()
{
switch (union_selection) {
case ALT_bad__request:
  delete field_bad__request;
  break;
case ALT_conflict:
  delete field_conflict;
  break;
case ALT_feature__not__implemented:
  delete field_feature__not__implemented;
  break;
case ALT_forbidden:
  delete field_forbidden;
  break;
case ALT_gone:
  delete field_gone;
  break;
case ALT_internal__server__error:
  delete field_internal__server__error;
  break;
case ALT_item__not__found:
  delete field_item__not__found;
  break;
case ALT_jid__malformed:
  delete field_jid__malformed;
  break;
case ALT_not__acceptable:
  delete field_not__acceptable;
  break;
case ALT_not__authorized:
  delete field_not__authorized;
  break;
case ALT_not__allowed:
  delete field_not__allowed;
  break;
case ALT_payment__required:
  delete field_payment__required;
  break;
case ALT_policy__violation:
  delete field_policy__violation;
  break;
case ALT_recipient__unavailable:
  delete field_recipient__unavailable;
  break;
case ALT_redirect:
  delete field_redirect;
  break;
case ALT_registration__required:
  delete field_registration__required;
  break;
case ALT_remote__server__not__found:
  delete field_remote__server__not__found;
  break;
case ALT_remote__server__timeout:
  delete field_remote__server__timeout;
  break;
case ALT_resource__constraint:
  delete field_resource__constraint;
  break;
case ALT_service__unavailable:
  delete field_service__unavailable;
  break;
case ALT_subscription__required:
  delete field_subscription__required;
  break;
case ALT_undefined__condition:
  delete field_undefined__condition;
  break;
case ALT_unexpected__request:
  delete field_unexpected__request;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void StanzaErrorGroup::log() const
{
switch (union_selection) {
case ALT_bad__request:
TTCN_Logger::log_event_str("{ bad_request := ");
field_bad__request->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_conflict:
TTCN_Logger::log_event_str("{ conflict := ");
field_conflict->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_feature__not__implemented:
TTCN_Logger::log_event_str("{ feature_not_implemented := ");
field_feature__not__implemented->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_forbidden:
TTCN_Logger::log_event_str("{ forbidden := ");
field_forbidden->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_gone:
TTCN_Logger::log_event_str("{ gone := ");
field_gone->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_internal__server__error:
TTCN_Logger::log_event_str("{ internal_server_error := ");
field_internal__server__error->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_item__not__found:
TTCN_Logger::log_event_str("{ item_not_found := ");
field_item__not__found->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_jid__malformed:
TTCN_Logger::log_event_str("{ jid_malformed := ");
field_jid__malformed->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_not__acceptable:
TTCN_Logger::log_event_str("{ not_acceptable := ");
field_not__acceptable->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_not__authorized:
TTCN_Logger::log_event_str("{ not_authorized := ");
field_not__authorized->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_not__allowed:
TTCN_Logger::log_event_str("{ not_allowed := ");
field_not__allowed->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_payment__required:
TTCN_Logger::log_event_str("{ payment_required := ");
field_payment__required->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_policy__violation:
TTCN_Logger::log_event_str("{ policy_violation := ");
field_policy__violation->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_recipient__unavailable:
TTCN_Logger::log_event_str("{ recipient_unavailable := ");
field_recipient__unavailable->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_redirect:
TTCN_Logger::log_event_str("{ redirect := ");
field_redirect->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_registration__required:
TTCN_Logger::log_event_str("{ registration_required := ");
field_registration__required->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_remote__server__not__found:
TTCN_Logger::log_event_str("{ remote_server_not_found := ");
field_remote__server__not__found->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_remote__server__timeout:
TTCN_Logger::log_event_str("{ remote_server_timeout := ");
field_remote__server__timeout->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_resource__constraint:
TTCN_Logger::log_event_str("{ resource_constraint := ");
field_resource__constraint->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_service__unavailable:
TTCN_Logger::log_event_str("{ service_unavailable := ");
field_service__unavailable->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_subscription__required:
TTCN_Logger::log_event_str("{ subscription_required := ");
field_subscription__required->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_undefined__condition:
TTCN_Logger::log_event_str("{ undefined_condition := ");
field_undefined__condition->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_unexpected__request:
TTCN_Logger::log_event_str("{ unexpected_request := ");
field_unexpected__request->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void StanzaErrorGroup::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup'");
    }
    if (strcmp("bad_request", param_field) == 0) {
      bad__request().set_param(param);
      return;
    } else if (strcmp("conflict", param_field) == 0) {
      conflict().set_param(param);
      return;
    } else if (strcmp("feature_not_implemented", param_field) == 0) {
      feature__not__implemented().set_param(param);
      return;
    } else if (strcmp("forbidden", param_field) == 0) {
      forbidden().set_param(param);
      return;
    } else if (strcmp("gone", param_field) == 0) {
      gone().set_param(param);
      return;
    } else if (strcmp("internal_server_error", param_field) == 0) {
      internal__server__error().set_param(param);
      return;
    } else if (strcmp("item_not_found", param_field) == 0) {
      item__not__found().set_param(param);
      return;
    } else if (strcmp("jid_malformed", param_field) == 0) {
      jid__malformed().set_param(param);
      return;
    } else if (strcmp("not_acceptable", param_field) == 0) {
      not__acceptable().set_param(param);
      return;
    } else if (strcmp("not_authorized", param_field) == 0) {
      not__authorized().set_param(param);
      return;
    } else if (strcmp("not_allowed", param_field) == 0) {
      not__allowed().set_param(param);
      return;
    } else if (strcmp("payment_required", param_field) == 0) {
      payment__required().set_param(param);
      return;
    } else if (strcmp("policy_violation", param_field) == 0) {
      policy__violation().set_param(param);
      return;
    } else if (strcmp("recipient_unavailable", param_field) == 0) {
      recipient__unavailable().set_param(param);
      return;
    } else if (strcmp("redirect", param_field) == 0) {
      redirect().set_param(param);
      return;
    } else if (strcmp("registration_required", param_field) == 0) {
      registration__required().set_param(param);
      return;
    } else if (strcmp("remote_server_not_found", param_field) == 0) {
      remote__server__not__found().set_param(param);
      return;
    } else if (strcmp("remote_server_timeout", param_field) == 0) {
      remote__server__timeout().set_param(param);
      return;
    } else if (strcmp("resource_constraint", param_field) == 0) {
      resource__constraint().set_param(param);
      return;
    } else if (strcmp("service_unavailable", param_field) == 0) {
      service__unavailable().set_param(param);
      return;
    } else if (strcmp("subscription_required", param_field) == 0) {
      subscription__required().set_param(param);
      return;
    } else if (strcmp("undefined_condition", param_field) == 0) {
      undefined__condition().set_param(param);
      return;
    } else if (strcmp("unexpected_request", param_field) == 0) {
      unexpected__request().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) return;
  if (param.get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = param.get_elem(param.get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "bad_request")) {
    bad__request().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "conflict")) {
    conflict().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "feature_not_implemented")) {
    feature__not__implemented().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "forbidden")) {
    forbidden().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "gone")) {
    gone().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "internal_server_error")) {
    internal__server__error().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "item_not_found")) {
    item__not__found().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "jid_malformed")) {
    jid__malformed().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "not_acceptable")) {
    not__acceptable().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "not_authorized")) {
    not__authorized().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "not_allowed")) {
    not__allowed().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "payment_required")) {
    payment__required().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "policy_violation")) {
    policy__violation().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "recipient_unavailable")) {
    recipient__unavailable().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "redirect")) {
    redirect().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "registration_required")) {
    registration__required().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "remote_server_not_found")) {
    remote__server__not__found().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "remote_server_timeout")) {
    remote__server__timeout().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "resource_constraint")) {
    resource__constraint().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "service_unavailable")) {
    service__unavailable().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "subscription_required")) {
    subscription__required().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "undefined_condition")) {
    undefined__condition().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "unexpected_request")) {
    unexpected__request().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.", mp_last->get_id()->get_name());
}

void StanzaErrorGroup::set_implicit_omit()
{
switch (union_selection) {
case ALT_bad__request:
field_bad__request->set_implicit_omit(); break;
case ALT_conflict:
field_conflict->set_implicit_omit(); break;
case ALT_feature__not__implemented:
field_feature__not__implemented->set_implicit_omit(); break;
case ALT_forbidden:
field_forbidden->set_implicit_omit(); break;
case ALT_gone:
field_gone->set_implicit_omit(); break;
case ALT_internal__server__error:
field_internal__server__error->set_implicit_omit(); break;
case ALT_item__not__found:
field_item__not__found->set_implicit_omit(); break;
case ALT_jid__malformed:
field_jid__malformed->set_implicit_omit(); break;
case ALT_not__acceptable:
field_not__acceptable->set_implicit_omit(); break;
case ALT_not__authorized:
field_not__authorized->set_implicit_omit(); break;
case ALT_not__allowed:
field_not__allowed->set_implicit_omit(); break;
case ALT_payment__required:
field_payment__required->set_implicit_omit(); break;
case ALT_policy__violation:
field_policy__violation->set_implicit_omit(); break;
case ALT_recipient__unavailable:
field_recipient__unavailable->set_implicit_omit(); break;
case ALT_redirect:
field_redirect->set_implicit_omit(); break;
case ALT_registration__required:
field_registration__required->set_implicit_omit(); break;
case ALT_remote__server__not__found:
field_remote__server__not__found->set_implicit_omit(); break;
case ALT_remote__server__timeout:
field_remote__server__timeout->set_implicit_omit(); break;
case ALT_resource__constraint:
field_resource__constraint->set_implicit_omit(); break;
case ALT_service__unavailable:
field_service__unavailable->set_implicit_omit(); break;
case ALT_subscription__required:
field_subscription__required->set_implicit_omit(); break;
case ALT_undefined__condition:
field_undefined__condition->set_implicit_omit(); break;
case ALT_unexpected__request:
field_unexpected__request->set_implicit_omit(); break;
default: break;
}
}

void StanzaErrorGroup::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_bad__request:
field_bad__request->encode_text(text_buf);
break;
case ALT_conflict:
field_conflict->encode_text(text_buf);
break;
case ALT_feature__not__implemented:
field_feature__not__implemented->encode_text(text_buf);
break;
case ALT_forbidden:
field_forbidden->encode_text(text_buf);
break;
case ALT_gone:
field_gone->encode_text(text_buf);
break;
case ALT_internal__server__error:
field_internal__server__error->encode_text(text_buf);
break;
case ALT_item__not__found:
field_item__not__found->encode_text(text_buf);
break;
case ALT_jid__malformed:
field_jid__malformed->encode_text(text_buf);
break;
case ALT_not__acceptable:
field_not__acceptable->encode_text(text_buf);
break;
case ALT_not__authorized:
field_not__authorized->encode_text(text_buf);
break;
case ALT_not__allowed:
field_not__allowed->encode_text(text_buf);
break;
case ALT_payment__required:
field_payment__required->encode_text(text_buf);
break;
case ALT_policy__violation:
field_policy__violation->encode_text(text_buf);
break;
case ALT_recipient__unavailable:
field_recipient__unavailable->encode_text(text_buf);
break;
case ALT_redirect:
field_redirect->encode_text(text_buf);
break;
case ALT_registration__required:
field_registration__required->encode_text(text_buf);
break;
case ALT_remote__server__not__found:
field_remote__server__not__found->encode_text(text_buf);
break;
case ALT_remote__server__timeout:
field_remote__server__timeout->encode_text(text_buf);
break;
case ALT_resource__constraint:
field_resource__constraint->encode_text(text_buf);
break;
case ALT_service__unavailable:
field_service__unavailable->encode_text(text_buf);
break;
case ALT_subscription__required:
field_subscription__required->encode_text(text_buf);
break;
case ALT_undefined__condition:
field_undefined__condition->encode_text(text_buf);
break;
case ALT_unexpected__request:
field_unexpected__request->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
}

void StanzaErrorGroup::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_bad__request:
bad__request().decode_text(text_buf);
break;
case ALT_conflict:
conflict().decode_text(text_buf);
break;
case ALT_feature__not__implemented:
feature__not__implemented().decode_text(text_buf);
break;
case ALT_forbidden:
forbidden().decode_text(text_buf);
break;
case ALT_gone:
gone().decode_text(text_buf);
break;
case ALT_internal__server__error:
internal__server__error().decode_text(text_buf);
break;
case ALT_item__not__found:
item__not__found().decode_text(text_buf);
break;
case ALT_jid__malformed:
jid__malformed().decode_text(text_buf);
break;
case ALT_not__acceptable:
not__acceptable().decode_text(text_buf);
break;
case ALT_not__authorized:
not__authorized().decode_text(text_buf);
break;
case ALT_not__allowed:
not__allowed().decode_text(text_buf);
break;
case ALT_payment__required:
payment__required().decode_text(text_buf);
break;
case ALT_policy__violation:
policy__violation().decode_text(text_buf);
break;
case ALT_recipient__unavailable:
recipient__unavailable().decode_text(text_buf);
break;
case ALT_redirect:
redirect().decode_text(text_buf);
break;
case ALT_registration__required:
registration__required().decode_text(text_buf);
break;
case ALT_remote__server__not__found:
remote__server__not__found().decode_text(text_buf);
break;
case ALT_remote__server__timeout:
remote__server__timeout().decode_text(text_buf);
break;
case ALT_resource__constraint:
resource__constraint().decode_text(text_buf);
break;
case ALT_service__unavailable:
service__unavailable().decode_text(text_buf);
break;
case ALT_subscription__required:
subscription__required().decode_text(text_buf);
break;
case ALT_undefined__condition:
undefined__condition().decode_text(text_buf);
break;
case ALT_unexpected__request:
unexpected__request().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
}

void StanzaErrorGroup::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void StanzaErrorGroup::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

boolean StanzaErrorGroup::can_start(const char *name, const char *uri, const XERdescriptor_t& xd, unsigned int flavor) {
  boolean exer = is_exer(flavor);
  if (!exer || (!(xd.xer_bits & UNTAGGED) && !(flavor & (USE_NIL|(exer ? XER_LIST : XER_RECOF))))) return check_name(name, xd, exer) && (!exer || (flavor & USE_TYPE_ATTR) || check_namespace(uri, xd));
  flavor &= ~XER_RECOF;
  if (Empty::can_start(name, uri, StanzaErrorGroup_bad__request_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_conflict_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_feature__not__implemented_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_forbidden_xer_, flavor)) return true;
  if (UNIVERSAL_CHARSTRING::can_start(name, uri, StanzaErrorGroup_gone_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_internal__server__error_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_item__not__found_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_jid__malformed_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_not__acceptable_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_not__authorized_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_not__allowed_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_payment__required_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_policy__violation_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_recipient__unavailable_xer_, flavor)) return true;
  if (UNIVERSAL_CHARSTRING::can_start(name, uri, StanzaErrorGroup_redirect_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_registration__required_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_remote__server__not__found_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_remote__server__timeout_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_resource__constraint_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_service__unavailable_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_subscription__required_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_undefined__condition_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StanzaErrorGroup_unexpected__request_xer_, flavor)) return true;
  return false;
}

char ** StanzaErrorGroup::collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const {
  size_t num_collected;
  char **collected_ns = Base_Type::collect_ns(p_td, num_collected, def_ns);
  char **new_ns;
  size_t num_new;
  boolean need_type = FALSE;
  try {
    bool def_ns_1 = false;
    switch (union_selection) {
    case ALT_bad__request:
      new_ns = field_bad__request->collect_ns(StanzaErrorGroup_bad__request_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      break;
    case ALT_conflict:
      new_ns = field_conflict->collect_ns(StanzaErrorGroup_conflict_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_conflict_xer_.namelens[1] > 2);
      break;
    case ALT_feature__not__implemented:
      new_ns = field_feature__not__implemented->collect_ns(StanzaErrorGroup_feature__not__implemented_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_feature__not__implemented_xer_.namelens[1] > 2);
      break;
    case ALT_forbidden:
      new_ns = field_forbidden->collect_ns(StanzaErrorGroup_forbidden_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_forbidden_xer_.namelens[1] > 2);
      break;
    case ALT_gone:
      new_ns = field_gone->collect_ns(StanzaErrorGroup_gone_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_gone_xer_.namelens[1] > 2);
      break;
    case ALT_internal__server__error:
      new_ns = field_internal__server__error->collect_ns(StanzaErrorGroup_internal__server__error_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_internal__server__error_xer_.namelens[1] > 2);
      break;
    case ALT_item__not__found:
      new_ns = field_item__not__found->collect_ns(StanzaErrorGroup_item__not__found_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_item__not__found_xer_.namelens[1] > 2);
      break;
    case ALT_jid__malformed:
      new_ns = field_jid__malformed->collect_ns(StanzaErrorGroup_jid__malformed_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_jid__malformed_xer_.namelens[1] > 2);
      break;
    case ALT_not__acceptable:
      new_ns = field_not__acceptable->collect_ns(StanzaErrorGroup_not__acceptable_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_not__acceptable_xer_.namelens[1] > 2);
      break;
    case ALT_not__authorized:
      new_ns = field_not__authorized->collect_ns(StanzaErrorGroup_not__authorized_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_not__authorized_xer_.namelens[1] > 2);
      break;
    case ALT_not__allowed:
      new_ns = field_not__allowed->collect_ns(StanzaErrorGroup_not__allowed_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_not__allowed_xer_.namelens[1] > 2);
      break;
    case ALT_payment__required:
      new_ns = field_payment__required->collect_ns(StanzaErrorGroup_payment__required_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_payment__required_xer_.namelens[1] > 2);
      break;
    case ALT_policy__violation:
      new_ns = field_policy__violation->collect_ns(StanzaErrorGroup_policy__violation_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_policy__violation_xer_.namelens[1] > 2);
      break;
    case ALT_recipient__unavailable:
      new_ns = field_recipient__unavailable->collect_ns(StanzaErrorGroup_recipient__unavailable_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_recipient__unavailable_xer_.namelens[1] > 2);
      break;
    case ALT_redirect:
      new_ns = field_redirect->collect_ns(StanzaErrorGroup_redirect_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_redirect_xer_.namelens[1] > 2);
      break;
    case ALT_registration__required:
      new_ns = field_registration__required->collect_ns(StanzaErrorGroup_registration__required_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_registration__required_xer_.namelens[1] > 2);
      break;
    case ALT_remote__server__not__found:
      new_ns = field_remote__server__not__found->collect_ns(StanzaErrorGroup_remote__server__not__found_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_remote__server__not__found_xer_.namelens[1] > 2);
      break;
    case ALT_remote__server__timeout:
      new_ns = field_remote__server__timeout->collect_ns(StanzaErrorGroup_remote__server__timeout_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_remote__server__timeout_xer_.namelens[1] > 2);
      break;
    case ALT_resource__constraint:
      new_ns = field_resource__constraint->collect_ns(StanzaErrorGroup_resource__constraint_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_resource__constraint_xer_.namelens[1] > 2);
      break;
    case ALT_service__unavailable:
      new_ns = field_service__unavailable->collect_ns(StanzaErrorGroup_service__unavailable_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_service__unavailable_xer_.namelens[1] > 2);
      break;
    case ALT_subscription__required:
      new_ns = field_subscription__required->collect_ns(StanzaErrorGroup_subscription__required_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_subscription__required_xer_.namelens[1] > 2);
      break;
    case ALT_undefined__condition:
      new_ns = field_undefined__condition->collect_ns(StanzaErrorGroup_undefined__condition_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_undefined__condition_xer_.namelens[1] > 2);
      break;
    case ALT_unexpected__request:
      new_ns = field_unexpected__request->collect_ns(StanzaErrorGroup_unexpected__request_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StanzaErrorGroup_unexpected__request_xer_.namelens[1] > 2);
      break;
    default: break;
    }
    if ((p_td.xer_bits & USE_TYPE_ATTR) && !(p_td.xer_bits & XER_ATTRIBUTE) && need_type) {
      collected_ns = (char**)Realloc(collected_ns, sizeof(char*) * ++num_collected);
      const namespace_t *c_ns = p_td.my_module->get_controlns();
      collected_ns[num_collected-1] = mprintf(" xmlns:%s='%s'", c_ns->px, c_ns->ns);
    }
  }
  catch (...) {
    while (num_collected > 0) Free(collected_ns[--num_collected]);
    Free(collected_ns);
    throw;
  }
  num = num_collected;
  return collected_ns;
}

int StanzaErrorGroup::XER_encode(const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const
{
  if (UNBOUND_VALUE==union_selection) {
    TTCN_error("Attempt to XER-encode an unbound union value.");
    return 0;
  }
  TTCN_EncDec_ErrorContext ec_0("Alternative '");
  TTCN_EncDec_ErrorContext ec_1;
  int encoded_length=(int)p_buf.get_len();
  unsigned int flavor_1 = p_flavor;
  if (is_exer(p_flavor)) flavor_1 &= ~XER_RECOF;
  bool omit_tag = begin_xml(p_td, p_buf, flavor_1, p_indent, false, (collector_fn)&StanzaErrorGroup::collect_ns);
  unsigned int flavor_0 = (p_flavor & XER_MASK);
  switch (union_selection) {
  case ALT_bad__request:
    ec_1.set_msg("bad_request': ");
    field_bad__request->XER_encode(StanzaErrorGroup_bad__request_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_conflict:
    ec_1.set_msg("conflict': ");
    field_conflict->XER_encode(StanzaErrorGroup_conflict_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_feature__not__implemented:
    ec_1.set_msg("feature_not_implemented': ");
    field_feature__not__implemented->XER_encode(StanzaErrorGroup_feature__not__implemented_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_forbidden:
    ec_1.set_msg("forbidden': ");
    field_forbidden->XER_encode(StanzaErrorGroup_forbidden_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_gone:
    ec_1.set_msg("gone': ");
    field_gone->XER_encode(StanzaErrorGroup_gone_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_internal__server__error:
    ec_1.set_msg("internal_server_error': ");
    field_internal__server__error->XER_encode(StanzaErrorGroup_internal__server__error_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_item__not__found:
    ec_1.set_msg("item_not_found': ");
    field_item__not__found->XER_encode(StanzaErrorGroup_item__not__found_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_jid__malformed:
    ec_1.set_msg("jid_malformed': ");
    field_jid__malformed->XER_encode(StanzaErrorGroup_jid__malformed_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_not__acceptable:
    ec_1.set_msg("not_acceptable': ");
    field_not__acceptable->XER_encode(StanzaErrorGroup_not__acceptable_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_not__authorized:
    ec_1.set_msg("not_authorized': ");
    field_not__authorized->XER_encode(StanzaErrorGroup_not__authorized_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_not__allowed:
    ec_1.set_msg("not_allowed': ");
    field_not__allowed->XER_encode(StanzaErrorGroup_not__allowed_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_payment__required:
    ec_1.set_msg("payment_required': ");
    field_payment__required->XER_encode(StanzaErrorGroup_payment__required_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_policy__violation:
    ec_1.set_msg("policy_violation': ");
    field_policy__violation->XER_encode(StanzaErrorGroup_policy__violation_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_recipient__unavailable:
    ec_1.set_msg("recipient_unavailable': ");
    field_recipient__unavailable->XER_encode(StanzaErrorGroup_recipient__unavailable_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_redirect:
    ec_1.set_msg("redirect': ");
    field_redirect->XER_encode(StanzaErrorGroup_redirect_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_registration__required:
    ec_1.set_msg("registration_required': ");
    field_registration__required->XER_encode(StanzaErrorGroup_registration__required_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_remote__server__not__found:
    ec_1.set_msg("remote_server_not_found': ");
    field_remote__server__not__found->XER_encode(StanzaErrorGroup_remote__server__not__found_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_remote__server__timeout:
    ec_1.set_msg("remote_server_timeout': ");
    field_remote__server__timeout->XER_encode(StanzaErrorGroup_remote__server__timeout_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_resource__constraint:
    ec_1.set_msg("resource_constraint': ");
    field_resource__constraint->XER_encode(StanzaErrorGroup_resource__constraint_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_service__unavailable:
    ec_1.set_msg("service_unavailable': ");
    field_service__unavailable->XER_encode(StanzaErrorGroup_service__unavailable_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_subscription__required:
    ec_1.set_msg("subscription_required': ");
    field_subscription__required->XER_encode(StanzaErrorGroup_subscription__required_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_undefined__condition:
    ec_1.set_msg("undefined_condition': ");
    field_undefined__condition->XER_encode(StanzaErrorGroup_undefined__condition_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_unexpected__request:
    ec_1.set_msg("unexpected_request': ");
    field_unexpected__request->XER_encode(StanzaErrorGroup_unexpected__request_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case UNBOUND_VALUE:
    (void)flavor_0;
    break;
  } //switch
  end_xml(p_td, p_buf, flavor_1, p_indent, 0);
  return (int)p_buf.get_len() - encoded_length;
}

int StanzaErrorGroup::XER_decode(const XERdescriptor_t& p_td, XmlReaderWrap& p_reader, unsigned int p_flavor, embed_values_dec_struct_t*)
{
  int e_xer = is_exer(p_flavor);
  int type = 0;
  int rd_ok=1, xml_depth=-1;
  int xerbits = p_td.xer_bits;
  if (p_flavor & XER_TOPLEVEL) xerbits &= ~UNTAGGED;
  if (xerbits & USE_TYPE_ATTR) p_flavor &= ~XER_RECOF;
  boolean own_tag = !(e_xer && ((xerbits & (ANY_ELEMENT | UNTAGGED)) || (p_flavor & (USE_NIL|(e_xer ? XER_LIST : XER_RECOF)))));
  if ((e_xer || !is_record_of(p_flavor)) && own_tag)
  for (rd_ok = p_reader.Ok(); rd_ok == 1; rd_ok = p_reader.Read()) {
    type = p_reader.NodeType();
    if (type == XML_READER_TYPE_ELEMENT) {
      verify_name(p_reader, p_td, e_xer);
      xml_depth = p_reader.Depth();
      if (!(e_xer && (p_td.xer_bits & USE_TYPE_ATTR))
        && !p_reader.IsEmptyElement()) rd_ok = p_reader.Read();
      break;
    }
  }
  unsigned int flavor_1 = (p_flavor & XER_MASK);
  for (rd_ok = p_reader.Ok(); rd_ok == 1; rd_ok = p_reader.Read()) {
    type = p_reader.NodeType();
    if (type == XML_READER_TYPE_ELEMENT) break;
    else if (type == XML_READER_TYPE_END_ELEMENT) break;
  }
  if (rd_ok) {
    TTCN_EncDec_ErrorContext ec_1("Alternative '");
    TTCN_EncDec_ErrorContext ec_2;
    const char *elem_name;
    const char *ns_uri = 0;
    {
      elem_name = (const char*)p_reader.LocalName();
      ns_uri    = (const char*)p_reader.NamespaceUri();
    }
    if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_bad__request_xer_, flavor_1) || (StanzaErrorGroup_bad__request_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("bad_request': ");
      bad__request().XER_decode(StanzaErrorGroup_bad__request_xer_, p_reader, flavor_1, 0);
      if (!bad__request().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_conflict_xer_, flavor_1) || (StanzaErrorGroup_conflict_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("conflict': ");
      conflict().XER_decode(StanzaErrorGroup_conflict_xer_, p_reader, flavor_1, 0);
      if (!conflict().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_feature__not__implemented_xer_, flavor_1) || (StanzaErrorGroup_feature__not__implemented_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("feature_not_implemented': ");
      feature__not__implemented().XER_decode(StanzaErrorGroup_feature__not__implemented_xer_, p_reader, flavor_1, 0);
      if (!feature__not__implemented().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_forbidden_xer_, flavor_1) || (StanzaErrorGroup_forbidden_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("forbidden': ");
      forbidden().XER_decode(StanzaErrorGroup_forbidden_xer_, p_reader, flavor_1, 0);
      if (!forbidden().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (UNIVERSAL_CHARSTRING::can_start(elem_name, ns_uri, StanzaErrorGroup_gone_xer_, flavor_1) || (StanzaErrorGroup_gone_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("gone': ");
      gone().XER_decode(StanzaErrorGroup_gone_xer_, p_reader, flavor_1, 0);
      if (!gone().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_internal__server__error_xer_, flavor_1) || (StanzaErrorGroup_internal__server__error_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("internal_server_error': ");
      internal__server__error().XER_decode(StanzaErrorGroup_internal__server__error_xer_, p_reader, flavor_1, 0);
      if (!internal__server__error().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_item__not__found_xer_, flavor_1) || (StanzaErrorGroup_item__not__found_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("item_not_found': ");
      item__not__found().XER_decode(StanzaErrorGroup_item__not__found_xer_, p_reader, flavor_1, 0);
      if (!item__not__found().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_jid__malformed_xer_, flavor_1) || (StanzaErrorGroup_jid__malformed_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("jid_malformed': ");
      jid__malformed().XER_decode(StanzaErrorGroup_jid__malformed_xer_, p_reader, flavor_1, 0);
      if (!jid__malformed().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_not__acceptable_xer_, flavor_1) || (StanzaErrorGroup_not__acceptable_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("not_acceptable': ");
      not__acceptable().XER_decode(StanzaErrorGroup_not__acceptable_xer_, p_reader, flavor_1, 0);
      if (!not__acceptable().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_not__authorized_xer_, flavor_1) || (StanzaErrorGroup_not__authorized_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("not_authorized': ");
      not__authorized().XER_decode(StanzaErrorGroup_not__authorized_xer_, p_reader, flavor_1, 0);
      if (!not__authorized().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_not__allowed_xer_, flavor_1) || (StanzaErrorGroup_not__allowed_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("not_allowed': ");
      not__allowed().XER_decode(StanzaErrorGroup_not__allowed_xer_, p_reader, flavor_1, 0);
      if (!not__allowed().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_payment__required_xer_, flavor_1) || (StanzaErrorGroup_payment__required_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("payment_required': ");
      payment__required().XER_decode(StanzaErrorGroup_payment__required_xer_, p_reader, flavor_1, 0);
      if (!payment__required().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_policy__violation_xer_, flavor_1) || (StanzaErrorGroup_policy__violation_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("policy_violation': ");
      policy__violation().XER_decode(StanzaErrorGroup_policy__violation_xer_, p_reader, flavor_1, 0);
      if (!policy__violation().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_recipient__unavailable_xer_, flavor_1) || (StanzaErrorGroup_recipient__unavailable_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("recipient_unavailable': ");
      recipient__unavailable().XER_decode(StanzaErrorGroup_recipient__unavailable_xer_, p_reader, flavor_1, 0);
      if (!recipient__unavailable().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (UNIVERSAL_CHARSTRING::can_start(elem_name, ns_uri, StanzaErrorGroup_redirect_xer_, flavor_1) || (StanzaErrorGroup_redirect_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("redirect': ");
      redirect().XER_decode(StanzaErrorGroup_redirect_xer_, p_reader, flavor_1, 0);
      if (!redirect().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_registration__required_xer_, flavor_1) || (StanzaErrorGroup_registration__required_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("registration_required': ");
      registration__required().XER_decode(StanzaErrorGroup_registration__required_xer_, p_reader, flavor_1, 0);
      if (!registration__required().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_remote__server__not__found_xer_, flavor_1) || (StanzaErrorGroup_remote__server__not__found_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("remote_server_not_found': ");
      remote__server__not__found().XER_decode(StanzaErrorGroup_remote__server__not__found_xer_, p_reader, flavor_1, 0);
      if (!remote__server__not__found().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_remote__server__timeout_xer_, flavor_1) || (StanzaErrorGroup_remote__server__timeout_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("remote_server_timeout': ");
      remote__server__timeout().XER_decode(StanzaErrorGroup_remote__server__timeout_xer_, p_reader, flavor_1, 0);
      if (!remote__server__timeout().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_resource__constraint_xer_, flavor_1) || (StanzaErrorGroup_resource__constraint_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("resource_constraint': ");
      resource__constraint().XER_decode(StanzaErrorGroup_resource__constraint_xer_, p_reader, flavor_1, 0);
      if (!resource__constraint().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_service__unavailable_xer_, flavor_1) || (StanzaErrorGroup_service__unavailable_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("service_unavailable': ");
      service__unavailable().XER_decode(StanzaErrorGroup_service__unavailable_xer_, p_reader, flavor_1, 0);
      if (!service__unavailable().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_subscription__required_xer_, flavor_1) || (StanzaErrorGroup_subscription__required_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("subscription_required': ");
      subscription__required().XER_decode(StanzaErrorGroup_subscription__required_xer_, p_reader, flavor_1, 0);
      if (!subscription__required().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_undefined__condition_xer_, flavor_1) || (StanzaErrorGroup_undefined__condition_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("undefined_condition': ");
      undefined__condition().XER_decode(StanzaErrorGroup_undefined__condition_xer_, p_reader, flavor_1, 0);
      if (!undefined__condition().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StanzaErrorGroup_unexpected__request_xer_, flavor_1) || (StanzaErrorGroup_unexpected__request_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("unexpected_request': ");
      unexpected__request().XER_decode(StanzaErrorGroup_unexpected__request_xer_, p_reader, flavor_1, 0);
      if (!unexpected__request().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else {
      ec_1.set_msg(" ");
      TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "'%s' does not match any alternative", elem_name);
      if (xml_depth >= 0) for (; rd_ok == 1 && p_reader.Depth() > xml_depth; rd_ok = p_reader.Read()) ;
    }
  }
  if ((e_xer || !is_record_of(p_flavor)) && own_tag)
  for (; rd_ok == 1; rd_ok = p_reader.Read()) {
    type = p_reader.NodeType();
    if (type == XML_READER_TYPE_END_ELEMENT) {
      verify_end(p_reader, p_td, xml_depth, e_xer);
      rd_ok = p_reader.Read(); // one last time
      break;
    }
  }
  return 1;
}

int StanzaErrorGroup::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_bad__request:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "bad_request");
    enc_len += field_bad__request->JSON_encode(StanzaErrorGroup_bad__request_descr_, p_tok);
    break;
  case ALT_conflict:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "conflict");
    enc_len += field_conflict->JSON_encode(StanzaErrorGroup_conflict_descr_, p_tok);
    break;
  case ALT_feature__not__implemented:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "feature_not_implemented");
    enc_len += field_feature__not__implemented->JSON_encode(StanzaErrorGroup_feature__not__implemented_descr_, p_tok);
    break;
  case ALT_forbidden:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "forbidden");
    enc_len += field_forbidden->JSON_encode(StanzaErrorGroup_forbidden_descr_, p_tok);
    break;
  case ALT_gone:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gone");
    enc_len += field_gone->JSON_encode(StanzaErrorGroup_gone_descr_, p_tok);
    break;
  case ALT_internal__server__error:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "internal_server_error");
    enc_len += field_internal__server__error->JSON_encode(StanzaErrorGroup_internal__server__error_descr_, p_tok);
    break;
  case ALT_item__not__found:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "item_not_found");
    enc_len += field_item__not__found->JSON_encode(StanzaErrorGroup_item__not__found_descr_, p_tok);
    break;
  case ALT_jid__malformed:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "jid_malformed");
    enc_len += field_jid__malformed->JSON_encode(StanzaErrorGroup_jid__malformed_descr_, p_tok);
    break;
  case ALT_not__acceptable:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "not_acceptable");
    enc_len += field_not__acceptable->JSON_encode(StanzaErrorGroup_not__acceptable_descr_, p_tok);
    break;
  case ALT_not__authorized:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "not_authorized");
    enc_len += field_not__authorized->JSON_encode(StanzaErrorGroup_not__authorized_descr_, p_tok);
    break;
  case ALT_not__allowed:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "not_allowed");
    enc_len += field_not__allowed->JSON_encode(StanzaErrorGroup_not__allowed_descr_, p_tok);
    break;
  case ALT_payment__required:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payment_required");
    enc_len += field_payment__required->JSON_encode(StanzaErrorGroup_payment__required_descr_, p_tok);
    break;
  case ALT_policy__violation:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "policy_violation");
    enc_len += field_policy__violation->JSON_encode(StanzaErrorGroup_policy__violation_descr_, p_tok);
    break;
  case ALT_recipient__unavailable:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "recipient_unavailable");
    enc_len += field_recipient__unavailable->JSON_encode(StanzaErrorGroup_recipient__unavailable_descr_, p_tok);
    break;
  case ALT_redirect:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "redirect");
    enc_len += field_redirect->JSON_encode(StanzaErrorGroup_redirect_descr_, p_tok);
    break;
  case ALT_registration__required:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "registration_required");
    enc_len += field_registration__required->JSON_encode(StanzaErrorGroup_registration__required_descr_, p_tok);
    break;
  case ALT_remote__server__not__found:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "remote_server_not_found");
    enc_len += field_remote__server__not__found->JSON_encode(StanzaErrorGroup_remote__server__not__found_descr_, p_tok);
    break;
  case ALT_remote__server__timeout:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "remote_server_timeout");
    enc_len += field_remote__server__timeout->JSON_encode(StanzaErrorGroup_remote__server__timeout_descr_, p_tok);
    break;
  case ALT_resource__constraint:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "resource_constraint");
    enc_len += field_resource__constraint->JSON_encode(StanzaErrorGroup_resource__constraint_descr_, p_tok);
    break;
  case ALT_service__unavailable:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "service_unavailable");
    enc_len += field_service__unavailable->JSON_encode(StanzaErrorGroup_service__unavailable_descr_, p_tok);
    break;
  case ALT_subscription__required:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "subscription_required");
    enc_len += field_subscription__required->JSON_encode(StanzaErrorGroup_subscription__required_descr_, p_tok);
    break;
  case ALT_undefined__condition:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "undefined_condition");
    enc_len += field_undefined__condition->JSON_encode(StanzaErrorGroup_undefined__condition_descr_, p_tok);
    break;
  case ALT_unexpected__request:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "unexpected_request");
    enc_len += field_unexpected__request->JSON_encode(StanzaErrorGroup_unexpected__request_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int StanzaErrorGroup::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "bad_request", name_len)) {
      int ret_val = bad__request().JSON_decode(StanzaErrorGroup_bad__request_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "bad_request");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "conflict", name_len)) {
      int ret_val = conflict().JSON_decode(StanzaErrorGroup_conflict_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "conflict");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "feature_not_implemented", name_len)) {
      int ret_val = feature__not__implemented().JSON_decode(StanzaErrorGroup_feature__not__implemented_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "feature_not_implemented");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "forbidden", name_len)) {
      int ret_val = forbidden().JSON_decode(StanzaErrorGroup_forbidden_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "forbidden");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "gone", name_len)) {
      int ret_val = gone().JSON_decode(StanzaErrorGroup_gone_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gone");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "internal_server_error", name_len)) {
      int ret_val = internal__server__error().JSON_decode(StanzaErrorGroup_internal__server__error_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "internal_server_error");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "item_not_found", name_len)) {
      int ret_val = item__not__found().JSON_decode(StanzaErrorGroup_item__not__found_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "item_not_found");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "jid_malformed", name_len)) {
      int ret_val = jid__malformed().JSON_decode(StanzaErrorGroup_jid__malformed_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "jid_malformed");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "not_acceptable", name_len)) {
      int ret_val = not__acceptable().JSON_decode(StanzaErrorGroup_not__acceptable_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "not_acceptable");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "not_authorized", name_len)) {
      int ret_val = not__authorized().JSON_decode(StanzaErrorGroup_not__authorized_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "not_authorized");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "not_allowed", name_len)) {
      int ret_val = not__allowed().JSON_decode(StanzaErrorGroup_not__allowed_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "not_allowed");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "payment_required", name_len)) {
      int ret_val = payment__required().JSON_decode(StanzaErrorGroup_payment__required_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payment_required");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "policy_violation", name_len)) {
      int ret_val = policy__violation().JSON_decode(StanzaErrorGroup_policy__violation_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "policy_violation");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "recipient_unavailable", name_len)) {
      int ret_val = recipient__unavailable().JSON_decode(StanzaErrorGroup_recipient__unavailable_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "recipient_unavailable");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "redirect", name_len)) {
      int ret_val = redirect().JSON_decode(StanzaErrorGroup_redirect_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "redirect");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "registration_required", name_len)) {
      int ret_val = registration__required().JSON_decode(StanzaErrorGroup_registration__required_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "registration_required");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "remote_server_not_found", name_len)) {
      int ret_val = remote__server__not__found().JSON_decode(StanzaErrorGroup_remote__server__not__found_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "remote_server_not_found");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "remote_server_timeout", name_len)) {
      int ret_val = remote__server__timeout().JSON_decode(StanzaErrorGroup_remote__server__timeout_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "remote_server_timeout");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "resource_constraint", name_len)) {
      int ret_val = resource__constraint().JSON_decode(StanzaErrorGroup_resource__constraint_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "resource_constraint");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "service_unavailable", name_len)) {
      int ret_val = service__unavailable().JSON_decode(StanzaErrorGroup_service__unavailable_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "service_unavailable");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "subscription_required", name_len)) {
      int ret_val = subscription__required().JSON_decode(StanzaErrorGroup_subscription__required_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "subscription_required");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "undefined_condition", name_len)) {
      int ret_val = undefined__condition().JSON_decode(StanzaErrorGroup_undefined__condition_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "undefined_condition");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "unexpected_request", name_len)) {
      int ret_val = unexpected__request().JSON_decode(StanzaErrorGroup_unexpected__request_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "unexpected_request");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void StanzaErrorGroup_template::copy_value(const StanzaErrorGroup& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case StanzaErrorGroup::ALT_bad__request:
single_value.field_bad__request = new Empty_template(other_value.bad__request());
break;
case StanzaErrorGroup::ALT_conflict:
single_value.field_conflict = new Empty_template(other_value.conflict());
break;
case StanzaErrorGroup::ALT_feature__not__implemented:
single_value.field_feature__not__implemented = new Empty_template(other_value.feature__not__implemented());
break;
case StanzaErrorGroup::ALT_forbidden:
single_value.field_forbidden = new Empty_template(other_value.forbidden());
break;
case StanzaErrorGroup::ALT_gone:
single_value.field_gone = new UNIVERSAL_CHARSTRING_template(other_value.gone());
break;
case StanzaErrorGroup::ALT_internal__server__error:
single_value.field_internal__server__error = new Empty_template(other_value.internal__server__error());
break;
case StanzaErrorGroup::ALT_item__not__found:
single_value.field_item__not__found = new Empty_template(other_value.item__not__found());
break;
case StanzaErrorGroup::ALT_jid__malformed:
single_value.field_jid__malformed = new Empty_template(other_value.jid__malformed());
break;
case StanzaErrorGroup::ALT_not__acceptable:
single_value.field_not__acceptable = new Empty_template(other_value.not__acceptable());
break;
case StanzaErrorGroup::ALT_not__authorized:
single_value.field_not__authorized = new Empty_template(other_value.not__authorized());
break;
case StanzaErrorGroup::ALT_not__allowed:
single_value.field_not__allowed = new Empty_template(other_value.not__allowed());
break;
case StanzaErrorGroup::ALT_payment__required:
single_value.field_payment__required = new Empty_template(other_value.payment__required());
break;
case StanzaErrorGroup::ALT_policy__violation:
single_value.field_policy__violation = new Empty_template(other_value.policy__violation());
break;
case StanzaErrorGroup::ALT_recipient__unavailable:
single_value.field_recipient__unavailable = new Empty_template(other_value.recipient__unavailable());
break;
case StanzaErrorGroup::ALT_redirect:
single_value.field_redirect = new UNIVERSAL_CHARSTRING_template(other_value.redirect());
break;
case StanzaErrorGroup::ALT_registration__required:
single_value.field_registration__required = new Empty_template(other_value.registration__required());
break;
case StanzaErrorGroup::ALT_remote__server__not__found:
single_value.field_remote__server__not__found = new Empty_template(other_value.remote__server__not__found());
break;
case StanzaErrorGroup::ALT_remote__server__timeout:
single_value.field_remote__server__timeout = new Empty_template(other_value.remote__server__timeout());
break;
case StanzaErrorGroup::ALT_resource__constraint:
single_value.field_resource__constraint = new Empty_template(other_value.resource__constraint());
break;
case StanzaErrorGroup::ALT_service__unavailable:
single_value.field_service__unavailable = new Empty_template(other_value.service__unavailable());
break;
case StanzaErrorGroup::ALT_subscription__required:
single_value.field_subscription__required = new Empty_template(other_value.subscription__required());
break;
case StanzaErrorGroup::ALT_undefined__condition:
single_value.field_undefined__condition = new Empty_template(other_value.undefined__condition());
break;
case StanzaErrorGroup::ALT_unexpected__request:
single_value.field_unexpected__request = new Empty_template(other_value.unexpected__request());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
set_selection(SPECIFIC_VALUE);
}

void StanzaErrorGroup_template::copy_template(const StanzaErrorGroup_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case StanzaErrorGroup::ALT_bad__request:
single_value.field_bad__request = new Empty_template(*other_value.single_value.field_bad__request);
break;
case StanzaErrorGroup::ALT_conflict:
single_value.field_conflict = new Empty_template(*other_value.single_value.field_conflict);
break;
case StanzaErrorGroup::ALT_feature__not__implemented:
single_value.field_feature__not__implemented = new Empty_template(*other_value.single_value.field_feature__not__implemented);
break;
case StanzaErrorGroup::ALT_forbidden:
single_value.field_forbidden = new Empty_template(*other_value.single_value.field_forbidden);
break;
case StanzaErrorGroup::ALT_gone:
single_value.field_gone = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_gone);
break;
case StanzaErrorGroup::ALT_internal__server__error:
single_value.field_internal__server__error = new Empty_template(*other_value.single_value.field_internal__server__error);
break;
case StanzaErrorGroup::ALT_item__not__found:
single_value.field_item__not__found = new Empty_template(*other_value.single_value.field_item__not__found);
break;
case StanzaErrorGroup::ALT_jid__malformed:
single_value.field_jid__malformed = new Empty_template(*other_value.single_value.field_jid__malformed);
break;
case StanzaErrorGroup::ALT_not__acceptable:
single_value.field_not__acceptable = new Empty_template(*other_value.single_value.field_not__acceptable);
break;
case StanzaErrorGroup::ALT_not__authorized:
single_value.field_not__authorized = new Empty_template(*other_value.single_value.field_not__authorized);
break;
case StanzaErrorGroup::ALT_not__allowed:
single_value.field_not__allowed = new Empty_template(*other_value.single_value.field_not__allowed);
break;
case StanzaErrorGroup::ALT_payment__required:
single_value.field_payment__required = new Empty_template(*other_value.single_value.field_payment__required);
break;
case StanzaErrorGroup::ALT_policy__violation:
single_value.field_policy__violation = new Empty_template(*other_value.single_value.field_policy__violation);
break;
case StanzaErrorGroup::ALT_recipient__unavailable:
single_value.field_recipient__unavailable = new Empty_template(*other_value.single_value.field_recipient__unavailable);
break;
case StanzaErrorGroup::ALT_redirect:
single_value.field_redirect = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_redirect);
break;
case StanzaErrorGroup::ALT_registration__required:
single_value.field_registration__required = new Empty_template(*other_value.single_value.field_registration__required);
break;
case StanzaErrorGroup::ALT_remote__server__not__found:
single_value.field_remote__server__not__found = new Empty_template(*other_value.single_value.field_remote__server__not__found);
break;
case StanzaErrorGroup::ALT_remote__server__timeout:
single_value.field_remote__server__timeout = new Empty_template(*other_value.single_value.field_remote__server__timeout);
break;
case StanzaErrorGroup::ALT_resource__constraint:
single_value.field_resource__constraint = new Empty_template(*other_value.single_value.field_resource__constraint);
break;
case StanzaErrorGroup::ALT_service__unavailable:
single_value.field_service__unavailable = new Empty_template(*other_value.single_value.field_service__unavailable);
break;
case StanzaErrorGroup::ALT_subscription__required:
single_value.field_subscription__required = new Empty_template(*other_value.single_value.field_subscription__required);
break;
case StanzaErrorGroup::ALT_undefined__condition:
single_value.field_undefined__condition = new Empty_template(*other_value.single_value.field_undefined__condition);
break;
case StanzaErrorGroup::ALT_unexpected__request:
single_value.field_unexpected__request = new Empty_template(*other_value.single_value.field_unexpected__request);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new StanzaErrorGroup_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
set_selection(other_value);
}

StanzaErrorGroup_template::StanzaErrorGroup_template()
{
}

StanzaErrorGroup_template::StanzaErrorGroup_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

StanzaErrorGroup_template::StanzaErrorGroup_template(const StanzaErrorGroup& other_value)
{
copy_value(other_value);
}

StanzaErrorGroup_template::StanzaErrorGroup_template(const OPTIONAL<StanzaErrorGroup>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const StanzaErrorGroup&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup from an unbound optional field.");
}
}

StanzaErrorGroup_template::StanzaErrorGroup_template(const StanzaErrorGroup_template& other_value)
: Base_Template(){
copy_template(other_value);
}

StanzaErrorGroup_template::~StanzaErrorGroup_template()
{
clean_up();
}

void StanzaErrorGroup_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case StanzaErrorGroup::ALT_bad__request:
delete single_value.field_bad__request;
break;
case StanzaErrorGroup::ALT_conflict:
delete single_value.field_conflict;
break;
case StanzaErrorGroup::ALT_feature__not__implemented:
delete single_value.field_feature__not__implemented;
break;
case StanzaErrorGroup::ALT_forbidden:
delete single_value.field_forbidden;
break;
case StanzaErrorGroup::ALT_gone:
delete single_value.field_gone;
break;
case StanzaErrorGroup::ALT_internal__server__error:
delete single_value.field_internal__server__error;
break;
case StanzaErrorGroup::ALT_item__not__found:
delete single_value.field_item__not__found;
break;
case StanzaErrorGroup::ALT_jid__malformed:
delete single_value.field_jid__malformed;
break;
case StanzaErrorGroup::ALT_not__acceptable:
delete single_value.field_not__acceptable;
break;
case StanzaErrorGroup::ALT_not__authorized:
delete single_value.field_not__authorized;
break;
case StanzaErrorGroup::ALT_not__allowed:
delete single_value.field_not__allowed;
break;
case StanzaErrorGroup::ALT_payment__required:
delete single_value.field_payment__required;
break;
case StanzaErrorGroup::ALT_policy__violation:
delete single_value.field_policy__violation;
break;
case StanzaErrorGroup::ALT_recipient__unavailable:
delete single_value.field_recipient__unavailable;
break;
case StanzaErrorGroup::ALT_redirect:
delete single_value.field_redirect;
break;
case StanzaErrorGroup::ALT_registration__required:
delete single_value.field_registration__required;
break;
case StanzaErrorGroup::ALT_remote__server__not__found:
delete single_value.field_remote__server__not__found;
break;
case StanzaErrorGroup::ALT_remote__server__timeout:
delete single_value.field_remote__server__timeout;
break;
case StanzaErrorGroup::ALT_resource__constraint:
delete single_value.field_resource__constraint;
break;
case StanzaErrorGroup::ALT_service__unavailable:
delete single_value.field_service__unavailable;
break;
case StanzaErrorGroup::ALT_subscription__required:
delete single_value.field_subscription__required;
break;
case StanzaErrorGroup::ALT_undefined__condition:
delete single_value.field_undefined__condition;
break;
case StanzaErrorGroup::ALT_unexpected__request:
delete single_value.field_unexpected__request;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

StanzaErrorGroup_template& StanzaErrorGroup_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

StanzaErrorGroup_template& StanzaErrorGroup_template::operator=(const StanzaErrorGroup& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

StanzaErrorGroup_template& StanzaErrorGroup_template::operator=(const OPTIONAL<StanzaErrorGroup>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const StanzaErrorGroup&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
return *this;
}

StanzaErrorGroup_template& StanzaErrorGroup_template::operator=(const StanzaErrorGroup_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean StanzaErrorGroup_template::match(const StanzaErrorGroup& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
StanzaErrorGroup::union_selection_type value_selection = other_value.get_selection();
if (value_selection == StanzaErrorGroup::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case StanzaErrorGroup::ALT_bad__request:
return single_value.field_bad__request->match(other_value.bad__request());
case StanzaErrorGroup::ALT_conflict:
return single_value.field_conflict->match(other_value.conflict());
case StanzaErrorGroup::ALT_feature__not__implemented:
return single_value.field_feature__not__implemented->match(other_value.feature__not__implemented());
case StanzaErrorGroup::ALT_forbidden:
return single_value.field_forbidden->match(other_value.forbidden());
case StanzaErrorGroup::ALT_gone:
return single_value.field_gone->match(other_value.gone());
case StanzaErrorGroup::ALT_internal__server__error:
return single_value.field_internal__server__error->match(other_value.internal__server__error());
case StanzaErrorGroup::ALT_item__not__found:
return single_value.field_item__not__found->match(other_value.item__not__found());
case StanzaErrorGroup::ALT_jid__malformed:
return single_value.field_jid__malformed->match(other_value.jid__malformed());
case StanzaErrorGroup::ALT_not__acceptable:
return single_value.field_not__acceptable->match(other_value.not__acceptable());
case StanzaErrorGroup::ALT_not__authorized:
return single_value.field_not__authorized->match(other_value.not__authorized());
case StanzaErrorGroup::ALT_not__allowed:
return single_value.field_not__allowed->match(other_value.not__allowed());
case StanzaErrorGroup::ALT_payment__required:
return single_value.field_payment__required->match(other_value.payment__required());
case StanzaErrorGroup::ALT_policy__violation:
return single_value.field_policy__violation->match(other_value.policy__violation());
case StanzaErrorGroup::ALT_recipient__unavailable:
return single_value.field_recipient__unavailable->match(other_value.recipient__unavailable());
case StanzaErrorGroup::ALT_redirect:
return single_value.field_redirect->match(other_value.redirect());
case StanzaErrorGroup::ALT_registration__required:
return single_value.field_registration__required->match(other_value.registration__required());
case StanzaErrorGroup::ALT_remote__server__not__found:
return single_value.field_remote__server__not__found->match(other_value.remote__server__not__found());
case StanzaErrorGroup::ALT_remote__server__timeout:
return single_value.field_remote__server__timeout->match(other_value.remote__server__timeout());
case StanzaErrorGroup::ALT_resource__constraint:
return single_value.field_resource__constraint->match(other_value.resource__constraint());
case StanzaErrorGroup::ALT_service__unavailable:
return single_value.field_service__unavailable->match(other_value.service__unavailable());
case StanzaErrorGroup::ALT_subscription__required:
return single_value.field_subscription__required->match(other_value.subscription__required());
case StanzaErrorGroup::ALT_undefined__condition:
return single_value.field_undefined__condition->match(other_value.undefined__condition());
case StanzaErrorGroup::ALT_unexpected__request:
return single_value.field_unexpected__request->match(other_value.unexpected__request());
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
return FALSE;
}

boolean StanzaErrorGroup_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case StanzaErrorGroup::ALT_bad__request:
return single_value.field_bad__request->is_value();
case StanzaErrorGroup::ALT_conflict:
return single_value.field_conflict->is_value();
case StanzaErrorGroup::ALT_feature__not__implemented:
return single_value.field_feature__not__implemented->is_value();
case StanzaErrorGroup::ALT_forbidden:
return single_value.field_forbidden->is_value();
case StanzaErrorGroup::ALT_gone:
return single_value.field_gone->is_value();
case StanzaErrorGroup::ALT_internal__server__error:
return single_value.field_internal__server__error->is_value();
case StanzaErrorGroup::ALT_item__not__found:
return single_value.field_item__not__found->is_value();
case StanzaErrorGroup::ALT_jid__malformed:
return single_value.field_jid__malformed->is_value();
case StanzaErrorGroup::ALT_not__acceptable:
return single_value.field_not__acceptable->is_value();
case StanzaErrorGroup::ALT_not__authorized:
return single_value.field_not__authorized->is_value();
case StanzaErrorGroup::ALT_not__allowed:
return single_value.field_not__allowed->is_value();
case StanzaErrorGroup::ALT_payment__required:
return single_value.field_payment__required->is_value();
case StanzaErrorGroup::ALT_policy__violation:
return single_value.field_policy__violation->is_value();
case StanzaErrorGroup::ALT_recipient__unavailable:
return single_value.field_recipient__unavailable->is_value();
case StanzaErrorGroup::ALT_redirect:
return single_value.field_redirect->is_value();
case StanzaErrorGroup::ALT_registration__required:
return single_value.field_registration__required->is_value();
case StanzaErrorGroup::ALT_remote__server__not__found:
return single_value.field_remote__server__not__found->is_value();
case StanzaErrorGroup::ALT_remote__server__timeout:
return single_value.field_remote__server__timeout->is_value();
case StanzaErrorGroup::ALT_resource__constraint:
return single_value.field_resource__constraint->is_value();
case StanzaErrorGroup::ALT_service__unavailable:
return single_value.field_service__unavailable->is_value();
case StanzaErrorGroup::ALT_subscription__required:
return single_value.field_subscription__required->is_value();
case StanzaErrorGroup::ALT_undefined__condition:
return single_value.field_undefined__condition->is_value();
case StanzaErrorGroup::ALT_unexpected__request:
return single_value.field_unexpected__request->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
}

StanzaErrorGroup StanzaErrorGroup_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
StanzaErrorGroup ret_val;
switch (single_value.union_selection) {
case StanzaErrorGroup::ALT_bad__request:
ret_val.bad__request() = single_value.field_bad__request->valueof();
break;
case StanzaErrorGroup::ALT_conflict:
ret_val.conflict() = single_value.field_conflict->valueof();
break;
case StanzaErrorGroup::ALT_feature__not__implemented:
ret_val.feature__not__implemented() = single_value.field_feature__not__implemented->valueof();
break;
case StanzaErrorGroup::ALT_forbidden:
ret_val.forbidden() = single_value.field_forbidden->valueof();
break;
case StanzaErrorGroup::ALT_gone:
ret_val.gone() = single_value.field_gone->valueof();
break;
case StanzaErrorGroup::ALT_internal__server__error:
ret_val.internal__server__error() = single_value.field_internal__server__error->valueof();
break;
case StanzaErrorGroup::ALT_item__not__found:
ret_val.item__not__found() = single_value.field_item__not__found->valueof();
break;
case StanzaErrorGroup::ALT_jid__malformed:
ret_val.jid__malformed() = single_value.field_jid__malformed->valueof();
break;
case StanzaErrorGroup::ALT_not__acceptable:
ret_val.not__acceptable() = single_value.field_not__acceptable->valueof();
break;
case StanzaErrorGroup::ALT_not__authorized:
ret_val.not__authorized() = single_value.field_not__authorized->valueof();
break;
case StanzaErrorGroup::ALT_not__allowed:
ret_val.not__allowed() = single_value.field_not__allowed->valueof();
break;
case StanzaErrorGroup::ALT_payment__required:
ret_val.payment__required() = single_value.field_payment__required->valueof();
break;
case StanzaErrorGroup::ALT_policy__violation:
ret_val.policy__violation() = single_value.field_policy__violation->valueof();
break;
case StanzaErrorGroup::ALT_recipient__unavailable:
ret_val.recipient__unavailable() = single_value.field_recipient__unavailable->valueof();
break;
case StanzaErrorGroup::ALT_redirect:
ret_val.redirect() = single_value.field_redirect->valueof();
break;
case StanzaErrorGroup::ALT_registration__required:
ret_val.registration__required() = single_value.field_registration__required->valueof();
break;
case StanzaErrorGroup::ALT_remote__server__not__found:
ret_val.remote__server__not__found() = single_value.field_remote__server__not__found->valueof();
break;
case StanzaErrorGroup::ALT_remote__server__timeout:
ret_val.remote__server__timeout() = single_value.field_remote__server__timeout->valueof();
break;
case StanzaErrorGroup::ALT_resource__constraint:
ret_val.resource__constraint() = single_value.field_resource__constraint->valueof();
break;
case StanzaErrorGroup::ALT_service__unavailable:
ret_val.service__unavailable() = single_value.field_service__unavailable->valueof();
break;
case StanzaErrorGroup::ALT_subscription__required:
ret_val.subscription__required() = single_value.field_subscription__required->valueof();
break;
case StanzaErrorGroup::ALT_undefined__condition:
ret_val.undefined__condition() = single_value.field_undefined__condition->valueof();
break;
case StanzaErrorGroup::ALT_unexpected__request:
ret_val.unexpected__request() = single_value.field_unexpected__request->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
return ret_val;
}

StanzaErrorGroup_template& StanzaErrorGroup_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return value_list.list_value[list_index];
}
void StanzaErrorGroup_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new StanzaErrorGroup_template[list_length];
}

Empty_template& StanzaErrorGroup_template::bad__request()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_bad__request) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_bad__request = new Empty_template(ANY_VALUE);
else single_value.field_bad__request = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_bad__request;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_bad__request;
}

const Empty_template& StanzaErrorGroup_template::bad__request() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field bad_request in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_bad__request) TTCN_error("Accessing non-selected field bad_request in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_bad__request;
}

Empty_template& StanzaErrorGroup_template::conflict()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_conflict) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_conflict = new Empty_template(ANY_VALUE);
else single_value.field_conflict = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_conflict;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_conflict;
}

const Empty_template& StanzaErrorGroup_template::conflict() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field conflict in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_conflict) TTCN_error("Accessing non-selected field conflict in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_conflict;
}

Empty_template& StanzaErrorGroup_template::feature__not__implemented()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_feature__not__implemented) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_feature__not__implemented = new Empty_template(ANY_VALUE);
else single_value.field_feature__not__implemented = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_feature__not__implemented;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_feature__not__implemented;
}

const Empty_template& StanzaErrorGroup_template::feature__not__implemented() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field feature_not_implemented in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_feature__not__implemented) TTCN_error("Accessing non-selected field feature_not_implemented in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_feature__not__implemented;
}

Empty_template& StanzaErrorGroup_template::forbidden()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_forbidden) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_forbidden = new Empty_template(ANY_VALUE);
else single_value.field_forbidden = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_forbidden;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_forbidden;
}

const Empty_template& StanzaErrorGroup_template::forbidden() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field forbidden in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_forbidden) TTCN_error("Accessing non-selected field forbidden in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_forbidden;
}

UNIVERSAL_CHARSTRING_template& StanzaErrorGroup_template::gone()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_gone) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_gone = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_gone = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = StanzaErrorGroup::ALT_gone;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_gone;
}

const UNIVERSAL_CHARSTRING_template& StanzaErrorGroup_template::gone() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field gone in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_gone) TTCN_error("Accessing non-selected field gone in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_gone;
}

Empty_template& StanzaErrorGroup_template::internal__server__error()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_internal__server__error) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_internal__server__error = new Empty_template(ANY_VALUE);
else single_value.field_internal__server__error = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_internal__server__error;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_internal__server__error;
}

const Empty_template& StanzaErrorGroup_template::internal__server__error() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field internal_server_error in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_internal__server__error) TTCN_error("Accessing non-selected field internal_server_error in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_internal__server__error;
}

Empty_template& StanzaErrorGroup_template::item__not__found()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_item__not__found) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_item__not__found = new Empty_template(ANY_VALUE);
else single_value.field_item__not__found = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_item__not__found;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_item__not__found;
}

const Empty_template& StanzaErrorGroup_template::item__not__found() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field item_not_found in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_item__not__found) TTCN_error("Accessing non-selected field item_not_found in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_item__not__found;
}

Empty_template& StanzaErrorGroup_template::jid__malformed()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_jid__malformed) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_jid__malformed = new Empty_template(ANY_VALUE);
else single_value.field_jid__malformed = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_jid__malformed;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_jid__malformed;
}

const Empty_template& StanzaErrorGroup_template::jid__malformed() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field jid_malformed in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_jid__malformed) TTCN_error("Accessing non-selected field jid_malformed in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_jid__malformed;
}

Empty_template& StanzaErrorGroup_template::not__acceptable()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_not__acceptable) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_not__acceptable = new Empty_template(ANY_VALUE);
else single_value.field_not__acceptable = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_not__acceptable;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_not__acceptable;
}

const Empty_template& StanzaErrorGroup_template::not__acceptable() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field not_acceptable in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_not__acceptable) TTCN_error("Accessing non-selected field not_acceptable in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_not__acceptable;
}

Empty_template& StanzaErrorGroup_template::not__authorized()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_not__authorized) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_not__authorized = new Empty_template(ANY_VALUE);
else single_value.field_not__authorized = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_not__authorized;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_not__authorized;
}

const Empty_template& StanzaErrorGroup_template::not__authorized() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field not_authorized in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_not__authorized) TTCN_error("Accessing non-selected field not_authorized in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_not__authorized;
}

Empty_template& StanzaErrorGroup_template::not__allowed()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_not__allowed) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_not__allowed = new Empty_template(ANY_VALUE);
else single_value.field_not__allowed = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_not__allowed;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_not__allowed;
}

const Empty_template& StanzaErrorGroup_template::not__allowed() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field not_allowed in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_not__allowed) TTCN_error("Accessing non-selected field not_allowed in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_not__allowed;
}

Empty_template& StanzaErrorGroup_template::payment__required()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_payment__required) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_payment__required = new Empty_template(ANY_VALUE);
else single_value.field_payment__required = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_payment__required;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_payment__required;
}

const Empty_template& StanzaErrorGroup_template::payment__required() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field payment_required in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_payment__required) TTCN_error("Accessing non-selected field payment_required in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_payment__required;
}

Empty_template& StanzaErrorGroup_template::policy__violation()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_policy__violation) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_policy__violation = new Empty_template(ANY_VALUE);
else single_value.field_policy__violation = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_policy__violation;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_policy__violation;
}

const Empty_template& StanzaErrorGroup_template::policy__violation() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field policy_violation in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_policy__violation) TTCN_error("Accessing non-selected field policy_violation in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_policy__violation;
}

Empty_template& StanzaErrorGroup_template::recipient__unavailable()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_recipient__unavailable) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_recipient__unavailable = new Empty_template(ANY_VALUE);
else single_value.field_recipient__unavailable = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_recipient__unavailable;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_recipient__unavailable;
}

const Empty_template& StanzaErrorGroup_template::recipient__unavailable() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field recipient_unavailable in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_recipient__unavailable) TTCN_error("Accessing non-selected field recipient_unavailable in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_recipient__unavailable;
}

UNIVERSAL_CHARSTRING_template& StanzaErrorGroup_template::redirect()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_redirect) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_redirect = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_redirect = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = StanzaErrorGroup::ALT_redirect;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_redirect;
}

const UNIVERSAL_CHARSTRING_template& StanzaErrorGroup_template::redirect() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field redirect in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_redirect) TTCN_error("Accessing non-selected field redirect in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_redirect;
}

Empty_template& StanzaErrorGroup_template::registration__required()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_registration__required) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_registration__required = new Empty_template(ANY_VALUE);
else single_value.field_registration__required = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_registration__required;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_registration__required;
}

const Empty_template& StanzaErrorGroup_template::registration__required() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field registration_required in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_registration__required) TTCN_error("Accessing non-selected field registration_required in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_registration__required;
}

Empty_template& StanzaErrorGroup_template::remote__server__not__found()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_remote__server__not__found) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_remote__server__not__found = new Empty_template(ANY_VALUE);
else single_value.field_remote__server__not__found = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_remote__server__not__found;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_remote__server__not__found;
}

const Empty_template& StanzaErrorGroup_template::remote__server__not__found() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field remote_server_not_found in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_remote__server__not__found) TTCN_error("Accessing non-selected field remote_server_not_found in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_remote__server__not__found;
}

Empty_template& StanzaErrorGroup_template::remote__server__timeout()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_remote__server__timeout) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_remote__server__timeout = new Empty_template(ANY_VALUE);
else single_value.field_remote__server__timeout = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_remote__server__timeout;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_remote__server__timeout;
}

const Empty_template& StanzaErrorGroup_template::remote__server__timeout() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field remote_server_timeout in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_remote__server__timeout) TTCN_error("Accessing non-selected field remote_server_timeout in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_remote__server__timeout;
}

Empty_template& StanzaErrorGroup_template::resource__constraint()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_resource__constraint) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_resource__constraint = new Empty_template(ANY_VALUE);
else single_value.field_resource__constraint = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_resource__constraint;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_resource__constraint;
}

const Empty_template& StanzaErrorGroup_template::resource__constraint() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field resource_constraint in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_resource__constraint) TTCN_error("Accessing non-selected field resource_constraint in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_resource__constraint;
}

Empty_template& StanzaErrorGroup_template::service__unavailable()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_service__unavailable) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_service__unavailable = new Empty_template(ANY_VALUE);
else single_value.field_service__unavailable = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_service__unavailable;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_service__unavailable;
}

const Empty_template& StanzaErrorGroup_template::service__unavailable() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field service_unavailable in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_service__unavailable) TTCN_error("Accessing non-selected field service_unavailable in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_service__unavailable;
}

Empty_template& StanzaErrorGroup_template::subscription__required()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_subscription__required) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_subscription__required = new Empty_template(ANY_VALUE);
else single_value.field_subscription__required = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_subscription__required;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_subscription__required;
}

const Empty_template& StanzaErrorGroup_template::subscription__required() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field subscription_required in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_subscription__required) TTCN_error("Accessing non-selected field subscription_required in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_subscription__required;
}

Empty_template& StanzaErrorGroup_template::undefined__condition()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_undefined__condition) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_undefined__condition = new Empty_template(ANY_VALUE);
else single_value.field_undefined__condition = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_undefined__condition;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_undefined__condition;
}

const Empty_template& StanzaErrorGroup_template::undefined__condition() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field undefined_condition in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_undefined__condition) TTCN_error("Accessing non-selected field undefined_condition in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_undefined__condition;
}

Empty_template& StanzaErrorGroup_template::unexpected__request()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StanzaErrorGroup::ALT_unexpected__request) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_unexpected__request = new Empty_template(ANY_VALUE);
else single_value.field_unexpected__request = new Empty_template;
single_value.union_selection = StanzaErrorGroup::ALT_unexpected__request;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_unexpected__request;
}

const Empty_template& StanzaErrorGroup_template::unexpected__request() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field unexpected_request in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
if (single_value.union_selection != StanzaErrorGroup::ALT_unexpected__request) TTCN_error("Accessing non-selected field unexpected_request in a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return *single_value.field_unexpected__request;
}

boolean StanzaErrorGroup_template::ischosen(StanzaErrorGroup::union_selection_type checked_selection) const
{
if (checked_selection == StanzaErrorGroup::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == StanzaErrorGroup::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
}
return FALSE;
}

void StanzaErrorGroup_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case StanzaErrorGroup::ALT_bad__request:
TTCN_Logger::log_event_str("{ bad_request := ");
single_value.field_bad__request->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_conflict:
TTCN_Logger::log_event_str("{ conflict := ");
single_value.field_conflict->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_feature__not__implemented:
TTCN_Logger::log_event_str("{ feature_not_implemented := ");
single_value.field_feature__not__implemented->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_forbidden:
TTCN_Logger::log_event_str("{ forbidden := ");
single_value.field_forbidden->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_gone:
TTCN_Logger::log_event_str("{ gone := ");
single_value.field_gone->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_internal__server__error:
TTCN_Logger::log_event_str("{ internal_server_error := ");
single_value.field_internal__server__error->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_item__not__found:
TTCN_Logger::log_event_str("{ item_not_found := ");
single_value.field_item__not__found->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_jid__malformed:
TTCN_Logger::log_event_str("{ jid_malformed := ");
single_value.field_jid__malformed->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_not__acceptable:
TTCN_Logger::log_event_str("{ not_acceptable := ");
single_value.field_not__acceptable->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_not__authorized:
TTCN_Logger::log_event_str("{ not_authorized := ");
single_value.field_not__authorized->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_not__allowed:
TTCN_Logger::log_event_str("{ not_allowed := ");
single_value.field_not__allowed->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_payment__required:
TTCN_Logger::log_event_str("{ payment_required := ");
single_value.field_payment__required->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_policy__violation:
TTCN_Logger::log_event_str("{ policy_violation := ");
single_value.field_policy__violation->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_recipient__unavailable:
TTCN_Logger::log_event_str("{ recipient_unavailable := ");
single_value.field_recipient__unavailable->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_redirect:
TTCN_Logger::log_event_str("{ redirect := ");
single_value.field_redirect->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_registration__required:
TTCN_Logger::log_event_str("{ registration_required := ");
single_value.field_registration__required->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_remote__server__not__found:
TTCN_Logger::log_event_str("{ remote_server_not_found := ");
single_value.field_remote__server__not__found->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_remote__server__timeout:
TTCN_Logger::log_event_str("{ remote_server_timeout := ");
single_value.field_remote__server__timeout->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_resource__constraint:
TTCN_Logger::log_event_str("{ resource_constraint := ");
single_value.field_resource__constraint->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_service__unavailable:
TTCN_Logger::log_event_str("{ service_unavailable := ");
single_value.field_service__unavailable->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_subscription__required:
TTCN_Logger::log_event_str("{ subscription_required := ");
single_value.field_subscription__required->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_undefined__condition:
TTCN_Logger::log_event_str("{ undefined_condition := ");
single_value.field_undefined__condition->log();
TTCN_Logger::log_event_str(" }");
break;
case StanzaErrorGroup::ALT_unexpected__request:
TTCN_Logger::log_event_str("{ unexpected_request := ");
single_value.field_unexpected__request->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void StanzaErrorGroup_template::log_match(const StanzaErrorGroup& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case StanzaErrorGroup::ALT_bad__request:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".bad_request");
single_value.field_bad__request->log_match(match_value.bad__request());
} else {
TTCN_Logger::log_event_str("{ bad_request := ");
single_value.field_bad__request->log_match(match_value.bad__request());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_conflict:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".conflict");
single_value.field_conflict->log_match(match_value.conflict());
} else {
TTCN_Logger::log_event_str("{ conflict := ");
single_value.field_conflict->log_match(match_value.conflict());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_feature__not__implemented:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".feature_not_implemented");
single_value.field_feature__not__implemented->log_match(match_value.feature__not__implemented());
} else {
TTCN_Logger::log_event_str("{ feature_not_implemented := ");
single_value.field_feature__not__implemented->log_match(match_value.feature__not__implemented());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_forbidden:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".forbidden");
single_value.field_forbidden->log_match(match_value.forbidden());
} else {
TTCN_Logger::log_event_str("{ forbidden := ");
single_value.field_forbidden->log_match(match_value.forbidden());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_gone:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".gone");
single_value.field_gone->log_match(match_value.gone());
} else {
TTCN_Logger::log_event_str("{ gone := ");
single_value.field_gone->log_match(match_value.gone());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_internal__server__error:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".internal_server_error");
single_value.field_internal__server__error->log_match(match_value.internal__server__error());
} else {
TTCN_Logger::log_event_str("{ internal_server_error := ");
single_value.field_internal__server__error->log_match(match_value.internal__server__error());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_item__not__found:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".item_not_found");
single_value.field_item__not__found->log_match(match_value.item__not__found());
} else {
TTCN_Logger::log_event_str("{ item_not_found := ");
single_value.field_item__not__found->log_match(match_value.item__not__found());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_jid__malformed:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".jid_malformed");
single_value.field_jid__malformed->log_match(match_value.jid__malformed());
} else {
TTCN_Logger::log_event_str("{ jid_malformed := ");
single_value.field_jid__malformed->log_match(match_value.jid__malformed());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_not__acceptable:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".not_acceptable");
single_value.field_not__acceptable->log_match(match_value.not__acceptable());
} else {
TTCN_Logger::log_event_str("{ not_acceptable := ");
single_value.field_not__acceptable->log_match(match_value.not__acceptable());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_not__authorized:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".not_authorized");
single_value.field_not__authorized->log_match(match_value.not__authorized());
} else {
TTCN_Logger::log_event_str("{ not_authorized := ");
single_value.field_not__authorized->log_match(match_value.not__authorized());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_not__allowed:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".not_allowed");
single_value.field_not__allowed->log_match(match_value.not__allowed());
} else {
TTCN_Logger::log_event_str("{ not_allowed := ");
single_value.field_not__allowed->log_match(match_value.not__allowed());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_payment__required:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".payment_required");
single_value.field_payment__required->log_match(match_value.payment__required());
} else {
TTCN_Logger::log_event_str("{ payment_required := ");
single_value.field_payment__required->log_match(match_value.payment__required());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_policy__violation:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".policy_violation");
single_value.field_policy__violation->log_match(match_value.policy__violation());
} else {
TTCN_Logger::log_event_str("{ policy_violation := ");
single_value.field_policy__violation->log_match(match_value.policy__violation());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_recipient__unavailable:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".recipient_unavailable");
single_value.field_recipient__unavailable->log_match(match_value.recipient__unavailable());
} else {
TTCN_Logger::log_event_str("{ recipient_unavailable := ");
single_value.field_recipient__unavailable->log_match(match_value.recipient__unavailable());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_redirect:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".redirect");
single_value.field_redirect->log_match(match_value.redirect());
} else {
TTCN_Logger::log_event_str("{ redirect := ");
single_value.field_redirect->log_match(match_value.redirect());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_registration__required:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".registration_required");
single_value.field_registration__required->log_match(match_value.registration__required());
} else {
TTCN_Logger::log_event_str("{ registration_required := ");
single_value.field_registration__required->log_match(match_value.registration__required());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_remote__server__not__found:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".remote_server_not_found");
single_value.field_remote__server__not__found->log_match(match_value.remote__server__not__found());
} else {
TTCN_Logger::log_event_str("{ remote_server_not_found := ");
single_value.field_remote__server__not__found->log_match(match_value.remote__server__not__found());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_remote__server__timeout:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".remote_server_timeout");
single_value.field_remote__server__timeout->log_match(match_value.remote__server__timeout());
} else {
TTCN_Logger::log_event_str("{ remote_server_timeout := ");
single_value.field_remote__server__timeout->log_match(match_value.remote__server__timeout());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_resource__constraint:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".resource_constraint");
single_value.field_resource__constraint->log_match(match_value.resource__constraint());
} else {
TTCN_Logger::log_event_str("{ resource_constraint := ");
single_value.field_resource__constraint->log_match(match_value.resource__constraint());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_service__unavailable:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".service_unavailable");
single_value.field_service__unavailable->log_match(match_value.service__unavailable());
} else {
TTCN_Logger::log_event_str("{ service_unavailable := ");
single_value.field_service__unavailable->log_match(match_value.service__unavailable());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_subscription__required:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".subscription_required");
single_value.field_subscription__required->log_match(match_value.subscription__required());
} else {
TTCN_Logger::log_event_str("{ subscription_required := ");
single_value.field_subscription__required->log_match(match_value.subscription__required());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_undefined__condition:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".undefined_condition");
single_value.field_undefined__condition->log_match(match_value.undefined__condition());
} else {
TTCN_Logger::log_event_str("{ undefined_condition := ");
single_value.field_undefined__condition->log_match(match_value.undefined__condition());
TTCN_Logger::log_event_str(" }");
}
break;
case StanzaErrorGroup::ALT_unexpected__request:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".unexpected_request");
single_value.field_unexpected__request->log_match(match_value.unexpected__request());
} else {
TTCN_Logger::log_event_str("{ unexpected_request := ");
single_value.field_unexpected__request->log_match(match_value.unexpected__request());
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void StanzaErrorGroup_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case StanzaErrorGroup::ALT_bad__request:
single_value.field_bad__request->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_conflict:
single_value.field_conflict->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_feature__not__implemented:
single_value.field_feature__not__implemented->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_forbidden:
single_value.field_forbidden->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_gone:
single_value.field_gone->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_internal__server__error:
single_value.field_internal__server__error->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_item__not__found:
single_value.field_item__not__found->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_jid__malformed:
single_value.field_jid__malformed->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_not__acceptable:
single_value.field_not__acceptable->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_not__authorized:
single_value.field_not__authorized->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_not__allowed:
single_value.field_not__allowed->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_payment__required:
single_value.field_payment__required->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_policy__violation:
single_value.field_policy__violation->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_recipient__unavailable:
single_value.field_recipient__unavailable->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_redirect:
single_value.field_redirect->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_registration__required:
single_value.field_registration__required->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_remote__server__not__found:
single_value.field_remote__server__not__found->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_remote__server__timeout:
single_value.field_remote__server__timeout->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_resource__constraint:
single_value.field_resource__constraint->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_service__unavailable:
single_value.field_service__unavailable->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_subscription__required:
single_value.field_subscription__required->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_undefined__condition:
single_value.field_undefined__condition->encode_text(text_buf);
break;
case StanzaErrorGroup::ALT_unexpected__request:
single_value.field_unexpected__request->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
}

void StanzaErrorGroup_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = StanzaErrorGroup::UNBOUND_VALUE;
StanzaErrorGroup::union_selection_type new_selection = (StanzaErrorGroup::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case StanzaErrorGroup::ALT_bad__request:
single_value.field_bad__request = new Empty_template;
single_value.field_bad__request->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_conflict:
single_value.field_conflict = new Empty_template;
single_value.field_conflict->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_feature__not__implemented:
single_value.field_feature__not__implemented = new Empty_template;
single_value.field_feature__not__implemented->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_forbidden:
single_value.field_forbidden = new Empty_template;
single_value.field_forbidden->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_gone:
single_value.field_gone = new UNIVERSAL_CHARSTRING_template;
single_value.field_gone->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_internal__server__error:
single_value.field_internal__server__error = new Empty_template;
single_value.field_internal__server__error->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_item__not__found:
single_value.field_item__not__found = new Empty_template;
single_value.field_item__not__found->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_jid__malformed:
single_value.field_jid__malformed = new Empty_template;
single_value.field_jid__malformed->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_not__acceptable:
single_value.field_not__acceptable = new Empty_template;
single_value.field_not__acceptable->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_not__authorized:
single_value.field_not__authorized = new Empty_template;
single_value.field_not__authorized->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_not__allowed:
single_value.field_not__allowed = new Empty_template;
single_value.field_not__allowed->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_payment__required:
single_value.field_payment__required = new Empty_template;
single_value.field_payment__required->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_policy__violation:
single_value.field_policy__violation = new Empty_template;
single_value.field_policy__violation->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_recipient__unavailable:
single_value.field_recipient__unavailable = new Empty_template;
single_value.field_recipient__unavailable->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_redirect:
single_value.field_redirect = new UNIVERSAL_CHARSTRING_template;
single_value.field_redirect->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_registration__required:
single_value.field_registration__required = new Empty_template;
single_value.field_registration__required->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_remote__server__not__found:
single_value.field_remote__server__not__found = new Empty_template;
single_value.field_remote__server__not__found->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_remote__server__timeout:
single_value.field_remote__server__timeout = new Empty_template;
single_value.field_remote__server__timeout->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_resource__constraint:
single_value.field_resource__constraint = new Empty_template;
single_value.field_resource__constraint->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_service__unavailable:
single_value.field_service__unavailable = new Empty_template;
single_value.field_service__unavailable->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_subscription__required:
single_value.field_subscription__required = new Empty_template;
single_value.field_subscription__required->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_undefined__condition:
single_value.field_undefined__condition = new Empty_template;
single_value.field_undefined__condition->decode_text(text_buf);
break;
case StanzaErrorGroup::ALT_unexpected__request:
single_value.field_unexpected__request = new Empty_template;
single_value.field_unexpected__request->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new StanzaErrorGroup_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
}

boolean StanzaErrorGroup_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean StanzaErrorGroup_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void StanzaErrorGroup_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup'");
    }
    if (strcmp("bad_request", param_field) == 0) {
      bad__request().set_param(param);
      return;
    } else if (strcmp("conflict", param_field) == 0) {
      conflict().set_param(param);
      return;
    } else if (strcmp("feature_not_implemented", param_field) == 0) {
      feature__not__implemented().set_param(param);
      return;
    } else if (strcmp("forbidden", param_field) == 0) {
      forbidden().set_param(param);
      return;
    } else if (strcmp("gone", param_field) == 0) {
      gone().set_param(param);
      return;
    } else if (strcmp("internal_server_error", param_field) == 0) {
      internal__server__error().set_param(param);
      return;
    } else if (strcmp("item_not_found", param_field) == 0) {
      item__not__found().set_param(param);
      return;
    } else if (strcmp("jid_malformed", param_field) == 0) {
      jid__malformed().set_param(param);
      return;
    } else if (strcmp("not_acceptable", param_field) == 0) {
      not__acceptable().set_param(param);
      return;
    } else if (strcmp("not_authorized", param_field) == 0) {
      not__authorized().set_param(param);
      return;
    } else if (strcmp("not_allowed", param_field) == 0) {
      not__allowed().set_param(param);
      return;
    } else if (strcmp("payment_required", param_field) == 0) {
      payment__required().set_param(param);
      return;
    } else if (strcmp("policy_violation", param_field) == 0) {
      policy__violation().set_param(param);
      return;
    } else if (strcmp("recipient_unavailable", param_field) == 0) {
      recipient__unavailable().set_param(param);
      return;
    } else if (strcmp("redirect", param_field) == 0) {
      redirect().set_param(param);
      return;
    } else if (strcmp("registration_required", param_field) == 0) {
      registration__required().set_param(param);
      return;
    } else if (strcmp("remote_server_not_found", param_field) == 0) {
      remote__server__not__found().set_param(param);
      return;
    } else if (strcmp("remote_server_timeout", param_field) == 0) {
      remote__server__timeout().set_param(param);
      return;
    } else if (strcmp("resource_constraint", param_field) == 0) {
      resource__constraint().set_param(param);
      return;
    } else if (strcmp("service_unavailable", param_field) == 0) {
      service__unavailable().set_param(param);
      return;
    } else if (strcmp("subscription_required", param_field) == 0) {
      subscription__required().set_param(param);
      return;
    } else if (strcmp("undefined_condition", param_field) == 0) {
      undefined__condition().set_param(param);
      return;
    } else if (strcmp("unexpected_request", param_field) == 0) {
      unexpected__request().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (param.get_size()==0) break;
    param.type_error("union template", "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = param.get_elem(param.get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "bad_request")) {
      bad__request().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "conflict")) {
      conflict().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "feature_not_implemented")) {
      feature__not__implemented().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "forbidden")) {
      forbidden().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "gone")) {
      gone().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "internal_server_error")) {
      internal__server__error().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "item_not_found")) {
      item__not__found().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "jid_malformed")) {
      jid__malformed().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "not_acceptable")) {
      not__acceptable().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "not_authorized")) {
      not__authorized().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "not_allowed")) {
      not__allowed().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "payment_required")) {
      payment__required().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "policy_violation")) {
      policy__violation().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "recipient_unavailable")) {
      recipient__unavailable().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "redirect")) {
      redirect().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "registration_required")) {
      registration__required().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "remote_server_not_found")) {
      remote__server__not__found().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "remote_server_timeout")) {
      remote__server__timeout().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "resource_constraint")) {
      resource__constraint().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "service_unavailable")) {
      service__unavailable().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "subscription_required")) {
      subscription__required().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "undefined_condition")) {
      undefined__condition().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "unexpected_request")) {
      unexpected__request().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
  }
  is_ifpresent = param.get_ifpresent();
}

void StanzaErrorGroup_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case StanzaErrorGroup::ALT_bad__request:
single_value.field_bad__request->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_conflict:
single_value.field_conflict->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_feature__not__implemented:
single_value.field_feature__not__implemented->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_forbidden:
single_value.field_forbidden->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_gone:
single_value.field_gone->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_internal__server__error:
single_value.field_internal__server__error->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_item__not__found:
single_value.field_item__not__found->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_jid__malformed:
single_value.field_jid__malformed->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_not__acceptable:
single_value.field_not__acceptable->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_not__authorized:
single_value.field_not__authorized->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_not__allowed:
single_value.field_not__allowed->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_payment__required:
single_value.field_payment__required->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_policy__violation:
single_value.field_policy__violation->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_recipient__unavailable:
single_value.field_recipient__unavailable->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_redirect:
single_value.field_redirect->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_registration__required:
single_value.field_registration__required->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_remote__server__not__found:
single_value.field_remote__server__not__found->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_remote__server__timeout:
single_value.field_remote__server__timeout->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_resource__constraint:
single_value.field_resource__constraint->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_service__unavailable:
single_value.field_service__unavailable->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_subscription__required:
single_value.field_subscription__required->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_undefined__condition:
single_value.field_undefined__condition->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
case StanzaErrorGroup::ALT_unexpected__request:
single_value.field_unexpected__request->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup.");
}
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.StanzaErrorGroup");
}

Text::Text()
{
  bound_flag = FALSE;
}

Text::Text(const OPTIONAL<CHARSTRING>& par_lang,
    const UNIVERSAL_CHARSTRING& par_base)
  :   field_lang(par_lang),
  field_base(par_base)
{
  bound_flag = TRUE;
}

Text::Text(const Text& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
bound_flag = TRUE;
if (other_value.lang().is_bound()) field_lang = other_value.lang();
else field_lang.clean_up();
if (other_value.base().is_bound()) field_base = other_value.base();
else field_base.clean_up();
}

void Text::clean_up()
{
field_lang.clean_up();
field_base.clean_up();
bound_flag = FALSE;
}

Text& Text::operator=(const Text& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
  bound_flag = TRUE;
  if (other_value.lang().is_bound()) field_lang = other_value.lang();
  else field_lang.clean_up();
  if (other_value.base().is_bound()) field_base = other_value.base();
  else field_base.clean_up();
}
return *this;
}

boolean Text::operator==(const Text& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_lang==other_value.field_lang
  && field_base==other_value.field_base;
}

boolean Text::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_lang.get_selection() || field_lang.is_bound()) return TRUE;
if(field_base.is_bound()) return TRUE;
return FALSE;
}
boolean Text::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_lang.get_selection() && !field_lang.is_value()) return FALSE;
if(!field_base.is_value()) return FALSE;
return TRUE;
}
int Text::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text");
  int ret_val = 1;
  if (field_lang.ispresent()) ret_val++;
  return ret_val;
}

void Text::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ lang := ");
field_lang.log();
TTCN_Logger::log_event_str(", base := ");
field_base.log();
TTCN_Logger::log_event_str(" }");
}

void Text::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@urn_ietf_params_xml_ns_xmpp_stanzas.Text'");
    }
    if (strcmp("lang", param_field) == 0) {
      lang().set_param(param);
      return;
    } else if (strcmp("base", param_field) == 0) {
      base().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@urn_ietf_params_xml_ns_xmpp_stanzas.Text'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lang().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) base().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lang")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lang().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "base")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          base().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @urn_ietf_params_xml_ns_xmpp_stanzas.Text: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@urn_ietf_params_xml_ns_xmpp_stanzas.Text");
  }
}

void Text::set_implicit_omit()
{
if (!lang().is_bound()) lang() = OMIT_VALUE;
else lang().set_implicit_omit();
if (base().is_bound()) base().set_implicit_omit();
}

void Text::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
field_lang.encode_text(text_buf);
field_base.encode_text(text_buf);
}

void Text::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_lang.decode_text(text_buf);
field_base.decode_text(text_buf);
}

void Text::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Text::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

char ** Text::collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const {
  size_t num_collected;
  char **collected_ns = Base_Type::collect_ns(p_td, num_collected, def_ns);
  try {
  char **new_ns;
  size_t num_new;
  bool def_ns_1 = false;
  new_ns = field_lang.collect_ns(Text_lang_xer_, num_new, def_ns);
  merge_ns(collected_ns, num_collected, new_ns, num_new);
  def_ns = def_ns || def_ns_1;
  new_ns = field_base.collect_ns(Text_base_xer_, num_new, def_ns);
  merge_ns(collected_ns, num_collected, new_ns, num_new);
  def_ns = def_ns || def_ns_1;
  }
  catch (...) {
    while (num_collected > 0) Free(collected_ns[--num_collected]);
    Free(collected_ns);
    throw;
  }
  num_ns = num_collected;
  return collected_ns;
}

boolean Text::can_start(const char *name, const char *uri, const XERdescriptor_t& xd, unsigned int flavor) {
  boolean e_xer = is_exer(flavor &= ~XER_RECOF);
  if (!e_xer || !((xd.xer_bits & UNTAGGED) || (flavor & (USE_NIL|XER_RECOF)))) return check_name(name, xd, e_xer) && (!e_xer || check_namespace(uri, xd));
  else if (CHARSTRING::can_start(name, uri, Text_lang_xer_, flavor)) return true;
  else if (UNIVERSAL_CHARSTRING::can_start(name, uri, Text_base_xer_, flavor)) return true;
  return false;
}

int Text::XER_encode(const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  int encoded_length=(int)p_buf.get_len();
  int e_xer = is_exer(p_flavor);
  const boolean omit_tag = e_xer && p_indent && ((p_td.xer_bits & (UNTAGGED|XER_ATTRIBUTE)) || (p_flavor & (USE_NIL|USE_TYPE_ATTR)));
  if (e_xer && (p_td.xer_bits & EMBED_VALUES)) p_flavor |= XER_CANONICAL;
  int is_indented = !is_canonical(p_flavor);
  size_t num_collected = 0;
  char **collected_ns = NULL;
  bool def_ns = false;
  if (e_xer) {
    if (p_indent == 0) {
      collected_ns = collect_ns(p_td, num_collected, def_ns);
    }
    else if ((p_flavor & DEF_NS_SQUASHED) && p_td.my_module && p_td.ns_index != -1){
      const namespace_t * ns = p_td.my_module->get_ns(p_td.ns_index);
      if (*ns->px == '\0') {
        collected_ns = Base_Type::collect_ns(p_td, num_collected, def_ns);
      }
    }
  }
  const boolean empty_ns_hack = e_xer && !omit_tag && (p_indent > 0)
    && (p_td.xer_bits & FORM_UNQUALIFIED)
    && p_td.my_module && p_td.ns_index != -1
    && *p_td.my_module->get_ns(p_td.ns_index)->px == '\0';
  const boolean delay_close = e_xer;
  size_t chopped_chars = 0;
  if (!omit_tag) {
    if (is_indented) do_indent(p_buf, p_indent);
    p_buf.put_c('<');
    if (e_xer) write_ns_prefix(p_td, p_buf);
    p_buf.put_s((size_t)p_td.namelens[e_xer]-(delay_close || (e_xer && (p_td.xer_bits & HAS_1UNTAGGED)))-(!is_indented || delay_close), (cbyte*)p_td.names[e_xer]);
  }
  else if (p_flavor & USE_TYPE_ATTR) {
    size_t buf_len = p_buf.get_len();
    const unsigned char * const buf_data = p_buf.get_data();
    if (buf_data[buf_len-1-chopped_chars] == '\n') ++chopped_chars;
    if (buf_data[buf_len-1-chopped_chars] == '>' ) ++chopped_chars;
    if (chopped_chars) {
      p_buf.increase_length(-chopped_chars);
    }
  }
  int sub_len=0, tmp_len; (void)tmp_len;
  p_flavor &= XER_MASK;
  { // !QN
  if (e_xer && num_collected) {
    size_t num_ns;
    for (num_ns = 0; num_ns < num_collected; ++num_ns) {
      p_buf.put_s(strlen(collected_ns[num_ns]), (cbyte*)collected_ns[num_ns]);
      Free(collected_ns[num_ns]);
    }
    Free(collected_ns);
  }

  if (def_ns) {
    p_flavor &= ~DEF_NS_SQUASHED;
    p_flavor |=  DEF_NS_PRESENT;
  }
  else if (empty_ns_hack) {
    p_buf.put_s(9, (cbyte*)" xmlns=''");
    p_flavor &= ~DEF_NS_PRESENT;
    p_flavor |=  DEF_NS_SQUASHED;
  }
  ec_1.set_msg("lang': ");
  tmp_len = field_lang.XER_encode(Text_lang_xer_, p_buf, p_flavor, p_indent+1, 0);
  if (!e_xer) sub_len += tmp_len;
  if (delay_close && (!omit_tag || chopped_chars)) p_buf.put_s(1, (cbyte*)">\n");
  ec_1.set_msg("base': ");
  sub_len += field_base.XER_encode(Text_base_xer_, p_buf, p_flavor, p_indent+!omit_tag, 0);
  } // QN?
  if (!omit_tag) {
  if (sub_len) {
    if (is_indented && !(e_xer && (p_td.xer_bits & (HAS_1UNTAGGED | USE_QNAME)))) {
      switch ((int)(e_xer && (p_td.xer_bits & USE_NIL))) {
      case 1: {
        const unsigned char *buf_end = p_buf.get_data() + (p_buf.get_len()-1);
        if (buf_end[-1] != '>' || *buf_end != '\n') break;
      }
      case 0:
        do_indent(p_buf, p_indent);
        break;
      }
    }
    p_buf.put_c('<');
    p_buf.put_c('/');
    if (e_xer) write_ns_prefix(p_td, p_buf);
    p_buf.put_s((size_t)p_td.namelens[e_xer]-!is_indented, (cbyte*)p_td.names[e_xer]);
  } else {
    p_buf.increase_length(-1);
    p_buf.put_s((size_t)2+is_indented, (cbyte*)"/>\n");
  }}
  return (int)p_buf.get_len() - encoded_length;
}

int Text::XER_decode(const XERdescriptor_t& p_td, XmlReaderWrap& p_reader, unsigned int p_flavor, embed_values_dec_struct_t*)
{
  bound_flag = TRUE;
  int e_xer = is_exer(p_flavor);
  int xerbits = p_td.xer_bits;
  if (p_flavor & XER_TOPLEVEL) xerbits &= ~UNTAGGED;
  const boolean omit_tag = e_xer && ((xerbits & (UNTAGGED|XER_ATTRIBUTE)) || (p_flavor & (USE_NIL|USE_TYPE_ATTR)));
  boolean tag_closed = (p_flavor & PARENT_CLOSED) != 0;
  const boolean parent_tag = e_xer && (p_flavor & (USE_TYPE_ATTR));
  (void)parent_tag;
  p_flavor &= XER_MASK;
  int rd_ok, xml_depth=-1, type;
  {
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  if (!omit_tag) for (rd_ok=p_reader.Ok(); rd_ok==1; rd_ok=p_reader.Read()) {
    type = p_reader.NodeType();
    if (type==XML_READER_TYPE_ELEMENT) {
      verify_name(p_reader, p_td, e_xer);
      xml_depth = p_reader.Depth();
      tag_closed = p_reader.IsEmptyElement();
      break;
    }
  }
if (e_xer) {
 if (!omit_tag || parent_tag) {
  if (Text_lang_xer_.dfeValue) field_lang = *static_cast<const CHARSTRING*>(Text_lang_xer_.dfeValue);
  else field_lang = OMIT_VALUE;
  for (rd_ok = p_reader.MoveToFirstAttribute(); rd_ok==1 && p_reader.NodeType()==XML_READER_TYPE_ATTRIBUTE; rd_ok = p_reader.AdvanceAttribute()) {
    if (p_reader.IsNamespaceDecl()) continue;
    const char *attr_name = (const char*)p_reader.LocalName();
    const char *ns_uri    = (const char*)p_reader.NamespaceUri();
    if (check_name(attr_name, Text_lang_xer_, 1) && check_namespace(ns_uri, Text_lang_xer_)) {
      ec_1.set_msg("lang': ");
      field_lang.XER_decode(Text_lang_xer_, p_reader, p_flavor | (p_td.xer_bits & USE_NIL), 0);
    } else    if (parent_tag && !strcmp(attr_name, "type") && !strcmp((const char*)p_reader.Prefix(), "xsi")) {} else
    {
      if (!p_reader.LocalName() || strcmp((const char*)p_reader.LocalName(), "schemaLocation") ||
          !p_reader.Prefix() || strcmp((const char*)p_reader.Prefix(), "xsi"))
      {
        ec_0.set_msg(" "); ec_1.set_msg(" ");
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Unexpected attribute '%s', ns '%s'", attr_name, ns_uri ? ns_uri : "");
      }
    }
  }
 }
  if ((!omit_tag || parent_tag) && !p_reader.IsEmptyElement()) rd_ok = p_reader.Read();
} else {
  if (!p_reader.IsEmptyElement()) p_reader.Read();
  {
    ec_1.set_msg("lang': ");
    field_lang.XER_decode(Text_lang_xer_, p_reader, p_flavor | (p_td.xer_bits & USE_NIL), 0);
  }
}
  if (e_xer && p_td.dfeValue && p_reader.IsEmptyElement()) {
    field_base = *static_cast<const UNIVERSAL_CHARSTRING*>(p_td.dfeValue);
  }
  else  {
    ec_1.set_msg("base': ");
    field_base.XER_decode(Text_base_xer_, p_reader, p_flavor | (p_td.xer_bits & USE_NIL)| (tag_closed ? PARENT_CLOSED : 0), 0);
  }
  } // errorcontext
  if (!omit_tag) {
    int current_depth;
    for (rd_ok = p_reader.Ok(); rd_ok == 1; rd_ok = p_reader.Read()) {
      type = p_reader.NodeType();
      if ((current_depth = p_reader.Depth()) > xml_depth) {
        if (XML_READER_TYPE_ELEMENT == type) {
          TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_TAG,
              "Unprocessed XML tag `%s'", (const char *)p_reader.Name());
        }
        continue;
      }
      else if (current_depth == xml_depth) {
        if (XML_READER_TYPE_ELEMENT == type) {
          verify_name(p_reader, p_td, e_xer);
          if (p_reader.IsEmptyElement()) {
            p_reader.Read();
            break;
          }
        }
        else if (XML_READER_TYPE_END_ELEMENT == type) {
          verify_end(p_reader, p_td, xml_depth, e_xer);
          rd_ok = p_reader.Read();
          break;
        }
      }
      else break;    }
  }
  return 1;
}

int Text::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_lang.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lang");
    enc_len += field_lang.JSON_encode(Text_lang_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "base");
    enc_len += field_base.JSON_encode(Text_base_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Text::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (4 == name_len && 0 == strncmp(fld_name, "lang", name_len)) {
        int ret_val = field_lang.JSON_decode(Text_lang_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lang");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (4 == name_len && 0 == strncmp(fld_name, "base", name_len)) {
        int ret_val = field_base.JSON_decode(Text_base_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "base");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_lang.is_bound()) {
    field_lang = OMIT_VALUE;
  }
  if (!field_base.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "base");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Text_template::single_value_struct {
CHARSTRING_template field_lang;
UNIVERSAL_CHARSTRING_template field_base;
};

void Text_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_lang = ANY_OR_OMIT;
single_value->field_base = ANY_VALUE;
}
}
}

void Text_template::copy_value(const Text& other_value)
{
single_value = new single_value_struct;
if (other_value.lang().is_bound()) {
  if (other_value.lang().ispresent()) single_value->field_lang = other_value.lang()();
  else single_value->field_lang = OMIT_VALUE;
} else {
  single_value->field_lang.clean_up();
}
if (other_value.base().is_bound()) {
  single_value->field_base = other_value.base();
} else {
  single_value->field_base.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Text_template::copy_template(const Text_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.lang().get_selection()) {
single_value->field_lang = other_value.lang();
} else {
single_value->field_lang.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.base().get_selection()) {
single_value->field_base = other_value.base();
} else {
single_value->field_base.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Text_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
break;
}
set_selection(other_value);
}

Text_template::Text_template()
{
}

Text_template::Text_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Text_template::Text_template(const Text& other_value)
{
copy_value(other_value);
}

Text_template::Text_template(const OPTIONAL<Text>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Text&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text from an unbound optional field.");
}
}

Text_template::Text_template(const Text_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Text_template::~Text_template()
{
clean_up();
}

Text_template& Text_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Text_template& Text_template::operator=(const Text& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Text_template& Text_template::operator=(const OPTIONAL<Text>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Text&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
}
return *this;
}

Text_template& Text_template::operator=(const Text_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Text_template::match(const Text& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.lang().is_bound()) return FALSE;
if((other_value.lang().ispresent() ? !single_value->field_lang.match((const CHARSTRING&)other_value.lang()) : !single_value->field_lang.match_omit()))return FALSE;
if(!other_value.base().is_bound()) return FALSE;
if(!single_value->field_base.match(other_value.base()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
}
return FALSE;
}

boolean Text_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_lang.is_omit() || single_value->field_lang.is_bound()) return TRUE;
if (single_value->field_base.is_bound()) return TRUE;
return FALSE;
}

boolean Text_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_lang.is_omit() && !single_value->field_lang.is_value()) return FALSE;
if (!single_value->field_base.is_value()) return FALSE;
return TRUE;
}

void Text_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Text Text_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
Text ret_val;
if (single_value->field_lang.is_omit()) ret_val.lang() = OMIT_VALUE;
else if (single_value->field_lang.is_bound()) {
ret_val.lang() = single_value->field_lang.valueof();
}
if (single_value->field_base.is_bound()) {
ret_val.base() = single_value->field_base.valueof();
}
return ret_val;
}

void Text_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Text_template[list_length];
}

Text_template& Text_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
return value_list.list_value[list_index];
}

CHARSTRING_template& Text_template::lang()
{
set_specific();
return single_value->field_lang;
}

const CHARSTRING_template& Text_template::lang() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lang of a non-specific template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
return single_value->field_lang;
}

UNIVERSAL_CHARSTRING_template& Text_template::base()
{
set_specific();
return single_value->field_base;
}

const UNIVERSAL_CHARSTRING_template& Text_template::base() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field base of a non-specific template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
return single_value->field_base;
}

int Text_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_lang.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
  }
  return 0;
}

void Text_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ lang := ");
single_value->field_lang.log();
TTCN_Logger::log_event_str(", base := ");
single_value->field_base.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Text_template::log_match(const Text& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.lang().ispresent()){
if(!single_value->field_lang.match(match_value.lang())){
TTCN_Logger::log_logmatch_info(".lang");
single_value->field_lang.log_match(match_value.lang());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_lang.match_omit()){
 TTCN_Logger::log_logmatch_info(".lang := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_lang.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_base.match(match_value.base())){
TTCN_Logger::log_logmatch_info(".base");
single_value->field_base.log_match(match_value.base());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ lang := ");
if (match_value.lang().ispresent()) single_value->field_lang.log_match(match_value.lang());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_lang.log();
if (single_value->field_lang.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", base := ");
single_value->field_base.log_match(match_value.base());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Text_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_lang.encode_text(text_buf);
single_value->field_base.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
}
}

void Text_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_lang.decode_text(text_buf);
single_value->field_base.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Text_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text.");
}
}

void Text_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@urn_ietf_params_xml_ns_xmpp_stanzas.Text'");
    }
    if (strcmp("lang", param_field) == 0) {
      lang().set_param(param);
      return;
    } else if (strcmp("base", param_field) == 0) {
      base().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@urn_ietf_params_xml_ns_xmpp_stanzas.Text'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @urn_ietf_params_xml_ns_xmpp_stanzas.Text has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lang().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) base().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lang")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lang().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "base")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          base().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @urn_ietf_params_xml_ns_xmpp_stanzas.Text: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@urn_ietf_params_xml_ns_xmpp_stanzas.Text");
  }
  is_ifpresent = param.get_ifpresent();
}

void Text_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_lang.check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.Text");
single_value->field_base.check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.Text");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_stanzas.Text");
}

boolean Text_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean Text_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}


/* Bodies of static functions */

static void pre_init_module()
{
http__www__w3__org__XML__1998__namespace::module_object.pre_init_module();
}

static void post_init_module()
{
http__www__w3__org__XML__1998__namespace::module_object.post_init_module();
}


} /* end of namespace */
