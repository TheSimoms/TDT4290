// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for user (user@user-multicom) on Fri Oct  9 11:34:10 2015

// Copyright Ericsson Telecom AB 2000-2014

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "urn_ietf_params_xml_ns_xmpp_streams.hh"

namespace urn__ietf__params__xml__ns__xmpp__streams {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x2e, 0x22, 0x2d, 0xf4, 0x0e, 0x19, 0xa8, 0x0a, 0x1f, 0x40, 0xe3, 0x00, 0xea, 0x10, 0x60, 0x2d };

/* Global variable definitions */

const XERdescriptor_t       Empty_xer_ = { {"Empty>\n", "empty>\n"}, {7, 7}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_JSONdescriptor_t Empty_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t Empty_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Empty", NULL, NULL, NULL, &Empty_xer_, &Empty_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Bad__format_xer_ = { {"Bad_format>\n", "bad-format>\n"}, {12, 12}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Bad__format_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Bad_format", NULL, NULL, NULL, &Bad__format_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Bad__namespace__prefix_xer_ = { {"Bad_namespace_prefix>\n", "bad-namespace-prefix>\n"}, {22, 22}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Bad__namespace__prefix_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Bad_namespace_prefix", NULL, NULL, NULL, &Bad__namespace__prefix_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Conflict_xer_ = { {"Conflict>\n", "conflict>\n"}, {10, 10}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Conflict_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Conflict", NULL, NULL, NULL, &Conflict_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Connection__timeout_xer_ = { {"Connection_timeout>\n", "connection-timeout>\n"}, {20, 20}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Connection__timeout_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Connection_timeout", NULL, NULL, NULL, &Connection__timeout_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Host__gone_xer_ = { {"Host_gone>\n", "host-gone>\n"}, {11, 11}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Host__gone_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Host_gone", NULL, NULL, NULL, &Host__gone_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Host__unknown_xer_ = { {"Host_unknown>\n", "host-unknown>\n"}, {14, 14}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Host__unknown_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Host_unknown", NULL, NULL, NULL, &Host__unknown_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Improper__addressing_xer_ = { {"Improper_addressing>\n", "improper-addressing>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Improper__addressing_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Improper_addressing", NULL, NULL, NULL, &Improper__addressing_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Internal__server__error_xer_ = { {"Internal_server_error>\n", "internal-server-error>\n"}, {23, 23}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Internal__server__error_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Internal_server_error", NULL, NULL, NULL, &Internal__server__error_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Invalid__from_xer_ = { {"Invalid_from>\n", "invalid-from>\n"}, {14, 14}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Invalid__from_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Invalid_from", NULL, NULL, NULL, &Invalid__from_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Invalid__id_xer_ = { {"Invalid_id>\n", "invalid-id>\n"}, {12, 12}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Invalid__id_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Invalid_id", NULL, NULL, NULL, &Invalid__id_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Invalid__namespace_xer_ = { {"Invalid_namespace>\n", "invalid-namespace>\n"}, {19, 19}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Invalid__namespace_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Invalid_namespace", NULL, NULL, NULL, &Invalid__namespace_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Invalid__xml_xer_ = { {"Invalid_xml>\n", "invalid-xml>\n"}, {13, 13}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Invalid__xml_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Invalid_xml", NULL, NULL, NULL, &Invalid__xml_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Not__authorized_xer_ = { {"Not_authorized>\n", "not-authorized>\n"}, {16, 16}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Not__authorized_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Not_authorized", NULL, NULL, NULL, &Not__authorized_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Not__well__formed_xer_ = { {"Not_well_formed>\n", "not-well-formed>\n"}, {17, 17}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Not__well__formed_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Not_well_formed", NULL, NULL, NULL, &Not__well__formed_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Policy__violation_xer_ = { {"Policy_violation>\n", "policy-violation>\n"}, {18, 18}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Policy__violation_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Policy_violation", NULL, NULL, NULL, &Policy__violation_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Remote__connection__failed_xer_ = { {"Remote_connection_failed>\n", "remote-connection-failed>\n"}, {26, 26}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Remote__connection__failed_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Remote_connection_failed", NULL, NULL, NULL, &Remote__connection__failed_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Reset_xer_ = { {"Reset>\n", "reset>\n"}, {7, 7}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Reset_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Reset", NULL, NULL, NULL, &Reset_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Resource__constraint_xer_ = { {"Resource_constraint>\n", "resource-constraint>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Resource__constraint_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Resource_constraint", NULL, NULL, NULL, &Resource__constraint_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Restricted__xml_xer_ = { {"Restricted_xml>\n", "restricted-xml>\n"}, {16, 16}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Restricted__xml_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Restricted_xml", NULL, NULL, NULL, &Restricted__xml_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       See__other__host_xer_ = { {"See_other_host>\n", "see-other-host>\n"}, {16, 16}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t See__other__host_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.See_other_host", NULL, &UsefulTtcn3Types::utf8string_raw_, &UNIVERSAL_CHARSTRING_text_, &See__other__host_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       System__shutdown_xer_ = { {"System_shutdown>\n", "system-shutdown>\n"}, {17, 17}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t System__shutdown_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.System_shutdown", NULL, NULL, NULL, &System__shutdown_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Undefined__condition_xer_ = { {"Undefined_condition>\n", "undefined-condition>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Undefined__condition_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Undefined_condition", NULL, NULL, NULL, &Undefined__condition_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Unsupported__encoding_xer_ = { {"Unsupported_encoding>\n", "unsupported-encoding>\n"}, {22, 22}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Unsupported__encoding_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Unsupported_encoding", NULL, NULL, NULL, &Unsupported__encoding_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Unsupported__stanza__type_xer_ = { {"Unsupported_stanza_type>\n", "unsupported-stanza-type>\n"}, {25, 25}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Unsupported__stanza__type_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Unsupported_stanza_type", NULL, NULL, NULL, &Unsupported__stanza__type_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Unsupported__version_xer_ = { {"Unsupported_version>\n", "unsupported-version>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Unsupported__version_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Unsupported_version", NULL, NULL, NULL, &Unsupported__version_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_xer_ = { {"StreamErrorGroup>\n", "StreamErrorGroup>\n"}, {18, 18}, 0 |UNTAGGED, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_JSONdescriptor_t StreamErrorGroup_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup", NULL, NULL, NULL, &StreamErrorGroup_xer_, &StreamErrorGroup_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_bad__format_xer_ = { {"bad_format>\n", "bad-format>\n"}, {12, 12}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_bad__format_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.bad_format", NULL, NULL, NULL, &StreamErrorGroup_bad__format_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_bad__namespace__prefix_xer_ = { {"bad_namespace_prefix>\n", "bad-namespace-prefix>\n"}, {22, 22}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_bad__namespace__prefix_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.bad_namespace_prefix", NULL, NULL, NULL, &StreamErrorGroup_bad__namespace__prefix_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_conflict_xer_ = { {"conflict>\n", "conflict>\n"}, {10, 10}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_conflict_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.conflict", NULL, NULL, NULL, &StreamErrorGroup_conflict_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_connection__timeout_xer_ = { {"connection_timeout>\n", "connection-timeout>\n"}, {20, 20}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_connection__timeout_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.connection_timeout", NULL, NULL, NULL, &StreamErrorGroup_connection__timeout_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_host__gone_xer_ = { {"host_gone>\n", "host-gone>\n"}, {11, 11}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_host__gone_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.host_gone", NULL, NULL, NULL, &StreamErrorGroup_host__gone_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_host__unknown_xer_ = { {"host_unknown>\n", "host-unknown>\n"}, {14, 14}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_host__unknown_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.host_unknown", NULL, NULL, NULL, &StreamErrorGroup_host__unknown_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_improper__addressing_xer_ = { {"improper_addressing>\n", "improper-addressing>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_improper__addressing_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.improper_addressing", NULL, NULL, NULL, &StreamErrorGroup_improper__addressing_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_internal__server__error_xer_ = { {"internal_server_error>\n", "internal-server-error>\n"}, {23, 23}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_internal__server__error_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.internal_server_error", NULL, NULL, NULL, &StreamErrorGroup_internal__server__error_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_invalid__from_xer_ = { {"invalid_from>\n", "invalid-from>\n"}, {14, 14}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_invalid__from_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.invalid_from", NULL, NULL, NULL, &StreamErrorGroup_invalid__from_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_invalid__id_xer_ = { {"invalid_id>\n", "invalid-id>\n"}, {12, 12}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_invalid__id_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.invalid_id", NULL, NULL, NULL, &StreamErrorGroup_invalid__id_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_invalid__namespace_xer_ = { {"invalid_namespace>\n", "invalid-namespace>\n"}, {19, 19}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_invalid__namespace_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.invalid_namespace", NULL, NULL, NULL, &StreamErrorGroup_invalid__namespace_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_invalid__xml_xer_ = { {"invalid_xml>\n", "invalid-xml>\n"}, {13, 13}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_invalid__xml_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.invalid_xml", NULL, NULL, NULL, &StreamErrorGroup_invalid__xml_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_not__authorized_xer_ = { {"not_authorized>\n", "not-authorized>\n"}, {16, 16}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_not__authorized_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.not_authorized", NULL, NULL, NULL, &StreamErrorGroup_not__authorized_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_not__well__formed_xer_ = { {"not_well_formed>\n", "not-well-formed>\n"}, {17, 17}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_not__well__formed_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.not_well_formed", NULL, NULL, NULL, &StreamErrorGroup_not__well__formed_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_policy__violation_xer_ = { {"policy_violation>\n", "policy-violation>\n"}, {18, 18}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_policy__violation_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.policy_violation", NULL, NULL, NULL, &StreamErrorGroup_policy__violation_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_remote__connection__failed_xer_ = { {"remote_connection_failed>\n", "remote-connection-failed>\n"}, {26, 26}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_remote__connection__failed_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.remote_connection_failed", NULL, NULL, NULL, &StreamErrorGroup_remote__connection__failed_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_reset_xer_ = { {"reset>\n", "reset>\n"}, {7, 7}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_reset_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.reset", NULL, NULL, NULL, &StreamErrorGroup_reset_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_resource__constraint_xer_ = { {"resource_constraint>\n", "resource-constraint>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_resource__constraint_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.resource_constraint", NULL, NULL, NULL, &StreamErrorGroup_resource__constraint_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_restricted__xml_xer_ = { {"restricted_xml>\n", "restricted-xml>\n"}, {16, 16}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_restricted__xml_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.restricted_xml", NULL, NULL, NULL, &StreamErrorGroup_restricted__xml_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_see__other__host_xer_ = { {"see_other_host>\n", "see-other-host>\n"}, {16, 16}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_see__other__host_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.see_other_host", NULL, &UsefulTtcn3Types::utf8string_raw_, &UNIVERSAL_CHARSTRING_text_, &StreamErrorGroup_see__other__host_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_system__shutdown_xer_ = { {"system_shutdown>\n", "system-shutdown>\n"}, {17, 17}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_system__shutdown_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.system_shutdown", NULL, NULL, NULL, &StreamErrorGroup_system__shutdown_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_undefined__condition_xer_ = { {"undefined_condition>\n", "undefined-condition>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_undefined__condition_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.undefined_condition", NULL, NULL, NULL, &StreamErrorGroup_undefined__condition_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_unsupported__encoding_xer_ = { {"unsupported_encoding>\n", "unsupported-encoding>\n"}, {22, 22}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_unsupported__encoding_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.unsupported_encoding", NULL, NULL, NULL, &StreamErrorGroup_unsupported__encoding_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_unsupported__stanza__type_xer_ = { {"unsupported_stanza_type>\n", "unsupported-stanza-type>\n"}, {25, 25}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_unsupported__stanza__type_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.unsupported_stanza_type", NULL, NULL, NULL, &StreamErrorGroup_unsupported__stanza__type_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       StreamErrorGroup_unsupported__version_xer_ = { {"unsupported_version>\n", "unsupported-version>\n"}, {21, 21}, 0, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t StreamErrorGroup_unsupported__version_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.unsupported_version", NULL, NULL, NULL, &StreamErrorGroup_unsupported__version_xer_, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Text_base_xer_ = { {"base>\n", "base>\n"}, {6, 6}, 0 |UNTAGGED, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Text_base_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Text.base", NULL, &UsefulTtcn3Types::utf8string_raw_, &UNIVERSAL_CHARSTRING_text_, &Text_base_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Text_xer_ = { {"Text>\n", "text>\n"}, {6, 6}, 0 |HAS_1UNTAGGED, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_JSONdescriptor_t Text_json_ = { false, NULL, false, NULL };
const TTCN_Typedescriptor_t Text_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Text", NULL, NULL, NULL, &Text_xer_, &Text_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Text_lang_xer_ = { {"lang>\n", "lang>\n"}, {6, 6}, 0 |XER_ATTRIBUTE |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, 11, 0, NULL, NULL };
const TTCN_Typedescriptor_t Text_lang_descr_ = { "@urn_ietf_params_xml_ns_xmpp_streams.Text.lang", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Text_lang_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 21;
static const namespace_t xml_namespaces[num_namespaces+1] = {
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { "urn:ietf:params:xml:ns:xmpp-streams", "tq0008" },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { NULL, NULL },
  { "http://www.w3.org/2001/XMLSchema-instance", "xsi" }
};

TTCN_Module module_object("urn_ietf_params_xml_ns_xmpp_streams", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 21LU, xml_namespaces, post_init_module, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_3,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

Empty::Empty()
{
enum_value = UNBOUND_VALUE;
}

Empty::Empty(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

Empty::Empty(enum_type other_value)
{
enum_value = other_value;
}

Empty::Empty(const Empty& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
enum_value = other_value.enum_value;
}

Empty& Empty::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

Empty& Empty::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

Empty& Empty::operator=(const Empty& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
enum_value = other_value.enum_value;
return *this;
}

boolean Empty::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
return enum_value == other_value;
}

boolean Empty::operator==(const Empty& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
return enum_value == other_value.enum_value;
}

boolean Empty::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
return enum_value < other_value;
}

boolean Empty::operator<(const Empty& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
return enum_value < other_value.enum_value;
}

boolean Empty::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
return enum_value > other_value;
}

boolean Empty::operator>(const Empty& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
return enum_value > other_value.enum_value;
}

const char *Empty::enum_to_str(enum_type enum_par, boolean txt)
{
switch (enum_par) {
case x: if (txt) return " "; else return "x";
default: return "<unknown>";
}
}

Empty::enum_type Empty::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, " ") || !strcmp(str_par, "x")) return x;
else return UNKNOWN_VALUE;
}

boolean Empty::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
return TRUE;
default:
return FALSE;
}
}

int Empty::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int Empty::enum2int(const Empty& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

Empty::operator Empty::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
return enum_value;
}

void Empty::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void Empty::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@urn_ietf_params_xml_ns_xmpp_streams.Empty");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
     param.error("Invalid enumerated value for type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
  }
}

void Empty::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
text_buf.push_int(enum_value);
}

void Empty::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.", enum_value);
}

void Empty::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Empty::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

boolean Empty::can_start(const char *name, const char *uri, const XERdescriptor_t& xd, unsigned int flavor) {
  boolean exer = is_exer(flavor);
  return check_name(name, xd, exer) && (!exer || check_namespace(uri, xd));
}

int Empty::XER_encode(const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const
{
  int encoded_length=(int)p_buf.get_len();
  const boolean e_xer = is_exer(p_flavor);
  p_flavor |= (SIMPLE_TYPE | BXER_EMPTY_ELEM);
  if (begin_xml(p_td, p_buf, p_flavor, p_indent, false) == -1) --encoded_length;
  if (!e_xer) p_buf.put_c('<');
  {
    const char * enumval = enum_to_str(enum_value, e_xer);
    p_buf.put_s(strlen(enumval), (const unsigned char*)enumval);
  }
  if (!e_xer) p_buf.put_s(2, (const unsigned char*)"/>");
  end_xml(p_td, p_buf, p_flavor, p_indent, false);
  return (int)p_buf.get_len() - encoded_length;
}

int Empty::XER_decode(const XERdescriptor_t& p_td, XmlReaderWrap& p_reader, unsigned int p_flavor, embed_values_dec_struct_t*)
{
  int rd_ok = 1, type;
  const int e_xer = is_exer(p_flavor);
  const boolean name_tag = !((!e_xer && is_record_of(p_flavor)) || (e_xer && ((p_td.xer_bits & UNTAGGED) ||(is_record_of(p_flavor) && is_exerlist(p_flavor)))));
  if (e_xer && ((p_td.xer_bits & XER_ATTRIBUTE) || is_exerlist(p_flavor))) {
    if ((p_td.xer_bits & XER_ATTRIBUTE)) verify_name(p_reader, p_td, e_xer);
    const char * value = (const char *)p_reader.Value();
    if (value) {
        enum_value = str_to_enum(value);
    }
  }
  else {
    if (name_tag)      for (; rd_ok == 1; rd_ok = p_reader.Read()) {
        type = p_reader.NodeType();
        if (XML_READER_TYPE_ELEMENT == type) {
          rd_ok = p_reader.Read();
          break;
        }
      }
    for (; rd_ok == 1; rd_ok = p_reader.Read()) {
      type = p_reader.NodeType();
      if (!e_xer && XML_READER_TYPE_ELEMENT == type) break;
      if (XML_READER_TYPE_TEXT == type) break;
    }
    const char *local_name = e_xer ? (const char *)p_reader.Value() : (const char *)p_reader.Name();
    if (!local_name) ; else    {
      for (; '\t'==*local_name || '\n'==*local_name; ++local_name) ;
      enum_value = str_to_enum(local_name);
    }
    if (name_tag)
      for (rd_ok = p_reader.Read(); rd_ok == 1; rd_ok = p_reader.Read()) {
        type = p_reader.NodeType();
        if (XML_READER_TYPE_END_ELEMENT == type) {
          rd_ok = p_reader.Read();
          break;
        }
      }
    else rd_ok = p_reader.Read();
  }
  if (e_xer && (p_flavor & EXIT_ON_ERROR) && UNKNOWN_VALUE == enum_value) clean_up();
  int decoded_length = 0;
  return decoded_length;
}

int Empty::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int Empty::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void Empty_template::copy_template(const Empty_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Empty_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
}
}

Empty_template::Empty_template()
{
}

Empty_template::Empty_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Empty_template::Empty_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!Empty::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty with unknown numeric value %d.", other_value);
single_value = (Empty::enum_type)other_value;
}

Empty_template::Empty_template(Empty::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

Empty_template::Empty_template(const Empty& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == Empty::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
single_value = other_value.enum_value;
}

Empty_template::Empty_template(const OPTIONAL<Empty>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (Empty::enum_type)(const Empty&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty from an unbound optional field.");
}
}

Empty_template::Empty_template(const Empty_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

Empty_template::~Empty_template()
{
clean_up();
}

boolean Empty_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean Empty_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != Empty::UNBOUND_VALUE;
}

void Empty_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

Empty_template& Empty_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Empty_template& Empty_template::operator=(int other_value)
{
if (!Empty::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (Empty::enum_type)other_value;
return *this;
}

Empty_template& Empty_template::operator=(Empty::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

Empty_template& Empty_template::operator=(const Empty& other_value)
{
if (other_value.enum_value == Empty::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

Empty_template& Empty_template::operator=(const OPTIONAL<Empty>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (Empty::enum_type)(const Empty&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
}
return *this;
}

Empty_template& Empty_template::operator=(const Empty_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Empty_template::match(Empty::enum_type other_value) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
}
return FALSE;
}

boolean Empty_template::match(const Empty& other_value) const
{
if (other_value.enum_value == Empty::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty with an unbound value.");
return match(other_value.enum_value);
}

Empty::enum_type Empty_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
return single_value;
}

void Empty_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Empty_template[list_length];
}

Empty_template& Empty_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
return value_list.list_value[list_index];
}

void Empty_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(Empty::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Empty_template::log_match(const Empty& match_value) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void Empty_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
}
}

void Empty_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (Empty::enum_type)text_buf.pull_int().get_val();
if (!Empty::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Empty_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
}
}

boolean Empty_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean Empty_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void Empty_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Enumerated: {
    Empty::enum_type enum_val = Empty::str_to_enum(param.get_enumerated());
    if (!Empty::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @urn_ietf_params_xml_ns_xmpp_streams.Empty.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@urn_ietf_params_xml_ns_xmpp_streams.Empty");
  }
  is_ifpresent = param.get_ifpresent();
}

void Empty_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.Empty");
}

void StreamErrorGroup::copy_value(const StreamErrorGroup& other_value)
{
switch (other_value.union_selection) {
case ALT_bad__format:
field_bad__format = new Empty(*other_value.field_bad__format);
break;
case ALT_bad__namespace__prefix:
field_bad__namespace__prefix = new Empty(*other_value.field_bad__namespace__prefix);
break;
case ALT_conflict:
field_conflict = new Empty(*other_value.field_conflict);
break;
case ALT_connection__timeout:
field_connection__timeout = new Empty(*other_value.field_connection__timeout);
break;
case ALT_host__gone:
field_host__gone = new Empty(*other_value.field_host__gone);
break;
case ALT_host__unknown:
field_host__unknown = new Empty(*other_value.field_host__unknown);
break;
case ALT_improper__addressing:
field_improper__addressing = new Empty(*other_value.field_improper__addressing);
break;
case ALT_internal__server__error:
field_internal__server__error = new Empty(*other_value.field_internal__server__error);
break;
case ALT_invalid__from:
field_invalid__from = new Empty(*other_value.field_invalid__from);
break;
case ALT_invalid__id:
field_invalid__id = new Empty(*other_value.field_invalid__id);
break;
case ALT_invalid__namespace:
field_invalid__namespace = new Empty(*other_value.field_invalid__namespace);
break;
case ALT_invalid__xml:
field_invalid__xml = new Empty(*other_value.field_invalid__xml);
break;
case ALT_not__authorized:
field_not__authorized = new Empty(*other_value.field_not__authorized);
break;
case ALT_not__well__formed:
field_not__well__formed = new Empty(*other_value.field_not__well__formed);
break;
case ALT_policy__violation:
field_policy__violation = new Empty(*other_value.field_policy__violation);
break;
case ALT_remote__connection__failed:
field_remote__connection__failed = new Empty(*other_value.field_remote__connection__failed);
break;
case ALT_reset:
field_reset = new Empty(*other_value.field_reset);
break;
case ALT_resource__constraint:
field_resource__constraint = new Empty(*other_value.field_resource__constraint);
break;
case ALT_restricted__xml:
field_restricted__xml = new Empty(*other_value.field_restricted__xml);
break;
case ALT_see__other__host:
field_see__other__host = new UNIVERSAL_CHARSTRING(*other_value.field_see__other__host);
break;
case ALT_system__shutdown:
field_system__shutdown = new Empty(*other_value.field_system__shutdown);
break;
case ALT_undefined__condition:
field_undefined__condition = new Empty(*other_value.field_undefined__condition);
break;
case ALT_unsupported__encoding:
field_unsupported__encoding = new Empty(*other_value.field_unsupported__encoding);
break;
case ALT_unsupported__stanza__type:
field_unsupported__stanza__type = new Empty(*other_value.field_unsupported__stanza__type);
break;
case ALT_unsupported__version:
field_unsupported__version = new Empty(*other_value.field_unsupported__version);
break;
default:
TTCN_error("Assignment of an unbound union value of type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
union_selection = other_value.union_selection;
}

StreamErrorGroup::StreamErrorGroup()
{
union_selection = UNBOUND_VALUE;
}

StreamErrorGroup::StreamErrorGroup(const StreamErrorGroup& other_value)
: Base_Type(){
copy_value(other_value);
}

StreamErrorGroup::~StreamErrorGroup()
{
clean_up();
}

StreamErrorGroup& StreamErrorGroup::operator=(const StreamErrorGroup& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean StreamErrorGroup::operator==(const StreamErrorGroup& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_bad__format:
return *field_bad__format == *other_value.field_bad__format;
case ALT_bad__namespace__prefix:
return *field_bad__namespace__prefix == *other_value.field_bad__namespace__prefix;
case ALT_conflict:
return *field_conflict == *other_value.field_conflict;
case ALT_connection__timeout:
return *field_connection__timeout == *other_value.field_connection__timeout;
case ALT_host__gone:
return *field_host__gone == *other_value.field_host__gone;
case ALT_host__unknown:
return *field_host__unknown == *other_value.field_host__unknown;
case ALT_improper__addressing:
return *field_improper__addressing == *other_value.field_improper__addressing;
case ALT_internal__server__error:
return *field_internal__server__error == *other_value.field_internal__server__error;
case ALT_invalid__from:
return *field_invalid__from == *other_value.field_invalid__from;
case ALT_invalid__id:
return *field_invalid__id == *other_value.field_invalid__id;
case ALT_invalid__namespace:
return *field_invalid__namespace == *other_value.field_invalid__namespace;
case ALT_invalid__xml:
return *field_invalid__xml == *other_value.field_invalid__xml;
case ALT_not__authorized:
return *field_not__authorized == *other_value.field_not__authorized;
case ALT_not__well__formed:
return *field_not__well__formed == *other_value.field_not__well__formed;
case ALT_policy__violation:
return *field_policy__violation == *other_value.field_policy__violation;
case ALT_remote__connection__failed:
return *field_remote__connection__failed == *other_value.field_remote__connection__failed;
case ALT_reset:
return *field_reset == *other_value.field_reset;
case ALT_resource__constraint:
return *field_resource__constraint == *other_value.field_resource__constraint;
case ALT_restricted__xml:
return *field_restricted__xml == *other_value.field_restricted__xml;
case ALT_see__other__host:
return *field_see__other__host == *other_value.field_see__other__host;
case ALT_system__shutdown:
return *field_system__shutdown == *other_value.field_system__shutdown;
case ALT_undefined__condition:
return *field_undefined__condition == *other_value.field_undefined__condition;
case ALT_unsupported__encoding:
return *field_unsupported__encoding == *other_value.field_unsupported__encoding;
case ALT_unsupported__stanza__type:
return *field_unsupported__stanza__type == *other_value.field_unsupported__stanza__type;
case ALT_unsupported__version:
return *field_unsupported__version == *other_value.field_unsupported__version;
default:
return FALSE;
}
}

Empty& StreamErrorGroup::bad__format()
{
if (union_selection != ALT_bad__format) {
clean_up();
field_bad__format = new Empty;
union_selection = ALT_bad__format;
}
return *field_bad__format;
}

const Empty& StreamErrorGroup::bad__format() const
{
if (union_selection != ALT_bad__format) TTCN_error("Using non-selected field bad_format in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_bad__format;
}

Empty& StreamErrorGroup::bad__namespace__prefix()
{
if (union_selection != ALT_bad__namespace__prefix) {
clean_up();
field_bad__namespace__prefix = new Empty;
union_selection = ALT_bad__namespace__prefix;
}
return *field_bad__namespace__prefix;
}

const Empty& StreamErrorGroup::bad__namespace__prefix() const
{
if (union_selection != ALT_bad__namespace__prefix) TTCN_error("Using non-selected field bad_namespace_prefix in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_bad__namespace__prefix;
}

Empty& StreamErrorGroup::conflict()
{
if (union_selection != ALT_conflict) {
clean_up();
field_conflict = new Empty;
union_selection = ALT_conflict;
}
return *field_conflict;
}

const Empty& StreamErrorGroup::conflict() const
{
if (union_selection != ALT_conflict) TTCN_error("Using non-selected field conflict in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_conflict;
}

Empty& StreamErrorGroup::connection__timeout()
{
if (union_selection != ALT_connection__timeout) {
clean_up();
field_connection__timeout = new Empty;
union_selection = ALT_connection__timeout;
}
return *field_connection__timeout;
}

const Empty& StreamErrorGroup::connection__timeout() const
{
if (union_selection != ALT_connection__timeout) TTCN_error("Using non-selected field connection_timeout in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_connection__timeout;
}

Empty& StreamErrorGroup::host__gone()
{
if (union_selection != ALT_host__gone) {
clean_up();
field_host__gone = new Empty;
union_selection = ALT_host__gone;
}
return *field_host__gone;
}

const Empty& StreamErrorGroup::host__gone() const
{
if (union_selection != ALT_host__gone) TTCN_error("Using non-selected field host_gone in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_host__gone;
}

Empty& StreamErrorGroup::host__unknown()
{
if (union_selection != ALT_host__unknown) {
clean_up();
field_host__unknown = new Empty;
union_selection = ALT_host__unknown;
}
return *field_host__unknown;
}

const Empty& StreamErrorGroup::host__unknown() const
{
if (union_selection != ALT_host__unknown) TTCN_error("Using non-selected field host_unknown in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_host__unknown;
}

Empty& StreamErrorGroup::improper__addressing()
{
if (union_selection != ALT_improper__addressing) {
clean_up();
field_improper__addressing = new Empty;
union_selection = ALT_improper__addressing;
}
return *field_improper__addressing;
}

const Empty& StreamErrorGroup::improper__addressing() const
{
if (union_selection != ALT_improper__addressing) TTCN_error("Using non-selected field improper_addressing in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_improper__addressing;
}

Empty& StreamErrorGroup::internal__server__error()
{
if (union_selection != ALT_internal__server__error) {
clean_up();
field_internal__server__error = new Empty;
union_selection = ALT_internal__server__error;
}
return *field_internal__server__error;
}

const Empty& StreamErrorGroup::internal__server__error() const
{
if (union_selection != ALT_internal__server__error) TTCN_error("Using non-selected field internal_server_error in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_internal__server__error;
}

Empty& StreamErrorGroup::invalid__from()
{
if (union_selection != ALT_invalid__from) {
clean_up();
field_invalid__from = new Empty;
union_selection = ALT_invalid__from;
}
return *field_invalid__from;
}

const Empty& StreamErrorGroup::invalid__from() const
{
if (union_selection != ALT_invalid__from) TTCN_error("Using non-selected field invalid_from in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_invalid__from;
}

Empty& StreamErrorGroup::invalid__id()
{
if (union_selection != ALT_invalid__id) {
clean_up();
field_invalid__id = new Empty;
union_selection = ALT_invalid__id;
}
return *field_invalid__id;
}

const Empty& StreamErrorGroup::invalid__id() const
{
if (union_selection != ALT_invalid__id) TTCN_error("Using non-selected field invalid_id in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_invalid__id;
}

Empty& StreamErrorGroup::invalid__namespace()
{
if (union_selection != ALT_invalid__namespace) {
clean_up();
field_invalid__namespace = new Empty;
union_selection = ALT_invalid__namespace;
}
return *field_invalid__namespace;
}

const Empty& StreamErrorGroup::invalid__namespace() const
{
if (union_selection != ALT_invalid__namespace) TTCN_error("Using non-selected field invalid_namespace in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_invalid__namespace;
}

Empty& StreamErrorGroup::invalid__xml()
{
if (union_selection != ALT_invalid__xml) {
clean_up();
field_invalid__xml = new Empty;
union_selection = ALT_invalid__xml;
}
return *field_invalid__xml;
}

const Empty& StreamErrorGroup::invalid__xml() const
{
if (union_selection != ALT_invalid__xml) TTCN_error("Using non-selected field invalid_xml in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_invalid__xml;
}

Empty& StreamErrorGroup::not__authorized()
{
if (union_selection != ALT_not__authorized) {
clean_up();
field_not__authorized = new Empty;
union_selection = ALT_not__authorized;
}
return *field_not__authorized;
}

const Empty& StreamErrorGroup::not__authorized() const
{
if (union_selection != ALT_not__authorized) TTCN_error("Using non-selected field not_authorized in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_not__authorized;
}

Empty& StreamErrorGroup::not__well__formed()
{
if (union_selection != ALT_not__well__formed) {
clean_up();
field_not__well__formed = new Empty;
union_selection = ALT_not__well__formed;
}
return *field_not__well__formed;
}

const Empty& StreamErrorGroup::not__well__formed() const
{
if (union_selection != ALT_not__well__formed) TTCN_error("Using non-selected field not_well_formed in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_not__well__formed;
}

Empty& StreamErrorGroup::policy__violation()
{
if (union_selection != ALT_policy__violation) {
clean_up();
field_policy__violation = new Empty;
union_selection = ALT_policy__violation;
}
return *field_policy__violation;
}

const Empty& StreamErrorGroup::policy__violation() const
{
if (union_selection != ALT_policy__violation) TTCN_error("Using non-selected field policy_violation in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_policy__violation;
}

Empty& StreamErrorGroup::remote__connection__failed()
{
if (union_selection != ALT_remote__connection__failed) {
clean_up();
field_remote__connection__failed = new Empty;
union_selection = ALT_remote__connection__failed;
}
return *field_remote__connection__failed;
}

const Empty& StreamErrorGroup::remote__connection__failed() const
{
if (union_selection != ALT_remote__connection__failed) TTCN_error("Using non-selected field remote_connection_failed in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_remote__connection__failed;
}

Empty& StreamErrorGroup::reset()
{
if (union_selection != ALT_reset) {
clean_up();
field_reset = new Empty;
union_selection = ALT_reset;
}
return *field_reset;
}

const Empty& StreamErrorGroup::reset() const
{
if (union_selection != ALT_reset) TTCN_error("Using non-selected field reset in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_reset;
}

Empty& StreamErrorGroup::resource__constraint()
{
if (union_selection != ALT_resource__constraint) {
clean_up();
field_resource__constraint = new Empty;
union_selection = ALT_resource__constraint;
}
return *field_resource__constraint;
}

const Empty& StreamErrorGroup::resource__constraint() const
{
if (union_selection != ALT_resource__constraint) TTCN_error("Using non-selected field resource_constraint in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_resource__constraint;
}

Empty& StreamErrorGroup::restricted__xml()
{
if (union_selection != ALT_restricted__xml) {
clean_up();
field_restricted__xml = new Empty;
union_selection = ALT_restricted__xml;
}
return *field_restricted__xml;
}

const Empty& StreamErrorGroup::restricted__xml() const
{
if (union_selection != ALT_restricted__xml) TTCN_error("Using non-selected field restricted_xml in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_restricted__xml;
}

UNIVERSAL_CHARSTRING& StreamErrorGroup::see__other__host()
{
if (union_selection != ALT_see__other__host) {
clean_up();
field_see__other__host = new UNIVERSAL_CHARSTRING;
union_selection = ALT_see__other__host;
}
return *field_see__other__host;
}

const UNIVERSAL_CHARSTRING& StreamErrorGroup::see__other__host() const
{
if (union_selection != ALT_see__other__host) TTCN_error("Using non-selected field see_other_host in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_see__other__host;
}

Empty& StreamErrorGroup::system__shutdown()
{
if (union_selection != ALT_system__shutdown) {
clean_up();
field_system__shutdown = new Empty;
union_selection = ALT_system__shutdown;
}
return *field_system__shutdown;
}

const Empty& StreamErrorGroup::system__shutdown() const
{
if (union_selection != ALT_system__shutdown) TTCN_error("Using non-selected field system_shutdown in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_system__shutdown;
}

Empty& StreamErrorGroup::undefined__condition()
{
if (union_selection != ALT_undefined__condition) {
clean_up();
field_undefined__condition = new Empty;
union_selection = ALT_undefined__condition;
}
return *field_undefined__condition;
}

const Empty& StreamErrorGroup::undefined__condition() const
{
if (union_selection != ALT_undefined__condition) TTCN_error("Using non-selected field undefined_condition in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_undefined__condition;
}

Empty& StreamErrorGroup::unsupported__encoding()
{
if (union_selection != ALT_unsupported__encoding) {
clean_up();
field_unsupported__encoding = new Empty;
union_selection = ALT_unsupported__encoding;
}
return *field_unsupported__encoding;
}

const Empty& StreamErrorGroup::unsupported__encoding() const
{
if (union_selection != ALT_unsupported__encoding) TTCN_error("Using non-selected field unsupported_encoding in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_unsupported__encoding;
}

Empty& StreamErrorGroup::unsupported__stanza__type()
{
if (union_selection != ALT_unsupported__stanza__type) {
clean_up();
field_unsupported__stanza__type = new Empty;
union_selection = ALT_unsupported__stanza__type;
}
return *field_unsupported__stanza__type;
}

const Empty& StreamErrorGroup::unsupported__stanza__type() const
{
if (union_selection != ALT_unsupported__stanza__type) TTCN_error("Using non-selected field unsupported_stanza_type in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_unsupported__stanza__type;
}

Empty& StreamErrorGroup::unsupported__version()
{
if (union_selection != ALT_unsupported__version) {
clean_up();
field_unsupported__version = new Empty;
union_selection = ALT_unsupported__version;
}
return *field_unsupported__version;
}

const Empty& StreamErrorGroup::unsupported__version() const
{
if (union_selection != ALT_unsupported__version) TTCN_error("Using non-selected field unsupported_version in a value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *field_unsupported__version;
}

boolean StreamErrorGroup::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return union_selection == checked_selection;
}

boolean StreamErrorGroup::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean StreamErrorGroup::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_bad__format: return field_bad__format->is_value();
case ALT_bad__namespace__prefix: return field_bad__namespace__prefix->is_value();
case ALT_conflict: return field_conflict->is_value();
case ALT_connection__timeout: return field_connection__timeout->is_value();
case ALT_host__gone: return field_host__gone->is_value();
case ALT_host__unknown: return field_host__unknown->is_value();
case ALT_improper__addressing: return field_improper__addressing->is_value();
case ALT_internal__server__error: return field_internal__server__error->is_value();
case ALT_invalid__from: return field_invalid__from->is_value();
case ALT_invalid__id: return field_invalid__id->is_value();
case ALT_invalid__namespace: return field_invalid__namespace->is_value();
case ALT_invalid__xml: return field_invalid__xml->is_value();
case ALT_not__authorized: return field_not__authorized->is_value();
case ALT_not__well__formed: return field_not__well__formed->is_value();
case ALT_policy__violation: return field_policy__violation->is_value();
case ALT_remote__connection__failed: return field_remote__connection__failed->is_value();
case ALT_reset: return field_reset->is_value();
case ALT_resource__constraint: return field_resource__constraint->is_value();
case ALT_restricted__xml: return field_restricted__xml->is_value();
case ALT_see__other__host: return field_see__other__host->is_value();
case ALT_system__shutdown: return field_system__shutdown->is_value();
case ALT_undefined__condition: return field_undefined__condition->is_value();
case ALT_unsupported__encoding: return field_unsupported__encoding->is_value();
case ALT_unsupported__stanza__type: return field_unsupported__stanza__type->is_value();
case ALT_unsupported__version: return field_unsupported__version->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void StreamErrorGroup::clean_up()
{
switch (union_selection) {
case ALT_bad__format:
  delete field_bad__format;
  break;
case ALT_bad__namespace__prefix:
  delete field_bad__namespace__prefix;
  break;
case ALT_conflict:
  delete field_conflict;
  break;
case ALT_connection__timeout:
  delete field_connection__timeout;
  break;
case ALT_host__gone:
  delete field_host__gone;
  break;
case ALT_host__unknown:
  delete field_host__unknown;
  break;
case ALT_improper__addressing:
  delete field_improper__addressing;
  break;
case ALT_internal__server__error:
  delete field_internal__server__error;
  break;
case ALT_invalid__from:
  delete field_invalid__from;
  break;
case ALT_invalid__id:
  delete field_invalid__id;
  break;
case ALT_invalid__namespace:
  delete field_invalid__namespace;
  break;
case ALT_invalid__xml:
  delete field_invalid__xml;
  break;
case ALT_not__authorized:
  delete field_not__authorized;
  break;
case ALT_not__well__formed:
  delete field_not__well__formed;
  break;
case ALT_policy__violation:
  delete field_policy__violation;
  break;
case ALT_remote__connection__failed:
  delete field_remote__connection__failed;
  break;
case ALT_reset:
  delete field_reset;
  break;
case ALT_resource__constraint:
  delete field_resource__constraint;
  break;
case ALT_restricted__xml:
  delete field_restricted__xml;
  break;
case ALT_see__other__host:
  delete field_see__other__host;
  break;
case ALT_system__shutdown:
  delete field_system__shutdown;
  break;
case ALT_undefined__condition:
  delete field_undefined__condition;
  break;
case ALT_unsupported__encoding:
  delete field_unsupported__encoding;
  break;
case ALT_unsupported__stanza__type:
  delete field_unsupported__stanza__type;
  break;
case ALT_unsupported__version:
  delete field_unsupported__version;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void StreamErrorGroup::log() const
{
switch (union_selection) {
case ALT_bad__format:
TTCN_Logger::log_event_str("{ bad_format := ");
field_bad__format->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_bad__namespace__prefix:
TTCN_Logger::log_event_str("{ bad_namespace_prefix := ");
field_bad__namespace__prefix->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_conflict:
TTCN_Logger::log_event_str("{ conflict := ");
field_conflict->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_connection__timeout:
TTCN_Logger::log_event_str("{ connection_timeout := ");
field_connection__timeout->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_host__gone:
TTCN_Logger::log_event_str("{ host_gone := ");
field_host__gone->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_host__unknown:
TTCN_Logger::log_event_str("{ host_unknown := ");
field_host__unknown->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_improper__addressing:
TTCN_Logger::log_event_str("{ improper_addressing := ");
field_improper__addressing->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_internal__server__error:
TTCN_Logger::log_event_str("{ internal_server_error := ");
field_internal__server__error->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_invalid__from:
TTCN_Logger::log_event_str("{ invalid_from := ");
field_invalid__from->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_invalid__id:
TTCN_Logger::log_event_str("{ invalid_id := ");
field_invalid__id->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_invalid__namespace:
TTCN_Logger::log_event_str("{ invalid_namespace := ");
field_invalid__namespace->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_invalid__xml:
TTCN_Logger::log_event_str("{ invalid_xml := ");
field_invalid__xml->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_not__authorized:
TTCN_Logger::log_event_str("{ not_authorized := ");
field_not__authorized->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_not__well__formed:
TTCN_Logger::log_event_str("{ not_well_formed := ");
field_not__well__formed->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_policy__violation:
TTCN_Logger::log_event_str("{ policy_violation := ");
field_policy__violation->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_remote__connection__failed:
TTCN_Logger::log_event_str("{ remote_connection_failed := ");
field_remote__connection__failed->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_reset:
TTCN_Logger::log_event_str("{ reset := ");
field_reset->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_resource__constraint:
TTCN_Logger::log_event_str("{ resource_constraint := ");
field_resource__constraint->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_restricted__xml:
TTCN_Logger::log_event_str("{ restricted_xml := ");
field_restricted__xml->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_see__other__host:
TTCN_Logger::log_event_str("{ see_other_host := ");
field_see__other__host->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_system__shutdown:
TTCN_Logger::log_event_str("{ system_shutdown := ");
field_system__shutdown->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_undefined__condition:
TTCN_Logger::log_event_str("{ undefined_condition := ");
field_undefined__condition->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_unsupported__encoding:
TTCN_Logger::log_event_str("{ unsupported_encoding := ");
field_unsupported__encoding->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_unsupported__stanza__type:
TTCN_Logger::log_event_str("{ unsupported_stanza_type := ");
field_unsupported__stanza__type->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_unsupported__version:
TTCN_Logger::log_event_str("{ unsupported_version := ");
field_unsupported__version->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void StreamErrorGroup::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup'");
    }
    if (strcmp("bad_format", param_field) == 0) {
      bad__format().set_param(param);
      return;
    } else if (strcmp("bad_namespace_prefix", param_field) == 0) {
      bad__namespace__prefix().set_param(param);
      return;
    } else if (strcmp("conflict", param_field) == 0) {
      conflict().set_param(param);
      return;
    } else if (strcmp("connection_timeout", param_field) == 0) {
      connection__timeout().set_param(param);
      return;
    } else if (strcmp("host_gone", param_field) == 0) {
      host__gone().set_param(param);
      return;
    } else if (strcmp("host_unknown", param_field) == 0) {
      host__unknown().set_param(param);
      return;
    } else if (strcmp("improper_addressing", param_field) == 0) {
      improper__addressing().set_param(param);
      return;
    } else if (strcmp("internal_server_error", param_field) == 0) {
      internal__server__error().set_param(param);
      return;
    } else if (strcmp("invalid_from", param_field) == 0) {
      invalid__from().set_param(param);
      return;
    } else if (strcmp("invalid_id", param_field) == 0) {
      invalid__id().set_param(param);
      return;
    } else if (strcmp("invalid_namespace", param_field) == 0) {
      invalid__namespace().set_param(param);
      return;
    } else if (strcmp("invalid_xml", param_field) == 0) {
      invalid__xml().set_param(param);
      return;
    } else if (strcmp("not_authorized", param_field) == 0) {
      not__authorized().set_param(param);
      return;
    } else if (strcmp("not_well_formed", param_field) == 0) {
      not__well__formed().set_param(param);
      return;
    } else if (strcmp("policy_violation", param_field) == 0) {
      policy__violation().set_param(param);
      return;
    } else if (strcmp("remote_connection_failed", param_field) == 0) {
      remote__connection__failed().set_param(param);
      return;
    } else if (strcmp("reset", param_field) == 0) {
      reset().set_param(param);
      return;
    } else if (strcmp("resource_constraint", param_field) == 0) {
      resource__constraint().set_param(param);
      return;
    } else if (strcmp("restricted_xml", param_field) == 0) {
      restricted__xml().set_param(param);
      return;
    } else if (strcmp("see_other_host", param_field) == 0) {
      see__other__host().set_param(param);
      return;
    } else if (strcmp("system_shutdown", param_field) == 0) {
      system__shutdown().set_param(param);
      return;
    } else if (strcmp("undefined_condition", param_field) == 0) {
      undefined__condition().set_param(param);
      return;
    } else if (strcmp("unsupported_encoding", param_field) == 0) {
      unsupported__encoding().set_param(param);
      return;
    } else if (strcmp("unsupported_stanza_type", param_field) == 0) {
      unsupported__stanza__type().set_param(param);
      return;
    } else if (strcmp("unsupported_version", param_field) == 0) {
      unsupported__version().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) return;
  if (param.get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = param.get_elem(param.get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "bad_format")) {
    bad__format().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "bad_namespace_prefix")) {
    bad__namespace__prefix().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "conflict")) {
    conflict().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "connection_timeout")) {
    connection__timeout().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "host_gone")) {
    host__gone().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "host_unknown")) {
    host__unknown().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "improper_addressing")) {
    improper__addressing().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "internal_server_error")) {
    internal__server__error().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "invalid_from")) {
    invalid__from().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "invalid_id")) {
    invalid__id().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "invalid_namespace")) {
    invalid__namespace().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "invalid_xml")) {
    invalid__xml().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "not_authorized")) {
    not__authorized().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "not_well_formed")) {
    not__well__formed().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "policy_violation")) {
    policy__violation().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "remote_connection_failed")) {
    remote__connection__failed().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "reset")) {
    reset().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "resource_constraint")) {
    resource__constraint().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "restricted_xml")) {
    restricted__xml().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "see_other_host")) {
    see__other__host().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "system_shutdown")) {
    system__shutdown().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "undefined_condition")) {
    undefined__condition().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "unsupported_encoding")) {
    unsupported__encoding().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "unsupported_stanza_type")) {
    unsupported__stanza__type().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "unsupported_version")) {
    unsupported__version().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.", mp_last->get_id()->get_name());
}

void StreamErrorGroup::set_implicit_omit()
{
switch (union_selection) {
case ALT_bad__format:
field_bad__format->set_implicit_omit(); break;
case ALT_bad__namespace__prefix:
field_bad__namespace__prefix->set_implicit_omit(); break;
case ALT_conflict:
field_conflict->set_implicit_omit(); break;
case ALT_connection__timeout:
field_connection__timeout->set_implicit_omit(); break;
case ALT_host__gone:
field_host__gone->set_implicit_omit(); break;
case ALT_host__unknown:
field_host__unknown->set_implicit_omit(); break;
case ALT_improper__addressing:
field_improper__addressing->set_implicit_omit(); break;
case ALT_internal__server__error:
field_internal__server__error->set_implicit_omit(); break;
case ALT_invalid__from:
field_invalid__from->set_implicit_omit(); break;
case ALT_invalid__id:
field_invalid__id->set_implicit_omit(); break;
case ALT_invalid__namespace:
field_invalid__namespace->set_implicit_omit(); break;
case ALT_invalid__xml:
field_invalid__xml->set_implicit_omit(); break;
case ALT_not__authorized:
field_not__authorized->set_implicit_omit(); break;
case ALT_not__well__formed:
field_not__well__formed->set_implicit_omit(); break;
case ALT_policy__violation:
field_policy__violation->set_implicit_omit(); break;
case ALT_remote__connection__failed:
field_remote__connection__failed->set_implicit_omit(); break;
case ALT_reset:
field_reset->set_implicit_omit(); break;
case ALT_resource__constraint:
field_resource__constraint->set_implicit_omit(); break;
case ALT_restricted__xml:
field_restricted__xml->set_implicit_omit(); break;
case ALT_see__other__host:
field_see__other__host->set_implicit_omit(); break;
case ALT_system__shutdown:
field_system__shutdown->set_implicit_omit(); break;
case ALT_undefined__condition:
field_undefined__condition->set_implicit_omit(); break;
case ALT_unsupported__encoding:
field_unsupported__encoding->set_implicit_omit(); break;
case ALT_unsupported__stanza__type:
field_unsupported__stanza__type->set_implicit_omit(); break;
case ALT_unsupported__version:
field_unsupported__version->set_implicit_omit(); break;
default: break;
}
}

void StreamErrorGroup::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_bad__format:
field_bad__format->encode_text(text_buf);
break;
case ALT_bad__namespace__prefix:
field_bad__namespace__prefix->encode_text(text_buf);
break;
case ALT_conflict:
field_conflict->encode_text(text_buf);
break;
case ALT_connection__timeout:
field_connection__timeout->encode_text(text_buf);
break;
case ALT_host__gone:
field_host__gone->encode_text(text_buf);
break;
case ALT_host__unknown:
field_host__unknown->encode_text(text_buf);
break;
case ALT_improper__addressing:
field_improper__addressing->encode_text(text_buf);
break;
case ALT_internal__server__error:
field_internal__server__error->encode_text(text_buf);
break;
case ALT_invalid__from:
field_invalid__from->encode_text(text_buf);
break;
case ALT_invalid__id:
field_invalid__id->encode_text(text_buf);
break;
case ALT_invalid__namespace:
field_invalid__namespace->encode_text(text_buf);
break;
case ALT_invalid__xml:
field_invalid__xml->encode_text(text_buf);
break;
case ALT_not__authorized:
field_not__authorized->encode_text(text_buf);
break;
case ALT_not__well__formed:
field_not__well__formed->encode_text(text_buf);
break;
case ALT_policy__violation:
field_policy__violation->encode_text(text_buf);
break;
case ALT_remote__connection__failed:
field_remote__connection__failed->encode_text(text_buf);
break;
case ALT_reset:
field_reset->encode_text(text_buf);
break;
case ALT_resource__constraint:
field_resource__constraint->encode_text(text_buf);
break;
case ALT_restricted__xml:
field_restricted__xml->encode_text(text_buf);
break;
case ALT_see__other__host:
field_see__other__host->encode_text(text_buf);
break;
case ALT_system__shutdown:
field_system__shutdown->encode_text(text_buf);
break;
case ALT_undefined__condition:
field_undefined__condition->encode_text(text_buf);
break;
case ALT_unsupported__encoding:
field_unsupported__encoding->encode_text(text_buf);
break;
case ALT_unsupported__stanza__type:
field_unsupported__stanza__type->encode_text(text_buf);
break;
case ALT_unsupported__version:
field_unsupported__version->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
}

void StreamErrorGroup::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_bad__format:
bad__format().decode_text(text_buf);
break;
case ALT_bad__namespace__prefix:
bad__namespace__prefix().decode_text(text_buf);
break;
case ALT_conflict:
conflict().decode_text(text_buf);
break;
case ALT_connection__timeout:
connection__timeout().decode_text(text_buf);
break;
case ALT_host__gone:
host__gone().decode_text(text_buf);
break;
case ALT_host__unknown:
host__unknown().decode_text(text_buf);
break;
case ALT_improper__addressing:
improper__addressing().decode_text(text_buf);
break;
case ALT_internal__server__error:
internal__server__error().decode_text(text_buf);
break;
case ALT_invalid__from:
invalid__from().decode_text(text_buf);
break;
case ALT_invalid__id:
invalid__id().decode_text(text_buf);
break;
case ALT_invalid__namespace:
invalid__namespace().decode_text(text_buf);
break;
case ALT_invalid__xml:
invalid__xml().decode_text(text_buf);
break;
case ALT_not__authorized:
not__authorized().decode_text(text_buf);
break;
case ALT_not__well__formed:
not__well__formed().decode_text(text_buf);
break;
case ALT_policy__violation:
policy__violation().decode_text(text_buf);
break;
case ALT_remote__connection__failed:
remote__connection__failed().decode_text(text_buf);
break;
case ALT_reset:
reset().decode_text(text_buf);
break;
case ALT_resource__constraint:
resource__constraint().decode_text(text_buf);
break;
case ALT_restricted__xml:
restricted__xml().decode_text(text_buf);
break;
case ALT_see__other__host:
see__other__host().decode_text(text_buf);
break;
case ALT_system__shutdown:
system__shutdown().decode_text(text_buf);
break;
case ALT_undefined__condition:
undefined__condition().decode_text(text_buf);
break;
case ALT_unsupported__encoding:
unsupported__encoding().decode_text(text_buf);
break;
case ALT_unsupported__stanza__type:
unsupported__stanza__type().decode_text(text_buf);
break;
case ALT_unsupported__version:
unsupported__version().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
}

void StreamErrorGroup::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void StreamErrorGroup::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

boolean StreamErrorGroup::can_start(const char *name, const char *uri, const XERdescriptor_t& xd, unsigned int flavor) {
  boolean exer = is_exer(flavor);
  if (!exer || (!(xd.xer_bits & UNTAGGED) && !(flavor & (USE_NIL|(exer ? XER_LIST : XER_RECOF))))) return check_name(name, xd, exer) && (!exer || (flavor & USE_TYPE_ATTR) || check_namespace(uri, xd));
  flavor &= ~XER_RECOF;
  if (Empty::can_start(name, uri, StreamErrorGroup_bad__format_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_bad__namespace__prefix_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_conflict_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_connection__timeout_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_host__gone_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_host__unknown_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_improper__addressing_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_internal__server__error_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_invalid__from_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_invalid__id_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_invalid__namespace_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_invalid__xml_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_not__authorized_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_not__well__formed_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_policy__violation_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_remote__connection__failed_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_reset_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_resource__constraint_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_restricted__xml_xer_, flavor)) return true;
  if (UNIVERSAL_CHARSTRING::can_start(name, uri, StreamErrorGroup_see__other__host_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_system__shutdown_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_undefined__condition_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_unsupported__encoding_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_unsupported__stanza__type_xer_, flavor)) return true;
  if (Empty::can_start(name, uri, StreamErrorGroup_unsupported__version_xer_, flavor)) return true;
  return false;
}

char ** StreamErrorGroup::collect_ns(const XERdescriptor_t& p_td, size_t& num, bool& def_ns) const {
  size_t num_collected;
  char **collected_ns = Base_Type::collect_ns(p_td, num_collected, def_ns);
  char **new_ns;
  size_t num_new;
  boolean need_type = FALSE;
  try {
    bool def_ns_1 = false;
    switch (union_selection) {
    case ALT_bad__format:
      new_ns = field_bad__format->collect_ns(StreamErrorGroup_bad__format_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      break;
    case ALT_bad__namespace__prefix:
      new_ns = field_bad__namespace__prefix->collect_ns(StreamErrorGroup_bad__namespace__prefix_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_bad__namespace__prefix_xer_.namelens[1] > 2);
      break;
    case ALT_conflict:
      new_ns = field_conflict->collect_ns(StreamErrorGroup_conflict_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_conflict_xer_.namelens[1] > 2);
      break;
    case ALT_connection__timeout:
      new_ns = field_connection__timeout->collect_ns(StreamErrorGroup_connection__timeout_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_connection__timeout_xer_.namelens[1] > 2);
      break;
    case ALT_host__gone:
      new_ns = field_host__gone->collect_ns(StreamErrorGroup_host__gone_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_host__gone_xer_.namelens[1] > 2);
      break;
    case ALT_host__unknown:
      new_ns = field_host__unknown->collect_ns(StreamErrorGroup_host__unknown_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_host__unknown_xer_.namelens[1] > 2);
      break;
    case ALT_improper__addressing:
      new_ns = field_improper__addressing->collect_ns(StreamErrorGroup_improper__addressing_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_improper__addressing_xer_.namelens[1] > 2);
      break;
    case ALT_internal__server__error:
      new_ns = field_internal__server__error->collect_ns(StreamErrorGroup_internal__server__error_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_internal__server__error_xer_.namelens[1] > 2);
      break;
    case ALT_invalid__from:
      new_ns = field_invalid__from->collect_ns(StreamErrorGroup_invalid__from_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_invalid__from_xer_.namelens[1] > 2);
      break;
    case ALT_invalid__id:
      new_ns = field_invalid__id->collect_ns(StreamErrorGroup_invalid__id_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_invalid__id_xer_.namelens[1] > 2);
      break;
    case ALT_invalid__namespace:
      new_ns = field_invalid__namespace->collect_ns(StreamErrorGroup_invalid__namespace_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_invalid__namespace_xer_.namelens[1] > 2);
      break;
    case ALT_invalid__xml:
      new_ns = field_invalid__xml->collect_ns(StreamErrorGroup_invalid__xml_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_invalid__xml_xer_.namelens[1] > 2);
      break;
    case ALT_not__authorized:
      new_ns = field_not__authorized->collect_ns(StreamErrorGroup_not__authorized_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_not__authorized_xer_.namelens[1] > 2);
      break;
    case ALT_not__well__formed:
      new_ns = field_not__well__formed->collect_ns(StreamErrorGroup_not__well__formed_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_not__well__formed_xer_.namelens[1] > 2);
      break;
    case ALT_policy__violation:
      new_ns = field_policy__violation->collect_ns(StreamErrorGroup_policy__violation_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_policy__violation_xer_.namelens[1] > 2);
      break;
    case ALT_remote__connection__failed:
      new_ns = field_remote__connection__failed->collect_ns(StreamErrorGroup_remote__connection__failed_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_remote__connection__failed_xer_.namelens[1] > 2);
      break;
    case ALT_reset:
      new_ns = field_reset->collect_ns(StreamErrorGroup_reset_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_reset_xer_.namelens[1] > 2);
      break;
    case ALT_resource__constraint:
      new_ns = field_resource__constraint->collect_ns(StreamErrorGroup_resource__constraint_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_resource__constraint_xer_.namelens[1] > 2);
      break;
    case ALT_restricted__xml:
      new_ns = field_restricted__xml->collect_ns(StreamErrorGroup_restricted__xml_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_restricted__xml_xer_.namelens[1] > 2);
      break;
    case ALT_see__other__host:
      new_ns = field_see__other__host->collect_ns(StreamErrorGroup_see__other__host_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_see__other__host_xer_.namelens[1] > 2);
      break;
    case ALT_system__shutdown:
      new_ns = field_system__shutdown->collect_ns(StreamErrorGroup_system__shutdown_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_system__shutdown_xer_.namelens[1] > 2);
      break;
    case ALT_undefined__condition:
      new_ns = field_undefined__condition->collect_ns(StreamErrorGroup_undefined__condition_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_undefined__condition_xer_.namelens[1] > 2);
      break;
    case ALT_unsupported__encoding:
      new_ns = field_unsupported__encoding->collect_ns(StreamErrorGroup_unsupported__encoding_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_unsupported__encoding_xer_.namelens[1] > 2);
      break;
    case ALT_unsupported__stanza__type:
      new_ns = field_unsupported__stanza__type->collect_ns(StreamErrorGroup_unsupported__stanza__type_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_unsupported__stanza__type_xer_.namelens[1] > 2);
      break;
    case ALT_unsupported__version:
      new_ns = field_unsupported__version->collect_ns(StreamErrorGroup_unsupported__version_xer_, num_new, def_ns_1);
      def_ns = def_ns || def_ns_1;
      merge_ns(collected_ns, num_collected, new_ns, num_new);
      need_type = (StreamErrorGroup_unsupported__version_xer_.namelens[1] > 2);
      break;
    default: break;
    }
    if ((p_td.xer_bits & USE_TYPE_ATTR) && !(p_td.xer_bits & XER_ATTRIBUTE) && need_type) {
      collected_ns = (char**)Realloc(collected_ns, sizeof(char*) * ++num_collected);
      const namespace_t *c_ns = p_td.my_module->get_controlns();
      collected_ns[num_collected-1] = mprintf(" xmlns:%s='%s'", c_ns->px, c_ns->ns);
    }
  }
  catch (...) {
    while (num_collected > 0) Free(collected_ns[--num_collected]);
    Free(collected_ns);
    throw;
  }
  num = num_collected;
  return collected_ns;
}

int StreamErrorGroup::XER_encode(const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const
{
  if (UNBOUND_VALUE==union_selection) {
    TTCN_error("Attempt to XER-encode an unbound union value.");
    return 0;
  }
  TTCN_EncDec_ErrorContext ec_0("Alternative '");
  TTCN_EncDec_ErrorContext ec_1;
  int encoded_length=(int)p_buf.get_len();
  unsigned int flavor_1 = p_flavor;
  if (is_exer(p_flavor)) flavor_1 &= ~XER_RECOF;
  bool omit_tag = begin_xml(p_td, p_buf, flavor_1, p_indent, false, (collector_fn)&StreamErrorGroup::collect_ns);
  unsigned int flavor_0 = (p_flavor & XER_MASK);
  switch (union_selection) {
  case ALT_bad__format:
    ec_1.set_msg("bad_format': ");
    field_bad__format->XER_encode(StreamErrorGroup_bad__format_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_bad__namespace__prefix:
    ec_1.set_msg("bad_namespace_prefix': ");
    field_bad__namespace__prefix->XER_encode(StreamErrorGroup_bad__namespace__prefix_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_conflict:
    ec_1.set_msg("conflict': ");
    field_conflict->XER_encode(StreamErrorGroup_conflict_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_connection__timeout:
    ec_1.set_msg("connection_timeout': ");
    field_connection__timeout->XER_encode(StreamErrorGroup_connection__timeout_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_host__gone:
    ec_1.set_msg("host_gone': ");
    field_host__gone->XER_encode(StreamErrorGroup_host__gone_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_host__unknown:
    ec_1.set_msg("host_unknown': ");
    field_host__unknown->XER_encode(StreamErrorGroup_host__unknown_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_improper__addressing:
    ec_1.set_msg("improper_addressing': ");
    field_improper__addressing->XER_encode(StreamErrorGroup_improper__addressing_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_internal__server__error:
    ec_1.set_msg("internal_server_error': ");
    field_internal__server__error->XER_encode(StreamErrorGroup_internal__server__error_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_invalid__from:
    ec_1.set_msg("invalid_from': ");
    field_invalid__from->XER_encode(StreamErrorGroup_invalid__from_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_invalid__id:
    ec_1.set_msg("invalid_id': ");
    field_invalid__id->XER_encode(StreamErrorGroup_invalid__id_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_invalid__namespace:
    ec_1.set_msg("invalid_namespace': ");
    field_invalid__namespace->XER_encode(StreamErrorGroup_invalid__namespace_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_invalid__xml:
    ec_1.set_msg("invalid_xml': ");
    field_invalid__xml->XER_encode(StreamErrorGroup_invalid__xml_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_not__authorized:
    ec_1.set_msg("not_authorized': ");
    field_not__authorized->XER_encode(StreamErrorGroup_not__authorized_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_not__well__formed:
    ec_1.set_msg("not_well_formed': ");
    field_not__well__formed->XER_encode(StreamErrorGroup_not__well__formed_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_policy__violation:
    ec_1.set_msg("policy_violation': ");
    field_policy__violation->XER_encode(StreamErrorGroup_policy__violation_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_remote__connection__failed:
    ec_1.set_msg("remote_connection_failed': ");
    field_remote__connection__failed->XER_encode(StreamErrorGroup_remote__connection__failed_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_reset:
    ec_1.set_msg("reset': ");
    field_reset->XER_encode(StreamErrorGroup_reset_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_resource__constraint:
    ec_1.set_msg("resource_constraint': ");
    field_resource__constraint->XER_encode(StreamErrorGroup_resource__constraint_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_restricted__xml:
    ec_1.set_msg("restricted_xml': ");
    field_restricted__xml->XER_encode(StreamErrorGroup_restricted__xml_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_see__other__host:
    ec_1.set_msg("see_other_host': ");
    field_see__other__host->XER_encode(StreamErrorGroup_see__other__host_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_system__shutdown:
    ec_1.set_msg("system_shutdown': ");
    field_system__shutdown->XER_encode(StreamErrorGroup_system__shutdown_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_undefined__condition:
    ec_1.set_msg("undefined_condition': ");
    field_undefined__condition->XER_encode(StreamErrorGroup_undefined__condition_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_unsupported__encoding:
    ec_1.set_msg("unsupported_encoding': ");
    field_unsupported__encoding->XER_encode(StreamErrorGroup_unsupported__encoding_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_unsupported__stanza__type:
    ec_1.set_msg("unsupported_stanza_type': ");
    field_unsupported__stanza__type->XER_encode(StreamErrorGroup_unsupported__stanza__type_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case ALT_unsupported__version:
    ec_1.set_msg("unsupported_version': ");
    field_unsupported__version->XER_encode(StreamErrorGroup_unsupported__version_xer_, p_buf, flavor_0, p_indent + (!p_indent || !omit_tag), 0);
    break;
  case UNBOUND_VALUE:
    (void)flavor_0;
    break;
  } //switch
  end_xml(p_td, p_buf, flavor_1, p_indent, 0);
  return (int)p_buf.get_len() - encoded_length;
}

int StreamErrorGroup::XER_decode(const XERdescriptor_t& p_td, XmlReaderWrap& p_reader, unsigned int p_flavor, embed_values_dec_struct_t*)
{
  int e_xer = is_exer(p_flavor);
  int type = 0;
  int rd_ok=1, xml_depth=-1;
  int xerbits = p_td.xer_bits;
  if (p_flavor & XER_TOPLEVEL) xerbits &= ~UNTAGGED;
  if (xerbits & USE_TYPE_ATTR) p_flavor &= ~XER_RECOF;
  boolean own_tag = !(e_xer && ((xerbits & (ANY_ELEMENT | UNTAGGED)) || (p_flavor & (USE_NIL|(e_xer ? XER_LIST : XER_RECOF)))));
  if ((e_xer || !is_record_of(p_flavor)) && own_tag)
  for (rd_ok = p_reader.Ok(); rd_ok == 1; rd_ok = p_reader.Read()) {
    type = p_reader.NodeType();
    if (type == XML_READER_TYPE_ELEMENT) {
      verify_name(p_reader, p_td, e_xer);
      xml_depth = p_reader.Depth();
      if (!(e_xer && (p_td.xer_bits & USE_TYPE_ATTR))
        && !p_reader.IsEmptyElement()) rd_ok = p_reader.Read();
      break;
    }
  }
  unsigned int flavor_1 = (p_flavor & XER_MASK);
  for (rd_ok = p_reader.Ok(); rd_ok == 1; rd_ok = p_reader.Read()) {
    type = p_reader.NodeType();
    if (type == XML_READER_TYPE_ELEMENT) break;
    else if (type == XML_READER_TYPE_END_ELEMENT) break;
  }
  if (rd_ok) {
    TTCN_EncDec_ErrorContext ec_1("Alternative '");
    TTCN_EncDec_ErrorContext ec_2;
    const char *elem_name;
    const char *ns_uri = 0;
    {
      elem_name = (const char*)p_reader.LocalName();
      ns_uri    = (const char*)p_reader.NamespaceUri();
    }
    if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_bad__format_xer_, flavor_1) || (StreamErrorGroup_bad__format_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("bad_format': ");
      bad__format().XER_decode(StreamErrorGroup_bad__format_xer_, p_reader, flavor_1, 0);
      if (!bad__format().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_bad__namespace__prefix_xer_, flavor_1) || (StreamErrorGroup_bad__namespace__prefix_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("bad_namespace_prefix': ");
      bad__namespace__prefix().XER_decode(StreamErrorGroup_bad__namespace__prefix_xer_, p_reader, flavor_1, 0);
      if (!bad__namespace__prefix().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_conflict_xer_, flavor_1) || (StreamErrorGroup_conflict_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("conflict': ");
      conflict().XER_decode(StreamErrorGroup_conflict_xer_, p_reader, flavor_1, 0);
      if (!conflict().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_connection__timeout_xer_, flavor_1) || (StreamErrorGroup_connection__timeout_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("connection_timeout': ");
      connection__timeout().XER_decode(StreamErrorGroup_connection__timeout_xer_, p_reader, flavor_1, 0);
      if (!connection__timeout().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_host__gone_xer_, flavor_1) || (StreamErrorGroup_host__gone_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("host_gone': ");
      host__gone().XER_decode(StreamErrorGroup_host__gone_xer_, p_reader, flavor_1, 0);
      if (!host__gone().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_host__unknown_xer_, flavor_1) || (StreamErrorGroup_host__unknown_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("host_unknown': ");
      host__unknown().XER_decode(StreamErrorGroup_host__unknown_xer_, p_reader, flavor_1, 0);
      if (!host__unknown().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_improper__addressing_xer_, flavor_1) || (StreamErrorGroup_improper__addressing_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("improper_addressing': ");
      improper__addressing().XER_decode(StreamErrorGroup_improper__addressing_xer_, p_reader, flavor_1, 0);
      if (!improper__addressing().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_internal__server__error_xer_, flavor_1) || (StreamErrorGroup_internal__server__error_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("internal_server_error': ");
      internal__server__error().XER_decode(StreamErrorGroup_internal__server__error_xer_, p_reader, flavor_1, 0);
      if (!internal__server__error().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_invalid__from_xer_, flavor_1) || (StreamErrorGroup_invalid__from_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("invalid_from': ");
      invalid__from().XER_decode(StreamErrorGroup_invalid__from_xer_, p_reader, flavor_1, 0);
      if (!invalid__from().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_invalid__id_xer_, flavor_1) || (StreamErrorGroup_invalid__id_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("invalid_id': ");
      invalid__id().XER_decode(StreamErrorGroup_invalid__id_xer_, p_reader, flavor_1, 0);
      if (!invalid__id().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_invalid__namespace_xer_, flavor_1) || (StreamErrorGroup_invalid__namespace_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("invalid_namespace': ");
      invalid__namespace().XER_decode(StreamErrorGroup_invalid__namespace_xer_, p_reader, flavor_1, 0);
      if (!invalid__namespace().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_invalid__xml_xer_, flavor_1) || (StreamErrorGroup_invalid__xml_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("invalid_xml': ");
      invalid__xml().XER_decode(StreamErrorGroup_invalid__xml_xer_, p_reader, flavor_1, 0);
      if (!invalid__xml().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_not__authorized_xer_, flavor_1) || (StreamErrorGroup_not__authorized_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("not_authorized': ");
      not__authorized().XER_decode(StreamErrorGroup_not__authorized_xer_, p_reader, flavor_1, 0);
      if (!not__authorized().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_not__well__formed_xer_, flavor_1) || (StreamErrorGroup_not__well__formed_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("not_well_formed': ");
      not__well__formed().XER_decode(StreamErrorGroup_not__well__formed_xer_, p_reader, flavor_1, 0);
      if (!not__well__formed().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_policy__violation_xer_, flavor_1) || (StreamErrorGroup_policy__violation_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("policy_violation': ");
      policy__violation().XER_decode(StreamErrorGroup_policy__violation_xer_, p_reader, flavor_1, 0);
      if (!policy__violation().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_remote__connection__failed_xer_, flavor_1) || (StreamErrorGroup_remote__connection__failed_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("remote_connection_failed': ");
      remote__connection__failed().XER_decode(StreamErrorGroup_remote__connection__failed_xer_, p_reader, flavor_1, 0);
      if (!remote__connection__failed().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_reset_xer_, flavor_1) || (StreamErrorGroup_reset_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("reset': ");
      reset().XER_decode(StreamErrorGroup_reset_xer_, p_reader, flavor_1, 0);
      if (!reset().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_resource__constraint_xer_, flavor_1) || (StreamErrorGroup_resource__constraint_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("resource_constraint': ");
      resource__constraint().XER_decode(StreamErrorGroup_resource__constraint_xer_, p_reader, flavor_1, 0);
      if (!resource__constraint().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_restricted__xml_xer_, flavor_1) || (StreamErrorGroup_restricted__xml_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("restricted_xml': ");
      restricted__xml().XER_decode(StreamErrorGroup_restricted__xml_xer_, p_reader, flavor_1, 0);
      if (!restricted__xml().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (UNIVERSAL_CHARSTRING::can_start(elem_name, ns_uri, StreamErrorGroup_see__other__host_xer_, flavor_1) || (StreamErrorGroup_see__other__host_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("see_other_host': ");
      see__other__host().XER_decode(StreamErrorGroup_see__other__host_xer_, p_reader, flavor_1, 0);
      if (!see__other__host().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_system__shutdown_xer_, flavor_1) || (StreamErrorGroup_system__shutdown_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("system_shutdown': ");
      system__shutdown().XER_decode(StreamErrorGroup_system__shutdown_xer_, p_reader, flavor_1, 0);
      if (!system__shutdown().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_undefined__condition_xer_, flavor_1) || (StreamErrorGroup_undefined__condition_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("undefined_condition': ");
      undefined__condition().XER_decode(StreamErrorGroup_undefined__condition_xer_, p_reader, flavor_1, 0);
      if (!undefined__condition().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_unsupported__encoding_xer_, flavor_1) || (StreamErrorGroup_unsupported__encoding_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("unsupported_encoding': ");
      unsupported__encoding().XER_decode(StreamErrorGroup_unsupported__encoding_xer_, p_reader, flavor_1, 0);
      if (!unsupported__encoding().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_unsupported__stanza__type_xer_, flavor_1) || (StreamErrorGroup_unsupported__stanza__type_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("unsupported_stanza_type': ");
      unsupported__stanza__type().XER_decode(StreamErrorGroup_unsupported__stanza__type_xer_, p_reader, flavor_1, 0);
      if (!unsupported__stanza__type().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else if (Empty::can_start(elem_name, ns_uri, StreamErrorGroup_unsupported__version_xer_, flavor_1) || (StreamErrorGroup_unsupported__version_xer_.xer_bits & ANY_ELEMENT)) {
      ec_2.set_msg("unsupported_version': ");
      unsupported__version().XER_decode(StreamErrorGroup_unsupported__version_xer_, p_reader, flavor_1, 0);
      if (!unsupported__version().is_bound()) {
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Failed to decode field.");
      }
    }
    else {
      ec_1.set_msg(" ");
      TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "'%s' does not match any alternative", elem_name);
      if (xml_depth >= 0) for (; rd_ok == 1 && p_reader.Depth() > xml_depth; rd_ok = p_reader.Read()) ;
    }
  }
  if ((e_xer || !is_record_of(p_flavor)) && own_tag)
  for (; rd_ok == 1; rd_ok = p_reader.Read()) {
    type = p_reader.NodeType();
    if (type == XML_READER_TYPE_END_ELEMENT) {
      verify_end(p_reader, p_td, xml_depth, e_xer);
      rd_ok = p_reader.Read(); // one last time
      break;
    }
  }
  return 1;
}

int StreamErrorGroup::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_bad__format:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "bad_format");
    enc_len += field_bad__format->JSON_encode(StreamErrorGroup_bad__format_descr_, p_tok);
    break;
  case ALT_bad__namespace__prefix:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "bad_namespace_prefix");
    enc_len += field_bad__namespace__prefix->JSON_encode(StreamErrorGroup_bad__namespace__prefix_descr_, p_tok);
    break;
  case ALT_conflict:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "conflict");
    enc_len += field_conflict->JSON_encode(StreamErrorGroup_conflict_descr_, p_tok);
    break;
  case ALT_connection__timeout:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "connection_timeout");
    enc_len += field_connection__timeout->JSON_encode(StreamErrorGroup_connection__timeout_descr_, p_tok);
    break;
  case ALT_host__gone:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "host_gone");
    enc_len += field_host__gone->JSON_encode(StreamErrorGroup_host__gone_descr_, p_tok);
    break;
  case ALT_host__unknown:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "host_unknown");
    enc_len += field_host__unknown->JSON_encode(StreamErrorGroup_host__unknown_descr_, p_tok);
    break;
  case ALT_improper__addressing:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "improper_addressing");
    enc_len += field_improper__addressing->JSON_encode(StreamErrorGroup_improper__addressing_descr_, p_tok);
    break;
  case ALT_internal__server__error:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "internal_server_error");
    enc_len += field_internal__server__error->JSON_encode(StreamErrorGroup_internal__server__error_descr_, p_tok);
    break;
  case ALT_invalid__from:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "invalid_from");
    enc_len += field_invalid__from->JSON_encode(StreamErrorGroup_invalid__from_descr_, p_tok);
    break;
  case ALT_invalid__id:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "invalid_id");
    enc_len += field_invalid__id->JSON_encode(StreamErrorGroup_invalid__id_descr_, p_tok);
    break;
  case ALT_invalid__namespace:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "invalid_namespace");
    enc_len += field_invalid__namespace->JSON_encode(StreamErrorGroup_invalid__namespace_descr_, p_tok);
    break;
  case ALT_invalid__xml:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "invalid_xml");
    enc_len += field_invalid__xml->JSON_encode(StreamErrorGroup_invalid__xml_descr_, p_tok);
    break;
  case ALT_not__authorized:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "not_authorized");
    enc_len += field_not__authorized->JSON_encode(StreamErrorGroup_not__authorized_descr_, p_tok);
    break;
  case ALT_not__well__formed:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "not_well_formed");
    enc_len += field_not__well__formed->JSON_encode(StreamErrorGroup_not__well__formed_descr_, p_tok);
    break;
  case ALT_policy__violation:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "policy_violation");
    enc_len += field_policy__violation->JSON_encode(StreamErrorGroup_policy__violation_descr_, p_tok);
    break;
  case ALT_remote__connection__failed:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "remote_connection_failed");
    enc_len += field_remote__connection__failed->JSON_encode(StreamErrorGroup_remote__connection__failed_descr_, p_tok);
    break;
  case ALT_reset:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reset");
    enc_len += field_reset->JSON_encode(StreamErrorGroup_reset_descr_, p_tok);
    break;
  case ALT_resource__constraint:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "resource_constraint");
    enc_len += field_resource__constraint->JSON_encode(StreamErrorGroup_resource__constraint_descr_, p_tok);
    break;
  case ALT_restricted__xml:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "restricted_xml");
    enc_len += field_restricted__xml->JSON_encode(StreamErrorGroup_restricted__xml_descr_, p_tok);
    break;
  case ALT_see__other__host:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "see_other_host");
    enc_len += field_see__other__host->JSON_encode(StreamErrorGroup_see__other__host_descr_, p_tok);
    break;
  case ALT_system__shutdown:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "system_shutdown");
    enc_len += field_system__shutdown->JSON_encode(StreamErrorGroup_system__shutdown_descr_, p_tok);
    break;
  case ALT_undefined__condition:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "undefined_condition");
    enc_len += field_undefined__condition->JSON_encode(StreamErrorGroup_undefined__condition_descr_, p_tok);
    break;
  case ALT_unsupported__encoding:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "unsupported_encoding");
    enc_len += field_unsupported__encoding->JSON_encode(StreamErrorGroup_unsupported__encoding_descr_, p_tok);
    break;
  case ALT_unsupported__stanza__type:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "unsupported_stanza_type");
    enc_len += field_unsupported__stanza__type->JSON_encode(StreamErrorGroup_unsupported__stanza__type_descr_, p_tok);
    break;
  case ALT_unsupported__version:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "unsupported_version");
    enc_len += field_unsupported__version->JSON_encode(StreamErrorGroup_unsupported__version_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int StreamErrorGroup::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "bad_format", name_len)) {
      int ret_val = bad__format().JSON_decode(StreamErrorGroup_bad__format_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "bad_format");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "bad_namespace_prefix", name_len)) {
      int ret_val = bad__namespace__prefix().JSON_decode(StreamErrorGroup_bad__namespace__prefix_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "bad_namespace_prefix");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "conflict", name_len)) {
      int ret_val = conflict().JSON_decode(StreamErrorGroup_conflict_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "conflict");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "connection_timeout", name_len)) {
      int ret_val = connection__timeout().JSON_decode(StreamErrorGroup_connection__timeout_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "connection_timeout");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "host_gone", name_len)) {
      int ret_val = host__gone().JSON_decode(StreamErrorGroup_host__gone_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "host_gone");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "host_unknown", name_len)) {
      int ret_val = host__unknown().JSON_decode(StreamErrorGroup_host__unknown_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "host_unknown");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "improper_addressing", name_len)) {
      int ret_val = improper__addressing().JSON_decode(StreamErrorGroup_improper__addressing_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "improper_addressing");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "internal_server_error", name_len)) {
      int ret_val = internal__server__error().JSON_decode(StreamErrorGroup_internal__server__error_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "internal_server_error");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "invalid_from", name_len)) {
      int ret_val = invalid__from().JSON_decode(StreamErrorGroup_invalid__from_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "invalid_from");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "invalid_id", name_len)) {
      int ret_val = invalid__id().JSON_decode(StreamErrorGroup_invalid__id_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "invalid_id");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "invalid_namespace", name_len)) {
      int ret_val = invalid__namespace().JSON_decode(StreamErrorGroup_invalid__namespace_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "invalid_namespace");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "invalid_xml", name_len)) {
      int ret_val = invalid__xml().JSON_decode(StreamErrorGroup_invalid__xml_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "invalid_xml");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "not_authorized", name_len)) {
      int ret_val = not__authorized().JSON_decode(StreamErrorGroup_not__authorized_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "not_authorized");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "not_well_formed", name_len)) {
      int ret_val = not__well__formed().JSON_decode(StreamErrorGroup_not__well__formed_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "not_well_formed");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "policy_violation", name_len)) {
      int ret_val = policy__violation().JSON_decode(StreamErrorGroup_policy__violation_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "policy_violation");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "remote_connection_failed", name_len)) {
      int ret_val = remote__connection__failed().JSON_decode(StreamErrorGroup_remote__connection__failed_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "remote_connection_failed");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "reset", name_len)) {
      int ret_val = reset().JSON_decode(StreamErrorGroup_reset_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reset");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "resource_constraint", name_len)) {
      int ret_val = resource__constraint().JSON_decode(StreamErrorGroup_resource__constraint_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "resource_constraint");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "restricted_xml", name_len)) {
      int ret_val = restricted__xml().JSON_decode(StreamErrorGroup_restricted__xml_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "restricted_xml");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "see_other_host", name_len)) {
      int ret_val = see__other__host().JSON_decode(StreamErrorGroup_see__other__host_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "see_other_host");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "system_shutdown", name_len)) {
      int ret_val = system__shutdown().JSON_decode(StreamErrorGroup_system__shutdown_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "system_shutdown");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "undefined_condition", name_len)) {
      int ret_val = undefined__condition().JSON_decode(StreamErrorGroup_undefined__condition_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "undefined_condition");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "unsupported_encoding", name_len)) {
      int ret_val = unsupported__encoding().JSON_decode(StreamErrorGroup_unsupported__encoding_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "unsupported_encoding");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "unsupported_stanza_type", name_len)) {
      int ret_val = unsupported__stanza__type().JSON_decode(StreamErrorGroup_unsupported__stanza__type_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "unsupported_stanza_type");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "unsupported_version", name_len)) {
      int ret_val = unsupported__version().JSON_decode(StreamErrorGroup_unsupported__version_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "unsupported_version");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void StreamErrorGroup_template::copy_value(const StreamErrorGroup& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case StreamErrorGroup::ALT_bad__format:
single_value.field_bad__format = new Empty_template(other_value.bad__format());
break;
case StreamErrorGroup::ALT_bad__namespace__prefix:
single_value.field_bad__namespace__prefix = new Empty_template(other_value.bad__namespace__prefix());
break;
case StreamErrorGroup::ALT_conflict:
single_value.field_conflict = new Empty_template(other_value.conflict());
break;
case StreamErrorGroup::ALT_connection__timeout:
single_value.field_connection__timeout = new Empty_template(other_value.connection__timeout());
break;
case StreamErrorGroup::ALT_host__gone:
single_value.field_host__gone = new Empty_template(other_value.host__gone());
break;
case StreamErrorGroup::ALT_host__unknown:
single_value.field_host__unknown = new Empty_template(other_value.host__unknown());
break;
case StreamErrorGroup::ALT_improper__addressing:
single_value.field_improper__addressing = new Empty_template(other_value.improper__addressing());
break;
case StreamErrorGroup::ALT_internal__server__error:
single_value.field_internal__server__error = new Empty_template(other_value.internal__server__error());
break;
case StreamErrorGroup::ALT_invalid__from:
single_value.field_invalid__from = new Empty_template(other_value.invalid__from());
break;
case StreamErrorGroup::ALT_invalid__id:
single_value.field_invalid__id = new Empty_template(other_value.invalid__id());
break;
case StreamErrorGroup::ALT_invalid__namespace:
single_value.field_invalid__namespace = new Empty_template(other_value.invalid__namespace());
break;
case StreamErrorGroup::ALT_invalid__xml:
single_value.field_invalid__xml = new Empty_template(other_value.invalid__xml());
break;
case StreamErrorGroup::ALT_not__authorized:
single_value.field_not__authorized = new Empty_template(other_value.not__authorized());
break;
case StreamErrorGroup::ALT_not__well__formed:
single_value.field_not__well__formed = new Empty_template(other_value.not__well__formed());
break;
case StreamErrorGroup::ALT_policy__violation:
single_value.field_policy__violation = new Empty_template(other_value.policy__violation());
break;
case StreamErrorGroup::ALT_remote__connection__failed:
single_value.field_remote__connection__failed = new Empty_template(other_value.remote__connection__failed());
break;
case StreamErrorGroup::ALT_reset:
single_value.field_reset = new Empty_template(other_value.reset());
break;
case StreamErrorGroup::ALT_resource__constraint:
single_value.field_resource__constraint = new Empty_template(other_value.resource__constraint());
break;
case StreamErrorGroup::ALT_restricted__xml:
single_value.field_restricted__xml = new Empty_template(other_value.restricted__xml());
break;
case StreamErrorGroup::ALT_see__other__host:
single_value.field_see__other__host = new UNIVERSAL_CHARSTRING_template(other_value.see__other__host());
break;
case StreamErrorGroup::ALT_system__shutdown:
single_value.field_system__shutdown = new Empty_template(other_value.system__shutdown());
break;
case StreamErrorGroup::ALT_undefined__condition:
single_value.field_undefined__condition = new Empty_template(other_value.undefined__condition());
break;
case StreamErrorGroup::ALT_unsupported__encoding:
single_value.field_unsupported__encoding = new Empty_template(other_value.unsupported__encoding());
break;
case StreamErrorGroup::ALT_unsupported__stanza__type:
single_value.field_unsupported__stanza__type = new Empty_template(other_value.unsupported__stanza__type());
break;
case StreamErrorGroup::ALT_unsupported__version:
single_value.field_unsupported__version = new Empty_template(other_value.unsupported__version());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
set_selection(SPECIFIC_VALUE);
}

void StreamErrorGroup_template::copy_template(const StreamErrorGroup_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case StreamErrorGroup::ALT_bad__format:
single_value.field_bad__format = new Empty_template(*other_value.single_value.field_bad__format);
break;
case StreamErrorGroup::ALT_bad__namespace__prefix:
single_value.field_bad__namespace__prefix = new Empty_template(*other_value.single_value.field_bad__namespace__prefix);
break;
case StreamErrorGroup::ALT_conflict:
single_value.field_conflict = new Empty_template(*other_value.single_value.field_conflict);
break;
case StreamErrorGroup::ALT_connection__timeout:
single_value.field_connection__timeout = new Empty_template(*other_value.single_value.field_connection__timeout);
break;
case StreamErrorGroup::ALT_host__gone:
single_value.field_host__gone = new Empty_template(*other_value.single_value.field_host__gone);
break;
case StreamErrorGroup::ALT_host__unknown:
single_value.field_host__unknown = new Empty_template(*other_value.single_value.field_host__unknown);
break;
case StreamErrorGroup::ALT_improper__addressing:
single_value.field_improper__addressing = new Empty_template(*other_value.single_value.field_improper__addressing);
break;
case StreamErrorGroup::ALT_internal__server__error:
single_value.field_internal__server__error = new Empty_template(*other_value.single_value.field_internal__server__error);
break;
case StreamErrorGroup::ALT_invalid__from:
single_value.field_invalid__from = new Empty_template(*other_value.single_value.field_invalid__from);
break;
case StreamErrorGroup::ALT_invalid__id:
single_value.field_invalid__id = new Empty_template(*other_value.single_value.field_invalid__id);
break;
case StreamErrorGroup::ALT_invalid__namespace:
single_value.field_invalid__namespace = new Empty_template(*other_value.single_value.field_invalid__namespace);
break;
case StreamErrorGroup::ALT_invalid__xml:
single_value.field_invalid__xml = new Empty_template(*other_value.single_value.field_invalid__xml);
break;
case StreamErrorGroup::ALT_not__authorized:
single_value.field_not__authorized = new Empty_template(*other_value.single_value.field_not__authorized);
break;
case StreamErrorGroup::ALT_not__well__formed:
single_value.field_not__well__formed = new Empty_template(*other_value.single_value.field_not__well__formed);
break;
case StreamErrorGroup::ALT_policy__violation:
single_value.field_policy__violation = new Empty_template(*other_value.single_value.field_policy__violation);
break;
case StreamErrorGroup::ALT_remote__connection__failed:
single_value.field_remote__connection__failed = new Empty_template(*other_value.single_value.field_remote__connection__failed);
break;
case StreamErrorGroup::ALT_reset:
single_value.field_reset = new Empty_template(*other_value.single_value.field_reset);
break;
case StreamErrorGroup::ALT_resource__constraint:
single_value.field_resource__constraint = new Empty_template(*other_value.single_value.field_resource__constraint);
break;
case StreamErrorGroup::ALT_restricted__xml:
single_value.field_restricted__xml = new Empty_template(*other_value.single_value.field_restricted__xml);
break;
case StreamErrorGroup::ALT_see__other__host:
single_value.field_see__other__host = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_see__other__host);
break;
case StreamErrorGroup::ALT_system__shutdown:
single_value.field_system__shutdown = new Empty_template(*other_value.single_value.field_system__shutdown);
break;
case StreamErrorGroup::ALT_undefined__condition:
single_value.field_undefined__condition = new Empty_template(*other_value.single_value.field_undefined__condition);
break;
case StreamErrorGroup::ALT_unsupported__encoding:
single_value.field_unsupported__encoding = new Empty_template(*other_value.single_value.field_unsupported__encoding);
break;
case StreamErrorGroup::ALT_unsupported__stanza__type:
single_value.field_unsupported__stanza__type = new Empty_template(*other_value.single_value.field_unsupported__stanza__type);
break;
case StreamErrorGroup::ALT_unsupported__version:
single_value.field_unsupported__version = new Empty_template(*other_value.single_value.field_unsupported__version);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new StreamErrorGroup_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
set_selection(other_value);
}

StreamErrorGroup_template::StreamErrorGroup_template()
{
}

StreamErrorGroup_template::StreamErrorGroup_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

StreamErrorGroup_template::StreamErrorGroup_template(const StreamErrorGroup& other_value)
{
copy_value(other_value);
}

StreamErrorGroup_template::StreamErrorGroup_template(const OPTIONAL<StreamErrorGroup>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const StreamErrorGroup&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup from an unbound optional field.");
}
}

StreamErrorGroup_template::StreamErrorGroup_template(const StreamErrorGroup_template& other_value)
: Base_Template(){
copy_template(other_value);
}

StreamErrorGroup_template::~StreamErrorGroup_template()
{
clean_up();
}

void StreamErrorGroup_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case StreamErrorGroup::ALT_bad__format:
delete single_value.field_bad__format;
break;
case StreamErrorGroup::ALT_bad__namespace__prefix:
delete single_value.field_bad__namespace__prefix;
break;
case StreamErrorGroup::ALT_conflict:
delete single_value.field_conflict;
break;
case StreamErrorGroup::ALT_connection__timeout:
delete single_value.field_connection__timeout;
break;
case StreamErrorGroup::ALT_host__gone:
delete single_value.field_host__gone;
break;
case StreamErrorGroup::ALT_host__unknown:
delete single_value.field_host__unknown;
break;
case StreamErrorGroup::ALT_improper__addressing:
delete single_value.field_improper__addressing;
break;
case StreamErrorGroup::ALT_internal__server__error:
delete single_value.field_internal__server__error;
break;
case StreamErrorGroup::ALT_invalid__from:
delete single_value.field_invalid__from;
break;
case StreamErrorGroup::ALT_invalid__id:
delete single_value.field_invalid__id;
break;
case StreamErrorGroup::ALT_invalid__namespace:
delete single_value.field_invalid__namespace;
break;
case StreamErrorGroup::ALT_invalid__xml:
delete single_value.field_invalid__xml;
break;
case StreamErrorGroup::ALT_not__authorized:
delete single_value.field_not__authorized;
break;
case StreamErrorGroup::ALT_not__well__formed:
delete single_value.field_not__well__formed;
break;
case StreamErrorGroup::ALT_policy__violation:
delete single_value.field_policy__violation;
break;
case StreamErrorGroup::ALT_remote__connection__failed:
delete single_value.field_remote__connection__failed;
break;
case StreamErrorGroup::ALT_reset:
delete single_value.field_reset;
break;
case StreamErrorGroup::ALT_resource__constraint:
delete single_value.field_resource__constraint;
break;
case StreamErrorGroup::ALT_restricted__xml:
delete single_value.field_restricted__xml;
break;
case StreamErrorGroup::ALT_see__other__host:
delete single_value.field_see__other__host;
break;
case StreamErrorGroup::ALT_system__shutdown:
delete single_value.field_system__shutdown;
break;
case StreamErrorGroup::ALT_undefined__condition:
delete single_value.field_undefined__condition;
break;
case StreamErrorGroup::ALT_unsupported__encoding:
delete single_value.field_unsupported__encoding;
break;
case StreamErrorGroup::ALT_unsupported__stanza__type:
delete single_value.field_unsupported__stanza__type;
break;
case StreamErrorGroup::ALT_unsupported__version:
delete single_value.field_unsupported__version;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

StreamErrorGroup_template& StreamErrorGroup_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

StreamErrorGroup_template& StreamErrorGroup_template::operator=(const StreamErrorGroup& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

StreamErrorGroup_template& StreamErrorGroup_template::operator=(const OPTIONAL<StreamErrorGroup>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const StreamErrorGroup&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
return *this;
}

StreamErrorGroup_template& StreamErrorGroup_template::operator=(const StreamErrorGroup_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean StreamErrorGroup_template::match(const StreamErrorGroup& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
StreamErrorGroup::union_selection_type value_selection = other_value.get_selection();
if (value_selection == StreamErrorGroup::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case StreamErrorGroup::ALT_bad__format:
return single_value.field_bad__format->match(other_value.bad__format());
case StreamErrorGroup::ALT_bad__namespace__prefix:
return single_value.field_bad__namespace__prefix->match(other_value.bad__namespace__prefix());
case StreamErrorGroup::ALT_conflict:
return single_value.field_conflict->match(other_value.conflict());
case StreamErrorGroup::ALT_connection__timeout:
return single_value.field_connection__timeout->match(other_value.connection__timeout());
case StreamErrorGroup::ALT_host__gone:
return single_value.field_host__gone->match(other_value.host__gone());
case StreamErrorGroup::ALT_host__unknown:
return single_value.field_host__unknown->match(other_value.host__unknown());
case StreamErrorGroup::ALT_improper__addressing:
return single_value.field_improper__addressing->match(other_value.improper__addressing());
case StreamErrorGroup::ALT_internal__server__error:
return single_value.field_internal__server__error->match(other_value.internal__server__error());
case StreamErrorGroup::ALT_invalid__from:
return single_value.field_invalid__from->match(other_value.invalid__from());
case StreamErrorGroup::ALT_invalid__id:
return single_value.field_invalid__id->match(other_value.invalid__id());
case StreamErrorGroup::ALT_invalid__namespace:
return single_value.field_invalid__namespace->match(other_value.invalid__namespace());
case StreamErrorGroup::ALT_invalid__xml:
return single_value.field_invalid__xml->match(other_value.invalid__xml());
case StreamErrorGroup::ALT_not__authorized:
return single_value.field_not__authorized->match(other_value.not__authorized());
case StreamErrorGroup::ALT_not__well__formed:
return single_value.field_not__well__formed->match(other_value.not__well__formed());
case StreamErrorGroup::ALT_policy__violation:
return single_value.field_policy__violation->match(other_value.policy__violation());
case StreamErrorGroup::ALT_remote__connection__failed:
return single_value.field_remote__connection__failed->match(other_value.remote__connection__failed());
case StreamErrorGroup::ALT_reset:
return single_value.field_reset->match(other_value.reset());
case StreamErrorGroup::ALT_resource__constraint:
return single_value.field_resource__constraint->match(other_value.resource__constraint());
case StreamErrorGroup::ALT_restricted__xml:
return single_value.field_restricted__xml->match(other_value.restricted__xml());
case StreamErrorGroup::ALT_see__other__host:
return single_value.field_see__other__host->match(other_value.see__other__host());
case StreamErrorGroup::ALT_system__shutdown:
return single_value.field_system__shutdown->match(other_value.system__shutdown());
case StreamErrorGroup::ALT_undefined__condition:
return single_value.field_undefined__condition->match(other_value.undefined__condition());
case StreamErrorGroup::ALT_unsupported__encoding:
return single_value.field_unsupported__encoding->match(other_value.unsupported__encoding());
case StreamErrorGroup::ALT_unsupported__stanza__type:
return single_value.field_unsupported__stanza__type->match(other_value.unsupported__stanza__type());
case StreamErrorGroup::ALT_unsupported__version:
return single_value.field_unsupported__version->match(other_value.unsupported__version());
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
return FALSE;
}

boolean StreamErrorGroup_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case StreamErrorGroup::ALT_bad__format:
return single_value.field_bad__format->is_value();
case StreamErrorGroup::ALT_bad__namespace__prefix:
return single_value.field_bad__namespace__prefix->is_value();
case StreamErrorGroup::ALT_conflict:
return single_value.field_conflict->is_value();
case StreamErrorGroup::ALT_connection__timeout:
return single_value.field_connection__timeout->is_value();
case StreamErrorGroup::ALT_host__gone:
return single_value.field_host__gone->is_value();
case StreamErrorGroup::ALT_host__unknown:
return single_value.field_host__unknown->is_value();
case StreamErrorGroup::ALT_improper__addressing:
return single_value.field_improper__addressing->is_value();
case StreamErrorGroup::ALT_internal__server__error:
return single_value.field_internal__server__error->is_value();
case StreamErrorGroup::ALT_invalid__from:
return single_value.field_invalid__from->is_value();
case StreamErrorGroup::ALT_invalid__id:
return single_value.field_invalid__id->is_value();
case StreamErrorGroup::ALT_invalid__namespace:
return single_value.field_invalid__namespace->is_value();
case StreamErrorGroup::ALT_invalid__xml:
return single_value.field_invalid__xml->is_value();
case StreamErrorGroup::ALT_not__authorized:
return single_value.field_not__authorized->is_value();
case StreamErrorGroup::ALT_not__well__formed:
return single_value.field_not__well__formed->is_value();
case StreamErrorGroup::ALT_policy__violation:
return single_value.field_policy__violation->is_value();
case StreamErrorGroup::ALT_remote__connection__failed:
return single_value.field_remote__connection__failed->is_value();
case StreamErrorGroup::ALT_reset:
return single_value.field_reset->is_value();
case StreamErrorGroup::ALT_resource__constraint:
return single_value.field_resource__constraint->is_value();
case StreamErrorGroup::ALT_restricted__xml:
return single_value.field_restricted__xml->is_value();
case StreamErrorGroup::ALT_see__other__host:
return single_value.field_see__other__host->is_value();
case StreamErrorGroup::ALT_system__shutdown:
return single_value.field_system__shutdown->is_value();
case StreamErrorGroup::ALT_undefined__condition:
return single_value.field_undefined__condition->is_value();
case StreamErrorGroup::ALT_unsupported__encoding:
return single_value.field_unsupported__encoding->is_value();
case StreamErrorGroup::ALT_unsupported__stanza__type:
return single_value.field_unsupported__stanza__type->is_value();
case StreamErrorGroup::ALT_unsupported__version:
return single_value.field_unsupported__version->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
}

StreamErrorGroup StreamErrorGroup_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
StreamErrorGroup ret_val;
switch (single_value.union_selection) {
case StreamErrorGroup::ALT_bad__format:
ret_val.bad__format() = single_value.field_bad__format->valueof();
break;
case StreamErrorGroup::ALT_bad__namespace__prefix:
ret_val.bad__namespace__prefix() = single_value.field_bad__namespace__prefix->valueof();
break;
case StreamErrorGroup::ALT_conflict:
ret_val.conflict() = single_value.field_conflict->valueof();
break;
case StreamErrorGroup::ALT_connection__timeout:
ret_val.connection__timeout() = single_value.field_connection__timeout->valueof();
break;
case StreamErrorGroup::ALT_host__gone:
ret_val.host__gone() = single_value.field_host__gone->valueof();
break;
case StreamErrorGroup::ALT_host__unknown:
ret_val.host__unknown() = single_value.field_host__unknown->valueof();
break;
case StreamErrorGroup::ALT_improper__addressing:
ret_val.improper__addressing() = single_value.field_improper__addressing->valueof();
break;
case StreamErrorGroup::ALT_internal__server__error:
ret_val.internal__server__error() = single_value.field_internal__server__error->valueof();
break;
case StreamErrorGroup::ALT_invalid__from:
ret_val.invalid__from() = single_value.field_invalid__from->valueof();
break;
case StreamErrorGroup::ALT_invalid__id:
ret_val.invalid__id() = single_value.field_invalid__id->valueof();
break;
case StreamErrorGroup::ALT_invalid__namespace:
ret_val.invalid__namespace() = single_value.field_invalid__namespace->valueof();
break;
case StreamErrorGroup::ALT_invalid__xml:
ret_val.invalid__xml() = single_value.field_invalid__xml->valueof();
break;
case StreamErrorGroup::ALT_not__authorized:
ret_val.not__authorized() = single_value.field_not__authorized->valueof();
break;
case StreamErrorGroup::ALT_not__well__formed:
ret_val.not__well__formed() = single_value.field_not__well__formed->valueof();
break;
case StreamErrorGroup::ALT_policy__violation:
ret_val.policy__violation() = single_value.field_policy__violation->valueof();
break;
case StreamErrorGroup::ALT_remote__connection__failed:
ret_val.remote__connection__failed() = single_value.field_remote__connection__failed->valueof();
break;
case StreamErrorGroup::ALT_reset:
ret_val.reset() = single_value.field_reset->valueof();
break;
case StreamErrorGroup::ALT_resource__constraint:
ret_val.resource__constraint() = single_value.field_resource__constraint->valueof();
break;
case StreamErrorGroup::ALT_restricted__xml:
ret_val.restricted__xml() = single_value.field_restricted__xml->valueof();
break;
case StreamErrorGroup::ALT_see__other__host:
ret_val.see__other__host() = single_value.field_see__other__host->valueof();
break;
case StreamErrorGroup::ALT_system__shutdown:
ret_val.system__shutdown() = single_value.field_system__shutdown->valueof();
break;
case StreamErrorGroup::ALT_undefined__condition:
ret_val.undefined__condition() = single_value.field_undefined__condition->valueof();
break;
case StreamErrorGroup::ALT_unsupported__encoding:
ret_val.unsupported__encoding() = single_value.field_unsupported__encoding->valueof();
break;
case StreamErrorGroup::ALT_unsupported__stanza__type:
ret_val.unsupported__stanza__type() = single_value.field_unsupported__stanza__type->valueof();
break;
case StreamErrorGroup::ALT_unsupported__version:
ret_val.unsupported__version() = single_value.field_unsupported__version->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
return ret_val;
}

StreamErrorGroup_template& StreamErrorGroup_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return value_list.list_value[list_index];
}
void StreamErrorGroup_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new StreamErrorGroup_template[list_length];
}

Empty_template& StreamErrorGroup_template::bad__format()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_bad__format) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_bad__format = new Empty_template(ANY_VALUE);
else single_value.field_bad__format = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_bad__format;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_bad__format;
}

const Empty_template& StreamErrorGroup_template::bad__format() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field bad_format in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_bad__format) TTCN_error("Accessing non-selected field bad_format in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_bad__format;
}

Empty_template& StreamErrorGroup_template::bad__namespace__prefix()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_bad__namespace__prefix) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_bad__namespace__prefix = new Empty_template(ANY_VALUE);
else single_value.field_bad__namespace__prefix = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_bad__namespace__prefix;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_bad__namespace__prefix;
}

const Empty_template& StreamErrorGroup_template::bad__namespace__prefix() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field bad_namespace_prefix in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_bad__namespace__prefix) TTCN_error("Accessing non-selected field bad_namespace_prefix in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_bad__namespace__prefix;
}

Empty_template& StreamErrorGroup_template::conflict()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_conflict) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_conflict = new Empty_template(ANY_VALUE);
else single_value.field_conflict = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_conflict;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_conflict;
}

const Empty_template& StreamErrorGroup_template::conflict() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field conflict in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_conflict) TTCN_error("Accessing non-selected field conflict in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_conflict;
}

Empty_template& StreamErrorGroup_template::connection__timeout()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_connection__timeout) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_connection__timeout = new Empty_template(ANY_VALUE);
else single_value.field_connection__timeout = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_connection__timeout;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_connection__timeout;
}

const Empty_template& StreamErrorGroup_template::connection__timeout() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field connection_timeout in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_connection__timeout) TTCN_error("Accessing non-selected field connection_timeout in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_connection__timeout;
}

Empty_template& StreamErrorGroup_template::host__gone()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_host__gone) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_host__gone = new Empty_template(ANY_VALUE);
else single_value.field_host__gone = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_host__gone;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_host__gone;
}

const Empty_template& StreamErrorGroup_template::host__gone() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field host_gone in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_host__gone) TTCN_error("Accessing non-selected field host_gone in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_host__gone;
}

Empty_template& StreamErrorGroup_template::host__unknown()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_host__unknown) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_host__unknown = new Empty_template(ANY_VALUE);
else single_value.field_host__unknown = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_host__unknown;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_host__unknown;
}

const Empty_template& StreamErrorGroup_template::host__unknown() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field host_unknown in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_host__unknown) TTCN_error("Accessing non-selected field host_unknown in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_host__unknown;
}

Empty_template& StreamErrorGroup_template::improper__addressing()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_improper__addressing) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_improper__addressing = new Empty_template(ANY_VALUE);
else single_value.field_improper__addressing = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_improper__addressing;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_improper__addressing;
}

const Empty_template& StreamErrorGroup_template::improper__addressing() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field improper_addressing in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_improper__addressing) TTCN_error("Accessing non-selected field improper_addressing in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_improper__addressing;
}

Empty_template& StreamErrorGroup_template::internal__server__error()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_internal__server__error) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_internal__server__error = new Empty_template(ANY_VALUE);
else single_value.field_internal__server__error = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_internal__server__error;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_internal__server__error;
}

const Empty_template& StreamErrorGroup_template::internal__server__error() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field internal_server_error in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_internal__server__error) TTCN_error("Accessing non-selected field internal_server_error in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_internal__server__error;
}

Empty_template& StreamErrorGroup_template::invalid__from()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_invalid__from) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_invalid__from = new Empty_template(ANY_VALUE);
else single_value.field_invalid__from = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_invalid__from;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_invalid__from;
}

const Empty_template& StreamErrorGroup_template::invalid__from() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field invalid_from in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_invalid__from) TTCN_error("Accessing non-selected field invalid_from in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_invalid__from;
}

Empty_template& StreamErrorGroup_template::invalid__id()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_invalid__id) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_invalid__id = new Empty_template(ANY_VALUE);
else single_value.field_invalid__id = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_invalid__id;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_invalid__id;
}

const Empty_template& StreamErrorGroup_template::invalid__id() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field invalid_id in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_invalid__id) TTCN_error("Accessing non-selected field invalid_id in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_invalid__id;
}

Empty_template& StreamErrorGroup_template::invalid__namespace()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_invalid__namespace) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_invalid__namespace = new Empty_template(ANY_VALUE);
else single_value.field_invalid__namespace = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_invalid__namespace;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_invalid__namespace;
}

const Empty_template& StreamErrorGroup_template::invalid__namespace() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field invalid_namespace in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_invalid__namespace) TTCN_error("Accessing non-selected field invalid_namespace in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_invalid__namespace;
}

Empty_template& StreamErrorGroup_template::invalid__xml()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_invalid__xml) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_invalid__xml = new Empty_template(ANY_VALUE);
else single_value.field_invalid__xml = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_invalid__xml;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_invalid__xml;
}

const Empty_template& StreamErrorGroup_template::invalid__xml() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field invalid_xml in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_invalid__xml) TTCN_error("Accessing non-selected field invalid_xml in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_invalid__xml;
}

Empty_template& StreamErrorGroup_template::not__authorized()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_not__authorized) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_not__authorized = new Empty_template(ANY_VALUE);
else single_value.field_not__authorized = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_not__authorized;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_not__authorized;
}

const Empty_template& StreamErrorGroup_template::not__authorized() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field not_authorized in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_not__authorized) TTCN_error("Accessing non-selected field not_authorized in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_not__authorized;
}

Empty_template& StreamErrorGroup_template::not__well__formed()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_not__well__formed) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_not__well__formed = new Empty_template(ANY_VALUE);
else single_value.field_not__well__formed = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_not__well__formed;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_not__well__formed;
}

const Empty_template& StreamErrorGroup_template::not__well__formed() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field not_well_formed in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_not__well__formed) TTCN_error("Accessing non-selected field not_well_formed in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_not__well__formed;
}

Empty_template& StreamErrorGroup_template::policy__violation()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_policy__violation) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_policy__violation = new Empty_template(ANY_VALUE);
else single_value.field_policy__violation = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_policy__violation;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_policy__violation;
}

const Empty_template& StreamErrorGroup_template::policy__violation() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field policy_violation in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_policy__violation) TTCN_error("Accessing non-selected field policy_violation in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_policy__violation;
}

Empty_template& StreamErrorGroup_template::remote__connection__failed()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_remote__connection__failed) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_remote__connection__failed = new Empty_template(ANY_VALUE);
else single_value.field_remote__connection__failed = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_remote__connection__failed;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_remote__connection__failed;
}

const Empty_template& StreamErrorGroup_template::remote__connection__failed() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field remote_connection_failed in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_remote__connection__failed) TTCN_error("Accessing non-selected field remote_connection_failed in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_remote__connection__failed;
}

Empty_template& StreamErrorGroup_template::reset()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_reset) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_reset = new Empty_template(ANY_VALUE);
else single_value.field_reset = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_reset;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_reset;
}

const Empty_template& StreamErrorGroup_template::reset() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field reset in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_reset) TTCN_error("Accessing non-selected field reset in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_reset;
}

Empty_template& StreamErrorGroup_template::resource__constraint()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_resource__constraint) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_resource__constraint = new Empty_template(ANY_VALUE);
else single_value.field_resource__constraint = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_resource__constraint;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_resource__constraint;
}

const Empty_template& StreamErrorGroup_template::resource__constraint() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field resource_constraint in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_resource__constraint) TTCN_error("Accessing non-selected field resource_constraint in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_resource__constraint;
}

Empty_template& StreamErrorGroup_template::restricted__xml()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_restricted__xml) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_restricted__xml = new Empty_template(ANY_VALUE);
else single_value.field_restricted__xml = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_restricted__xml;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_restricted__xml;
}

const Empty_template& StreamErrorGroup_template::restricted__xml() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field restricted_xml in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_restricted__xml) TTCN_error("Accessing non-selected field restricted_xml in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_restricted__xml;
}

UNIVERSAL_CHARSTRING_template& StreamErrorGroup_template::see__other__host()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_see__other__host) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_see__other__host = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_see__other__host = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = StreamErrorGroup::ALT_see__other__host;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_see__other__host;
}

const UNIVERSAL_CHARSTRING_template& StreamErrorGroup_template::see__other__host() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field see_other_host in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_see__other__host) TTCN_error("Accessing non-selected field see_other_host in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_see__other__host;
}

Empty_template& StreamErrorGroup_template::system__shutdown()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_system__shutdown) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_system__shutdown = new Empty_template(ANY_VALUE);
else single_value.field_system__shutdown = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_system__shutdown;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_system__shutdown;
}

const Empty_template& StreamErrorGroup_template::system__shutdown() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field system_shutdown in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_system__shutdown) TTCN_error("Accessing non-selected field system_shutdown in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_system__shutdown;
}

Empty_template& StreamErrorGroup_template::undefined__condition()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_undefined__condition) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_undefined__condition = new Empty_template(ANY_VALUE);
else single_value.field_undefined__condition = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_undefined__condition;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_undefined__condition;
}

const Empty_template& StreamErrorGroup_template::undefined__condition() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field undefined_condition in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_undefined__condition) TTCN_error("Accessing non-selected field undefined_condition in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_undefined__condition;
}

Empty_template& StreamErrorGroup_template::unsupported__encoding()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_unsupported__encoding) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_unsupported__encoding = new Empty_template(ANY_VALUE);
else single_value.field_unsupported__encoding = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_unsupported__encoding;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_unsupported__encoding;
}

const Empty_template& StreamErrorGroup_template::unsupported__encoding() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field unsupported_encoding in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_unsupported__encoding) TTCN_error("Accessing non-selected field unsupported_encoding in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_unsupported__encoding;
}

Empty_template& StreamErrorGroup_template::unsupported__stanza__type()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_unsupported__stanza__type) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_unsupported__stanza__type = new Empty_template(ANY_VALUE);
else single_value.field_unsupported__stanza__type = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_unsupported__stanza__type;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_unsupported__stanza__type;
}

const Empty_template& StreamErrorGroup_template::unsupported__stanza__type() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field unsupported_stanza_type in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_unsupported__stanza__type) TTCN_error("Accessing non-selected field unsupported_stanza_type in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_unsupported__stanza__type;
}

Empty_template& StreamErrorGroup_template::unsupported__version()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != StreamErrorGroup::ALT_unsupported__version) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_unsupported__version = new Empty_template(ANY_VALUE);
else single_value.field_unsupported__version = new Empty_template;
single_value.union_selection = StreamErrorGroup::ALT_unsupported__version;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_unsupported__version;
}

const Empty_template& StreamErrorGroup_template::unsupported__version() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field unsupported_version in a non-specific template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
if (single_value.union_selection != StreamErrorGroup::ALT_unsupported__version) TTCN_error("Accessing non-selected field unsupported_version in a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return *single_value.field_unsupported__version;
}

boolean StreamErrorGroup_template::ischosen(StreamErrorGroup::union_selection_type checked_selection) const
{
if (checked_selection == StreamErrorGroup::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == StreamErrorGroup::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
}
return FALSE;
}

void StreamErrorGroup_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case StreamErrorGroup::ALT_bad__format:
TTCN_Logger::log_event_str("{ bad_format := ");
single_value.field_bad__format->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_bad__namespace__prefix:
TTCN_Logger::log_event_str("{ bad_namespace_prefix := ");
single_value.field_bad__namespace__prefix->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_conflict:
TTCN_Logger::log_event_str("{ conflict := ");
single_value.field_conflict->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_connection__timeout:
TTCN_Logger::log_event_str("{ connection_timeout := ");
single_value.field_connection__timeout->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_host__gone:
TTCN_Logger::log_event_str("{ host_gone := ");
single_value.field_host__gone->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_host__unknown:
TTCN_Logger::log_event_str("{ host_unknown := ");
single_value.field_host__unknown->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_improper__addressing:
TTCN_Logger::log_event_str("{ improper_addressing := ");
single_value.field_improper__addressing->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_internal__server__error:
TTCN_Logger::log_event_str("{ internal_server_error := ");
single_value.field_internal__server__error->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_invalid__from:
TTCN_Logger::log_event_str("{ invalid_from := ");
single_value.field_invalid__from->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_invalid__id:
TTCN_Logger::log_event_str("{ invalid_id := ");
single_value.field_invalid__id->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_invalid__namespace:
TTCN_Logger::log_event_str("{ invalid_namespace := ");
single_value.field_invalid__namespace->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_invalid__xml:
TTCN_Logger::log_event_str("{ invalid_xml := ");
single_value.field_invalid__xml->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_not__authorized:
TTCN_Logger::log_event_str("{ not_authorized := ");
single_value.field_not__authorized->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_not__well__formed:
TTCN_Logger::log_event_str("{ not_well_formed := ");
single_value.field_not__well__formed->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_policy__violation:
TTCN_Logger::log_event_str("{ policy_violation := ");
single_value.field_policy__violation->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_remote__connection__failed:
TTCN_Logger::log_event_str("{ remote_connection_failed := ");
single_value.field_remote__connection__failed->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_reset:
TTCN_Logger::log_event_str("{ reset := ");
single_value.field_reset->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_resource__constraint:
TTCN_Logger::log_event_str("{ resource_constraint := ");
single_value.field_resource__constraint->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_restricted__xml:
TTCN_Logger::log_event_str("{ restricted_xml := ");
single_value.field_restricted__xml->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_see__other__host:
TTCN_Logger::log_event_str("{ see_other_host := ");
single_value.field_see__other__host->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_system__shutdown:
TTCN_Logger::log_event_str("{ system_shutdown := ");
single_value.field_system__shutdown->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_undefined__condition:
TTCN_Logger::log_event_str("{ undefined_condition := ");
single_value.field_undefined__condition->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_unsupported__encoding:
TTCN_Logger::log_event_str("{ unsupported_encoding := ");
single_value.field_unsupported__encoding->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_unsupported__stanza__type:
TTCN_Logger::log_event_str("{ unsupported_stanza_type := ");
single_value.field_unsupported__stanza__type->log();
TTCN_Logger::log_event_str(" }");
break;
case StreamErrorGroup::ALT_unsupported__version:
TTCN_Logger::log_event_str("{ unsupported_version := ");
single_value.field_unsupported__version->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void StreamErrorGroup_template::log_match(const StreamErrorGroup& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case StreamErrorGroup::ALT_bad__format:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".bad_format");
single_value.field_bad__format->log_match(match_value.bad__format());
} else {
TTCN_Logger::log_event_str("{ bad_format := ");
single_value.field_bad__format->log_match(match_value.bad__format());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_bad__namespace__prefix:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".bad_namespace_prefix");
single_value.field_bad__namespace__prefix->log_match(match_value.bad__namespace__prefix());
} else {
TTCN_Logger::log_event_str("{ bad_namespace_prefix := ");
single_value.field_bad__namespace__prefix->log_match(match_value.bad__namespace__prefix());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_conflict:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".conflict");
single_value.field_conflict->log_match(match_value.conflict());
} else {
TTCN_Logger::log_event_str("{ conflict := ");
single_value.field_conflict->log_match(match_value.conflict());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_connection__timeout:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".connection_timeout");
single_value.field_connection__timeout->log_match(match_value.connection__timeout());
} else {
TTCN_Logger::log_event_str("{ connection_timeout := ");
single_value.field_connection__timeout->log_match(match_value.connection__timeout());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_host__gone:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".host_gone");
single_value.field_host__gone->log_match(match_value.host__gone());
} else {
TTCN_Logger::log_event_str("{ host_gone := ");
single_value.field_host__gone->log_match(match_value.host__gone());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_host__unknown:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".host_unknown");
single_value.field_host__unknown->log_match(match_value.host__unknown());
} else {
TTCN_Logger::log_event_str("{ host_unknown := ");
single_value.field_host__unknown->log_match(match_value.host__unknown());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_improper__addressing:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".improper_addressing");
single_value.field_improper__addressing->log_match(match_value.improper__addressing());
} else {
TTCN_Logger::log_event_str("{ improper_addressing := ");
single_value.field_improper__addressing->log_match(match_value.improper__addressing());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_internal__server__error:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".internal_server_error");
single_value.field_internal__server__error->log_match(match_value.internal__server__error());
} else {
TTCN_Logger::log_event_str("{ internal_server_error := ");
single_value.field_internal__server__error->log_match(match_value.internal__server__error());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_invalid__from:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".invalid_from");
single_value.field_invalid__from->log_match(match_value.invalid__from());
} else {
TTCN_Logger::log_event_str("{ invalid_from := ");
single_value.field_invalid__from->log_match(match_value.invalid__from());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_invalid__id:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".invalid_id");
single_value.field_invalid__id->log_match(match_value.invalid__id());
} else {
TTCN_Logger::log_event_str("{ invalid_id := ");
single_value.field_invalid__id->log_match(match_value.invalid__id());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_invalid__namespace:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".invalid_namespace");
single_value.field_invalid__namespace->log_match(match_value.invalid__namespace());
} else {
TTCN_Logger::log_event_str("{ invalid_namespace := ");
single_value.field_invalid__namespace->log_match(match_value.invalid__namespace());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_invalid__xml:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".invalid_xml");
single_value.field_invalid__xml->log_match(match_value.invalid__xml());
} else {
TTCN_Logger::log_event_str("{ invalid_xml := ");
single_value.field_invalid__xml->log_match(match_value.invalid__xml());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_not__authorized:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".not_authorized");
single_value.field_not__authorized->log_match(match_value.not__authorized());
} else {
TTCN_Logger::log_event_str("{ not_authorized := ");
single_value.field_not__authorized->log_match(match_value.not__authorized());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_not__well__formed:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".not_well_formed");
single_value.field_not__well__formed->log_match(match_value.not__well__formed());
} else {
TTCN_Logger::log_event_str("{ not_well_formed := ");
single_value.field_not__well__formed->log_match(match_value.not__well__formed());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_policy__violation:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".policy_violation");
single_value.field_policy__violation->log_match(match_value.policy__violation());
} else {
TTCN_Logger::log_event_str("{ policy_violation := ");
single_value.field_policy__violation->log_match(match_value.policy__violation());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_remote__connection__failed:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".remote_connection_failed");
single_value.field_remote__connection__failed->log_match(match_value.remote__connection__failed());
} else {
TTCN_Logger::log_event_str("{ remote_connection_failed := ");
single_value.field_remote__connection__failed->log_match(match_value.remote__connection__failed());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_reset:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".reset");
single_value.field_reset->log_match(match_value.reset());
} else {
TTCN_Logger::log_event_str("{ reset := ");
single_value.field_reset->log_match(match_value.reset());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_resource__constraint:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".resource_constraint");
single_value.field_resource__constraint->log_match(match_value.resource__constraint());
} else {
TTCN_Logger::log_event_str("{ resource_constraint := ");
single_value.field_resource__constraint->log_match(match_value.resource__constraint());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_restricted__xml:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".restricted_xml");
single_value.field_restricted__xml->log_match(match_value.restricted__xml());
} else {
TTCN_Logger::log_event_str("{ restricted_xml := ");
single_value.field_restricted__xml->log_match(match_value.restricted__xml());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_see__other__host:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".see_other_host");
single_value.field_see__other__host->log_match(match_value.see__other__host());
} else {
TTCN_Logger::log_event_str("{ see_other_host := ");
single_value.field_see__other__host->log_match(match_value.see__other__host());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_system__shutdown:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".system_shutdown");
single_value.field_system__shutdown->log_match(match_value.system__shutdown());
} else {
TTCN_Logger::log_event_str("{ system_shutdown := ");
single_value.field_system__shutdown->log_match(match_value.system__shutdown());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_undefined__condition:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".undefined_condition");
single_value.field_undefined__condition->log_match(match_value.undefined__condition());
} else {
TTCN_Logger::log_event_str("{ undefined_condition := ");
single_value.field_undefined__condition->log_match(match_value.undefined__condition());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_unsupported__encoding:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".unsupported_encoding");
single_value.field_unsupported__encoding->log_match(match_value.unsupported__encoding());
} else {
TTCN_Logger::log_event_str("{ unsupported_encoding := ");
single_value.field_unsupported__encoding->log_match(match_value.unsupported__encoding());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_unsupported__stanza__type:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".unsupported_stanza_type");
single_value.field_unsupported__stanza__type->log_match(match_value.unsupported__stanza__type());
} else {
TTCN_Logger::log_event_str("{ unsupported_stanza_type := ");
single_value.field_unsupported__stanza__type->log_match(match_value.unsupported__stanza__type());
TTCN_Logger::log_event_str(" }");
}
break;
case StreamErrorGroup::ALT_unsupported__version:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".unsupported_version");
single_value.field_unsupported__version->log_match(match_value.unsupported__version());
} else {
TTCN_Logger::log_event_str("{ unsupported_version := ");
single_value.field_unsupported__version->log_match(match_value.unsupported__version());
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void StreamErrorGroup_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case StreamErrorGroup::ALT_bad__format:
single_value.field_bad__format->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_bad__namespace__prefix:
single_value.field_bad__namespace__prefix->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_conflict:
single_value.field_conflict->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_connection__timeout:
single_value.field_connection__timeout->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_host__gone:
single_value.field_host__gone->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_host__unknown:
single_value.field_host__unknown->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_improper__addressing:
single_value.field_improper__addressing->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_internal__server__error:
single_value.field_internal__server__error->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_invalid__from:
single_value.field_invalid__from->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_invalid__id:
single_value.field_invalid__id->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_invalid__namespace:
single_value.field_invalid__namespace->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_invalid__xml:
single_value.field_invalid__xml->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_not__authorized:
single_value.field_not__authorized->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_not__well__formed:
single_value.field_not__well__formed->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_policy__violation:
single_value.field_policy__violation->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_remote__connection__failed:
single_value.field_remote__connection__failed->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_reset:
single_value.field_reset->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_resource__constraint:
single_value.field_resource__constraint->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_restricted__xml:
single_value.field_restricted__xml->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_see__other__host:
single_value.field_see__other__host->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_system__shutdown:
single_value.field_system__shutdown->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_undefined__condition:
single_value.field_undefined__condition->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_unsupported__encoding:
single_value.field_unsupported__encoding->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_unsupported__stanza__type:
single_value.field_unsupported__stanza__type->encode_text(text_buf);
break;
case StreamErrorGroup::ALT_unsupported__version:
single_value.field_unsupported__version->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
}

void StreamErrorGroup_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = StreamErrorGroup::UNBOUND_VALUE;
StreamErrorGroup::union_selection_type new_selection = (StreamErrorGroup::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case StreamErrorGroup::ALT_bad__format:
single_value.field_bad__format = new Empty_template;
single_value.field_bad__format->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_bad__namespace__prefix:
single_value.field_bad__namespace__prefix = new Empty_template;
single_value.field_bad__namespace__prefix->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_conflict:
single_value.field_conflict = new Empty_template;
single_value.field_conflict->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_connection__timeout:
single_value.field_connection__timeout = new Empty_template;
single_value.field_connection__timeout->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_host__gone:
single_value.field_host__gone = new Empty_template;
single_value.field_host__gone->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_host__unknown:
single_value.field_host__unknown = new Empty_template;
single_value.field_host__unknown->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_improper__addressing:
single_value.field_improper__addressing = new Empty_template;
single_value.field_improper__addressing->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_internal__server__error:
single_value.field_internal__server__error = new Empty_template;
single_value.field_internal__server__error->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_invalid__from:
single_value.field_invalid__from = new Empty_template;
single_value.field_invalid__from->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_invalid__id:
single_value.field_invalid__id = new Empty_template;
single_value.field_invalid__id->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_invalid__namespace:
single_value.field_invalid__namespace = new Empty_template;
single_value.field_invalid__namespace->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_invalid__xml:
single_value.field_invalid__xml = new Empty_template;
single_value.field_invalid__xml->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_not__authorized:
single_value.field_not__authorized = new Empty_template;
single_value.field_not__authorized->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_not__well__formed:
single_value.field_not__well__formed = new Empty_template;
single_value.field_not__well__formed->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_policy__violation:
single_value.field_policy__violation = new Empty_template;
single_value.field_policy__violation->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_remote__connection__failed:
single_value.field_remote__connection__failed = new Empty_template;
single_value.field_remote__connection__failed->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_reset:
single_value.field_reset = new Empty_template;
single_value.field_reset->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_resource__constraint:
single_value.field_resource__constraint = new Empty_template;
single_value.field_resource__constraint->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_restricted__xml:
single_value.field_restricted__xml = new Empty_template;
single_value.field_restricted__xml->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_see__other__host:
single_value.field_see__other__host = new UNIVERSAL_CHARSTRING_template;
single_value.field_see__other__host->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_system__shutdown:
single_value.field_system__shutdown = new Empty_template;
single_value.field_system__shutdown->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_undefined__condition:
single_value.field_undefined__condition = new Empty_template;
single_value.field_undefined__condition->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_unsupported__encoding:
single_value.field_unsupported__encoding = new Empty_template;
single_value.field_unsupported__encoding->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_unsupported__stanza__type:
single_value.field_unsupported__stanza__type = new Empty_template;
single_value.field_unsupported__stanza__type->decode_text(text_buf);
break;
case StreamErrorGroup::ALT_unsupported__version:
single_value.field_unsupported__version = new Empty_template;
single_value.field_unsupported__version->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new StreamErrorGroup_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
}

boolean StreamErrorGroup_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean StreamErrorGroup_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}

void StreamErrorGroup_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup'");
    }
    if (strcmp("bad_format", param_field) == 0) {
      bad__format().set_param(param);
      return;
    } else if (strcmp("bad_namespace_prefix", param_field) == 0) {
      bad__namespace__prefix().set_param(param);
      return;
    } else if (strcmp("conflict", param_field) == 0) {
      conflict().set_param(param);
      return;
    } else if (strcmp("connection_timeout", param_field) == 0) {
      connection__timeout().set_param(param);
      return;
    } else if (strcmp("host_gone", param_field) == 0) {
      host__gone().set_param(param);
      return;
    } else if (strcmp("host_unknown", param_field) == 0) {
      host__unknown().set_param(param);
      return;
    } else if (strcmp("improper_addressing", param_field) == 0) {
      improper__addressing().set_param(param);
      return;
    } else if (strcmp("internal_server_error", param_field) == 0) {
      internal__server__error().set_param(param);
      return;
    } else if (strcmp("invalid_from", param_field) == 0) {
      invalid__from().set_param(param);
      return;
    } else if (strcmp("invalid_id", param_field) == 0) {
      invalid__id().set_param(param);
      return;
    } else if (strcmp("invalid_namespace", param_field) == 0) {
      invalid__namespace().set_param(param);
      return;
    } else if (strcmp("invalid_xml", param_field) == 0) {
      invalid__xml().set_param(param);
      return;
    } else if (strcmp("not_authorized", param_field) == 0) {
      not__authorized().set_param(param);
      return;
    } else if (strcmp("not_well_formed", param_field) == 0) {
      not__well__formed().set_param(param);
      return;
    } else if (strcmp("policy_violation", param_field) == 0) {
      policy__violation().set_param(param);
      return;
    } else if (strcmp("remote_connection_failed", param_field) == 0) {
      remote__connection__failed().set_param(param);
      return;
    } else if (strcmp("reset", param_field) == 0) {
      reset().set_param(param);
      return;
    } else if (strcmp("resource_constraint", param_field) == 0) {
      resource__constraint().set_param(param);
      return;
    } else if (strcmp("restricted_xml", param_field) == 0) {
      restricted__xml().set_param(param);
      return;
    } else if (strcmp("see_other_host", param_field) == 0) {
      see__other__host().set_param(param);
      return;
    } else if (strcmp("system_shutdown", param_field) == 0) {
      system__shutdown().set_param(param);
      return;
    } else if (strcmp("undefined_condition", param_field) == 0) {
      undefined__condition().set_param(param);
      return;
    } else if (strcmp("unsupported_encoding", param_field) == 0) {
      unsupported__encoding().set_param(param);
      return;
    } else if (strcmp("unsupported_stanza_type", param_field) == 0) {
      unsupported__stanza__type().set_param(param);
      return;
    } else if (strcmp("unsupported_version", param_field) == 0) {
      unsupported__version().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (param.get_size()==0) break;
    param.type_error("union template", "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = param.get_elem(param.get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "bad_format")) {
      bad__format().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "bad_namespace_prefix")) {
      bad__namespace__prefix().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "conflict")) {
      conflict().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "connection_timeout")) {
      connection__timeout().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "host_gone")) {
      host__gone().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "host_unknown")) {
      host__unknown().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "improper_addressing")) {
      improper__addressing().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "internal_server_error")) {
      internal__server__error().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "invalid_from")) {
      invalid__from().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "invalid_id")) {
      invalid__id().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "invalid_namespace")) {
      invalid__namespace().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "invalid_xml")) {
      invalid__xml().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "not_authorized")) {
      not__authorized().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "not_well_formed")) {
      not__well__formed().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "policy_violation")) {
      policy__violation().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "remote_connection_failed")) {
      remote__connection__failed().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "reset")) {
      reset().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "resource_constraint")) {
      resource__constraint().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "restricted_xml")) {
      restricted__xml().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "see_other_host")) {
      see__other__host().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "system_shutdown")) {
      system__shutdown().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "undefined_condition")) {
      undefined__condition().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "unsupported_encoding")) {
      unsupported__encoding().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "unsupported_stanza_type")) {
      unsupported__stanza__type().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "unsupported_version")) {
      unsupported__version().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
  }
  is_ifpresent = param.get_ifpresent();
}

void StreamErrorGroup_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case StreamErrorGroup::ALT_bad__format:
single_value.field_bad__format->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_bad__namespace__prefix:
single_value.field_bad__namespace__prefix->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_conflict:
single_value.field_conflict->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_connection__timeout:
single_value.field_connection__timeout->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_host__gone:
single_value.field_host__gone->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_host__unknown:
single_value.field_host__unknown->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_improper__addressing:
single_value.field_improper__addressing->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_internal__server__error:
single_value.field_internal__server__error->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_invalid__from:
single_value.field_invalid__from->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_invalid__id:
single_value.field_invalid__id->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_invalid__namespace:
single_value.field_invalid__namespace->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_invalid__xml:
single_value.field_invalid__xml->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_not__authorized:
single_value.field_not__authorized->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_not__well__formed:
single_value.field_not__well__formed->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_policy__violation:
single_value.field_policy__violation->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_remote__connection__failed:
single_value.field_remote__connection__failed->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_reset:
single_value.field_reset->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_resource__constraint:
single_value.field_resource__constraint->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_restricted__xml:
single_value.field_restricted__xml->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_see__other__host:
single_value.field_see__other__host->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_system__shutdown:
single_value.field_system__shutdown->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_undefined__condition:
single_value.field_undefined__condition->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_unsupported__encoding:
single_value.field_unsupported__encoding->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_unsupported__stanza__type:
single_value.field_unsupported__stanza__type->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
case StreamErrorGroup::ALT_unsupported__version:
single_value.field_unsupported__version->check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup.");
}
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.StreamErrorGroup");
}

Text::Text()
{
  bound_flag = FALSE;
}

Text::Text(const OPTIONAL<CHARSTRING>& par_lang,
    const UNIVERSAL_CHARSTRING& par_base)
  :   field_lang(par_lang),
  field_base(par_base)
{
  bound_flag = TRUE;
}

Text::Text(const Text& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
bound_flag = TRUE;
if (other_value.lang().is_bound()) field_lang = other_value.lang();
else field_lang.clean_up();
if (other_value.base().is_bound()) field_base = other_value.base();
else field_base.clean_up();
}

void Text::clean_up()
{
field_lang.clean_up();
field_base.clean_up();
bound_flag = FALSE;
}

Text& Text::operator=(const Text& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
  bound_flag = TRUE;
  if (other_value.lang().is_bound()) field_lang = other_value.lang();
  else field_lang.clean_up();
  if (other_value.base().is_bound()) field_base = other_value.base();
  else field_base.clean_up();
}
return *this;
}

boolean Text::operator==(const Text& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_lang==other_value.field_lang
  && field_base==other_value.field_base;
}

boolean Text::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_lang.get_selection() || field_lang.is_bound()) return TRUE;
if(field_base.is_bound()) return TRUE;
return FALSE;
}
boolean Text::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_lang.get_selection() && !field_lang.is_value()) return FALSE;
if(!field_base.is_value()) return FALSE;
return TRUE;
}
int Text::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @urn_ietf_params_xml_ns_xmpp_streams.Text");
  int ret_val = 1;
  if (field_lang.ispresent()) ret_val++;
  return ret_val;
}

void Text::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ lang := ");
field_lang.log();
TTCN_Logger::log_event_str(", base := ");
field_base.log();
TTCN_Logger::log_event_str(" }");
}

void Text::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@urn_ietf_params_xml_ns_xmpp_streams.Text'");
    }
    if (strcmp("lang", param_field) == 0) {
      lang().set_param(param);
      return;
    } else if (strcmp("base", param_field) == 0) {
      base().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@urn_ietf_params_xml_ns_xmpp_streams.Text'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @urn_ietf_params_xml_ns_xmpp_streams.Text has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lang().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) base().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lang")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lang().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "base")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          base().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @urn_ietf_params_xml_ns_xmpp_streams.Text: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@urn_ietf_params_xml_ns_xmpp_streams.Text");
  }
}

void Text::set_implicit_omit()
{
if (!lang().is_bound()) lang() = OMIT_VALUE;
else lang().set_implicit_omit();
if (base().is_bound()) base().set_implicit_omit();
}

void Text::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
field_lang.encode_text(text_buf);
field_base.encode_text(text_buf);
}

void Text::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_lang.decode_text(text_buf);
field_base.decode_text(text_buf);
}

void Text::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Text::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

char ** Text::collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns) const {
  size_t num_collected;
  char **collected_ns = Base_Type::collect_ns(p_td, num_collected, def_ns);
  try {
  char **new_ns;
  size_t num_new;
  bool def_ns_1 = false;
  new_ns = field_lang.collect_ns(Text_lang_xer_, num_new, def_ns);
  merge_ns(collected_ns, num_collected, new_ns, num_new);
  def_ns = def_ns || def_ns_1;
  new_ns = field_base.collect_ns(Text_base_xer_, num_new, def_ns);
  merge_ns(collected_ns, num_collected, new_ns, num_new);
  def_ns = def_ns || def_ns_1;
  }
  catch (...) {
    while (num_collected > 0) Free(collected_ns[--num_collected]);
    Free(collected_ns);
    throw;
  }
  num_ns = num_collected;
  return collected_ns;
}

boolean Text::can_start(const char *name, const char *uri, const XERdescriptor_t& xd, unsigned int flavor) {
  boolean e_xer = is_exer(flavor &= ~XER_RECOF);
  if (!e_xer || !((xd.xer_bits & UNTAGGED) || (flavor & (USE_NIL|XER_RECOF)))) return check_name(name, xd, e_xer) && (!e_xer || check_namespace(uri, xd));
  else if (CHARSTRING::can_start(name, uri, Text_lang_xer_, flavor)) return true;
  else if (UNIVERSAL_CHARSTRING::can_start(name, uri, Text_base_xer_, flavor)) return true;
  return false;
}

int Text::XER_encode(const XERdescriptor_t& p_td, TTCN_Buffer& p_buf, unsigned int p_flavor, int p_indent, embed_values_enc_struct_t*) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  int encoded_length=(int)p_buf.get_len();
  int e_xer = is_exer(p_flavor);
  const boolean omit_tag = e_xer && p_indent && ((p_td.xer_bits & (UNTAGGED|XER_ATTRIBUTE)) || (p_flavor & (USE_NIL|USE_TYPE_ATTR)));
  if (e_xer && (p_td.xer_bits & EMBED_VALUES)) p_flavor |= XER_CANONICAL;
  int is_indented = !is_canonical(p_flavor);
  size_t num_collected = 0;
  char **collected_ns = NULL;
  bool def_ns = false;
  if (e_xer) {
    if (p_indent == 0) {
      collected_ns = collect_ns(p_td, num_collected, def_ns);
    }
    else if ((p_flavor & DEF_NS_SQUASHED) && p_td.my_module && p_td.ns_index != -1){
      const namespace_t * ns = p_td.my_module->get_ns(p_td.ns_index);
      if (*ns->px == '\0') {
        collected_ns = Base_Type::collect_ns(p_td, num_collected, def_ns);
      }
    }
  }
  const boolean empty_ns_hack = e_xer && !omit_tag && (p_indent > 0)
    && (p_td.xer_bits & FORM_UNQUALIFIED)
    && p_td.my_module && p_td.ns_index != -1
    && *p_td.my_module->get_ns(p_td.ns_index)->px == '\0';
  const boolean delay_close = e_xer;
  size_t chopped_chars = 0;
  if (!omit_tag) {
    if (is_indented) do_indent(p_buf, p_indent);
    p_buf.put_c('<');
    if (e_xer) write_ns_prefix(p_td, p_buf);
    p_buf.put_s((size_t)p_td.namelens[e_xer]-(delay_close || (e_xer && (p_td.xer_bits & HAS_1UNTAGGED)))-(!is_indented || delay_close), (cbyte*)p_td.names[e_xer]);
  }
  else if (p_flavor & USE_TYPE_ATTR) {
    size_t buf_len = p_buf.get_len();
    const unsigned char * const buf_data = p_buf.get_data();
    if (buf_data[buf_len-1-chopped_chars] == '\n') ++chopped_chars;
    if (buf_data[buf_len-1-chopped_chars] == '>' ) ++chopped_chars;
    if (chopped_chars) {
      p_buf.increase_length(-chopped_chars);
    }
  }
  int sub_len=0, tmp_len; (void)tmp_len;
  p_flavor &= XER_MASK;
  { // !QN
  if (e_xer && num_collected) {
    size_t num_ns;
    for (num_ns = 0; num_ns < num_collected; ++num_ns) {
      p_buf.put_s(strlen(collected_ns[num_ns]), (cbyte*)collected_ns[num_ns]);
      Free(collected_ns[num_ns]);
    }
    Free(collected_ns);
  }

  if (def_ns) {
    p_flavor &= ~DEF_NS_SQUASHED;
    p_flavor |=  DEF_NS_PRESENT;
  }
  else if (empty_ns_hack) {
    p_buf.put_s(9, (cbyte*)" xmlns=''");
    p_flavor &= ~DEF_NS_PRESENT;
    p_flavor |=  DEF_NS_SQUASHED;
  }
  ec_1.set_msg("lang': ");
  tmp_len = field_lang.XER_encode(Text_lang_xer_, p_buf, p_flavor, p_indent+1, 0);
  if (!e_xer) sub_len += tmp_len;
  if (delay_close && (!omit_tag || chopped_chars)) p_buf.put_s(1, (cbyte*)">\n");
  ec_1.set_msg("base': ");
  sub_len += field_base.XER_encode(Text_base_xer_, p_buf, p_flavor, p_indent+!omit_tag, 0);
  } // QN?
  if (!omit_tag) {
  if (sub_len) {
    if (is_indented && !(e_xer && (p_td.xer_bits & (HAS_1UNTAGGED | USE_QNAME)))) {
      switch ((int)(e_xer && (p_td.xer_bits & USE_NIL))) {
      case 1: {
        const unsigned char *buf_end = p_buf.get_data() + (p_buf.get_len()-1);
        if (buf_end[-1] != '>' || *buf_end != '\n') break;
      }
      case 0:
        do_indent(p_buf, p_indent);
        break;
      }
    }
    p_buf.put_c('<');
    p_buf.put_c('/');
    if (e_xer) write_ns_prefix(p_td, p_buf);
    p_buf.put_s((size_t)p_td.namelens[e_xer]-!is_indented, (cbyte*)p_td.names[e_xer]);
  } else {
    p_buf.increase_length(-1);
    p_buf.put_s((size_t)2+is_indented, (cbyte*)"/>\n");
  }}
  return (int)p_buf.get_len() - encoded_length;
}

int Text::XER_decode(const XERdescriptor_t& p_td, XmlReaderWrap& p_reader, unsigned int p_flavor, embed_values_dec_struct_t*)
{
  bound_flag = TRUE;
  int e_xer = is_exer(p_flavor);
  int xerbits = p_td.xer_bits;
  if (p_flavor & XER_TOPLEVEL) xerbits &= ~UNTAGGED;
  const boolean omit_tag = e_xer && ((xerbits & (UNTAGGED|XER_ATTRIBUTE)) || (p_flavor & (USE_NIL|USE_TYPE_ATTR)));
  boolean tag_closed = (p_flavor & PARENT_CLOSED) != 0;
  const boolean parent_tag = e_xer && (p_flavor & (USE_TYPE_ATTR));
  (void)parent_tag;
  p_flavor &= XER_MASK;
  int rd_ok, xml_depth=-1, type;
  {
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  if (!omit_tag) for (rd_ok=p_reader.Ok(); rd_ok==1; rd_ok=p_reader.Read()) {
    type = p_reader.NodeType();
    if (type==XML_READER_TYPE_ELEMENT) {
      verify_name(p_reader, p_td, e_xer);
      xml_depth = p_reader.Depth();
      tag_closed = p_reader.IsEmptyElement();
      break;
    }
  }
if (e_xer) {
 if (!omit_tag || parent_tag) {
  if (Text_lang_xer_.dfeValue) field_lang = *static_cast<const CHARSTRING*>(Text_lang_xer_.dfeValue);
  else field_lang = OMIT_VALUE;
  for (rd_ok = p_reader.MoveToFirstAttribute(); rd_ok==1 && p_reader.NodeType()==XML_READER_TYPE_ATTRIBUTE; rd_ok = p_reader.AdvanceAttribute()) {
    if (p_reader.IsNamespaceDecl()) continue;
    const char *attr_name = (const char*)p_reader.LocalName();
    const char *ns_uri    = (const char*)p_reader.NamespaceUri();
    if (check_name(attr_name, Text_lang_xer_, 1) && check_namespace(ns_uri, Text_lang_xer_)) {
      ec_1.set_msg("lang': ");
      field_lang.XER_decode(Text_lang_xer_, p_reader, p_flavor | (p_td.xer_bits & USE_NIL), 0);
    } else    if (parent_tag && !strcmp(attr_name, "type") && !strcmp((const char*)p_reader.Prefix(), "xsi")) {} else
    {
      if (!p_reader.LocalName() || strcmp((const char*)p_reader.LocalName(), "schemaLocation") ||
          !p_reader.Prefix() || strcmp((const char*)p_reader.Prefix(), "xsi"))
      {
        ec_0.set_msg(" "); ec_1.set_msg(" ");
        TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_INVAL_MSG, "Unexpected attribute '%s', ns '%s'", attr_name, ns_uri ? ns_uri : "");
      }
    }
  }
 }
  if ((!omit_tag || parent_tag) && !p_reader.IsEmptyElement()) rd_ok = p_reader.Read();
} else {
  if (!p_reader.IsEmptyElement()) p_reader.Read();
  {
    ec_1.set_msg("lang': ");
    field_lang.XER_decode(Text_lang_xer_, p_reader, p_flavor | (p_td.xer_bits & USE_NIL), 0);
  }
}
  if (e_xer && p_td.dfeValue && p_reader.IsEmptyElement()) {
    field_base = *static_cast<const UNIVERSAL_CHARSTRING*>(p_td.dfeValue);
  }
  else  {
    ec_1.set_msg("base': ");
    field_base.XER_decode(Text_base_xer_, p_reader, p_flavor | (p_td.xer_bits & USE_NIL)| (tag_closed ? PARENT_CLOSED : 0), 0);
  }
  } // errorcontext
  if (!omit_tag) {
    int current_depth;
    for (rd_ok = p_reader.Ok(); rd_ok == 1; rd_ok = p_reader.Read()) {
      type = p_reader.NodeType();
      if ((current_depth = p_reader.Depth()) > xml_depth) {
        if (XML_READER_TYPE_ELEMENT == type) {
          TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_TAG,
              "Unprocessed XML tag `%s'", (const char *)p_reader.Name());
        }
        continue;
      }
      else if (current_depth == xml_depth) {
        if (XML_READER_TYPE_ELEMENT == type) {
          verify_name(p_reader, p_td, e_xer);
          if (p_reader.IsEmptyElement()) {
            p_reader.Read();
            break;
          }
        }
        else if (XML_READER_TYPE_END_ELEMENT == type) {
          verify_end(p_reader, p_td, xml_depth, e_xer);
          rd_ok = p_reader.Read();
          break;
        }
      }
      else break;    }
  }
  return 1;
}

int Text::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_lang.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lang");
    enc_len += field_lang.JSON_encode(Text_lang_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "base");
    enc_len += field_base.JSON_encode(Text_base_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Text::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;

  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (4 == name_len && 0 == strncmp(fld_name, "lang", name_len)) {
        int ret_val = field_lang.JSON_decode(Text_lang_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lang");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else if (4 == name_len && 0 == strncmp(fld_name, "base", name_len)) {
        int ret_val = field_base.JSON_decode(Text_base_descr_, p_tok, p_silent);
        if (0 > ret_val) {
          if (JSON_ERROR_INVALID_TOKEN) {
            JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "base");
          }
          return JSON_ERROR_FATAL;
        }
        dec_len += ret_val;
      } else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_lang.is_bound()) {
    field_lang = OMIT_VALUE;
  }
  if (!field_base.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "base");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Text_template::single_value_struct {
CHARSTRING_template field_lang;
UNIVERSAL_CHARSTRING_template field_base;
};

void Text_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_lang = ANY_OR_OMIT;
single_value->field_base = ANY_VALUE;
}
}
}

void Text_template::copy_value(const Text& other_value)
{
single_value = new single_value_struct;
if (other_value.lang().is_bound()) {
  if (other_value.lang().ispresent()) single_value->field_lang = other_value.lang()();
  else single_value->field_lang = OMIT_VALUE;
} else {
  single_value->field_lang.clean_up();
}
if (other_value.base().is_bound()) {
  single_value->field_base = other_value.base();
} else {
  single_value->field_base.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Text_template::copy_template(const Text_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.lang().get_selection()) {
single_value->field_lang = other_value.lang();
} else {
single_value->field_lang.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.base().get_selection()) {
single_value->field_base = other_value.base();
} else {
single_value->field_base.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Text_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
break;
}
set_selection(other_value);
}

Text_template::Text_template()
{
}

Text_template::Text_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Text_template::Text_template(const Text& other_value)
{
copy_value(other_value);
}

Text_template::Text_template(const OPTIONAL<Text>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Text&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @urn_ietf_params_xml_ns_xmpp_streams.Text from an unbound optional field.");
}
}

Text_template::Text_template(const Text_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Text_template::~Text_template()
{
clean_up();
}

Text_template& Text_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Text_template& Text_template::operator=(const Text& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Text_template& Text_template::operator=(const OPTIONAL<Text>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Text&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
}
return *this;
}

Text_template& Text_template::operator=(const Text_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Text_template::match(const Text& other_value) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.lang().is_bound()) return FALSE;
if((other_value.lang().ispresent() ? !single_value->field_lang.match((const CHARSTRING&)other_value.lang()) : !single_value->field_lang.match_omit()))return FALSE;
if(!other_value.base().is_bound()) return FALSE;
if(!single_value->field_base.match(other_value.base()))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
}
return FALSE;
}

boolean Text_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_lang.is_omit() || single_value->field_lang.is_bound()) return TRUE;
if (single_value->field_base.is_bound()) return TRUE;
return FALSE;
}

boolean Text_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_lang.is_omit() && !single_value->field_lang.is_value()) return FALSE;
if (!single_value->field_base.is_value()) return FALSE;
return TRUE;
}

void Text_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Text Text_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
Text ret_val;
if (single_value->field_lang.is_omit()) ret_val.lang() = OMIT_VALUE;
else if (single_value->field_lang.is_bound()) {
ret_val.lang() = single_value->field_lang.valueof();
}
if (single_value->field_base.is_bound()) {
ret_val.base() = single_value->field_base.valueof();
}
return ret_val;
}

void Text_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Text_template[list_length];
}

Text_template& Text_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
return value_list.list_value[list_index];
}

CHARSTRING_template& Text_template::lang()
{
set_specific();
return single_value->field_lang;
}

const CHARSTRING_template& Text_template::lang() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lang of a non-specific template of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
return single_value->field_lang;
}

UNIVERSAL_CHARSTRING_template& Text_template::base()
{
set_specific();
return single_value->field_base;
}

const UNIVERSAL_CHARSTRING_template& Text_template::base() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field base of a non-specific template of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
return single_value->field_base;
}

int Text_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @urn_ietf_params_xml_ns_xmpp_streams.Text which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_lang.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @urn_ietf_params_xml_ns_xmpp_streams.Text containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @urn_ietf_params_xml_ns_xmpp_streams.Text containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @urn_ietf_params_xml_ns_xmpp_streams.Text containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @urn_ietf_params_xml_ns_xmpp_streams.Text containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @urn_ietf_params_xml_ns_xmpp_streams.Text containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
  }
  return 0;
}

void Text_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ lang := ");
single_value->field_lang.log();
TTCN_Logger::log_event_str(", base := ");
single_value->field_base.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Text_template::log_match(const Text& match_value) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.lang().ispresent()){
if(!single_value->field_lang.match(match_value.lang())){
TTCN_Logger::log_logmatch_info(".lang");
single_value->field_lang.log_match(match_value.lang());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_lang.match_omit()){
 TTCN_Logger::log_logmatch_info(".lang := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_lang.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_base.match(match_value.base())){
TTCN_Logger::log_logmatch_info(".base");
single_value->field_base.log_match(match_value.base());
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ lang := ");
if (match_value.lang().ispresent()) single_value->field_lang.log_match(match_value.lang());
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_lang.log();
if (single_value->field_lang.match_omit()) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", base := ");
single_value->field_base.log_match(match_value.base());
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Text_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_lang.encode_text(text_buf);
single_value->field_base.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
}
}

void Text_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_lang.decode_text(text_buf);
single_value->field_base.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Text_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @urn_ietf_params_xml_ns_xmpp_streams.Text.");
}
}

void Text_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@urn_ietf_params_xml_ns_xmpp_streams.Text'");
    }
    if (strcmp("lang", param_field) == 0) {
      lang().set_param(param);
      return;
    } else if (strcmp("base", param_field) == 0) {
      base().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@urn_ietf_params_xml_ns_xmpp_streams.Text'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
    set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      list_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @urn_ietf_params_xml_ns_xmpp_streams.Text has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lang().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) base().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), false);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lang")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lang().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "base")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          base().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @urn_ietf_params_xml_ns_xmpp_streams.Text: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@urn_ietf_params_xml_ns_xmpp_streams.Text");
  }
  is_ifpresent = param.get_ifpresent();
}

void Text_template::check_restriction(template_res t_res, const char* t_name) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_lang.check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.Text");
single_value->field_base.check_restriction(t_res, t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.Text");
return;
case TR_PRESENT:
if (!match_omit()) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@urn_ietf_params_xml_ns_xmpp_streams.Text");
}

boolean Text_template::is_present() const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit();
}

boolean Text_template::match_omit() const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
default:
return FALSE;
}
return FALSE;
}


/* Bodies of static functions */

static void pre_init_module()
{
XSD::module_object.pre_init_module();
}

static void post_init_module()
{
XSD::module_object.post_init_module();
}


} /* end of namespace */
